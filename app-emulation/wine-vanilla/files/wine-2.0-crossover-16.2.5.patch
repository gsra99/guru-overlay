diff -Naur wine-2.0a/configure wine-2.0b/configure
--- wine-2.0a/configure	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/configure	2017-07-11 20:37:49.000000000 +0100
@@ -749,6 +749,7 @@
 FLEX
 TOOLSDIR
 TARGETFLAGS
+FORCE_ALIGN_ARG_BUG_CFLAGS
 LD
 CPPBIN
 ac_ct_CXX
@@ -867,6 +868,7 @@
 with_wine64
 enable_largefile
 with_x
+enable_32autole
 enable_acledit
 enable_aclui
 enable_activeds
@@ -1212,6 +1214,8 @@
 enable_iccvid
 enable_icmp
 enable_ieframe
+enable_ieinfo5_ocx
+enable_iernonce
 enable_imaadp32_acm
 enable_imagehlp
 enable_imm32
@@ -1418,6 +1422,7 @@
 enable_traffic
 enable_twain_32
 enable_ucrtbase
+enable_uiautomationcore
 enable_unicows
 enable_updspapi
 enable_url
@@ -1448,6 +1453,7 @@
 enable_windowscodecs
 enable_windowscodecsext
 enable_winealsa_drv
+enable_wineandroid_drv
 enable_winebus_sys
 enable_winecoreaudio_drv
 enable_wined3d
@@ -5069,6 +5075,11 @@
 
 case $host in
   *-darwin*)
+    if test "x$enable_win64" != "xyes"
+    then
+      FORCE_ALIGN_ARG_BUG_CFLAGS="-mno-sse"
+
+    fi
     with_fontconfig=${with_fontconfig:-no}
     ;;
   *-mingw32*|*-cygwin*)
@@ -8337,6 +8348,7 @@
 
   linux-android*)
     DLLFLAGS="$DLLFLAGS -fPIC"
+    enable_wineandroid_drv=${enable_wineandroid_drv:-yes}
     { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the compiler supports -fPIC -Wl,--export-dynamic" >&5
 $as_echo_n "checking whether the compiler supports -fPIC -Wl,--export-dynamic... " >&6; }
 if ${ac_cv_cflags__fPIC__Wl___export_dynamic+:} false; then :
@@ -8870,8 +8882,8 @@
 
 enable_winecoreaudio_drv=${enable_winecoreaudio_drv:-no}
 enable_wineqtdecoder=${enable_wineqtdecoder:-no}
+enable_wineandroid_drv=${enable_wineandroid_drv:-no}
 enable_winemac_drv=${enable_winemac_drv:-no}
-test "$ac_cv_header_linux_joystick_h" = "yes" -o "$ac_cv_header_IOKit_hid_IOHIDLib_h" = "yes" || enable_winejoystick_drv=${enable_winejoystick_drv:-no}
 
 CROSSTARGET=""
 
@@ -10769,14 +10781,14 @@
 fi
         if test "x$with_glu" != "xno"
         then
-            { $as_echo "$as_me:${as_lineno-$LINENO}: checking for gluLookAt in -lGLU" >&5
-$as_echo_n "checking for gluLookAt in -lGLU... " >&6; }
-if ${ac_cv_lib_GLU_gluLookAt+:} false; then :
+                        { $as_echo "$as_me:${as_lineno-$LINENO}: checking for -lGLU" >&5
+$as_echo_n "checking for -lGLU... " >&6; }
+if ${ac_cv_lib_soname_GLU+:} false; then :
   $as_echo_n "(cached) " >&6
 else
-  ac_check_lib_save_LIBS=$LIBS
+  ac_check_soname_save_LIBS=$LIBS
 LIBS="-lGLU $OPENGL_LIBS $X_LIBS -lm $X_EXTRA_LIBS $LIBS"
-cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 
 /* Override any GCC internal prototype to avoid an error.
@@ -10795,21 +10807,34 @@
 }
 _ACEOF
 if ac_fn_c_try_link "$LINENO"; then :
-  ac_cv_lib_GLU_gluLookAt=yes
-else
-  ac_cv_lib_GLU_gluLookAt=no
+  case "$LIBEXT" in
+    dll) ac_cv_lib_soname_GLU=`$ac_cv_path_LDD conftest.exe | grep "GLU" | sed -e "s/dll.*/dll/"';2,$d'` ;;
+    dylib) ac_cv_lib_soname_GLU=`$OTOOL -L conftest$ac_exeext | grep "libGLU\\.[0-9A-Za-z.]*dylib" | sed -e "s/^.*\/\(libGLU\.[0-9A-Za-z.]*dylib\).*$/\1/"';2,$d'` ;;
+    *) ac_cv_lib_soname_GLU=`$READELF -d conftest$ac_exeext | grep "NEEDED.*libGLU\\.$LIBEXT" | sed -e "s/^.*\\[\\(libGLU\\.$LIBEXT[^	 ]*\\)\\].*$/\1/"';2,$d'`
+       if ${ac_cv_lib_soname_GLU:+false} :; then :
+  ac_cv_lib_soname_GLU=`$LDD conftest$ac_exeext | grep "libGLU\\.$LIBEXT" | sed -e "s/^.*\(libGLU\.$LIBEXT[^	 ]*\).*$/\1/"';2,$d'`
+fi ;;
+  esac
 fi
 rm -f core conftest.err conftest.$ac_objext \
     conftest$ac_exeext conftest.$ac_ext
-LIBS=$ac_check_lib_save_LIBS
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_GLU_gluLookAt" >&5
-$as_echo "$ac_cv_lib_GLU_gluLookAt" >&6; }
-if test "x$ac_cv_lib_GLU_gluLookAt" = xyes; then :
-  :
+  LIBS=$ac_check_soname_save_LIBS
 fi
+if ${ac_cv_lib_soname_GLU:+false} :; then :
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: not found" >&5
+$as_echo "not found" >&6; }
+
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_soname_GLU" >&5
+$as_echo "$ac_cv_lib_soname_GLU" >&6; }
 
-            if test "x$ac_cv_lib_GLU_gluLookAt" != xyes; then :
+cat >>confdefs.h <<_ACEOF
+#define SONAME_LIBGLU "$ac_cv_lib_soname_GLU"
+_ACEOF
+
+
+fi
+            if test "x$ac_cv_lib_soname_GLU" = "x"; then :
   case "x$with_glu" in
   x)   as_fn_append wine_notices "|libGLU ${notice_platform}development files not found, GLU won't be supported." ;;
   xno) ;;
@@ -10914,7 +10939,7 @@
 enable_winex11_drv=${enable_winex11_drv:-no}
 fi
 
-test "x$ac_cv_lib_GLU_gluLookAt" != xyes && enable_glu32=${enable_glu32:-no}
+test "x$ac_cv_lib_soname_GLU" = "x" && enable_glu32=${enable_glu32:-no}
 
 if test "$ac_cv_header_CL_cl_h" = "yes"
 then
@@ -15702,6 +15727,69 @@
 
 LIBS=$ac_save_LIBS
 
+ac_save_LIBS=$LIBS
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for library containing shm_open" >&5
+$as_echo_n "checking for library containing shm_open... " >&6; }
+if ${ac_cv_search_shm_open+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_func_search_save_LIBS=$LIBS
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char shm_open ();
+int
+main ()
+{
+return shm_open ();
+  ;
+  return 0;
+}
+_ACEOF
+for ac_lib in '' rt; do
+  if test -z "$ac_lib"; then
+    ac_res="none required"
+  else
+    ac_res=-l$ac_lib
+    LIBS="-l$ac_lib  $ac_func_search_save_LIBS"
+  fi
+  if ac_fn_c_try_link "$LINENO"; then :
+  ac_cv_search_shm_open=$ac_res
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext
+  if ${ac_cv_search_shm_open+:} false; then :
+  break
+fi
+done
+if ${ac_cv_search_shm_open+:} false; then :
+
+else
+  ac_cv_search_shm_open=no
+fi
+rm conftest.$ac_ext
+LIBS=$ac_func_search_save_LIBS
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_search_shm_open" >&5
+$as_echo "$ac_cv_search_shm_open" >&6; }
+ac_res=$ac_cv_search_shm_open
+if test "$ac_res" != no; then :
+  test "$ac_res" = "none required" || LIBS="$ac_res $LIBS"
+
+$as_echo "#define HAVE_SHM_OPEN 1" >>confdefs.h
+
+                test "$ac_res" = "none required" || RT_LIBS="$ac_res"
+
+fi
+
+LIBS=$ac_save_LIBS
+
 LDAP_LIBS=""
 
 if test "$ac_cv_header_ldap_h" = "yes" -a "$ac_cv_header_lber_h" = "yes"
@@ -17470,7 +17558,8 @@
 
 $as_echo_n "creating Makefile rules..." >&6
 
-ALL_VARS_RULES="OPENGL_LIBS = $OPENGL_LIBS
+ALL_VARS_RULES="FORCE_ALIGN_ARG_BUG_CFLAGS = $FORCE_ALIGN_ARG_BUG_CFLAGS
+OPENGL_LIBS = $OPENGL_LIBS
 SOCKET_LIBS = $SOCKET_LIBS
 COREFOUNDATION_LIBS = $COREFOUNDATION_LIBS
 IOKIT_LIBS = $IOKIT_LIBS
@@ -17581,6 +17670,7 @@
 wine_fn_config_symlink wine64
 fi
 
+wine_fn_config_dll 32autole enable_32autole
 wine_fn_config_dll acledit enable_acledit
 wine_fn_config_dll aclui enable_aclui implib
 wine_fn_config_dll activeds enable_activeds implib
@@ -18005,6 +18095,8 @@
 wine_fn_config_dll icmp enable_icmp
 wine_fn_config_dll ieframe enable_ieframe clean,implib
 wine_fn_config_test dlls/ieframe/tests ieframe_test
+wine_fn_config_dll ieinfo5.ocx enable_ieinfo5_ocx
+wine_fn_config_dll iernonce enable_iernonce
 wine_fn_config_dll ifsmgr.vxd enable_win16
 wine_fn_config_dll imaadp32.acm enable_imaadp32_acm
 wine_fn_config_dll imagehlp enable_imagehlp implib
@@ -18328,6 +18420,7 @@
 wine_fn_config_dll typelib.dll16 enable_win16
 wine_fn_config_dll ucrtbase enable_ucrtbase implib
 wine_fn_config_test dlls/ucrtbase/tests ucrtbase_test
+wine_fn_config_dll uiautomationcore enable_uiautomationcore
 wine_fn_config_dll unicows enable_unicows implib
 wine_fn_config_dll updspapi enable_updspapi
 wine_fn_config_dll url enable_url implib
@@ -18388,6 +18481,7 @@
 wine_fn_config_dll windowscodecsext enable_windowscodecsext implib
 wine_fn_config_test dlls/windowscodecsext/tests windowscodecsext_test
 wine_fn_config_dll winealsa.drv enable_winealsa_drv
+wine_fn_config_dll wineandroid.drv enable_wineandroid_drv
 wine_fn_config_dll winebus.sys enable_winebus_sys
 wine_fn_config_dll winecoreaudio.drv enable_winecoreaudio_drv
 wine_fn_config_lib winecrt0
diff -Naur wine-2.0a/configure.ac wine-2.0b/configure.ac
--- wine-2.0a/configure.ac	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/configure.ac	2017-07-11 20:37:49.000000000 +0100
@@ -128,6 +128,11 @@
 
 case $host in
   *-darwin*)
+dnl Add -mno-sse to work around #13762
+    if test "x$enable_win64" != "xyes"
+    then
+      AC_SUBST(FORCE_ALIGN_ARG_BUG_CFLAGS,"-mno-sse")
+    fi
     with_fontconfig=${with_fontconfig:-no}
     ;;
   *-mingw32*|*-cygwin*)
@@ -846,6 +851,7 @@
 
   linux-android*)
     DLLFLAGS="$DLLFLAGS -fPIC"
+    enable_wineandroid_drv=${enable_wineandroid_drv:-yes}
     WINE_TRY_CFLAGS([-fPIC -Wl,--export-dynamic],
                     [LDEXECFLAGS="-Wl,--export-dynamic"])
     WINE_TRY_CFLAGS([-fPIC -Wl,--rpath,\$ORIGIN/../lib],
@@ -937,8 +943,8 @@
 
 enable_winecoreaudio_drv=${enable_winecoreaudio_drv:-no}
 enable_wineqtdecoder=${enable_wineqtdecoder:-no}
+enable_wineandroid_drv=${enable_wineandroid_drv:-no}
 enable_winemac_drv=${enable_winemac_drv:-no}
-test "$ac_cv_header_linux_joystick_h" = "yes" -o "$ac_cv_header_IOKit_hid_IOHIDLib_h" = "yes" || enable_winejoystick_drv=${enable_winejoystick_drv:-no}
 
 dnl Check for cross compiler to build test programs
 AC_SUBST(CROSSTARGET,"")
@@ -1142,8 +1148,9 @@
 		     $X_LIBS -lm $X_EXTRA_LIBS)
         if test "x$with_glu" != "xno"
         then
-            AC_CHECK_LIB(GLU,gluLookAt,[:],,[$OPENGL_LIBS $X_LIBS -lm $X_EXTRA_LIBS])
-            WINE_NOTICE_WITH(glu,[test "x$ac_cv_lib_GLU_gluLookAt" != xyes],
+            dnl *** CrossOver Hack 10798 ***
+            WINE_CHECK_SONAME(GLU,gluLookAt,,,[$OPENGL_LIBS $X_LIBS -lm $X_EXTRA_LIBS])
+            WINE_NOTICE_WITH(glu,[test "x$ac_cv_lib_soname_GLU" = "x"],
                              [libGLU ${notice_platform}development files not found, GLU won't be supported.])
         fi
 
@@ -1167,7 +1174,8 @@
 to install ${notice_platform}development packages of Xlib/Xfree86 at the very least.],
 [enable_winex11_drv])
 
-test "x$ac_cv_lib_GLU_gluLookAt" != xyes && enable_glu32=${enable_glu32:-no}
+dnl *** CrossOver Hack 10798 ***
+test "x$ac_cv_lib_soname_GLU" = "x" && enable_glu32=${enable_glu32:-no}
 
 dnl **** Check for OpenCL ****
 if test "$ac_cv_header_CL_cl_h" = "yes"
@@ -2108,6 +2116,13 @@
                 test "$ac_res" = "none required" || AC_SUBST(RT_LIBS,"$ac_res")])
 LIBS=$ac_save_LIBS
 
+dnl Check for shm_open which may be in -lrt
+ac_save_LIBS=$LIBS
+AC_SEARCH_LIBS(shm_open, rt,
+               [AC_DEFINE(HAVE_SHM_OPEN, 1, [Define to 1 if you have the `shm_open' function.])
+                test "$ac_res" = "none required" || AC_SUBST(RT_LIBS,"$ac_res")])
+LIBS=$ac_save_LIBS
+
 dnl **** Check for OpenLDAP ***
 AC_SUBST(LDAP_LIBS,"")
 if test "$ac_cv_header_ldap_h" = "yes" -a "$ac_cv_header_lber_h" = "yes"
@@ -2642,6 +2657,7 @@
 WINE_CONFIG_SYMLINK(,tools,[wine],,winewrapper)
 WINE_CONFIG_SYMLINK(,tools,[wine64],enable_win64,winewrapper)
 
+WINE_CONFIG_DLL(32autole)
 WINE_CONFIG_DLL(acledit)
 WINE_CONFIG_DLL(aclui,,[implib])
 WINE_CONFIG_DLL(activeds,,[implib])
@@ -3066,6 +3082,8 @@
 WINE_CONFIG_DLL(icmp)
 WINE_CONFIG_DLL(ieframe,,[clean,implib])
 WINE_CONFIG_TEST(dlls/ieframe/tests)
+WINE_CONFIG_DLL(ieinfo5.ocx)
+WINE_CONFIG_DLL(iernonce)
 WINE_CONFIG_DLL(ifsmgr.vxd,enable_win16)
 WINE_CONFIG_DLL(imaadp32.acm)
 WINE_CONFIG_DLL(imagehlp,,[implib])
@@ -3389,6 +3407,7 @@
 WINE_CONFIG_DLL(typelib.dll16,enable_win16)
 WINE_CONFIG_DLL(ucrtbase,,[implib])
 WINE_CONFIG_TEST(dlls/ucrtbase/tests)
+WINE_CONFIG_DLL(uiautomationcore)
 WINE_CONFIG_DLL(unicows,,[implib])
 WINE_CONFIG_DLL(updspapi)
 WINE_CONFIG_DLL(url,,[implib])
@@ -3449,6 +3468,7 @@
 WINE_CONFIG_DLL(windowscodecsext,,[implib])
 WINE_CONFIG_TEST(dlls/windowscodecsext/tests)
 WINE_CONFIG_DLL(winealsa.drv)
+WINE_CONFIG_DLL(wineandroid.drv)
 WINE_CONFIG_DLL(winebus.sys)
 WINE_CONFIG_DLL(winecoreaudio.drv)
 WINE_CONFIG_LIB(winecrt0)
diff -Naur wine-2.0a/dlls/32autole/32autole.spec wine-2.0b/dlls/32autole/32autole.spec
--- wine-2.0a/dlls/32autole/32autole.spec	1970-01-01 01:00:00.000000000 +0100
+++ wine-2.0b/dlls/32autole/32autole.spec	2017-07-11 20:37:49.000000000 +0100
@@ -0,0 +1,419 @@
+2 stdcall SysAllocString(wstr) oleaut32.SysAllocString
+3 stdcall SysReAllocString(ptr wstr) oleaut32.SysReAllocString
+4 stdcall SysAllocStringLen(wstr long) oleaut32.SysAllocStringLen
+5 stdcall SysReAllocStringLen(ptr ptr long) oleaut32.SysReAllocStringLen
+6 stdcall SysFreeString(wstr) oleaut32.SysFreeString
+7 stdcall SysStringLen(wstr) oleaut32.SysStringLen
+8 stdcall VariantInit(ptr) oleaut32.VariantInit
+9 stdcall VariantClear(ptr) oleaut32.VariantClear
+10 stdcall VariantCopy(ptr ptr) oleaut32.VariantCopy
+11 stdcall VariantCopyInd(ptr ptr) oleaut32.VariantCopyInd
+12 stdcall VariantChangeType(ptr ptr long long) oleaut32.VariantChangeType
+13 stdcall VariantTimeToDosDateTime(double ptr ptr) oleaut32.VariantTimeToDosDateTime
+14 stdcall DosDateTimeToVariantTime(long long ptr) oleaut32.DosDateTimeToVariantTime
+15 stdcall SafeArrayCreate(long long ptr) oleaut32.SafeArrayCreate
+16 stdcall SafeArrayDestroy(ptr) oleaut32.SafeArrayDestroy
+17 stdcall SafeArrayGetDim(ptr) oleaut32.SafeArrayGetDim
+18 stdcall SafeArrayGetElemsize(ptr) oleaut32.SafeArrayGetElemsize
+19 stdcall SafeArrayGetUBound(ptr long long) oleaut32.SafeArrayGetUBound
+20 stdcall SafeArrayGetLBound(ptr long long) oleaut32.SafeArrayGetLBound
+21 stdcall SafeArrayLock(ptr) oleaut32.SafeArrayLock
+22 stdcall SafeArrayUnlock(ptr) oleaut32.SafeArrayUnlock
+23 stdcall SafeArrayAccessData(ptr ptr) oleaut32.SafeArrayAccessData
+24 stdcall SafeArrayUnaccessData(ptr) oleaut32.SafeArrayUnaccessData
+25 stdcall SafeArrayGetElement(ptr ptr ptr) oleaut32.SafeArrayGetElement
+26 stdcall SafeArrayPutElement(ptr ptr ptr) oleaut32.SafeArrayPutElement
+27 stdcall SafeArrayCopy(ptr ptr) oleaut32.SafeArrayCopy
+28 stdcall DispGetParam(ptr long long ptr ptr) oleaut32.DispGetParam
+29 stdcall DispGetIDsOfNames(ptr ptr long ptr) oleaut32.DispGetIDsOfNames
+30 stdcall DispInvoke(ptr ptr long long ptr ptr ptr ptr) oleaut32.DispInvoke
+31 stdcall CreateDispTypeInfo(ptr long ptr) oleaut32.CreateDispTypeInfo
+32 stdcall CreateStdDispatch(ptr ptr ptr ptr) oleaut32.CreateStdDispatch
+33 stdcall RegisterActiveObject(ptr ptr long ptr) oleaut32.RegisterActiveObject
+34 stdcall RevokeActiveObject(long ptr) oleaut32.RevokeActiveObject
+35 stdcall GetActiveObject(ptr ptr ptr) oleaut32.GetActiveObject
+36 stdcall SafeArrayAllocDescriptor(long ptr) oleaut32.SafeArrayAllocDescriptor
+37 stdcall SafeArrayAllocData(ptr) oleaut32.SafeArrayAllocData
+38 stdcall SafeArrayDestroyDescriptor(ptr) oleaut32.SafeArrayDestroyDescriptor
+39 stdcall SafeArrayDestroyData(ptr) oleaut32.SafeArrayDestroyData
+40 stdcall SafeArrayRedim(ptr ptr) oleaut32.SafeArrayRedim
+41 stdcall SafeArrayAllocDescriptorEx(long long ptr) oleaut32.SafeArrayAllocDescriptorEx
+42 stdcall SafeArrayCreateEx(long long ptr ptr) oleaut32.SafeArrayCreateEx
+43 stdcall SafeArrayCreateVectorEx(long long long ptr) oleaut32.SafeArrayCreateVectorEx
+44 stdcall SafeArraySetRecordInfo(ptr ptr) oleaut32.SafeArraySetRecordInfo
+45 stdcall SafeArrayGetRecordInfo(ptr ptr) oleaut32.SafeArrayGetRecordInfo
+46 stdcall VarParseNumFromStr(wstr long long ptr ptr) oleaut32.VarParseNumFromStr
+47 stdcall VarNumFromParseNum(ptr ptr long ptr) oleaut32.VarNumFromParseNum
+48 stdcall VarI2FromUI1(long ptr) oleaut32.VarI2FromUI1
+49 stdcall VarI2FromI4(long ptr) oleaut32.VarI2FromI4
+50 stdcall VarI2FromR4(float ptr) oleaut32.VarI2FromR4
+51 stdcall VarI2FromR8(double ptr) oleaut32.VarI2FromR8
+52 stdcall VarI2FromCy(int64 ptr) oleaut32.VarI2FromCy
+53 stdcall VarI2FromDate(double ptr) oleaut32.VarI2FromDate
+54 stdcall VarI2FromStr(wstr long long ptr) oleaut32.VarI2FromStr
+55 stdcall VarI2FromDisp(ptr long ptr) oleaut32.VarI2FromDisp
+56 stdcall VarI2FromBool(long ptr) oleaut32.VarI2FromBool
+57 stdcall SafeArraySetIID(ptr ptr) oleaut32.SafeArraySetIID
+58 stdcall VarI4FromUI1(long ptr) oleaut32.VarI4FromUI1
+59 stdcall VarI4FromI2(long ptr) oleaut32.VarI4FromI2
+60 stdcall VarI4FromR4(float ptr) oleaut32.VarI4FromR4
+61 stdcall VarI4FromR8(double ptr) oleaut32.VarI4FromR8
+62 stdcall VarI4FromCy(int64 ptr) oleaut32.VarI4FromCy
+63 stdcall VarI4FromDate(double ptr) oleaut32.VarI4FromDate
+64 stdcall VarI4FromStr(wstr long long ptr) oleaut32.VarI4FromStr
+65 stdcall VarI4FromDisp(ptr long ptr) oleaut32.VarI4FromDisp
+66 stdcall VarI4FromBool(long ptr) oleaut32.VarI4FromBool
+67 stdcall SafeArrayGetIID(ptr ptr) oleaut32.SafeArrayGetIID
+68 stdcall VarR4FromUI1(long ptr) oleaut32.VarR4FromUI1
+69 stdcall VarR4FromI2(long ptr) oleaut32.VarR4FromI2
+70 stdcall VarR4FromI4(long ptr) oleaut32.VarR4FromI4
+71 stdcall VarR4FromR8(double ptr) oleaut32.VarR4FromR8
+72 stdcall VarR4FromCy(int64 ptr) oleaut32.VarR4FromCy
+73 stdcall VarR4FromDate(double ptr) oleaut32.VarR4FromDate
+74 stdcall VarR4FromStr(wstr long long ptr) oleaut32.VarR4FromStr
+75 stdcall VarR4FromDisp(ptr long ptr) oleaut32.VarR4FromDisp
+76 stdcall VarR4FromBool(long ptr) oleaut32.VarR4FromBool
+77 stdcall SafeArrayGetVartype(ptr ptr) oleaut32.SafeArrayGetVartype
+78 stdcall VarR8FromUI1(long ptr) oleaut32.VarR8FromUI1
+79 stdcall VarR8FromI2(long ptr) oleaut32.VarR8FromI2
+80 stdcall VarR8FromI4(long ptr) oleaut32.VarR8FromI4
+81 stdcall VarR8FromR4(float ptr) oleaut32.VarR8FromR4
+82 stdcall VarR8FromCy(int64 ptr) oleaut32.VarR8FromCy
+83 stdcall VarR8FromDate(double ptr) oleaut32.VarR8FromDate
+84 stdcall VarR8FromStr(wstr long long ptr) oleaut32.VarR8FromStr
+85 stdcall VarR8FromDisp(ptr long ptr) oleaut32.VarR8FromDisp
+86 stdcall VarR8FromBool(long ptr) oleaut32.VarR8FromBool
+87 stdcall VarFormat(ptr ptr long long long ptr) oleaut32.VarFormat
+88 stdcall VarDateFromUI1(long ptr) oleaut32.VarDateFromUI1
+89 stdcall VarDateFromI2(long ptr) oleaut32.VarDateFromI2
+90 stdcall VarDateFromI4(long ptr) oleaut32.VarDateFromI4
+91 stdcall VarDateFromR4(float ptr) oleaut32.VarDateFromR4
+92 stdcall VarDateFromR8(double ptr) oleaut32.VarDateFromR8
+93 stdcall VarDateFromCy(int64 ptr) oleaut32.VarDateFromCy
+94 stdcall VarDateFromStr(wstr long long ptr) oleaut32.VarDateFromStr
+95 stdcall VarDateFromDisp(ptr long ptr) oleaut32.VarDateFromDisp
+96 stdcall VarDateFromBool(long ptr) oleaut32.VarDateFromBool
+97 stdcall VarFormatDateTime(ptr long long ptr) oleaut32.VarFormatDateTime
+98 stdcall VarCyFromUI1(long ptr) oleaut32.VarCyFromUI1
+99 stdcall VarCyFromI2(long ptr) oleaut32.VarCyFromI2
+100 stdcall VarCyFromI4(long ptr) oleaut32.VarCyFromI4
+101 stdcall VarCyFromR4(float ptr) oleaut32.VarCyFromR4
+102 stdcall VarCyFromR8(double ptr) oleaut32.VarCyFromR8
+103 stdcall VarCyFromDate(double ptr) oleaut32.VarCyFromDate
+104 stdcall VarCyFromStr(wstr long long ptr) oleaut32.VarCyFromStr
+105 stdcall VarCyFromDisp(ptr long ptr) oleaut32.VarCyFromDisp
+106 stdcall VarCyFromBool(long ptr) oleaut32.VarCyFromBool
+107 stdcall VarFormatNumber(ptr long long long long long ptr) oleaut32.VarFormatNumber
+108 stdcall VarBstrFromUI1(long long long ptr) oleaut32.VarBstrFromUI1
+109 stdcall VarBstrFromI2(long long long ptr) oleaut32.VarBstrFromI2
+110 stdcall VarBstrFromI4(long long long ptr) oleaut32.VarBstrFromI4
+111 stdcall VarBstrFromR4(float long long ptr) oleaut32.VarBstrFromR4
+112 stdcall VarBstrFromR8(double long long ptr) oleaut32.VarBstrFromR8
+113 stdcall VarBstrFromCy(int64 long long ptr) oleaut32.VarBstrFromCy
+114 stdcall VarBstrFromDate(double long long ptr) oleaut32.VarBstrFromDate
+115 stdcall VarBstrFromDisp(ptr long long ptr) oleaut32.VarBstrFromDisp
+116 stdcall VarBstrFromBool(long long long ptr) oleaut32.VarBstrFromBool
+117 stdcall VarFormatPercent(ptr long long long long long ptr) oleaut32.VarFormatPercent
+118 stdcall VarBoolFromUI1(long ptr) oleaut32.VarBoolFromUI1
+119 stdcall VarBoolFromI2(long ptr) oleaut32.VarBoolFromI2
+120 stdcall VarBoolFromI4(long ptr) oleaut32.VarBoolFromI4
+121 stdcall VarBoolFromR4(float ptr) oleaut32.VarBoolFromR4
+122 stdcall VarBoolFromR8(double ptr) oleaut32.VarBoolFromR8
+123 stdcall VarBoolFromDate(double ptr) oleaut32.VarBoolFromDate
+124 stdcall VarBoolFromCy(int64 ptr) oleaut32.VarBoolFromCy
+125 stdcall VarBoolFromStr(wstr long long ptr) oleaut32.VarBoolFromStr
+126 stdcall VarBoolFromDisp(ptr long ptr) oleaut32.VarBoolFromDisp
+127 stdcall VarFormatCurrency(ptr long long long long long ptr) oleaut32.VarFormatCurrency
+128 stdcall VarWeekdayName(long long long long ptr) oleaut32.VarWeekdayName
+129 stdcall VarMonthName(long long long ptr) oleaut32.VarMonthName
+130 stdcall VarUI1FromI2(long ptr) oleaut32.VarUI1FromI2
+131 stdcall VarUI1FromI4(long ptr) oleaut32.VarUI1FromI4
+132 stdcall VarUI1FromR4(float ptr) oleaut32.VarUI1FromR4
+133 stdcall VarUI1FromR8(double ptr) oleaut32.VarUI1FromR8
+134 stdcall VarUI1FromCy(int64 ptr) oleaut32.VarUI1FromCy
+135 stdcall VarUI1FromDate(double ptr) oleaut32.VarUI1FromDate
+136 stdcall VarUI1FromStr(wstr long long ptr) oleaut32.VarUI1FromStr
+137 stdcall VarUI1FromDisp(ptr long ptr) oleaut32.VarUI1FromDisp
+138 stdcall VarUI1FromBool(long ptr) oleaut32.VarUI1FromBool
+139 stdcall VarFormatFromTokens (ptr ptr ptr long ptr long) oleaut32.VarFormatFromTokens
+140 stdcall VarTokenizeFormatString (ptr ptr long long long long ptr) oleaut32.VarTokenizeFormatString
+141 stdcall VarAdd(ptr ptr ptr) oleaut32.VarAdd
+142 stdcall VarAnd(ptr ptr ptr) oleaut32.VarAnd
+143 stdcall VarDiv(ptr ptr ptr) oleaut32.VarDiv
+144 stub OACreateTypeLib2
+146 stdcall DispCallFunc(ptr long long long long ptr ptr ptr) oleaut32.DispCallFunc
+147 stdcall VariantChangeTypeEx(ptr ptr long long long) oleaut32.VariantChangeTypeEx
+148 stdcall SafeArrayPtrOfIndex(ptr ptr ptr) oleaut32.SafeArrayPtrOfIndex
+149 stdcall SysStringByteLen(ptr) oleaut32.SysStringByteLen
+150 stdcall SysAllocStringByteLen(ptr long) oleaut32.SysAllocStringByteLen
+152 stdcall VarEqv(ptr ptr ptr) oleaut32.VarEqv
+153 stdcall VarIdiv(ptr ptr ptr) oleaut32.VarIdiv
+154 stdcall VarImp(ptr ptr ptr) oleaut32.VarImp
+155 stdcall VarMod(ptr ptr ptr) oleaut32.VarMod
+156 stdcall VarMul(ptr ptr ptr) oleaut32.VarMul
+157 stdcall VarOr(ptr ptr ptr) oleaut32.VarOr
+158 stdcall VarPow(ptr ptr ptr) oleaut32.VarPow
+159 stdcall VarSub(ptr ptr ptr) oleaut32.VarSub
+160 stdcall CreateTypeLib(long wstr ptr) oleaut32.CreateTypeLib
+161 stdcall LoadTypeLib (wstr ptr) oleaut32.LoadTypeLib
+162 stdcall LoadRegTypeLib (ptr long long long ptr) oleaut32.LoadRegTypeLib
+163 stdcall RegisterTypeLib(ptr wstr wstr) oleaut32.RegisterTypeLib
+164 stdcall QueryPathOfRegTypeLib(ptr long long long ptr) oleaut32.QueryPathOfRegTypeLib
+165 stdcall LHashValOfNameSys(long long wstr) oleaut32.LHashValOfNameSys
+166 stdcall LHashValOfNameSysA(long long str) oleaut32.LHashValOfNameSysA
+167 stdcall VarXor(ptr ptr ptr) oleaut32.VarXor
+168 stdcall VarAbs(ptr ptr) oleaut32.VarAbs
+169 stdcall VarFix(ptr ptr) oleaut32.VarFix
+170 stdcall OaBuildVersion() oleaut32.OaBuildVersion
+171 stdcall ClearCustData(ptr) oleaut32.ClearCustData
+172 stdcall VarInt(ptr ptr) oleaut32.VarInt
+173 stdcall VarNeg(ptr ptr) oleaut32.VarNeg
+174 stdcall VarNot(ptr ptr) oleaut32.VarNot
+175 stdcall VarRound(ptr long ptr) oleaut32.VarRound
+176 stdcall VarCmp(ptr ptr long long) oleaut32.VarCmp
+177 stdcall VarDecAdd(ptr ptr ptr) oleaut32.VarDecAdd
+178 stdcall VarDecDiv(ptr ptr ptr) oleaut32.VarDecDiv
+179 stdcall VarDecMul(ptr ptr ptr) oleaut32.VarDecMul
+180 stdcall CreateTypeLib2(long wstr ptr) oleaut32.CreateTypeLib2
+181 stdcall VarDecSub(ptr ptr ptr) oleaut32.VarDecSub
+182 stdcall VarDecAbs(ptr ptr) oleaut32.VarDecAbs
+183 stdcall LoadTypeLibEx (wstr long ptr) oleaut32.LoadTypeLibEx
+184 stdcall SystemTimeToVariantTime(ptr ptr) oleaut32.SystemTimeToVariantTime
+185 stdcall VariantTimeToSystemTime(double ptr) oleaut32.VariantTimeToSystemTime
+186 stdcall UnRegisterTypeLib (ptr long long long long) oleaut32.UnRegisterTypeLib
+187 stdcall VarDecFix(ptr ptr) oleaut32.VarDecFix
+188 stdcall VarDecInt(ptr ptr) oleaut32.VarDecInt
+189 stdcall VarDecNeg(ptr ptr) oleaut32.VarDecNeg
+190 stdcall VarDecFromUI1(long ptr) oleaut32.VarDecFromUI1
+191 stdcall VarDecFromI2(long ptr) oleaut32.VarDecFromI2
+192 stdcall VarDecFromI4(long ptr) oleaut32.VarDecFromI4
+193 stdcall VarDecFromR4(float ptr) oleaut32.VarDecFromR4
+194 stdcall VarDecFromR8(double ptr) oleaut32.VarDecFromR8
+195 stdcall VarDecFromDate(double ptr) oleaut32.VarDecFromDate
+196 stdcall VarDecFromCy(int64 ptr) oleaut32.VarDecFromCy
+197 stdcall VarDecFromStr(wstr long long ptr) oleaut32.VarDecFromStr
+198 stdcall VarDecFromDisp(ptr long ptr) oleaut32.VarDecFromDisp
+199 stdcall VarDecFromBool(long ptr) oleaut32.VarDecFromBool
+200 stdcall GetErrorInfo(long ptr) ole32.GetErrorInfo
+201 stdcall SetErrorInfo(long ptr) ole32.SetErrorInfo
+202 stdcall CreateErrorInfo(ptr) ole32.CreateErrorInfo
+203 stdcall VarDecRound(ptr long ptr) oleaut32.VarDecRound
+204 stdcall VarDecCmp(ptr ptr) oleaut32.VarDecCmp
+205 stdcall VarI2FromI1(long ptr) oleaut32.VarI2FromI1
+206 stdcall VarI2FromUI2(long ptr) oleaut32.VarI2FromUI2
+207 stdcall VarI2FromUI4(long ptr) oleaut32.VarI2FromUI4
+208 stdcall VarI2FromDec(ptr ptr) oleaut32.VarI2FromDec
+209 stdcall VarI4FromI1(long ptr) oleaut32.VarI4FromI1
+210 stdcall VarI4FromUI2(long ptr) oleaut32.VarI4FromUI2
+211 stdcall VarI4FromUI4(long ptr) oleaut32.VarI4FromUI4
+212 stdcall VarI4FromDec(ptr ptr) oleaut32.VarI4FromDec
+213 stdcall VarR4FromI1(long ptr) oleaut32.VarR4FromI1
+214 stdcall VarR4FromUI2(long ptr) oleaut32.VarR4FromUI2
+215 stdcall VarR4FromUI4(long ptr) oleaut32.VarR4FromUI4
+216 stdcall VarR4FromDec(ptr ptr) oleaut32.VarR4FromDec
+217 stdcall VarR8FromI1(long ptr) oleaut32.VarR8FromI1
+218 stdcall VarR8FromUI2(long ptr) oleaut32.VarR8FromUI2
+219 stdcall VarR8FromUI4(long ptr) oleaut32.VarR8FromUI4
+220 stdcall VarR8FromDec(ptr ptr) oleaut32.VarR8FromDec
+221 stdcall VarDateFromI1(long ptr) oleaut32.VarDateFromI1
+222 stdcall VarDateFromUI2(long ptr) oleaut32.VarDateFromUI2
+223 stdcall VarDateFromUI4(long ptr) oleaut32.VarDateFromUI4
+224 stdcall VarDateFromDec(ptr ptr) oleaut32.VarDateFromDec
+225 stdcall VarCyFromI1(long ptr) oleaut32.VarCyFromI1
+226 stdcall VarCyFromUI2(long ptr) oleaut32.VarCyFromUI2
+227 stdcall VarCyFromUI4(long ptr) oleaut32.VarCyFromUI4
+228 stdcall VarCyFromDec(ptr ptr) oleaut32.VarCyFromDec
+229 stdcall VarBstrFromI1(long long long ptr) oleaut32.VarBstrFromI1
+230 stdcall VarBstrFromUI2(long long long ptr) oleaut32.VarBstrFromUI2
+231 stdcall VarBstrFromUI4(long long long ptr) oleaut32.VarBstrFromUI4
+232 stdcall VarBstrFromDec(ptr long long ptr) oleaut32.VarBstrFromDec
+233 stdcall VarBoolFromI1(long ptr) oleaut32.VarBoolFromI1
+234 stdcall VarBoolFromUI2(long ptr) oleaut32.VarBoolFromUI2
+235 stdcall VarBoolFromUI4(long ptr) oleaut32.VarBoolFromUI4
+236 stdcall VarBoolFromDec(ptr ptr) oleaut32.VarBoolFromDec
+237 stdcall VarUI1FromI1(long ptr) oleaut32.VarUI1FromI1
+238 stdcall VarUI1FromUI2(long ptr) oleaut32.VarUI1FromUI2
+239 stdcall VarUI1FromUI4(long ptr) oleaut32.VarUI1FromUI4
+240 stdcall VarUI1FromDec(ptr ptr) oleaut32.VarUI1FromDec
+241 stdcall VarDecFromI1(long ptr) oleaut32.VarDecFromI1
+242 stdcall VarDecFromUI2(long ptr) oleaut32.VarDecFromUI2
+243 stdcall VarDecFromUI4(long ptr) oleaut32.VarDecFromUI4
+244 stdcall VarI1FromUI1(long ptr) oleaut32.VarI1FromUI1
+245 stdcall VarI1FromI2(long ptr) oleaut32.VarI1FromI2
+246 stdcall VarI1FromI4(long ptr) oleaut32.VarI1FromI4
+247 stdcall VarI1FromR4(float ptr) oleaut32.VarI1FromR4
+248 stdcall VarI1FromR8(double ptr) oleaut32.VarI1FromR8
+249 stdcall VarI1FromDate(double ptr) oleaut32.VarI1FromDate
+250 stdcall VarI1FromCy(int64 ptr) oleaut32.VarI1FromCy
+251 stdcall VarI1FromStr(wstr long long ptr) oleaut32.VarI1FromStr
+252 stdcall VarI1FromDisp(ptr long ptr) oleaut32.VarI1FromDisp
+253 stdcall VarI1FromBool(long ptr) oleaut32.VarI1FromBool
+254 stdcall VarI1FromUI2(long ptr) oleaut32.VarI1FromUI2
+255 stdcall VarI1FromUI4(long ptr) oleaut32.VarI1FromUI4
+256 stdcall VarI1FromDec(ptr ptr) oleaut32.VarI1FromDec
+257 stdcall VarUI2FromUI1(long ptr) oleaut32.VarUI2FromUI1
+258 stdcall VarUI2FromI2(long ptr) oleaut32.VarUI2FromI2
+259 stdcall VarUI2FromI4(long ptr) oleaut32.VarUI2FromI4
+260 stdcall VarUI2FromR4(float ptr) oleaut32.VarUI2FromR4
+261 stdcall VarUI2FromR8(double ptr) oleaut32.VarUI2FromR8
+262 stdcall VarUI2FromDate(double ptr) oleaut32.VarUI2FromDate
+263 stdcall VarUI2FromCy(int64 ptr) oleaut32.VarUI2FromCy
+264 stdcall VarUI2FromStr(wstr long long ptr) oleaut32.VarUI2FromStr
+265 stdcall VarUI2FromDisp(ptr long ptr) oleaut32.VarUI2FromDisp
+266 stdcall VarUI2FromBool(long ptr) oleaut32.VarUI2FromBool
+267 stdcall VarUI2FromI1(long ptr) oleaut32.VarUI2FromI1
+268 stdcall VarUI2FromUI4(long ptr) oleaut32.VarUI2FromUI4
+269 stdcall VarUI2FromDec(ptr ptr) oleaut32.VarUI2FromDec
+270 stdcall VarUI4FromUI1(long ptr) oleaut32.VarUI4FromUI1
+271 stdcall VarUI4FromI2(long ptr) oleaut32.VarUI4FromI2
+272 stdcall VarUI4FromI4(long ptr) oleaut32.VarUI4FromI4
+273 stdcall VarUI4FromR4(float ptr) oleaut32.VarUI4FromR4
+274 stdcall VarUI4FromR8(double ptr) oleaut32.VarUI4FromR8
+275 stdcall VarUI4FromDate(double ptr) oleaut32.VarUI4FromDate
+276 stdcall VarUI4FromCy(int64 ptr) oleaut32.VarUI4FromCy
+277 stdcall VarUI4FromStr(wstr long long ptr) oleaut32.VarUI4FromStr
+278 stdcall VarUI4FromDisp(ptr long ptr) oleaut32.VarUI4FromDisp
+279 stdcall VarUI4FromBool(long ptr) oleaut32.VarUI4FromBool
+280 stdcall VarUI4FromI1(long ptr) oleaut32.VarUI4FromI1
+281 stdcall VarUI4FromUI2(long ptr) oleaut32.VarUI4FromUI2
+282 stdcall VarUI4FromDec(ptr ptr) oleaut32.VarUI4FromDec
+283 stdcall BSTR_UserSize(ptr long ptr) oleaut32.BSTR_UserSize
+284 stdcall BSTR_UserMarshal(ptr ptr ptr) oleaut32.BSTR_UserMarshal
+285 stdcall BSTR_UserUnmarshal(ptr ptr ptr) oleaut32.BSTR_UserUnmarshal
+286 stdcall BSTR_UserFree(ptr ptr) oleaut32.BSTR_UserFree
+287 stdcall VARIANT_UserSize(ptr long ptr) oleaut32.VARIANT_UserSize
+288 stdcall VARIANT_UserMarshal(ptr ptr ptr) oleaut32.VARIANT_UserMarshal
+289 stdcall VARIANT_UserUnmarshal(ptr ptr ptr) oleaut32.VARIANT_UserUnmarshal
+290 stdcall VARIANT_UserFree(ptr ptr) oleaut32.VARIANT_UserFree
+291 stdcall LPSAFEARRAY_UserSize(ptr long ptr) oleaut32.LPSAFEARRAY_UserSize
+292 stdcall LPSAFEARRAY_UserMarshal(ptr ptr ptr) oleaut32.LPSAFEARRAY_UserMarshal
+293 stdcall LPSAFEARRAY_UserUnmarshal(ptr ptr ptr) oleaut32.LPSAFEARRAY_UserUnmarshal
+294 stdcall LPSAFEARRAY_UserFree(ptr ptr) oleaut32.LPSAFEARRAY_UserFree
+295 stub LPSAFEARRAY_Size
+296 stub LPSAFEARRAY_Marshal
+297 stub LPSAFEARRAY_Unmarshal
+298 stdcall VarDecCmpR8(ptr double) oleaut32.VarDecCmpR8
+299 stdcall VarCyAdd(int64 int64 ptr) oleaut32.VarCyAdd
+303 stdcall VarCyMul(int64 int64 ptr) oleaut32.VarCyMul
+304 stdcall VarCyMulI4(int64 long ptr) oleaut32.VarCyMulI4
+305 stdcall VarCySub(int64 int64 ptr) oleaut32.VarCySub
+306 stdcall VarCyAbs(int64 ptr) oleaut32.VarCyAbs
+307 stdcall VarCyFix(int64 ptr) oleaut32.VarCyFix
+308 stdcall VarCyInt(int64 ptr) oleaut32.VarCyInt
+309 stdcall VarCyNeg(int64 ptr) oleaut32.VarCyNeg
+310 stdcall VarCyRound(int64 long ptr) oleaut32.VarCyRound
+311 stdcall VarCyCmp(int64 int64) oleaut32.VarCyCmp
+312 stdcall VarCyCmpR8(int64 double) oleaut32.VarCyCmpR8
+313 stdcall VarBstrCat(wstr wstr ptr) oleaut32.VarBstrCat
+314 stdcall VarBstrCmp(wstr wstr long long) oleaut32.VarBstrCmp
+315 stdcall VarR8Pow(double double ptr) oleaut32.VarR8Pow
+316 stdcall VarR4CmpR8(float double) oleaut32.VarR4CmpR8
+317 stdcall VarR8Round(double long ptr) oleaut32.VarR8Round
+318 stdcall VarCat(ptr ptr ptr) oleaut32.VarCat
+319 stdcall VarDateFromUdateEx(ptr long long ptr) oleaut32.VarDateFromUdateEx
+322 stdcall GetRecordInfoFromGuids(ptr long long long ptr ptr) oleaut32.GetRecordInfoFromGuids
+323 stdcall GetRecordInfoFromTypeInfo(ptr ptr) oleaut32.GetRecordInfoFromTypeInfo
+325 stub SetVarConversionLocaleSetting
+326 stub GetVarConversionLocaleSetting
+327 stdcall SetOaNoCache() oleaut32.SetOaNoCache
+329 stdcall VarCyMulI8(int64 int64 ptr) oleaut32.VarCyMulI8
+330 stdcall VarDateFromUdate(ptr long ptr) oleaut32.VarDateFromUdate
+331 stdcall VarUdateFromDate(double long ptr) oleaut32.VarUdateFromDate
+332 stub GetAltMonthNames
+333 stdcall VarI8FromUI1(long long) oleaut32.VarI8FromUI1
+334 stdcall VarI8FromI2(long long) oleaut32.VarI8FromI2
+335 stdcall VarI8FromR4(float long) oleaut32.VarI8FromR4
+336 stdcall VarI8FromR8(double long) oleaut32.VarI8FromR8
+337 stdcall VarI8FromCy(int64 ptr) oleaut32.VarI8FromCy
+338 stdcall VarI8FromDate(double long) oleaut32.VarI8FromDate
+339 stdcall VarI8FromStr(wstr long long ptr) oleaut32.VarI8FromStr
+340 stdcall VarI8FromDisp(ptr long ptr) oleaut32.VarI8FromDisp
+341 stdcall VarI8FromBool(long long) oleaut32.VarI8FromBool
+342 stdcall VarI8FromI1(long long) oleaut32.VarI8FromI1
+343 stdcall VarI8FromUI2(long long) oleaut32.VarI8FromUI2
+344 stdcall VarI8FromUI4(long long) oleaut32.VarI8FromUI4
+345 stdcall VarI8FromDec(ptr ptr) oleaut32.VarI8FromDec
+346 stdcall VarI2FromI8(int64 ptr) oleaut32.VarI2FromI8
+347 stdcall VarI2FromUI8(int64 ptr) oleaut32.VarI2FromUI8
+348 stdcall VarI4FromI8(int64 ptr) oleaut32.VarI4FromI8
+349 stdcall VarI4FromUI8(int64 ptr) oleaut32.VarI4FromUI8
+360 stdcall VarR4FromI8(int64 ptr) oleaut32.VarR4FromI8
+361 stdcall VarR4FromUI8(int64 ptr) oleaut32.VarR4FromUI8
+362 stdcall VarR8FromI8(int64 ptr) oleaut32.VarR8FromI8
+363 stdcall VarR8FromUI8(int64 ptr) oleaut32.VarR8FromUI8
+364 stdcall VarDateFromI8(int64 ptr) oleaut32.VarDateFromI8
+365 stdcall VarDateFromUI8(int64 ptr) oleaut32.VarDateFromUI8
+366 stdcall VarCyFromI8(int64 ptr) oleaut32.VarCyFromI8
+367 stdcall VarCyFromUI8(int64 ptr) oleaut32.VarCyFromUI8
+368 stdcall VarBstrFromI8(int64 long long ptr) oleaut32.VarBstrFromI8
+369 stdcall VarBstrFromUI8(int64 long long ptr) oleaut32.VarBstrFromUI8
+370 stdcall VarBoolFromI8(int64 ptr) oleaut32.VarBoolFromI8
+371 stdcall VarBoolFromUI8(int64 ptr) oleaut32.VarBoolFromUI8
+372 stdcall VarUI1FromI8(int64 ptr) oleaut32.VarUI1FromI8
+373 stdcall VarUI1FromUI8(int64 ptr) oleaut32.VarUI1FromUI8
+374 stdcall VarDecFromI8(int64 ptr) oleaut32.VarDecFromI8
+375 stdcall VarDecFromUI8(int64 ptr) oleaut32.VarDecFromUI8
+376 stdcall VarI1FromI8(int64 ptr) oleaut32.VarI1FromI8
+377 stdcall VarI1FromUI8(int64 ptr) oleaut32.VarI1FromUI8
+378 stdcall VarUI2FromI8(int64 ptr) oleaut32.VarUI2FromI8
+379 stdcall VarUI2FromUI8(int64 ptr) oleaut32.VarUI2FromUI8
+380 stub UserHWND_from_local
+381 stub UserHWND_to_local
+382 stub UserHWND_free_inst
+383 stub UserHWND_free_local
+384 stub UserBSTR_from_local
+385 stub UserBSTR_to_local
+386 stub UserBSTR_free_inst
+387 stub UserBSTR_free_local
+388 stub UserVARIANT_from_local
+389 stub UserVARIANT_to_local
+390 stub UserVARIANT_free_inst
+391 stub UserVARIANT_free_local
+392 stub UserEXCEPINFO_from_local
+393 stub UserEXCEPINFO_to_local
+394 stub UserEXCEPINFO_free_inst
+395 stub UserEXCEPINFO_free_local
+396 stub UserMSG_from_local
+397 stub UserMSG_to_local
+398 stub UserMSG_free_inst
+399 stub UserMSG_free_local
+401 stdcall OleLoadPictureEx(ptr long long long long long long ptr) oleaut32.OleLoadPictureEx
+402 stub OleLoadPictureFileEx
+411 stdcall SafeArrayCreateVector(long long long) oleaut32.SafeArrayCreateVector
+412 stdcall SafeArrayCopyData(ptr ptr) oleaut32.SafeArrayCopyData
+413 stdcall VectorFromBstr(ptr ptr) oleaut32.VectorFromBstr
+414 stdcall BstrFromVector(ptr ptr) oleaut32.BstrFromVector
+415 stdcall OleIconToCursor(long long) oleaut32.OleIconToCursor
+416 stdcall OleCreatePropertyFrameIndirect(ptr) oleaut32.OleCreatePropertyFrameIndirect
+417 stdcall OleCreatePropertyFrame(ptr long long ptr long ptr long ptr ptr long ptr) oleaut32.OleCreatePropertyFrame
+418 stdcall OleLoadPicture(ptr long long ptr ptr) oleaut32.OleLoadPicture
+419 stdcall OleCreatePictureIndirect(ptr ptr long ptr) oleaut32.OleCreatePictureIndirect
+420 stdcall OleCreateFontIndirect(ptr ptr ptr) oleaut32.OleCreateFontIndirect
+421 stdcall OleTranslateColor(long long long) oleaut32.OleTranslateColor
+422 stub OleLoadPictureFile
+423 stub OleSavePictureFile
+424 stdcall OleLoadPicturePath(wstr ptr long long ptr ptr) oleaut32.OleLoadPicturePath
+425 stdcall VarUI4FromI8(int64 ptr) oleaut32.VarUI4FromI8
+426 stdcall VarUI4FromUI8(int64 ptr) oleaut32.VarUI4FromUI8
+427 stdcall VarI8FromUI8(int64 ptr) oleaut32.VarI8FromUI8
+428 stdcall VarUI8FromI8(int64 ptr) oleaut32.VarUI8FromI8
+429 stdcall VarUI8FromUI1(long ptr) oleaut32.VarUI8FromUI1
+430 stdcall VarUI8FromI2(long ptr) oleaut32.VarUI8FromI2
+431 stdcall VarUI8FromR4(float ptr) oleaut32.VarUI8FromR4
+432 stdcall VarUI8FromR8(double ptr) oleaut32.VarUI8FromR8
+433 stdcall VarUI8FromCy(int64 ptr) oleaut32.VarUI8FromCy
+434 stdcall VarUI8FromDate(double ptr) oleaut32.VarUI8FromDate
+435 stdcall VarUI8FromStr(wstr long long ptr) oleaut32.VarUI8FromStr
+436 stdcall VarUI8FromDisp(ptr long ptr) oleaut32.VarUI8FromDisp
+437 stdcall VarUI8FromBool(long ptr) oleaut32.VarUI8FromBool
+438 stdcall VarUI8FromI1(long ptr) oleaut32.VarUI8FromI1
+439 stdcall VarUI8FromUI2(long ptr) oleaut32.VarUI8FromUI2
+440 stdcall VarUI8FromUI4(long ptr) oleaut32.VarUI8FromUI4
+441 stdcall VarUI8FromDec(long ptr) oleaut32.VarUI8FromDec
+442 stdcall RegisterTypeLibForUser(ptr wstr wstr) oleaut32.RegisterTypeLibForUser
+443 stdcall UnRegisterTypeLibForUser(ptr long long long long) oleaut32.UnRegisterTypeLibForUser
+
+@ stdcall -private DllCanUnloadNow() oleaut32.DllCanUnloadNow
+@ stdcall -private DllGetClassObject(ptr ptr ptr) oleaut32.DllGetClassObject
+@ stdcall -private DllRegisterServer() oleaut32.DllRegisterServer
+@ stdcall -private DllUnregisterServer() oleaut32.DllUnregisterServer
diff -Naur wine-2.0a/dlls/32autole/Makefile.in wine-2.0b/dlls/32autole/Makefile.in
--- wine-2.0a/dlls/32autole/Makefile.in	1970-01-01 01:00:00.000000000 +0100
+++ wine-2.0b/dlls/32autole/Makefile.in	2017-07-11 20:37:49.000000000 +0100
@@ -0,0 +1,2 @@
+MODULE    = 32autole.dll
+IMPORTS   = oleaut32
diff -Naur wine-2.0a/dlls/advapi32/advapi.c wine-2.0b/dlls/advapi32/advapi.c
--- wine-2.0a/dlls/advapi32/advapi.c	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/advapi32/advapi.c	2017-07-11 20:37:49.000000000 +0100
@@ -22,6 +22,7 @@
 #include <stdio.h>
 #include <string.h>
 #include <stdarg.h>
+#include <stdlib.h>
 
 #include "windef.h"
 #include "winbase.h"
@@ -84,10 +85,18 @@
 BOOL WINAPI
 GetUserNameW( LPWSTR lpszName, LPDWORD lpSize )
 {
-    const char *name = wine_get_user_name();
-    DWORD i, len = MultiByteToWideChar( CP_UNIXCP, 0, name, -1, NULL, 0 );
+    /* CrossOver Hack 12735: Use a consistent username */
+    const char *report_real_username = getenv( "CX_REPORT_REAL_USERNAME" );
+    const char *name;
+    DWORD i, len;
     LPWSTR backslash;
 
+    if (!report_real_username)
+        name = "crossover";
+    else
+        name = wine_get_user_name();
+
+    len = MultiByteToWideChar( CP_UNIXCP, 0, name, -1, NULL, 0 );
     if (len > *lpSize)
     {
         SetLastError( ERROR_INSUFFICIENT_BUFFER );
diff -Naur wine-2.0a/dlls/advapi32/security.c wine-2.0b/dlls/advapi32/security.c
--- wine-2.0a/dlls/advapi32/security.c	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/advapi32/security.c	2017-07-11 20:37:49.000000000 +0100
@@ -2421,10 +2421,54 @@
     HANDLE file;
     DWORD access = 0, err;
     NTSTATUS status;
+    static int is_office = 2;
 
     TRACE("(%s, 0x%x, %p)\n", debugstr_w(lpFileName), RequestedInformation,
           pSecurityDescriptor );
 
+    /* CX HACK 10834 -- msoffice sets FILE_EXECUTE on files it saves and Wine
+     * maps that to the x permission on files. Some Linux file managers decide
+     * to try to execute the file instead of opening it with the assigned
+     * application. So, skip setting that bit for msoffice programs. */
+    if(is_office == 2){
+        char name[MAX_PATH], *p;
+        GetModuleFileNameA(GetModuleHandleA(NULL), name, sizeof(name));
+        p = strrchr(name, '\\');
+        if(p)
+            ++p;
+        else
+            p = name;
+        if(strcasecmp(p, "CLVIEW.EXE") == 0 ||
+                strcasecmp(p, "CNFNOT32.EXE") == 0 ||
+                strcasecmp(p, "DSSM.EXE") == 0 ||
+                strcasecmp(p, "excelcnv.exe") == 0 ||
+                strcasecmp(p, "EXCEL.EXE") == 0 ||
+                strcasecmp(p, "GRAPH.EXE") == 0 ||
+                strcasecmp(p, "MSOHTMED.EXE") == 0 ||
+                strcasecmp(p, "MSQRY32.EXE") == 0 ||
+                strcasecmp(p, "MSTORDB.EXE") == 0 ||
+                strcasecmp(p, "MSTORE.EXE") == 0 ||
+                strcasecmp(p, "OIS.EXE") == 0 ||
+                strcasecmp(p, "OUTLOOK.EXE") == 0 ||
+                strcasecmp(p, "POWERPNT.EXE") == 0 ||
+                strcasecmp(p, "PPTVIEW.EXE") == 0 ||
+                strcasecmp(p, "SCANOST.EXE") == 0 ||
+                strcasecmp(p, "SCANPST.EXE") == 0 ||
+                strcasecmp(p, "SELFCERT.EXE") == 0 ||
+                strcasecmp(p, "SETLANG.EXE") == 0 ||
+                strcasecmp(p, "VPREVIEW.EXE") == 0 ||
+                strcasecmp(p, "WINWORD.EXE") == 0 ||
+                strcasecmp(p, "Wordconv.exe") == 0)
+            is_office = 1;
+        else
+            is_office = 0;
+    }
+    if(is_office){
+        TRACE("CX HACK 10834: Skipping SetFileSecurity\n");
+        return TRUE;
+    }
+    /* End hack */
+
     if (RequestedInformation & OWNER_SECURITY_INFORMATION ||
         RequestedInformation & GROUP_SECURITY_INFORMATION)
         access |= WRITE_OWNER;
diff -Naur wine-2.0a/dlls/advapi32/service.c wine-2.0b/dlls/advapi32/service.c
--- wine-2.0a/dlls/advapi32/service.c	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/advapi32/service.c	2017-07-11 20:37:49.000000000 +0100
@@ -226,6 +226,31 @@
     RpcBindingFree(&h);
 }
 
+/* CROSSOVER HACK: Office 2000 setup installs native rpcrt4 and then uses
+ * services functions which fail (due to bugs in the string binding functions
+ * causing {NULL, "\\pipe\\svcctl"} to be transformed to "\\\\\\pipe\\svcctl"
+ * instead of "\\\\.\\pipe\\svctl") and causes I_RpcExceptionFilter to be used.
+ * Unfortunately, this function isn't available in the version of rpcrt4 that
+ * it installs and so we replace it with a non-imported version of it below */
+int WINAPI I_RpcExceptionFilter(ULONG ExceptionCode)
+{
+    TRACE("0x%x\n", ExceptionCode);
+    switch (ExceptionCode)
+    {
+    case STATUS_DATATYPE_MISALIGNMENT:
+    case STATUS_BREAKPOINT:
+    case STATUS_ACCESS_VIOLATION:
+    case STATUS_ILLEGAL_INSTRUCTION:
+    case STATUS_PRIVILEGED_INSTRUCTION:
+    case 0xC00000AA /*STATUS_INSTRUCTION_MISALIGNMENT*/:
+    case STATUS_STACK_OVERFLOW:
+    case 0xC0000194 /*STATUS_POSSIBLE_DEADLOCK*/:
+        return EXCEPTION_CONTINUE_SEARCH;
+    default:
+        return EXCEPTION_EXECUTE_HANDLER;
+    }
+}
+
 DECLSPEC_HIDDEN handle_t __RPC_USER SVCCTL_HANDLEW_bind(SVCCTL_HANDLEW MachineName)
 {
     return rpc_wstr_bind((RPC_WSTR)MachineName);
diff -Naur wine-2.0a/dlls/bcrypt/bcrypt_main.c wine-2.0b/dlls/bcrypt/bcrypt_main.c
--- wine-2.0a/dlls/bcrypt/bcrypt_main.c	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/bcrypt/bcrypt_main.c	2017-07-11 20:37:49.000000000 +0100
@@ -71,7 +71,21 @@
 {
     int ret;
 
-    if (!(libgnutls_handle = wine_dlopen( SONAME_LIBGNUTLS, RTLD_NOW, NULL, 0 )))
+if (1) { /* CROSSOVER HACK - bug 10151 */
+    const char *libgnutls_name_candidates[] = {SONAME_LIBGNUTLS,
+                                               "libgnutls.so.30",
+                                               "libgnutls.so.28",
+                                               "libgnutls-deb0.so.28",
+                                               "libgnutls.so.26",
+                                               NULL};
+    int i;
+    for (i=0; libgnutls_name_candidates[i] && !libgnutls_handle; i++)
+        libgnutls_handle = wine_dlopen(libgnutls_name_candidates[i], RTLD_NOW, NULL, 0);
+}
+else
+    libgnutls_handle = wine_dlopen( SONAME_LIBGNUTLS, RTLD_NOW, NULL, 0 );
+
+    if (!libgnutls_handle)
     {
         ERR_(winediag)( "failed to load libgnutls, no support for crypto hashes\n" );
         return FALSE;
diff -Naur wine-2.0a/dlls/comctl32/pager.c wine-2.0b/dlls/comctl32/pager.c
--- wine-2.0a/dlls/comctl32/pager.c	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/comctl32/pager.c	2017-07-11 20:37:49.000000000 +0100
@@ -388,34 +388,6 @@
     return 0;
 }
 
-static LRESULT
-PAGER_WindowPosChanging(PAGER_INFO* infoPtr, WINDOWPOS *winpos)
-{
-    if ((infoPtr->dwStyle & CCS_NORESIZE) && !(winpos->flags & SWP_NOSIZE))
-    {
-        /* don't let the app resize the nonscrollable dimension of a control
-         * that was created with CCS_NORESIZE style
-         * (i.e. height for a horizontal pager, or width for a vertical one) */
-
-	/* except if the current dimension is 0 and app is setting for
-	 * first time, then save amount as dimension. - GA 8/01 */
-
-        if (infoPtr->dwStyle & PGS_HORZ)
-	    if (!infoPtr->nHeight && winpos->cy)
-		infoPtr->nHeight = winpos->cy;
-	    else
-		winpos->cy = infoPtr->nHeight;
-        else
-	    if (!infoPtr->nWidth && winpos->cx)
-		infoPtr->nWidth = winpos->cx;
-	    else
-		winpos->cx = infoPtr->nWidth;
-	return 0;
-    }
-
-    return DefWindowProcW (infoPtr->hwndSelf, WM_WINDOWPOSCHANGING, 0, (LPARAM)winpos);
-}
-
 /******************************************************************
  * For the PGM_RECALCSIZE message (but not the other uses in      *
  * this module), the native control does only the following:      *
@@ -1036,6 +1008,8 @@
 {
     PAGER_INFO *infoPtr = (PAGER_INFO *)GetWindowLongPtrW(hwnd, 0);
 
+    TRACE("(%p, %#x, %#lx, %#lx)\n", hwnd, uMsg, wParam, lParam);
+
     if (!infoPtr && (uMsg != WM_CREATE))
 	return DefWindowProcW (hwnd, uMsg, wParam, lParam);
 
@@ -1094,9 +1068,6 @@
         case WM_NCPAINT:
             return PAGER_NCPaint (infoPtr, (HRGN)wParam);
 
-        case WM_WINDOWPOSCHANGING:
-            return PAGER_WindowPosChanging (infoPtr, (WINDOWPOS*)lParam);
-
         case WM_STYLECHANGED:
             return PAGER_StyleChanged(infoPtr, wParam, (LPSTYLESTRUCT)lParam);
 
diff -Naur wine-2.0a/dlls/comctl32/tests/pager.c wine-2.0b/dlls/comctl32/tests/pager.c
--- wine-2.0a/dlls/comctl32/tests/pager.c	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/comctl32/tests/pager.c	2017-07-11 20:37:49.000000000 +0100
@@ -83,6 +83,28 @@
         add_message(sequences, PAGER_SEQ_INDEX, &msg);
     }
 
+    if (message == WM_NOTIFY)
+    {
+        NMHDR *nmhdr = (NMHDR *)lParam;
+
+        switch (nmhdr->code)
+        {
+            case PGN_CALCSIZE:
+            {
+                NMPGCALCSIZE *nmpgcs = (NMPGCALCSIZE *)lParam;
+                DWORD style = GetWindowLongA(nmpgcs->hdr.hwndFrom, GWL_STYLE);
+
+                if (style & PGS_HORZ)
+                    ok(nmpgcs->dwFlag == PGF_CALCWIDTH, "Unexpected flags %#x.\n", nmpgcs->dwFlag);
+                else
+                    ok(nmpgcs->dwFlag == PGF_CALCHEIGHT, "Unexpected flags %#x.\n", nmpgcs->dwFlag);
+                break;
+            }
+            default:
+                ;
+        }
+    }
+
     defwndproc_counter++;
     ret = DefWindowProcA(hwnd, message, wParam, lParam);
     defwndproc_counter--;
@@ -148,7 +170,7 @@
 static void test_pager(void)
 {
     HWND pager, child;
-    RECT rect;
+    RECT rect, rect2;
 
     pager = create_pager_control( PGS_HORZ );
     if (!pager)
@@ -182,6 +204,29 @@
     ok_sequence(sequences, PAGER_SEQ_INDEX, set_pos_seq, "set pos", TRUE);
 
     DestroyWindow( pager );
+
+    /* Test if resizing works */
+    pager = create_pager_control( CCS_NORESIZE );
+    ok(pager != NULL, "failed to create pager control\n");
+
+    GetWindowRect( pager, &rect );
+    MoveWindow( pager, 0, 0, 200, 100, TRUE );
+    GetWindowRect( pager, &rect2 );
+    ok(rect2.right - rect2.left > rect.right - rect.left, "expected pager window to resize, %s\n",
+        wine_dbgstr_rect( &rect2 ));
+
+    DestroyWindow( pager );
+
+    pager = create_pager_control( CCS_NORESIZE | PGS_HORZ );
+    ok(pager != NULL, "failed to create pager control\n");
+
+    GetWindowRect( pager, &rect );
+    MoveWindow( pager, 0, 0, 100, 200, TRUE );
+    GetWindowRect( pager, &rect2 );
+    ok(rect2.bottom - rect2.top > rect.bottom - rect.top, "expected pager window to resize, %s\n",
+        wine_dbgstr_rect( &rect2 ));
+
+    DestroyWindow( pager );
 }
 
 START_TEST(pager)
diff -Naur wine-2.0a/dlls/comctl32/theming.c wine-2.0b/dlls/comctl32/theming.c
--- wine-2.0a/dlls/comctl32/theming.c	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/comctl32/theming.c	2017-07-11 20:37:49.000000000 +0100
@@ -124,7 +124,15 @@
     static const WCHAR refDataPropName[] = 
         { 'C','C','3','2','T','h','e','m','i','n','g','D','a','t','a',0 };
 
-    if (!IsThemeActive()) return;
+    /* CrossOver only HACK - Theming subclassing is disabled
+     * It confuses Delphi programs (such as the DVD Pro installer) and is
+     * generally bad because it removes the A/W duality of the builtin USER
+     * classes like edit controls and list boxes. These probably need to depend
+     * on a manifest resource being present in the executable or maybe need to
+     * use hooks into user32 instead.
+     */
+
+    if (1 || !IsThemeActive()) return;
 
     atSubclassProp = GlobalAddAtomW (subclassPropName);
     atRefDataProp = GlobalAddAtomW (refDataPropName);
diff -Naur wine-2.0a/dlls/credui/banner.bmp wine-2.0b/dlls/credui/banner.bmp
--- wine-2.0a/dlls/credui/banner.bmp	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/credui/banner.bmp	2017-07-11 20:37:49.000000000 +0100
@@ -1,19 +1,842 @@
-BM6á      6   (   @  <          á               yõ yõ yõzõzõzõ{õ{õ{õ|õ|õ|õ}õ}õ}õ~õ~õ~õõõõõõö	ö	ö
-ö
-ö
-öööööööööööööööööö÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷øøøøøøøøøøøøøø ø ø ø!ø!ø"ø"ø"ø#ø#ù$ù$ù$ù%ù%ù%ù&ù&ù&ù'ù'ù(ù(ù(ù)ù)ù*ù*ù*ù+ù+ù,ù,ú, ú- ú- ú.¡ú.¡ú.¡ú/¢ú/¢ú/¢ú0£ú0£ú1£ú1¤ú1¤ú2¤ú2¥ú3¥ú3¥ú3¦ú4¦ú4¦ú5§ú5§û5§û6¨û6¨û6¨û7©û7©û7©û8ªû8ªû9ªû9«û9«û:«û:¬û;¬û;¬û;­û<­û<­û=®û=®û=®û=®û=®û=­û<­ú<¬ú;¬ú;«ú;«ù:ªù:ªù9©ø9©ø9¨ø8§ø8§÷7¦÷7¦÷7¥ö6¥ö6¤ö6¤ö5£õ5£õ4¢õ4¢ô4¡ô3¡ô3 ô2 ó2ó2ó1ó1ò1ò0ò0ñ/ñ/ñ/ñ.ð.ð.ð-ï-ï,ï,î,î+î+î*í*í*í)ì)ì(ì(ì(ë'ë'ë&ê&ê&ê%ê%é%é$é$è#è#è#è"ç"ç!ç!æ!æ æ æååååäääãããââââáá~á~à}à}à|à|ß{ß{ßzÞzÞyÞxÝxÝwÝwÝvÜvÜuÜuÜtÛtÛsÛsÚrÚrÚqÚqÙpÙpÙoØoØnØnØm×m×l×lÖkÖjÖ
-jÖ
-iÕ
-iÕ	hÕ	hÔgÔgÔgÔfÓeÓeÓdÒdÒcÒcÑbÑbÑaÑaÐ`Ð`Ð_Ï_Ï^Ï]Ï]Î \Î yõ yõ yõzõzõzõ{õ{õ{õ|õ|õ|õ}õ}õ}õ~õ~õ~õõõõõõö	ö	ö
-ö
-ö
-öööööööööööööööööö÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷øøøøøøøøøøøøøø ø ø ø!ø!ø"ø"ø"ø#ø#ù$ù$ù$ù%ù%ù%ù&ù&ù&ù'ù'ù(ù(ù(ù)ù)ù*ù*ù*ù+ù+ù,ù,ú, ú- ú- ú.¡ú.¡ú.¡ú/¢ú/¢ú/¢ú0£ú0£ú1£ú1¤ú1¤ú2¤ú2¥ú3¥ú3¥ú3¦ú4¦ú4¦ú5§ú5§û5§û6¨û6¨û6¨û7©û7©û7©û8ªû8ªû9ªû9«û9«û:«û:¬û;¬û;¬û;­û<­û<­û=®û=®û=®û=®û=®û=­û<­ú<¬ú;¬ú;«ú;«ù:ªù:ªù9©ø9©ø9¨ø8§ø8§÷7¦÷7¦÷7¥ö6¥ö6¤ö6¤ö5£õ5£õ4¢õ4¢ô4¡ô3¡ô3 ô2 ó2ó2ó1ó1ò1ò0ò0ñ/ñ/ñ/ñ.ð.ð.ð-ï-ï,ï,î,î+î+î*í*í*í)ì)ì(ì(ì(ë'ë'ë&ê&ê&ê%ê%é%é$é$è#è#è#è"ç"ç!ç!æ!æ æ æååååäääãããââââáá~á~à}à}à|à|ß{ß{ßzÞzÞyÞxÝxÝwÝwÝvÜvÜuÜuÜtÛtÛsÛsÚrÚrÚqÚqÙpÙpÙoØoØnØnØm×m×l×lÖkÖjÖ
-jÖ
-iÕ
-iÕ	hÕ	hÔgÔgÔgÔfÓeÓeÓdÒdÒcÒcÑbÑbÑaÑaÐ`Ð`Ð_Ï_Ï^Ï]Ï]Î \Î yõ yõ yõzõzõzõ{õ{õ{õ|õ|õ|õ}õ}õ}õ~õ~õ~õõõõõõö	ö	ö
-ö
-ö
-öööööööööööööööööö÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷øøøøøøøøøøøøøø ø ø ø!ø!ø"ø"ø"ø#ø#ù$ù$ù$ù%ù%ù%ù&ù&ù&ù'ù'ù(ù(ù(ù)ù)ù*ù*ù*ù+ù+ù,ù,ú, ú- ú- ú.¡ú.¡ú.¡ú/¢ú/¢ú/¢ú0£ú0£ú1£ú1¤ú1¤ú2¤ú2¥ú3¥ú3¥ú3¦ú4¦ú4¦ú5§ú5§û5§û6¨û6¨û6¨û7©û7©û7©û8ªû8ªû9ªû9«û9«û:«û:¬û;¬û;¬û;­û<­û<­û=®û=®û=®û=®û=®û=­û<­ú<¬ú;¬ú;«ú;«ù:ªù:ªù9©ø9©ø9¨ø8§ø8§÷7¦÷7¦÷7¥ö6¥ö6¤ö6¤ö5£õ5£õ4¢õ4¢ô4¡ô3¡ô3 ô2 ó2ó2ó1ó1ò1ò0ò0ñ/ñ/ñ/ñ.ð.ð.ð-ï-ï,ï,î,î+î+î*í*í*í)ì)ì(ì(ì(ë'ë'ë&ê&ê&ê%ê%é%é$é$è#è#è#è"ç"ç!ç!æ!æ æ æååååäääãããââââáá~á~à}à}à|à|ß{ß{ßzÞzÞyÞxÝxÝwÝwÝvÜvÜuÜuÜtÛtÛsÛsÚrÚrÚqÚqÙpÙpÙoØoØnØnØm×m×l×lÖkÖjÖ
-jÖ
-iÕ
-iÕ	hÕ	hÔgÔgÔgÔfÓeÓeÓdÒdÒcÒcÑbÑbÑaÑaÐ`Ð`Ð_Ï_Ï^Ï]Ï]Î \ÎªsHªsHªsHªsHªsHªsHªsHªsHªsHªsHªsHªsHªsHªsHªsH©sG©sG©sG©sG©sG©sG©sG©sG©sG©sG©sG©rG©rG©rG©rG©rG©rG©rG©rG©rG©rG©rG©rG©rF©rF©rF©rF©rF¨qF¨qF¨qF¨qF¨qF¨qF¨qF¨qF¨qE¨qE¨qE¨qE§pE§pE§pE§pE§pE§pE§pE§pD§pD§pD§oD§oD§oD¦oD¦oD¦oD¦oC¦oC¦oC¦nC¦nC¥nC¥nC¥nC¥nB¥nB¥mB¥mB¥mB¥mB¥mB¤mA¤mA¤mA¤lA¤lA¤lA¤lA£l@£l@£l@£k@£k@£k@£k@£k@£k@¢j?¢j?¢j?¢j?¢j?¢j?¢i>¢i>¡i>¡i>¡i>¡i>¡h=¡h= h= h= h= h= g< g< g< g<g<f;f;f;f;f;f;e:e:e:e:e:d9d9d9d9d9c8c8c8c8c8b8b8b7b7b7a7a7a6a6a6`6`6`5`5`5_5_5_4_4_4^4^3^3^3^3]3]2]2]2\2\2\1\1\1[1[0[0[0Z0Z0Z0Z/Z/Y/Y/Y/Y.X.X.X.X-X-W-W-W-W,V,V,V,V+U+U+U+U*U*T*T*T)T)S)S)S)S(R(R(R(R(Q'Q'Q'Q'P&P&P&P&P&O%O%O%O%N$N$N$N$M#M#M#M#L"L"L"L"K!K!K!K!J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J ªtHªtHªtHªtHªtHªtHªtHªtHªtHªtHªtHªtHªtHªtHªtHªtHªtHªtHªtHªtHªsHªsHªsHªsHªsHªsHªsHªsHªsHªsHªsHªsHªsHªsHªsH©sG©sG©sG©sG©sG©rG©rG©rG©rG©rG©rG©rG©rG©rG©rF©rF©rF©rF¨qF¨qF¨qF¨qF¨qF¨qF¨qE¨qE¨qE¨qE§pE§pE§pE§pE§pE§pE§pD§pD§oD§oD§oD¦oD¦oD¦oD¦oC¦oC¦nC¦nC¦nC¥nC¥nC¥nB¥nB¥nB¥mB¥mB¥mB¥mB¤mA¤mA¤mA¤lA¤lA¤lA¤lA£l@£l@£k@£k@£k@£k@£k@£k@¢j?¢j?¢j?¢j?¢j?¢j?¢i>¢i>¡i>¡i>¡i>¡i>¡h=¡h= h= h= h= g< g< g< g<g<g<f;f;f;f;f;e:e:e:e:e:d9d9d9d9d9c8c8c8c8c8b8b8b7b7b7a7a7a6a6a6`6`6`5`5`5_5_4_4_4^4^4^3^3^3]3]3]2]2]2\2\1\1\1[1[1[0[0[0Z0Z0Z0Z/Y/Y/Y/Y.X.X.X.X-X-W-W-W-W,V,V,V,V+U+U+U+U*U*T*T*T)T)S)S)S)S(R(R(R(R(Q'Q'Q'Q'P&P&P&P&O%O%O%O%O%N$N$N$N$M#M#M#M#L"L"L"L"K!K!K!K!J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J «uI«uI«uI«uI«uI«uI«uI«uI«uI«uI«uI«uI«uI«tI«tI«tI«tI«tI«tI«tI«tI«tI«tI«tI«tI«tI«tI«tI«tI«tI«tIªtHªtHªtHªtHªtHªtHªsHªsHªsHªsHªsHªsHªsHªsHªsH©sG©sG©sG©sG©rG©rG©rG©rG©rG©rG©rG©rF©rF©rF¨qF¨qF¨qF¨qF¨qF¨qF¨qE¨qE¨qE§pE§pE§pE§pE§pE§pE§pD§pD§oD§oD§oD¦oD¦oD¦oC¦oC¦oC¦nC¦nC¥nC¥nC¥nB¥nB¥mB¥mB¥mB¥mB¥mB¤mA¤mA¤lA¤lA¤lA¤lA£l@£l@£k@£k@£k@£k@£k@£k@¢j?¢j?¢j?¢j?¢j?¢j?¢i>¢i>¡i>¡i>¡i>¡h=¡h= h= h= h= h= g< g< g<g<g<f;f;f;f;f;e:e:e:e:e:d9d9d9d9d9c8c8c8c8c8b8b8b7b7b7a7a7a6a6a6`6`5`5`5_5_5_4_4_4^4^3^3^3^3]3]2]2]2\2\1\1\1[1[1[0[0[0Z0Z0Z0Z/Y/Y/Y/Y.Y.X.X.X-X-W-W-W-W,V,V,V,V+U+U+U+U*U*T*T*T)T)S)S)S)S(R(R(R(R(Q'Q'Q'Q'P&P&P&P&O%O%O%O%N$N$N$N$M#M#M#M#L"L"L"L"K!K!K!K!J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J ¬uJ¬uJ¬uJ¬uJ¬uJ¬uJ¬uJ¬uJ¬uJ¬uJ¬uJ¬uJ¬uJ¬uJ¬uJ¬uJ¬uJ¬uJ¬uJ«uI«uI«uI«uI«uI«uI«uI«uI«uI«uI«uI«uI«uI«uI«uI«tI«tI«tI«tI«tI«tI«tI«tI«tIªtHªtHªtHªtHªsHªsHªsHªsHªsHªsHªsHªsH©sG©sG©sG©rG©rG©rG©rG©rG©rG©rF©rF©rF¨qF¨qF¨qF¨qF¨qF¨qF¨qE¨qE§pE§pE§pE§pE§pE§pD§pD§pD§oD§oD¦oD¦oD¦oC¦oC¦nC¦nC¦nC¥nC¥nC¥nB¥nB¥mB¥mB¥mB¥mB¤mA¤mA¤lA¤lA¤lA¤lA£l@£l@£k@£k@£k@£k@£k@£k@¢j?¢j?¢j?¢j?¢j?¢i>¢i>¡i>¡i>¡i>¡i>¡h=¡h= h= h= h= g< g< g< g<g<f;f;f;f;f;e:e:e:e:e:d9d9d9d9d9c8c8c8c8c8b8b7b7b7b7a7a6a6a6`6`6`5`5`5_5_4_4_4^4^4^3^3^3]3]2]2]2\2\2\1\1\1[1[0[0[0Z0Z0Z0Z/Y/Y/Y/Y.Y.X.X.X-X-W-W-W-W,V,V,V,V+U+U+U+U*T*T*T*T)T)S)S)S(S(R(R(R(R(Q'Q'Q'Q'P&P&P&P&O%O%O%O%N$N$N$N$M#M#M#M#L"L"L"L"K!K!K!K!J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J ¬vK¬vK¬vK¬vK¬vK¬vK¬vK¬vK¬vK¬vK¬vJ¬vJ¬vJ¬vJ¬vJ¬vJ¬vJ¬vJ¬vJ¬vJ¬vJ¬vJ¬vJ¬vJ¬vJ¬vJ¬vJ¬vJ¬vJ¬vJ¬uJ¬uJ¬uJ¬uJ¬uJ¬uJ«uI«uI«uI«uI«uI«uI«uI«uI«uI«tI«tI«tI«tI«tI«tI«tIªtHªtHªtHªtHªsHªsHªsHªsHªsHªsH©sG©sG©sG©rG©rG©rG©rG©rG©rF©rF©rF¨qF¨qF¨qF¨qF¨qF¨qE¨qE§pE§pE§pE§pE§pE§pD§pD§oD§oD§oD¦oD¦oD¦oC¦oC¦nC¦nC¥nC¥nC¥nB¥nB¥mB¥mB¥mB¥mB¤mA¤mA¤lA¤lA¤lA¤lA£l@£l@£k@£k@£k@£k@£k@¢j?¢j?¢j?¢j?¢j?¢j?¢i>¢i>¡i>¡i>¡i>¡h=¡h= h= h= h= g< g< g< g<g<f;f;f;f;f;e:e:e:e:e:d9d9d9d9d9c8c8c8c8b8b8b7b7b7a7a7a6a6a6`6`5`5`5_5_5_4_4_4^4^3^3^3]3]3]2]2\2\2\1\1\1[1[0[0[0Z0Z0Z0Z/Y/Y/Y/Y.Y.X.X.X-X-W-W-W-W,V,V,V,V+U+U+U+U*T*T*T*T)S)S)S)S(S(R(R(R(R(Q'Q'Q'Q'P&P&P&P&O%O%O%O%N$N$N$N$M#M#M#M#L"L"L"L"K!K!K!K!J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J ­wK­wK­wK­wK­wK­wK­wK­wK­wK­wK­wK­wK­wK­wK­wK­wK­wK­wK­wK­wK­wK­wK­wK­wK­wK­wK¬vK¬vK¬vK¬vK¬vK¬vK¬vJ¬vJ¬vJ¬vJ¬vJ¬vJ¬vJ¬vJ¬vJ¬vJ¬uJ¬uJ¬uJ¬uJ«uI«uI«uI«uI«uI«uI«uI«tI«tI«tI«tI«tI«tI«tIªtHªtHªtHªsHªsHªsHªsHªsH©sG©sG©sG©rG©rG©rG©rG©rG©rF©rF¨qF¨qF¨qF¨qF¨qF¨qE¨qE§pE§pE§pE§pE§pE§pD§pD§oD§oD¦oD¦oD¦oC¦oC¦nC¦nC¥nC¥nC¥nB¥nB¥mB¥mB¥mB¥mB¤mA¤mA¤lA¤lA¤lA¤lA£l@£k@£k@£k@£k@£k@£k@¢j?¢j?¢j?¢j?¢j?¢i>¢i>¡i>¡i>¡i>¡h=¡h= h= h= h= g< g< g<g<g<f;f;f;f;f;e:e:e:e:e:d9d9d9d9c8c8c8c8c8b8b8b7b7b7a7a6a6a6`6`6`5`5`5_5_4_4_4^4^3^3^3]3]3]2]2]2\2\1\1\1[1[0[0[0Z0Z0Z0Z/Y/Y/Y/Y.Y.X.X.X-X-W-W-W-W,V,V,V,V+U+U+U+U*T*T*T*T)S)S)S)S(R(R(R(R(Q'Q'Q'Q'P&P&P&P&O%O%O%O%N$N$N$N$M#M#M#M#L"L"L"L"K!K!K!K!J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J ®xL®xL®xL®xL®xL®xL®xL®xL®xL®xL®xL®xL®xL®xL®xL­xL­wK¬wK¬wK¬wK­wK¬wL­wL­wL­wL­wL­wL­wL­wL­wK­wK¬wK¬wK¬vJ«vJ«vJ¬vJ¬wK¬wK¬vK¬vK¬vK¬vK¬vJ¬vJ¬vJ¬vJ¬vJ¬vJ¬vJ¬vJ¬uJ¬uJ¬uJ«uI«uI«uI«uI«uI«uI«tI«tI«tI«tI«tI«tIªtHªtHªtHªsHªsHªsHªsHªsH©sG©sG©rG©rG©rG©rG©rG©rF©rF¨qF¨qF¨qF¨qF¨qF¨qE¨qE§pE§pE§pE§pE§pD§pD§oD§oD¦oD¦oD¦oC¦oC¦nC¦nC¥nC¥nC¥nB¥nB¥mB¥mB¥mB¥mB¤mA¤lA¤lA¤lA¤lA£l@£l@£k@£k@£k@£k@£k@¢j?¢j?¢j?¢j?¢j?¢i>¢i>¡i>¡i>¡i>¡h=¡h= h= h= h= g< g< g<g<g<f;f;f;f;f;e:e:e:e:d9d9d9d9d9c8c8c8c8b8b8b7b7b7a7a6a6a6`6`6`5`5`5_5_4_4_4^4^4^3^3]3]3]2]2]2\2\1\1\1[1[0[0[0Z0Z0Z0Z/Y/Y/Y/Y.Y.X.X.X-X-W-W-W,W,V,V,V+V+U+U+U+U*T*T*T*T)S)S)S)S(R(R(R(R(Q'Q'Q'Q'P&P&P&P&O%O%O%O%N$N$N$N$M#M#M#M#L"L"L"L"K!K!K!K!J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J ®yM®yM®yM®yM®yM®yM®yM®yM®yM®yM®yM¬xLªvK¨uJ¦tJ¥rI¤qH£pH£pH£pH¤qH¥rI¦sJ©tK«vK­wK®xL®xL¬wK©uJ¨tI¦rH¤qH¤qH£pG£pG£pH¤pH¦rI§sI©tJ«vJ­wK­wK­wK­wK­wK­wK¬vK¬vK¬vK¬vK¬vJ¬vJ¬vJ¬vJ¬vJ¬vJ¬uJ¬uJ¬uJ«uI«uI«uI«uI«uI«uI«tI«tI«tI«tI«tIªtHªtHªsHªsHªsHªsHªsH©sG©sG©rG©rG©rG©rG©rG©rF©rF¨qF¨qF¨qF¨qF¨qE¨qE§pE§pE§pE§pE§pD§pD§oD§oD¦oD¦oD¦oC¦oC¦nC¦nC¥nC¥nC¥nB¥mB¥mB¥mB¥mB¤mA¤mA¤lA¤lA¤lA£l@£l@£k@£k@£k@£k@£k@¢j?¢j?¢j?¢j?¢j?¢i>¢i>¡i>¡i>¡i>¡h=¡h= h= h= h= g< g< g<g<f;f;f;f;f;e:e:e:e:e:d9d9d9d9c8c8c8c8c8b8b7b7b7a7a7a6a6a6`6`5`5`5_5_4_4_4^4^4^3^3]3]3]2]2]2\2\1\1\1[1[0[0[0Z0Z0Z0Z/Y/Y/Y/Y.X.X.X.X-W-W-W-W,W,V,V,V+V+U+U+U*U*T*T*T)T)S)S)S(S(R(R(R(R(Q'Q'Q'Q'P&P&P&O%O%O%O%N$N$N$N$M#M#M#M#L"L"L"L"K!K!K!K!J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J ¯yN¯yN¯yN¯yN¯yN¯yN¯yN¯yN¯yN®xM«vL¨tK¦sJ£qI¡pHnGnGtV}jtU¡pG¤qH¦sI©uJ«vK©vK§tJ¤rI¢pH oGpKzequZnJmF nF¢pG¥rH§sI«vK­xL®xL®xL­wL­wL­wL­wK­wK­wK­wK­wK­wK­wK¬vK¬vK¬vK¬vJ¬vJ¬vJ¬vJ¬vJ¬uJ¬uJ¬uJ«uI«uI«uI«uI«uI«tI«tI«tI«tI«tIªtHªtHªsHªsHªsHªsHªsH©sG©sG©rG©rG©rG©rG©rF©rF¨qF¨qF¨qF¨qF¨qE¨qE§pE§pE§pE§pE§pD§pD§oD§oD¦oD¦oC¦oC¦nC¦nC¥nC¥nC¥nB¥nB¥mB¥mB¥mB¤mA¤mA¤lA¤lA¤lA£l@£l@£k@£k@£k@£k@£k@¢j?¢j?¢j?¢j?¢j?¢i>¡i>¡i>¡i>¡i>¡h= h= h= h= g< g< g<g<g<f;f;f;f;f;e:e:e:e:d9d9d9d9d9c8c8c8c8b8b7b7b7a7a7a6a6a6`6`5`5`5_5_4_4_4^4^4^3^3]3]3]2]2]2\2\1\1\1[1[0[0[0Z0Z0Z0Z/Y/Y/Y/Y.X.X.X.X-W-W-W-W,V,V,V,V+U+U+U+U*T*T*T*T)S)S)S)S(R(R(R(R(Q'Q'Q'Q'P&P&P&P&O%O%O%O%N$N$N$N$M#M#M#M#L"L"L"L"K!K!K!J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J °zO°zO°zO°zO°zO°zO°zO°zO°zO­xNªvM¨tK¤rJ¢pHnFlEydÎÑÎ´·¶ðññwZ¡pH¤rI§tJ§tK§uJ¦tJ£qHsPqÄÆÄÚÜÛ«¬«rmE oG¢qH¦sI©uK«vL®xM®xM®xM®xL®xL®xL®xL®xL®xL®xL­wL­wL­wL­wK­wK­wK­wK­wK¬vK¬vK¬vK¬vJ¬vJ¬vJ¬vJ¬vJ¬uJ¬uJ¬uJ«uI«uI«uI«uI«tI«tI«tI«tI«tIªtHªtHªsHªsHªsHªsH©sG©sG©rG©rG©rG©rG©rF©rF¨qF¨qF¨qF¨qF¨qE¨qE§pE§pE§pE§pD§pD§oD§oD¦oD¦oD¦oC¦oC¦nC¥nC¥nC¥nB¥nB¥mB¥mB¥mB¤mA¤mA¤lA¤lA¤lA£l@£l@£k@£k@£k@£k@£k@¢j?¢j?¢j?¢j?¢j?¢i>¡i>¡i>¡i>¡h=¡h= h= h= h= g< g< g<g<f;f;f;f;f;e:e:e:e:d9d9d9d9d9c8c8c8c8b8b8b7b7a7a7a6a6a6`6`5`5`5_5_4_4_4^4^4^3^3]3]3]2]2]2\2\1\1\1[1[0[0[0Z0Z0Z/Z/Y/Y/Y/Y.X.X.X.X-W-W-W-W,V,V,V,V+U+U+U+U*T*T*T)T)S)S)S(S(R(R(R(R(Q'Q'Q'Q'P&P&P&O%O%O%O%N$N$N$N$M#M#M#M#L"L"L"L"K!K!K!K!J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J °{O°{O°{O°{O°{O°{O°{O°{O°{O®zN«xM¨vL¦tJ¤rI¡pHuSûûûõöö²µ´æèçíîî¤rI¦tK©vLªvLªvL¨uL¡vSÖØÖûûûôöôìïí³¶µëìëpI¢qH¥sI§tKªvL®xM¯yN¯yM¯yM¯yM®yM®yM®yM®xM®xM®xM®xL®xL®xL®xL®xL®xL­wL­wL­wL­wK­wK­wK­wK­wK¬vK¬vK¬vJ¬vJ¬vJ¬vJ¬vJ¬uJ¬uJ«uI«uI«uI«uI«uI«tI«tI«tI«tIªtHªtHªsHªsHªsHªsH©sG©sG©rG©rG©rG©rG©rF©rF¨qF¨qF¨qF¨qE¨qE§pE§pE§pE§pE§pD§pD§oD¦oD¦oD¦oC¦oC¦nC¥nC¥nC¥nB¥nB¥mB¥mB¥mB¤mA¤mA¤lA¤lA¤lA£l@£l@£k@£k@£k@£k@¢j?¢j?¢j?¢j?¢j?¢i>¢i>¡i>¡i>¡i>¡h= h= h= h= g< g< g<g<g<f;f;f;f;e:e:e:e:e:d9d9d9d9c8c8c8c8b8b8b7b7b7a7a6a6a6`6`5`5`5_5_4_4_4^4^3^3^3]3]3]2]2\2\2\1\1[1[1[0[0Z0Z0Z0Z/Z/Y/Y/Y.Y.X.X.X-X-W-W-W,W,V,V,V+U+U+U+U*T*T*T*T)S)S)S)S(R(R(R(R(Q'Q'Q'Q'P&P&P&P&O%O%O%O%N$N$N$N$M#M#M#L"L"L"L"K!K!K!K!J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J ±|P±|P±|P±|P±|P±|P±|P±|P±|P±|P°|P®zN«xM©wM¥uNìíí÷øøëíí¾ÁÀÌÎÎþþþ§vO«wM®yO°{P°zO­yMc¶¸¶ÿÿÿßäáÚàÝÏÕÒ¬±¯øøø®°­z^¨uLªvM­xM¯zN°zN°zN°zN¯zN¯zN¯zN¯yN¯yN¯yN¯yM¯yM¯yM®yM®yM®yM®xM®xM®xM®xL®xL®xL®xL®xL­wL­wL­wK­wK­wK­wK­wK¬vK¬vK¬vJ¬vJ¬vJ¬vJ¬vJ¬uJ¬uJ«uI«uI«uI«uI«tI«tI«tI«tIªtHªtHªsHªsHªsHªsH©sG©sG©rG©rG©rG©rF©rF¨qF¨qF¨qF¨qF¨qE¨qE§pE§pE§pE§pD§pD§oD¦oD¦oD¦oC¦oC¦nC¥nC¥nC¥nB¥nB¥mB¥mB¥mB¤mA¤mA¤lA¤lA¤lA£l@£k@£k@£k@£k@£k@¢j?¢j?¢j?¢j?¢j?¢i>¡i>¡i>¡i>¡h=¡h= h= h= h= g< g< g<g<f;f;f;f;e:e:e:e:e:d9d9d9d9c8c8c8c8b8b8b7b7a7a7a6a6a6`6`5`5`5_5_4_4_4^4^3^3^3]3]2]2]2\2\1\1\1[1[1[0[0Z0Z0Z0Z/Y/Y/Y/Y.X.X.X.X-W-W-W-W,V,V,V,V+U+U+U+U*T*T*T*T)S)S)S(S(R(R(R(R(Q'Q'Q'P&P&P&P&O%O%O%O%N$N$N$N$M#M#M#M#L"L"L"L"K!K!K!J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J ²}Q²}Q²}Q²}Q²}Q²}Q²}Q²}Q²}Q²}Q²}Q²}Q²}Q±}Qm¿ÂÀÿÿÿìííéìëÍÏÏº½½úûú³´±¤a²|Q±|P±|P±|P±|P­}UøùøåéçÜâßÃÇÄº¿¾úûú§¨¥¦~[¯{O°{O°{O°{O°{O°{O°{O°{O°zO°zO°zO°zN°zN°zN¯zN¯zN¯zN¯yN¯yN¯yN¯yM¯yM®yM®yM®yM®xM®xM®xL®xL®xL®xL®xL­wL­wL­wK­wK­wK­wK­wK¬vK¬vK¬vJ¬vJ¬vJ¬vJ¬uJ¬uJ«uI«uI«uI«uI«tI«tI«tI«tIªtHªtHªsHªsHªsH©sG©sG©rG©rG©rG©rG©rF©rF¨qF¨qF¨qF¨qE¨qE§pE§pE§pE§pD§pD§oD¦oD¦oD¦oC¦oC¦nC¥nC¥nC¥nB¥mB¥mB¥mB¥mB¤mA¤lA¤lA¤lA£l@£l@£k@£k@£k@£k@¢j?¢j?¢j?¢j?¢j?¢i>¡i>¡i>¡i>¡h=¡h= h= h= h= g< g< g<g<f;f;f;f;f;e:e:e:e:d9d9d9d9c8c8c8c8b8b8b7b7a7a7a6a6a6`6`5`5`5_5_4_4_4^4^3^3^3]3]2]2]2\2\1\1\1[1[0[0[0Z0Z0Z/Z/Y/Y/Y.Y.X.X.X-X-W-W-W,W,V,V,V+V+U+U+U*T*T*T*T)S)S)S)S(R(R(R(R(Q'Q'Q'Q'P&P&P&P&O%O%O%N$N$N$N$M#M#M#M#L"L"L"L"K!K!K!K!J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J µW³S³~R³~R³~R³~R³~R³~R²}Q²}Q²}Q²}Q²}Q²}Q¢d§ª¨ýýýøøøêììÙÜÛ¬°¯ïïïÛÝÜs²}Q²}Q²}Q²}Q²}Q²}Qq¶¸¶øùøßäá´¹·ÎÑÏüüü±}Q±|P±|P±|P±|P±|P±{P±{P±{P±{P°{O°{O°{O°{O°{O°{O°zO°zO°zN°zN°zN¯zN¯zN¯zN¯yN¯yN¯yM¯yM¯yM®yM®yM®xM®xM®xL®xL®xL®xL®xL­wL­wL­wK­wK­wK­wK¬vK¬vK¬vJ¬vJ¬vJ¬vJ¬uJ¬uJ«uI«uI«uI«uI«tI«tI«tIªtHªtHªsHªsHªsHªsH©sG©rG©rG©rG©rG©rF©rF¨qF¨qF¨qF¨qE¨qE§pE§pE§pE§pD§pD§oD¦oD¦oD¦oC¦nC¦nC¥nC¥nC¥nB¥mB¥mB¥mB¤mA¤mA¤lA¤lA¤lA£l@£k@£k@£k@£k@£k@¢j?¢j?¢j?¢j?¢i>¢i>¡i>¡i>¡i>¡h= h= h= h= g< g< g<g<f;f;f;f;f;e:e:e:e:d9d9d9d9c8c8c8c8b8b7b7b7a7a7a6a6`6`6`5`5_5_5_4_4^4^4^3^3]3]3]2]2\2\2\1\1[1[1[0[0Z0Z0Z0Z/Y/Y/Y/Y.X.X.X.X-W-W-W-W,V,V,V,V+U+U+U+U*T*T*T)T)S)S)S(S(R(R(R(Q'Q'Q'Q'P&P&P&P&O%O%O%O%N$N$N$N$M#M#M#L"L"L"L"K!K!K!K!J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J ÁsÁsÀo¾l½h»d¹`¸]¶Y´U³S³~R³~R³~R±~SqÜÝÝûüüäææ®²°ØÚÚôõõ³~R³~R³~R³~R²To×Ù×øùøÜàß¬°®äçåêëë²}Q²}Q²}Q²}Q²|Q²|Q²|Q±|P±|P±|P±|P±|P±|P±{P±{P±{P°{O°{O°{O°{O°{O°{O°zO°zO°zN°zN°zN¯zN¯zN¯yN¯yN¯yM¯yM¯yM®yM®yM®xM®xM®xL®xL®xL®xL­wL­wL­wK­wK­wK­wK¬vK¬vK¬vJ¬vJ¬vJ¬vJ¬uJ¬uJ«uI«uI«uI«tI«tI«tI«tIªtHªsHªsHªsHªsH©sG©sG©rG©rG©rG©rF©rF¨qF¨qF¨qF¨qE§pE§pE§pE§pE§pD§oD§oD¦oD¦oC¦oC¦nC¦nC¥nC¥nB¥nB¥mB¥mB¥mB¤mA¤lA¤lA¤lA£l@£l@£k@£k@£k@£k@¢j?¢j?¢j?¢j?¢i>¢i>¡i>¡i>¡i>¡h= h= h= h= g< g< g<g<f;f;f;f;f;e:e:e:e:d9d9d9d9c8c8c8c8b8b7b7b7a7a6a6a6`6`5`5`5_5_4_4_4^4^3^3^3]3]2]2]2\2\1\1\1[1[0[0[0Z0Z0Z0Z/Y/Y/Y.Y.X.X.X-X-W-W-W,W,V,V,V+U+U+U+U*T*T*T*T)S)S)S)S(R(R(R(R(Q'Q'Q'P&P&P&P&O%O%O%O%N$N$N$N$M#M#M#M#L"L"L"K!K!K!K!J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J ÂsÂsÂsÂsÂsÂsÂsÂsÂsÂsÂsÁp¿l½h¼eºa§lýýýäçæ»¾½ÄÆÆýýý°X´S³~R³~Rm¬¯®úûúö÷÷æëèÏÓÑ±´²÷øøÉËÉ i³~R²}Q²}Q²}Q²}Q²}Q²}Q²}Q²}Q²}Q²}Q²|Q²|Q²|Q±|P±|P±|P±|P±|P±|P±{P±{P°{O°{O°{O°{O°{O°zO°zO°zN°zN¯zN¯zN¯zN¯yN¯yN¯yM¯yM®yM®yM®xM®xM®xL®xL®xL®xL­wL­wL­wK­wK­wK­wK¬vK¬vK¬vJ¬vJ¬vJ¬uJ¬uJ«uI«uI«uI«tI«tI«tI«tIªtHªtHªsHªsHªsH©sG©sG©rG©rG©rG©rF¨qF¨qF¨qF¨qF¨qE§pE§pE§pE§pD§pD§oD¦oD¦oD¦oC¦nC¦nC¥nC¥nC¥nB¥mB¥mB¥mB¤mA¤lA¤lA¤lA£l@£l@£k@£k@£k@£k@¢j?¢j?¢j?¢j?¢j?¢i>¡i>¡i>¡i>¡h= h= h= h= g< g< g<g<f;f;f;f;e:e:e:e:e:d9d9d9d9c8c8c8c8b8b7b7b7a7a6a6a6`6`5`5`5_5_4_4_4^4^3^3^3]3]2]2]2\2\1\1\1[1[0[0Z0Z0Z0Z/Y/Y/Y/Y.X.X.X.X-W-W-W-W,V,V,V+V+U+U+U*U*T*T*T)S)S)S)S(R(R(R(R(Q'Q'Q'Q'P&P&P&O%O%O%O%N$N$N$N$M#M#M#M#L"L"L"K!K!K!K!J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J ÃtÃtÃtÃtÃtÃtÃtÃtÃtÃtÃtÃtÃtÂtÂtÂuçèçòôôâåäÉÌË°´³÷÷÷¾À½§o¸\¶XµUÓÕÔÿÿÿçëéæêèÁÅÃÃÆÄýýý¬Z³~R³~R³~R³~R³~R³~R³~R³~R³~R²}Q²}Q²}Q²}Q²}Q²}Q²}Q²}Q²|Q²|Q²|Q±|P±|P±|P±|P±|P±{P±{P°{O°{O°{O°{O°{O°zO°zO°zN°zN¯zN¯zN¯yN¯yN¯yM¯yM®yM®yM®xM®xM®xL®xL®xL®xL­wL­wK­wK­wK­wK¬vK¬vK¬vJ¬vJ¬vJ¬uJ¬uJ«uI«uI«uI«tI«tI«tI«tIªtHªsHªsHªsHªsH©sG©rG©rG©rG©rG©rF¨qF¨qF¨qF¨qE¨qE§pE§pE§pE§pD§oD§oD¦oD¦oC¦oC¦nC¥nC¥nC¥nB¥mB¥mB¥mB¤mA¤mA¤lA¤lA¤lA£l@£k@£k@£k@£k@¢j?¢j?¢j?¢j?¢j?¢i>¡i>¡i>¡i>¡h= h= h= h= g< g< g<g<f;f;f;f;e:e:e:e:d9d9d9d9c8c8c8c8b8b8b7b7a7a7a6a6`6`6`5`5_5_5_4_4^4^4^3^3]3]3]2]2\2\1\1\1[1[0[0[0Z0Z0Z/Z/Y/Y/Y.Y.X.X.X-W-W-W-W,V,V,V,V+U+U+U+U*T*T*T)T)S)S)S(R(R(R(R(Q'Q'Q'Q'P&P&P&P&O%O%O%N$N$N$N$M#M#M#M#L"L"L"L"K!K!K!J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J È¡Ç ~Æ|ÅzÅyÄwÃuÃuÃuÃuÃuÃuÃuÃuÃu¶yÿÿÿðññæèçÖÙÙ§«ªåææâããÃtÃtÃt»uÖ×Öüüüéíë²¶µÖÙØùúú´S´S´S´S´S´S´S´S³~R³~R³~R³~R³~R³~R³~R³~R²}Q²}Q²}Q²}Q²}Q²}Q²}Q²}Q²|Q²|Q±|P±|P±|P±|P±|P±{P±{P°{O°{O°{O°{O°zO°zO°zN°zN¯zN¯zN¯yN¯yN¯yM¯yM®yM®yM®xM®xL®xL®xL®xL­wL­wL­wK­wK­wK¬vK¬vK¬vJ¬vJ¬vJ¬uJ¬uJ«uI«uI«uI«tI«tI«tI«tIªtHªsHªsHªsH©sG©sG©rG©rG©rG©rF©rF¨qF¨qF¨qF¨qE§pE§pE§pE§pD§pD§oD¦oD¦oD¦oC¦nC¦nC¥nC¥nB¥nB¥mB¥mB¤mA¤mA¤lA¤lA¤lA£l@£k@£k@£k@£k@¢j?¢j?¢j?¢j?¢j?¢i>¡i>¡i>¡i>¡h= h= h= h= g< g< g<g<f;f;f;f;e:e:e:e:d9d9d9d9c8c8c8c8b8b7b7b7a7a6a6a6`6`5`5`5_5_4_4_4^4^3^3^3]3]2]2]2\2\1\1[1[1[0[0Z0Z0Z0Z/Y/Y/Y/Y.X.X.X-X-W-W-W,W,V,V,V+U+U+U+U*T*T*T*T)S)S)S(S(R(R(R(Q'Q'Q'Q'P&P&P&P&O%O%O%O%N$N$N$M#M#M#M#L"L"L"L"K!K!K!J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J Ï­Ï­Ï­Ï­Ï­Ï­Ï­Î«ÍªÍ©Ì§Ë¥Ê¤Ê£É¡ÆÊËÊäæåùùùîðï­±¯ÌÐÎøùùÃuÃuÃuÃu¿vñòñæèæ¬°¯îðïåææÃtÁp¿m¾j¼f»c¹_¸\¶XµU´S´S´S´S³~R³~R³~R³~R³~R³~R³~R³~R²}Q²}Q²}Q²}Q²}Q²}Q²}Q²|Q²|Q±|P±|P±|P±|P±{P±{P°{O°{O°{O°{O°zO°zO°zN°zN¯zN¯zN¯yN¯yM¯yM®yM®yM®xM®xM®xL®xL®xL­wL­wL­wK­wK­wK¬vK¬vK¬vJ¬vJ¬vJ¬uJ¬uJ«uI«uI«uI«tI«tI«tIªtHªtHªsHªsHªsH©sG©rG©rG©rG©rG©rF¨qF¨qF¨qF¨qE¨qE§pE§pE§pD§pD§oD¦oD¦oD¦oC¦nC¦nC¥nC¥nB¥nB¥mB¥mB¤mA¤mA¤lA¤lA¤lA£l@£k@£k@£k@£k@¢j?¢j?¢j?¢j?¢i>¢i>¡i>¡i>¡i>¡h= h= h= h= g< g<g<g<f;f;f;f;e:e:e:e:d9d9d9d9c8c8c8c8b8b7b7b7a7a6a6`6`6`5`5_5_5_4_4^4^4^3^3]3]2]2]2\2\1\1\1[1[0[0[0Z0Z0Z/Y/Y/Y/Y.X.X.X.X-W-W-W-W,V,V,V+V+U+U+U*T*T*T*T)S)S)S)S(R(R(R(R(Q'Q'Q'P&P&P&P&O%O%O%O%N$N$N$M#M#M#M#L"L"L"L"K!K!K!J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J Ð­Ð­Ð­Ð­Ð­Ð­Ð­Ð­Ð­Ð­Ð­Ð­Ð­Ð­Ð­Ð­Â§² üýýº¾½¶º¸ûûûÀ¢Ê¥¾ « üýüÓÖÖ·»¹ûüüÀÁ¿®|ÃuÃuÃuÃtÃtÃtÃtÃtÃtÂtÂsÀo¿l½i¼f»cº`¸\·Z¶W´S³~R³~R³~R³~R³~R³~R²}Q²}Q²}Q²}Q²}Q²}Q²|Q²|Q±|P±|P±|P±|P±{P±{P°{O°{O°{O°{O°zO°zN°zN¯zN¯zN¯yN¯yN¯yM¯yM®yM®xM®xM®xL®xL®xL­wL­wL­wK­wK­wK¬vK¬vK¬vJ¬vJ¬vJ¬uJ¬uJ«uI«uI«uI«tI«tI«tIªtHªsHªsHªsH©sG©sG©rG©rG©rG©rF¨qF¨qF¨qF¨qE¨qE§pE§pE§pE§pD§oD§oD¦oD¦oC¦nC¦nC¥nC¥nB¥nB¥mB¥mB¤mA¤mA¤lA¤lA¤lA£l@£k@£k@£k@£k@¢j?¢j?¢j?¢j?¢i>¢i>¡i>¡i>¡h=¡h= h= h= g< g< g<g<f;f;f;f;e:e:e:e:d9d9d9d9c8c8c8c8b8b7b7b7a7a6a6a6`6`5`5`5_5_4_4_4^4^3^3]3]3]2]2\2\2\1\1[1[0[0[0Z0Z0Z/Z/Y/Y/Y.Y.X.X.X-W-W-W-W,V,V,V,V+U+U+U*U*T*T*T)S)S)S)S(R(R(R(R(Q'Q'Q'P&P&P&P&O%O%O%O%N$N$N$M#M#M#M#L"L"L"L"K!K!K!J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J J Ð­Ð­Ð­Ð­Ð­Ð­Ð­Ð­Ð­Ð­Ð­Ð­Ð­Ð­Ð­Ð­Ð­Ð­Á¦üüüÉÎÍª¯®ïññÉËÉ°Ð­ÈÊÉëìëúûûùúúÃÇÅÉÍËþþþÈ©ÍªÍ¨Ì§Ë¥Ê¥É£È¢È¡Ç ~Æ}ÆzÅxÄwÃuÃtÂtÂtÂtÂsÂsÂsÁqÀo¿l½i»dºb¹_·[¶YµW³S²}Q²}Q²}Q²}Q²}Q²|Q²|Q±|P±|P±|P±|P±{P°{O°{O°{O°{O°zO°zO°zN¯zN¯zN¯yN¯yN¯yM¯yM®yM®xM®xM®xL®xL®xL­wL­wL­wK­wK­wK¬vK¬vK¬vJ¬vJ¬vJ¬uJ«uI«uI«uI«tI«tI«tIªtHªtHªsHªsHªsH©sG©rG©rG©rG©rF©rF¨qF¨qF¨qE¨qE§pE§pE§pE§pD§oD§oD¦oD¦oC¦nC¦nC¥nC¥nB¥nB¥mB¥mB¤mA¤mA¤lA¤lA£l@£l@£k@£k@£k@£k@¢j?¢j?¢j?¢j?¢i>¡i>¡i>¡i>¡h= h= h= h= g< g< g<g<f;f;f;f;e:e:e:e:d9d9d9d9c8c8c8c8b8b7b7a7a7a6a6`6`6`5`5_5_4_4_4^4^3^3^3]3]2]2]2\2\1\1[1[1[0[0Z0Z0Z0Z/Y/Y/Y.Y.X.X.X-W-W-W-W,V,V,V,V+U+U+U*U*T*T*T)S)S)S)S(R(R(R(R(Q'Q'Q'P&P&P&P&O%O%O%O%N$N$N$M#M#M#M#L"L"L"L"K!K!K!J J J J J J J J J L#L#M#N%N%P'Q)Q)S*S+S+U.U.W0W1W1Z3Z3[5\7\7_9_9`;a<a=c?c?eAeAfBhEhEÖ¹ Ö¸Ö¸Õ·Õ·Õ¶Õ¶Ô¶ÔµÔµÔ´Ô´Ó³Ó³Ó²Ò²Ò²½¦íîîòôóÓ×Ö«°®ØÜÛçéèÎ¬ÿÿÿùúúóõôðòñº¾¼âäã÷÷÷Ð­Ð­Ð­Ï­Ï­Ï­Ï­Ï­Ï­Ï¬Ï¬Î¬Î¬Î¬Î¬Î¬Î«Í©Ì¨Ë§Ë¥É¤È£È¢Ç Ç}Æ|ÅzÄxÄwÂuÁtÁsÁrÀo¿m½j¼gºd¹a¸_·]¶Z´V³S²}Q±|P±{P±{P°{O°{O°{O°zO°zO°zN°zN¯zN¯yN¯yN¯yM®yM®yM®xM®xM®xL®xL®xL­wL­wK­wK­wK­wK¬vK¬vJ¬vJ¬vJ¬uJ¬uJ«uI«uI«uI«tI«tI«tIªtHªsHªsHªsH©sG©rG©rG©rG©rF©rF¨qF¨qF¨qF¨qE§pE§pE§pE§pD§oD§oD¦oD¦oC¦nC¦nC¥nC¥nB¥mB¥mB¥mB¤mA¤mA¤lA¤lA£l@£l@£k@£k@£k@£k@¢j?¢j?¢j?¢j?¢i>¡i>¡i>¡i>¡h= h= h= h= g< g<g<f;f;f;f;e:e:e:e:d9d9d9d9c8c8c8c8b8b7b7b7a7a6a6a6`6`5`5`5_5_4_4^4^4^3^3]3]2]2]2\2\1\1\1[1[0[0Z0Z0Z0Z/Y/Y/Y/Y.X.X.X-X-W-W-W,V,V,V,V+U+U+U+U*T*T*U+U,U,V-W-V-X0Y0Y0Z2Z2[3[4[4\5]6\5^8^8_9`:`:a;a<a<c>c?b>e@e@eAfBfBgDhEhEjGlIlInL nM oN oN oN¡pO¢rQ¢rQ¢rQ¢rR£sS£sS£sS£tT¤uU¤uU¤uU¤vV¥wW¥wW¥wW¦xX¦yZ¦yZ¦yZ§yZ¨{\¨{\¨{\¨|]©}_©}_©}_©}_ª~aª~aÚ¾¦Ú¾¦Ú¾¦Ú¾¦Ú¾¦Ú¾¦Ú¾¦Ú¾¦Ú¾¦Ú¾¦Ú¾¦Ú¾¦Ú¾¦Ú¾¦Ú¾¦Ú¾¦Ú¾¦÷ø÷ùúú×ÛÙÕÙØ¶»¹ÅÉÇûüû×»¤¬£ÌÍÌüýýôõõèêé¿ÁÀö÷÷ßáà«¡Ö·Ö·Ö·Õ¶Õ¶Õ¶ÕµÕµÔ´Ó´Ó´Ó³Ó³Ó³Ò±Ò±Ò±Ð°Ð°Ð°Ð¯Ð®Ï­Ï­Ï­Ï¬Î¬Í¬Í«Í«Í«Í«Í«Í©Ë¨Ë§Ê¦Ê¥É¤É£Ç¡Æ ÆÅ~Å}Ä{ÄxÁuÀq¿o½k¼iºd¹a·^¶\µZ´W²U±~S°{Q°zO¯yM®yM®yM®xM®xL®xL®xL­wL­wL­wK­wK­wK¬vK¬vJ¬vJ¬vJ¬uJ¬uJ«uI«uI«uI«tI«tI«tIªtHªsHªsHªsH©sG©rG©rG©rG©rF©rF¨qF¨qF¨qE¨qE§pE§pE§pE§pD§oD¦oD¦oD¦oC¦nC¥nC¥nC¥nB¥mB¥mB¥mB¤mA¤lA¤lA¤lA£l@£k@£k@£k@£k@¢j?¢j?¢j?¢j?¢i>¢i>¡i>¡i>¡h= h= h= h= g< g< g<g<f;f;f;f;e:e:e:e:d9d9d9d9c8c8c8b8b8b7c9c9c8c8e;d;d:e;f=e=f=g>g>f>h@h@g@hAiAiAiB lE lE lE¡mG¡nG¢oI¢oJ£pL£pL¢pK¤sO¥tP¥tP¥uQ¦uR¦vS§wU¨xU§wU§wU©zX©{Z©{Zª{[ª}[ª}\«}]¬`¬_¬~_¬`¬`¬`¬`¬a¬b¬b¬b­c­d­d­d­e®e®e®e®f¯f®f®f®g¯h®h®h¯g°j±k°k°l±n±n°n°m²p²p²o²o²o²o²o²o²q³r³r³r³r³r³r³r³r´s´s´s´s´s´s´s´tµuµuµuµuµuµuµuµv¶w¶w¶w¶w¶w¶w¶w·x·yÚ¾¦Ú¾¦Ú¾¦Ú¾¦Ú¾¦Ú¾¦Ú¾¦Ú¾¦Ú¾¦Ú¾¦Ú¾¦Ú¾¦Ú¾¦Ú¾¦Ú¾¦Ú¾¦Ú¾¦¡º½»úûúðòñÖÙØÂÆÅº¾½÷ø÷©¬ªÂ®Í¶¢úúúøùùàáàÒÓÒþþþ¶·¶Â¯Ù½¦Ù½¦Ù½¦Ù½¦Ù¼¦Ù¼¦Ù¼¦Ù¼¦Ù¼¦Ù¼¦Ù¼¦Ù¼¦Ù¼¥Ù¼¥Ù¼¥Ø¼¥Ø¼¥Ø¼¥Ø¼¥Ø¼¤Ø¼¤Ø¼¤×¼¤×¼¤×¼¤×¼¤×»£×»£×»£×»£Öº£Öº¢Öº¡Öº¡Õ¹ Õ¹ Õ¹ Õ¹ Õ·Ô·Ô·Ô·Ô¶ÓµÓµÓ´Ò´Ò´Ò´Ò³Ò³Ò³Ò³Ñ±Ñ±Ï°Ï¯Ï®Î¬Î«ÍªË©Ê¨É¦È¥È£Ç¢Æ ÅÃzÂyÁw¿t¿r½q½n¼l¼l»j»jºg¹f¸e¸d·c·c·cµ_³Z³]´_µ`µaµaµaµaµaµa´a´a´`´`µbµbµaµaµa´a´aµbµb´bµdµc¶e¶e¶eµdµdµe·h¶g¶g¶g·i·j¶j·k·l¸l¹m¸m¸m¹o¹oºqºqºqºp»rºsºr»t»t»u»u»u»u¼x½z½{½{¾|¾|¾~¿ÀÀ¿ÀÁÁÀÁÂÂÂÁÁÂÃ Ã ÂÂÃ¡Ã¡Ã Ã Ã Ã Ã¡Ã¡Ã¡Ã¡Â¡Â¡Â¡Â Â Á Á Â Â Â Â Â Â Â Â Â Â¡Â¡Â¡Â¡Â¡Â Á Á Á ÁÁ Á¡Á¡Á Á À À À Á Á¡Á¡Á¡Á¡Á Á Á Â¡Â¡Á¡Á¡Á¡Á À À À À À À ÀÀ¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿Ú¾§Ú¾§Ú¾§Ú¾§Ú¾§Ú¾§Ú¾§Ú¾§Ú¾§Ú¾§Ú¾§Ú¾§Ú¾§Ú¾§Ú¾§Ú¾§Ú¾§Ö»¥®£àâáíîîÉÎÌ·¼ºèêéÊÌËÜÝÜþþþúúúÚÜÛãåäþþþ×¼¥Ú¾¦Ú¾¦Ù½¦Ù½¦Ù½¦Ù½¦Ù½¦Ù½¦Ù½¦Ù½¦Ù¼¦Ù¼¦Ù¼¦Ù¼¦Ù¼¦Ù¼¦Ù¼¦Ù¼¥Ù¼¥Ù¼¥Ø¼¥Ø¼¥Ø¼¥Ø¼¥Ø¼¤Ø¼¤×¼¤×¼¤×¼¤×¼¤×»£×»£×»£×»£Ö»£Ö»¢Ö»¢Ö»¢Ö»¢Ö»¢Ö»¢Öº¢Öº¢Öº¢Öº¢Öº¢Ö¹¢Ö¹¢Ö¹¢Ö¹¢Ö¹¢Ö¹¢Ö¹¢Ö¹¢Ö¹¢Ö¹¢Ö¸¢Õ¸¡Õ¸¡Õ¸¡Õ¸¡Õ¸¡Õ¸ Õ¸ Ô¸ Ô¸ Ô¸ Ô¸ Ó¸ Ó¸ Ó· Ó·Ó·Ó·Ó·Ó·Ó·Ó·Ó¶Ó¶Ó¶Ó¶Ó¶ÓµÒµÒµÒµÒ´Ð³Ò´Ò´Ò´Ò´Ò´Ñ´Ñ´Ñ´Ñ´Ñ´Ð´Ð´Ð´Ð´Ð³Ð³Ð³Ð³Ð³Ð²Ð²Ð²Ð²Ð±Ï±Ï±Ï±Ï°Ï°Î°Î°Î°Î°Í°Í°Í°Í°Í°Í¯Í¯Í¯Í¯Í¯Í¯Í¯Í¯Í®Ì®Ì®Ì®Ì®Ì®Ì®Ì®Ì­Ì­Ë­Ë­Ë­Ë­Ë­Ê¬Ê¬Ê¬Ê¬Ê«Ê«Ê«Ê«Ê«É«É«É«É«É«É«ÉªÉªÉªÉªÉ©É©É©É©È©È©È©È©È¨È¨È¨È¨È¨Ç¨Ç¨Ç§Æ§Æ§Æ§Æ§Æ§Å§Å¦Å¦Å¦Å¦Å¦Å¦Å¦Å¦Å¦Å¦Å¦Å¦Å¥Å¥Å¥Å¤Ä¤Ä¤Ä¤Ä£Ä£Ã£Ã¢Ã¢Ã¢Â¢Â¢Â¢Â¢Â¢Â¢Â¢Â¢Â¢Â¢Â¢Â¢Â¡Á¡Á¡Á¡Á À À À À À À ÀÀ¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿Ú¿§Ú¿§Ú¿§Ú¿§Ú¿§Ú¿§Ú¿§Ú¿§Ú¿§Ú¿§Ú¿§Ú¿§Ú¿§Ú¿§Ú¿§Ú¿§Ú¿§Ú¿§Ú¿§ÛÝÜéìëÍÒÐºÀ½ÏÓÒ¿ÁÀýýýýþýüüüùúùÚÛÚóõóôõôÚ¾¦Ú¾¦Ú¾¦Ú¾¦Ú¾¦Ú¾¦Ú¾¦Ú¾¦Ú¾¦Ù½¦Ù½¦Ù½¦Ù½¦Ù½¦Ù½¦Ù½¦Ù¼¦Ù¼¦Ù¼¦Ù¼¦Ù¼¦Ù¼¦Ù¼¦Ù¼¥Ù¼¥Ø¼¥Ø¼¥Ø¼¥Ø¼¥Ø¼¤Ø¼¤×¼¤×¼¤×¼¤×»£×»£×»£×»£Ö»£Ö»£Ö»¢Ö»¢Ö»¢Ö»¢Ö»¢Öº¢Öº¢Öº¢Öº¢Öº¢Ö¹¢Ö¹¢Ö¹¢Ö¹¢Ö¹¢Ö¹¢Ö¹¢Ö¹¢Ö¹¢Ö¸¢Ö¸¢Õ¸¡Õ¸¡Õ¸¡Õ¸¡Õ¸ Õ¸ Ô¸ Ô¸ Ô¸ Ô¸ Ó¸ Ó¸ Ó· Ó·Ó·Ó·Ó·Ó·Ó·Ó·Ó¶Ó¶Ó¶Ó¶Ó¶ÓµÒµÒµÐ´Ò´Ò´Ò´Ò´Ò´Ò´Ò´Ñ´Ñ´Ñ´Ñ´Ñ´Ð´Ð´Ð´Ð´Ð³Ð³Ð³Ð³Ð²Ð²Ð²Ð²Ð±Ï±Ï±Ï±Ï°Ï°Ï°Î°Î°Î°Î°Í°Í°Í°Í°Í°Í¯Í¯Í¯Í¯Í¯Í¯Í¯Í®Í®Ì®Ì®Ì®Ì®Ì®Ì®Ì­Ì­Ì­Ë­Ë­Ë­Ë­Ë­Ê¬Ê¬Ê¬Ê«Ê«Ê«Ê«Ê«É«É«É«É«É«É«É«ÉªÉªÉªÉ©É©É©É©È©È©È©È©È¨È¨È¨È¨È¨Ç¨Ç¨Ç§Æ§Æ§Æ§Æ§Æ§Å§Å§Å¦Å¦Å¦Å¦Å¦Å¦Å¦Å¦Å¦Å¦Å¦Å¥Å¥Å¥Å¤Ä¤Ä¤Ä¤Ä£Ä£Ã£Ã¢Ã¢Ã¢Â¢Â¢Â¢Â¢Â¢Â¢Â¢Â¢Â¢Â¢Â¢Â¢Â¡Á¡Á¡Á¡Á À À À À À À ÀÀ¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿Ù½¦Ù½¦Ù¼¥Ù¼¤Ù¼¤Ù¼¤Ù¼¤Ù¼¤Ù¼¤Ù¼¤Ù¼¤Ù¼¤Ù»¤Ø»£Ø»£Ø»¢Ø»¢Ø»¢Á­¡¤¢ûüüÓ×ÖÇÌÊª¯­¢¦¥ÐÒÑþþþýýýýýýöööäåäÿÿÿ×Ø×±£×¸×¸×¸×¸Õ·Õ·Õ·Õ¶Õ¶Ô´Ô´Ô´Ô´Ô´Ó³Ó³Ó³Ó³Ó²Ñ°Ñ°Ñ°Ð°Ð¯Ð®Ï®Ï¬Ï¬Ï¬Ì©Ì¨Ì¨Ì§Ì¦Ê¥Ê¥Ê¤Ê¤Ê£É¢É¢È¢È¢Ç¡Ç ~Ç ~Ç~Ç}ÅzÅzÅzÄyÄyÂvÂuÂuÂuÂuÁsÀqÀqÀqÀq¿p¿p¾n¾m¾l¾k½k¼i¼i¼i¼i»i»iºfºfºf¹f¹f¹e¹e¸e¸e¸d¶`¶`µ_µ\¶a·c·c·c·d·d·d¹g¸h¹j¹jºj»m¼n¼o½q½r¿uÀzÀzÂ}Â~ÃÄÄ¡Æ¢Æ¢Æ¤Æ¤Ç¥È¦É§É¨É¨Ê©Ê©É©É©ÊªÊªÊªÊªÊªÊªÊªË«Ê«Ê«Ê«Ë«Ê«Ê«Ë¬Ë­Ë­Ë­Ì­Ì­Ì­Ë­Ë­Ë­Ë­Ë­Ê¬Ê¬Ê¬Ê¬Ê«Ê«Ê«Ê«Ê«É«É«É«É«É«É«ÉªÉªÉªÉ©É©É©É©È©È©È©È©È¨È¨È¨È¨È¨Ç¨Ç¨Ç§Æ§Æ§Æ§Æ§Æ§Å§Å§Å¦Å¦Å¦Å¦Å¦Å¦Å¦Å¦Å¦Å¦Å¥Å¥Å¥Å¥Å¤Ä¤Ä¤Ä¤Ä£Ä£Ã£Ã¢Ã¢Ã¢Â¢Â¢Â¢Â¢Â¢Â¢Â¢Â¢Â¢Â¢Â¢Â¢Â¡Á¡Á¡Á Á À À À À À À ÀÀ¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿Î§Î§Î§Í§Í¦Í¦Ì¦Ì¥Ì¤Ë¤Ë¢Ë¢Ë¢Ê¡~É {É {É {Èy¢ÔÖÕïððÀÅÃ§««ÕÖÖüüüÿÿÿýýýýýýñòñìíìþþþ§©¦µmÀgÀg¿e¾d¾d¾d¾b¾b¾b½`¼`¼`»^»]»]»]º[º[º[¸Y¸X¸X¸X¸X¸X·W·W·W·W·W·V·V¶V¶V¶V¶V¶UµUµUµUµUµTµTµT´T´T´S´S´S´S³~R³~R³~R³~R³~R²}Q²}Q²}Q²}Q²}Q²|Q±|P±|P±|P±{P±{P°{O°{O°zO°zO°zN¯zN¯zN¯yN¯yM¯yM®yM®xM®xL®xL®xL­wL­wL­wK­wK¬vK¬vK¬vJ¬vJ¬uJ¬uJ«uI«uI«tI«tI«tIªtHªsHªsHªsH©sG©rG©rG©rG©rF¨qF¨qF¨qF¨qE§pE§pE§pE§pD§oD§oD¦oD§qE¨qG¨sJ©uLªwM«wO¬yR­|U¯~W±Z²^³a´d·h¸k¹nºoºp»q¼s¼s½t½v½x¾y¾{¿|À~À~ÀÀÀÀ~ÀÀÀÁÁÁÁÁÁÁÁÂÂÂÃÂ Â Ã Â Â Ã¢Ã¡Ã¡Ä¢Ä¢Ä¢Ä¢Ä¢Ä¤Ä¤Å¤Å¥Å¤Æ¥Æ¦Æ¦Ç§Æ§Ç¨Ç§Æ§Æ§Æ§Æ§Æ§Å§Å¦Å¦Å¦Å¦Å¦Å¦Å¦Å¦Å¦Å¦Å¦Å¥Å¥Å¥Å¥Å¤Ä¤Ä¤Ä¤Ä£Ä£Ã£Ã¢Ã¢Ã¢Â¢Â¢Â¢Â¢Â¢Â¢Â¢Â¢Â¢Â¢Â¢Â¢Â¡Á¡Á¡Á À À À À À À ÀÀÀ¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¾`¾_¾_½^½]½]½]½]½]½]½]½]½]½]½]½]½]½]©m¶¸µâãã¡¥¤ìíìÿÿÿþþþüýýùúùùúúùùùïðïóôóýýý»]»[»[»[»[»[»[»[»[ºZºZºZºZºZºZºZ¹Y¹Y¹Y¹Y¹Y¹Y¹Y¹Y¸X¸X¸X¸X¸X·W·W·W·W·W·W·V¶V¶V¶V¶V¶UµUµUµUµUµTµTµT´T´S´S´S´S´S³~R³~R³~R³~R³~R²}Q²}Q²}Q²}Q²|Q±|P±|P±|P±{P±{P°{O°{O°{O°zO°zN¯zN¯zN¯yN¯yM¯yM®yM®xM®xL®xL®xL­wL­wK­wK­wK¬vK¬vJ¬vJ¬vJ¬uJ«uI«uI«uI«tI«tI«tIªtHªsHªsHªsH©sG©rG©rG©rG©rF¨qF¨qF¨qF¨qE§pE§pE§pD§pD§oD¦oD¦oC¦oC¦nC¥nC¥nB¥mB¥mB¥mB¤mA¤lA¤lA¤lA£l@£k@£lA¤mC¦pF¦qH§sJ©uMªwP¬yR¬{U®}X¯Z°]±`²b²b³c³e´gµg¶i¶k·l·m¸o¹q¹rºt»v¼x½y¾{¾{¾{¾{½{½{½{¼{¼{¼{¼{¼z¼z¼z¼z¼y¼y»y»x»x»x»x»x»x»x»xºwºw»xºyºy»z»z¼|»{»|¼}¼~¼~¼~½½¾¾¾¿¾¿¿¿À¿ÀÀÁÁÁ¡Á Â¡Á¡Â¢Â¢Â¢Â¢Â¢Â¢Â¢Â¢Â¢Â¢Â¢Â¡Â¡Á¡Á¡Á À À À À À À ÀÀ¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¾^¾^¾^¾^¾^¾^¾^½^½^½^½^½^½^½^½^½^½^¼_ÄÅÄ³¶¶£§¥üüüýýýëìëßààÝÞÝàááåææìììîïîòóòýýý´µ²y¼\¼\¼\»\»\»\»[»[»[»[»[»[»[ºZºZºZºZºZºZ¹Y¹Y¹Y¹Y¹Y¹Y¹Y¸X¸X¸X¸X¸X¸X·W·W·W·W·W·V¶V¶V¶V¶V¶UµUµUµUµTµTµT´T´T´S´S´S´S³~R³~R³~R³~R³~R²}Q²}Q²}Q²}Q²|Q±|P±|P±|P±{P±{P°{O°{O°zO°zO°zN¯zN¯zN¯yN¯yM®yM®yM®xM®xL®xL®xL­wL­wK­wK­wK¬vK¬vJ¬vJ¬vJ¬uJ«uI«uI«uI«tI«tIªtHªtHªsHªsH©sG©sG©rG©rG©rF¨qF¨qF¨qF¨qE§pE§pE§pE§pD§oD¦oD¦oD¦oC¦nC¥nC¥nB¥nB¥mB¥mB¤mA¤lA¤lA¤lA£l@£k@£k@£k@£k@¢j?¢j?¢j?¢j?¢i>¡i>¡i>¡h=¡h=¡i?¢kA£lC¥oF¦qI§tL©vOªxR«{V­}Y®[°^°_¯^¯^¯^¯^¯]°^°`±a²c²e³g´i´jµl¶n·o¸p¸r¹tºv»w¼y»y»x»x»x»x»x»x»x»xºwºwºw¹w¹w¹w¹w¹w¸v¸v¸v¸v¸u¸u¸u¸u¸u¸u¸u¸t·t·t·s·s·s¶s¶s¶s¶s¶sµrµrµr´q´qµsµs¶t¶t·v·w¸x¸w¸x¹y¹y¹z¹{º{º}º~º~»~»¼»¼¼¼¼½½¾¾¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¾_¾_¾_¾_¾_¾_¾_¾_¾_¾_¾_¾_¾_¾_¾_¾_¾_y¾Á¾ËÌÌüüü÷÷÷ÓÔÓÎÏÏÔÕÕÙÚÚÞßßáãâæçæéêéíîîõööýýý¡£ ­i¼]¼]¼]¼\¼\¼\¼\»\»\»\»[»[»[»[»[»[ºZºZºZºZºZºZ¹Y¹Y¹Y¹Y¹Y¹Y¹Y¸X¸X¸X¸X¸X·W·W·W·W·V·V¶V¶V¶V¶U¶UµUµUµUµTµTµT´T´S´S´S´S´S³~R³~R³~R³~R²}Q²}Q²}Q²}Q²|Q±|P±|P±|P±{P±{P°{O°{O°zO°zO°zN¯zN¯yN¯yN¯yM®yM®xM®xM®xL®xL­wL­wL­wK­wK¬vK¬vK¬vJ¬vJ¬uJ¬uJ«uI«uI«tI«tI«tIªtHªsHªsHªsH©sG©rG©rG©rF©rF¨qF¨qF¨qE¨qE§pE§pE§pD§oD§oD¦oD¦oC¦nC¥nC¥nC¥nB¥mB¥mB¤mA¤mA¤lA¤lA£l@£k@£k@£k@£k@¢j?¢j?¢j?¢j?¢i>¡i>¡i>¡i>¡h= h= h= g< g< g<g<f;f;f;f;e: h>¡j@¢lC¤oG¥qJ§tN¨vPªxS¬{W­[¯]®]®]®]­\­\­\­~\­~[¬~[¬}[¬}[¬}Z­\­^®_¯a°c²f³h´jµmµn¶p·r¸t¹u¹w¹w¹w¹w¸v¸v¸v¸v¸u¸u¸u¸u¸u¸u¸u¸t·t·t·s·s·s¶s¶s¶s¶sµrµrµrµr´q´q´q´q´q´q´q´q´p´p´p´p´o³o³o³o³o²o²o²n²n±n±n±n±n°n°m°m°m°m°l°m±n±n²o²p³r³r´s´sµuµu¶w¶x·y·y¸{¸|¹}¹}º~»»¼¼½½¾¾¿¿¿¿¿`¿`¿`¿`¿`¿`¿`¿`¿`¿`¿`¿`¿`¿`¿`¾_µeòòòíîíùùùËÌËÇÈÈÍÎÍÒÓÓ×ÙØÛÞÝßâáãääæççîîîðññôõõòóó½_½]½]½]½]¼]¼]¼]¼\¼\¼\¼\»\»\»[»[»[»[»[ºZºZºZºZºZºZ¹Y¹Y¹Y¹Y¹Y¹Y¹Y¸X¸X¸X¸X·W·W·W·W·W·V·V¶V¶V¶V¶UµUµUµUµTµTµT´T´S´S´S´S´S³~R³~R³~R³~R²}Q²}Q²}Q²}Q²|Q±|P±|P±|P±{P°{O°{O°{O°zO°zN°zN¯zN¯yN¯yM¯yM®yM®xM®xL®xL®xL­wL­wK­wK­wK¬vK¬vJ¬vJ¬vJ¬uJ«uI«uI«uI«tI«tIªtHªsHªsHªsH©sG©rG©rG©rG©rF¨qF¨qF¨qF¨qE§pE§pE§pD§pD§oD¦oD¦oC¦nC¦nC¥nC¥nB¥mB¥mB¥mB¤mA¤lA¤lA£l@£k@£k@£k@£k@¢j?¢j?¢j?¢j?¢i>¡i>¡i>¡i>¡h= h= h= g< g< g<g<f;f;f;f;e:e:e:d9d9d9d9c8c8c8c:f=i@¡lD£nG¤qJ¦tN¨wRªyV¬}Y¬~[¬}[¬}[¬}Z¬}Z«|Z«|Y«|Y«|Y«{Y«{Y«{Y«{Yª{Xª{Xª{XªzXª{X«}Z¬~]­_®a®c°e±g±h²k³m´o¶r·t¸u¸t¸t·t·t·s·s¶s¶s¶s¶s¶sµrµrµrµr´q´q´q´q´q´q´q´q´p´p´p´p´o³o³o³o²o²o²o²n²n±n±n±n±n°n°m°m°m°l°l°l°l°l°l°l°l°l°l°l°l°l°l°l°l°l°l°l°l°l°l°l°l°l°l°l°l°l°l°m±n²oÀaÀaÀaÀaÀaÀaÀaÀaÀaÀaÀa¿`¿`¿`¿`¿`{×ÚÙÂÆÄ¢¦¥þþþÚÚÚÀÀÀÅÇÇËÎÍÑÓÒÖ××ÙÛÚÝßßàãâåèçîïîíîîëììúûû­­©±g½^½^½^½^½^½]½]½]½]¼]¼]¼\¼\¼\¼\»\»[»[»[»[»[»[ºZºZºZºZºZ¹Y¹Y¹Y¹Y¹Y¹Y¸X¸X¸X¸X¸X·W·W·W·W·V·V¶V¶V¶V¶UµUµUµUµTµTµT´T´S´S´S´S³~R³~R³~R³~R³~R²}Q²}Q²}Q²}Q²|Q±|P±|P±|P±{P°{O°{O°{O°zO°zN¯zN¯zN¯yN¯yM®yM®yM®xM®xL®xL­wL­wL­wK­wK¬vK¬vK¬vJ¬vJ¬uJ«uI«uI«uI«tI«tIªtHªtHªsHªsH©sG©sG©rG©rG©rF¨qF¨qF¨qF¨qE§pE§pE§pE§pD§oD¦oD¦oC¦nC¦nC¥nC¥nB¥mB¥mB¥mB¤mA¤lA¤lA£l@£l@£k@£k@£k@¢j?¢j?¢j?¢j?¢i>¡i>¡i>¡i>¡h= h= h= g< g< g<g<f;f;f;e:e:e:e:d9d9d9d9c8c8c8b8b8b7b7a7a6a6a6`6a7d;g? jB¢mF¤pI¥sN§vQ©yU«{Y«{Y«{Y«{Y«{Yª{Xª{Xª{XªzX©zW©zW©yW©yW¨yV¨yV¨xV¨xV§xU§wU§wU§wU§wU§xV©zXª{Yª|[«~^¬`®b¯e°g±i²k³nµqµrµrµr´q´q´q´q´q´q´q´q´q´p´p´p´o³o³o³o³o²o²o²n²n²n±n±n±n°n°m°m°m°m°l°l°l°l°l°l°l°l°l°l°l°l°l°l°l°l°l°l°l°l°l°l°l°l°l°l°l°l°l°l°l°lÀaÀaÀaÀaÀaÀaÀaÀaÀaÀaÀaÀaÀaÀaÀaÀaö÷÷ÛÝÜ÷÷÷ÓÔÔÃÄÄÄÆÅÊÌËÏÐÏÓÕÔ×ÙØÚÝÜÝßÞéëêëíìêëêçêèïññÝßÞ¡y¾_¾_¾_¾^¾^½^½^½^½^½]½]½]½]¼]¼\¼\¼\¼\»\»\»[»[»[»[»[ºZºZºZºZºZ¹Y¹Y¹Y¹Y¹Y¹Y¸X¸X¸X¸X·W·W·W·W·W·V¶V¶V¶V¶UµUµUµUµTµTµT´T´S´S´S´S³~R³~R³~R³~R²}Q²}Q²}Q²}Q²|Q²|Q±|P±|P±{P±{P°{O°{O°zO°zO°zN¯zN¯yN¯yM¯yM®yM®xM®xL®xL®xL­wL­wK­wK­wK¬vK¬vJ¬vJ¬uJ¬uJ«uI«uI«tI«tI«tIªtHªsHªsH©sG©sG©rG©rG©rF¨qF¨qF¨qF¨qE§pE§pE§pE§pD§oD¦oD¦oC¦oC¦nC¥nC¥nB¥mB¥mB¥mB¤mA¤lA¤lA£l@£l@£k@£k@£k@¢j?¢j?¢j?¢j?¢i>¡i>¡i>¡i>¡h= h= h= g< g< g<g<f;f;f;e:e:e:e:d9d9d9d9c8c8c8b8b7b7b7a7a6a6`6`6`5`5_5_4_4_4^4^3_4a9e<h@ lD¢nI¤rL¦uQ©xU©zW©zW©zW©yW©yW¨yV¨xV¨xV¨xV§xU§wU§wU§wU§wU§wU§wU§wT¦vT¦vT¦vS¦vS¦uS¥uS¥uR¥tR¥tR¥uS¦wT§wV¨zY©|[ª~^¬`­c®e¯h°k²n³o´p´p´p´o³o³o³o³o²o²o²n²n±n±n±n±n°n°m°m°m°l°l°l°l°l°l°l°l°l°l°l°l°l°l°l°l°l°l°l°l°l°l°l°l°l°l°l°l°l°l°l°lÁbÁbÁbÁbÁbÁbÁbÁbÁbÁbÁbÁbÁbÁbÁb¼eö÷÷ïðððñðçêéçéèáãâÙÛÚÔÖÕÑÕÔÕØ××ÛÚåæåéëêéëêçéèäææçêéðñð¿`¾_¾_¾_¾_¾_¾_¾^¾^½^½^½^½]½]½]½]¼]¼]¼\¼\¼\»\»\»[»[»[»[ºZºZºZºZºZ¹Y¹Y¹Y¹Y¹Y¹Y¸X¸X¸X¸X·W·W·W·W·W·V¶V¶V¶V¶UµUµUµUµTµTµT´T´S´S´S´S³~R³~R³~R³~R²}Q²}Q²}Q²}Q²|Q±|P±|P±|P±{P°{O°{O°{O°zO°zN¯zN¯zN¯yN¯yM®yM®xM®xM®xL®xL­wL­wK­wK­wK¬vK¬vJ¬vJ¬vJ¬uJ«uI«uI«tI«tI«tIªtHªsHªsHªsH©sG©rG©rG©rF©rF¨qF¨qF¨qE§pE§pE§pE§pD§oD¦oD¦oC¦oC¦nC¥nC¥nB¥mB¥mB¥mB¤mA¤lA¤lA£l@£l@£k@£k@£k@¢j?¢j?¢j?¢j?¢i>¡i>¡i>¡h=¡h= h= h= g< g<g<g<f;f;f;e:e:e:e:d9d9d9c8c8c8c8b8b7b7b7a7a6a6`6`5`5`5_5_4_4^4^3^3^3]3]2]2\2\2\1\1\3`6c;g?jC¡mH£qL¥sP§wU§xU§xU§wU§wU§wU§wU§wU§wU§wT¦vT¦vT¦vS¦uS¥uS¥uS¥uR¥tR¥tR¤tQ¤sQ¤sQ¤sQ£sP£sP£sP£sP¢rP¢rP¢rP¢rP£rP¤tS¥vU§wW¨zZ©|]ª}_«a¬d®g¯i°k²n±n±n±n°n°n°m°m°m°l°l°l°l°l°l°l°l°l°l°l°l°l°l°l°l°l°l°l°l°l°l°l°l°l°l°l°l°l°l°lÂcÂcÂcÂcÂcÂcÂcÂcÂcÂcÂcÂcÂcÁbÁbµj«¬¨ñòò÷ø÷éëêãæåãåäâäãáäâéëêìîíæèèãåäèêéçéèæèçãæåáãââäãö÷÷¿`¿`¿`¿`¿`¾_¾_¾_¾_¾_¾^¾^½^½^½^½^½]½]½]¼]¼]¼\¼\¼\»\»[»[»[»[»[ºZºZºZºZ¹Y¹Y¹Y¹Y¹Y¹Y¸X¸X¸X¸X·W·W·W·W·W·V¶V¶V¶V¶UµUµUµUµTµT´T´T´S´S´S´S³~R³~R³~R²}Q²}Q²}Q²}Q²|Q²|Q±|P±|P±{P°{O°{O°{O°zO°zN°zN¯zN¯yN¯yM®yM®yM®xM®xL®xL­wL­wL­wK­wK¬vK¬vJ¬vJ¬vJ¬uJ«uI«uI«uI«tI«tIªtHªsHªsHªsH©sG©rG©rG©rF©rF¨qF¨qF¨qE§pE§pE§pE§pD§oD¦oD¦oC¦oC¦nC¥nC¥nB¥mB¥mB¥mB¤mA¤lA¤lA£l@£k@£k@£k@£k@¢j?¢j?¢j?¢j?¢i>¡i>¡i>¡h= h= h= h= g< g<g<f;f;f;f;e:e:e:e:d9d9d9c8c8c8c8b8b7b7a7a7a6a6`6`5`5_5_5_4_4^4^3^3^3]3]2]2\2\1\1\1[1[0[0Z0Z0Z0Z/Y/[1^5a9d>hB lF¡nJ¤rO¦uR¦vT¦vT¦vT¦vS¦uS¥uS¥uR¥tR¥tR¥tR¤tQ¤sQ¤sQ£sP£sP£sP£sP£sP¢rP¢rP¢rP¢rP¢qO¢qO¢qO¢pN¡pN¡pN¡pN¡oM oM oM oL pM¡rP¢tR¤uU¥xX¦z[¨{]©~_«b¬e®g¯k°l°l°l°l°l°l°l°l°l°l°l°l°l°l°l°l°l°l°l°l°l°l°l°l°l°l°l°lÂdÂdÂdÂdÂdÂdÂdÂcÂcÂcÂcÂcÂcÂcÂc¶jª«¨òôóôôôåèçßâáßâàáäãøùùóôóâããòóòûüûìîíåèçãåäàãáÝàßàãâõõõÀaÀaÀa¿`¿`¿`¿`¿`¾_¾_¾_¾_¾_¾_¾^½^½^½^½^½]½]½]¼]¼\¼\¼\»\»\»[»[»[»[ºZºZºZºZ¹Y¹Y¹Y¹Y¹Y¹Y¸X¸X¸X¸X·W·W·W·W·V·V¶V¶V¶U¶UµUµUµTµTµT´T´S´S´S´S³~R³~R³~R³~R²}Q²}Q²}Q²}Q²|Q±|P±|P±|P±{P°{O°{O°zO°zO°zN¯zN¯yN¯yM¯yM®yM®xM®xL®xL®xL­wL­wK­wK¬vK¬vJ¬vJ¬vJ¬uJ«uI«uI«uI«tI«tIªtHªsHªsHªsH©sG©rG©rG©rF©rF¨qF¨qF¨qE§pE§pE§pE§pD§oD¦oD¦oC¦nC¦nC¥nC¥nB¥mB¥mB¥mB¤mA¤lA¤lA£l@£k@£k@£k@£k@¢j?¢j?¢j?¢i>¢i>¡i>¡i>¡h= h= h= h= g< g<g<f;f;f;f;e:e:e:d9d9d9d9c8c8c8b8b8b7b7a7a6a6a6`6`5`5_5_4_4_4^4^3^3]3]2]2]2\2\1\1[1[0[0[0Z0Z0Z/Y/Y/Y/Y.X.X.X-W-W-W-Z/]4a9e=hB lG¡pL¤tP¥tR¥tR¤tQ¤tQ¤sQ¤sQ£sP£sP£sP£sP£sP¢rP¢rP¢rP¢qO¢qO¢qO¢qO¢pN¡pN¡pN¡oM oM oM oM oL oLoLnLnLnLnLmKmKmKlJlJmK oN¡qP£tT¥vW¦xY¨{\©}_«b¬e®i°k°l°l°l°l°l°l°l°l°l°l°l°l°l°l°l°lÃdÃdÃdÃdÃdÃdÃdÃdÃdÃdÃdÃdÃdÃdÃd½gûûûçèèçéèÛßÝÛÞÝùùùÅÉÇÃÇÅûûûãæåàãáÜàÞÙÝÛãæåéêêÀaÀaÀaÀaÀaÀa¿`¿`¿`¿`¿`¿`¾_¾_¾_¾_¾^¾^½^½^½^½]½]½]¼]¼]¼\¼\¼\»\»[»[»[»[ºZºZºZºZ¹Y¹Y¹Y¹Y¹Y¹Y¸X¸X¸X¸X·W·W·W·W·V¶V¶V¶V¶UµUµUµUµTµT´T´T´S´S´S³~R³~R³~R³~R²}Q²}Q²}Q²}Q²|Q±|P±|P±|P±{P°{O°{O°zO°zO°zN¯zN¯yN¯yM¯yM®yM®xM®xL®xL®xL­wL­wK­wK¬vK¬vK¬vJ¬vJ¬uJ«uI«uI«uI«tI«tIªtHªsHªsHªsH©sG©rG©rG©rF©rF¨qF¨qF¨qE§pE§pE§pE§pD§oD¦oD¦oC¦nC¦nC¥nC¥nB¥mB¥mB¤mA¤mA¤lA¤lA£l@£k@£k@£k@£k@¢j?¢j?¢j?¢i>¡i>¡i>¡i>¡h= h= h= g< g< g<g<f;f;f;f;e:e:e:d9d9d9d9c8c8c8b8b7b7b7a7a6a6`6`5`5`5_5_4_4^4^4^3^3]3]2]2\2\2\1\1[1[0[0Z0Z0Z0Z/Y/Y/Y.X.X.X.X-W-W-W,W,V,V,V+U+U+U*X.[3_8c<gAkF oK£sP£sP£sP£sP¢rP¢rP¢rP¢rP¢qO¢qO¢qO¢pN¡pN¡pN¡pN¡oM oM oM oL oLoLoLnLnLnLmKmKmKmKlJlJlJlJlJlJlJlJlJlJlJlJlJnL¡qP£sS¤uU¦xY¨z\©}_«b¬d®h¯k°l°l°l°l°lÄeÄeÄeÄeÄeÄeÄeÄeÄeÄeÄeÄeÄeÄeÃeÃeòóóµ··ÆÈÇñòñ×ÛÚãååïðïÂÇÆ¸¿¼³¥ìîíèêêÜßÞØÜÛÖÙ×ïðïÈÊÈ¥tÁbÁbÁbÀaÀaÀaÀaÀaÀa¿`¿`¿`¿`¿`¾_¾_¾_¾_¾_¾^½^½^½^½]½]½]¼]¼]¼\¼\¼\»\»[»[»[»[ºZºZºZºZ¹Y¹Y¹Y¹Y¹Y¹Y¸X¸X¸X·W·W·W·W·V·V¶V¶V¶U¶UµUµUµTµTµT´T´S´S´S´S³~R³~R³~R²}Q²}Q²}Q²}Q²|Q±|P±|P±|P±{P°{O°{O°{O°zO°zN¯zN¯yN¯yN¯yM®yM®xM®xL®xL®xL­wL­wK­wK¬vK¬vJ¬vJ¬vJ¬uJ«uI«uI«uI«tI«tIªtHªsHªsHªsH©sG©rG©rG©rF¨qF¨qF¨qF¨qE§pE§pE§pD§pD§oD¦oD¦oC¦nC¥nC¥nC¥nB¥mB¥mB¤mA¤lA¤lA¤lA£l@£k@£k@£k@¢j?¢j?¢j?¢j?¢i>¡i>¡i>¡i>¡h= h= h= g< g<g<g<f;f;f;e:e:e:e:d9d9d9c8c8c8c8b8b7b7a7a7a6a6`6`5`5_5_5_4_4^4^3^3]3]3]2]2\2\1\1[1[1[0[0Z0Z0Z/Z/Y/Y/Y.X.X.X-X-W-W-W,V,V,V+V+U+U+U*T*T*T)T)S)S)S(U,Y1^6b;e@iEmJ¡pN¢qO¢qO¢qO¢pN¡pN¡pN¡oM oM oM oM oL oLoLnLnLnLnLmKmKmKlJlJlJlJlJlJlJlJlJlJlJlJlJlJlJlJlJlJlJlJlJlJlJlJmK¡pO¢rR¤uU¦xXÄfÄfÄfÄfÄfÄfÄfÄfÄfÄfÄfÄfÄfÄfÄfÄe¤yÉÌÊâåäúúúÚÞÜçééãää³¸¶ÑÔÓÚÝÝ¹À¾×ÙÙìîíØÜÛÕÚ××ÚÚúûú»gÁbÁbÁbÁbÁbÁbÀaÀaÀaÀaÀaÀa¿`¿`¿`¿`¿`¾_¾_¾_¾_¾^¾^½^½^½^½]½]¼]¼]¼\¼\»\»\»[»[»[»[ºZºZºZºZ¹Y¹Y¹Y¹Y¹Y¸X¸X¸X¸X·W·W·W·W·V¶V¶V¶V¶UµUµUµTµTµT´T´S´S´S´S³~R³~R³~R³~R²}Q²}Q²}Q²|Q²|Q±|P±|P±{P°{O°{O°{O°zO°zN¯zN¯yN¯yM¯yM®yM®xM®xL®xL®xL­wL­wK­wK¬vK¬vJ¬vJ¬vJ¬uJ«uI«uI«tI«tI«tIªtHªsHªsH©sG©sG©rG©rG©rF¨qF¨qF¨qF¨qE§pE§pE§pD§oD§oD¦oD¦oC¦nC¥nC¥nB¥mB¥mB¥mB¤mA¤lA¤lA£l@£l@£k@£k@£k@¢j?¢j?¢j?¢j?¢i>¡i>¡i>¡h= h= h= h= g< g<g<f;f;f;f;e:e:e:d9d9d9d9c8c8c8b8b8b7b7a7a6a6`6`6`5`5_5_4_4^4^4^3^3]3]2]2]2\2\1\1[1[0[0[0Z0Z0Z/Y/Y/Y.Y.X.X.X-W-W-W,W,V,V,V+U+U+U*U*T*T*T)S)S)S(S(R(R(R(Q'Q'Q'Q'S*X/\5`:d?hDlI¡oM oM oM oL oLoLnLnLnLnLmKmKmKlJlJlJlJlJlJlJlJlJlJlJlJlJlJlJlJlJlJlJlJlJlJlJlJlJlJlJlJlJÅgÅgÅgÅgÅgÅgÅgÅgÅgÅgÅgÅgÅgÅfÅfÀ ³²©óôô§ª¨ÆÉÇõööëîíñññ¶½¹ØÜÛÊÏÍçéèçéèÕÚ×ÑÖÔïððÌÎÍ}ÂcÂcÂcÂcÂcÁbÁbÁbÁbÁbÀaÀaÀaÀaÀaÀa¿`¿`¿`¿`¾_¾_¾_¾_¾^¾^½^½^½]½]½]¼]¼\¼\¼\»\»[»[»[»[ºZºZºZºZ¹Y¹Y¹Y¹Y¹Y¸X¸X¸X¸X·W·W·W·W·V¶V¶V¶V¶UµUµUµUµTµT´T´S´S´S´S³~R³~R³~R³~R²}Q²}Q²}Q²|Q²|Q±|P±|P±{P°{O°{O°{O°zO°zN¯zN¯yN¯yM¯yM®yM®xM®xL®xL­wL­wL­wK­wK¬vK¬vJ¬vJ¬vJ¬uJ«uI«uI«tI«tI«tIªtHªsHªsH©sG©rG©rG©rG©rF¨qF¨qF¨qE§pE§pE§pE§pD§oD¦oD¦oC¦oC¦nC¥nC¥nB¥mB¥mB¥mB¤mA¤lA¤lA£l@£k@£k@£k@£k@¢j?¢j?¢j?¢i>¡i>¡i>¡i>¡h= h= h= g< g< g<g<f;f;f;e:e:e:e:d9d9d9c8c8c8c8b8b7b7a7a7a6a6`6`5`5_5_5_4_4^4^3^3^3]3]2]2\2\1\1\1[1[0[0Z0Z0Z/Z/Y/Y/Y.X.X.X-X-W-W-W,V,V,V+U+U+U+U*T*T*T)S)S)S)S(R(R(R(Q'Q'Q'Q'P&P&P&O%O%O%O%O%S*X0[4`:d?iFlJnLnLmKmKmKmKlJlJlJlJlJlJlJlJlJlJlJlJlJlJlJlJlJlJlJlJlJlJlJlJlJlJlJlJÆhÆhÆhÆhÆhÆhÆhÆhÆhÆgÆgÆgÆgÄrº±¢¿ÅÂïððÁÅÄ¢¦¥ðññâãâõöõþþþº¾½¹¿½åèè»Â¿±¶³úúú×ÛÙÒ×Õèëêãåä¿fÃdÂdÂdÂcÂcÂcÂcÁbÁbÁbÁbÁbÀaÀaÀaÀaÀaÀa¿`¿`¿`¿`¾_¾_¾_¾_¾^½^½^½^½]½]½]¼]¼\¼\¼\»\»[»[»[»[ºZºZºZºZ¹Y¹Y¹Y¹Y¹Y¸X¸X¸X¸X·W·W·W·V¶V¶V¶V¶UµUµUµUµTµT´T´S´S´S´S³~R³~R³~R³~R²}Q²}Q²}Q²|Q±|P±|P±|P±{P°{O°{O°zO°zO°zN¯zN¯yN¯yM®yM®yM®xM®xL®xL­wL­wK­wK­wK¬vK¬vJ¬vJ¬uJ¬uJ«uI«uI«tI«tIªtHªtHªsHªsH©sG©rG©rG©rF©rF¨qF¨qF¨qE§pE§pE§pE§pD§oD¦oD¦oC¦nC¥nC¥nC¥nB¥mB¥mB¤mA¤lA¤lA¤lA£l@£k@£k@£k@¢j?¢j?¢j?¢j?¢i>¡i>¡i>¡h=¡h= h= h= g< g<g<f;f;f;f;e:e:e:d9d9d9d9c8c8c8b8b8b7b7a7a6a6`6`6`5`5_5_4_4^4^4^3^3]3]2]2\2\2\1\1[1[0[0Z0Z0Z0Z/Y/Y/Y.X.X.X.X-W-W-W,V,V,V,V+U+U+U*T*T*T*T)S)S)S(R(R(R(R(Q'Q'Q'P&P&P&P&O%O%O%N$N$N$N$M#M#M#L"P&T,Y2\6`;eAiFlJlJlJlJlJlJlJlJlJlJlJlJlJlJlJlJlJlJlJlJlJlJlJlJlJlJlJÆhÆhÆhÆhÆhÆhÆhÆhÆhÆhÆhÆi¾¨¸¾¹ÔØ×çêêáäã¸»¶¤¦¦¤äååÕØ×òóó½ÃÁÝàßÒÖÕÂÈÆùùùÞáàÝàßóôôÞàß»jÃeÃeÃdÃdÃdÂdÂcÂcÂcÂcÂcÁbÁbÁbÁbÀaÀaÀaÀaÀaÀa¿`¿`¿`¿`¾_¾_¾_¾_¾^½^½^½^½]½]¼]¼]¼\¼\»\»[»[»[»[ºZºZºZºZ¹Y¹Y¹Y¹Y¹Y¸X¸X¸X¸X·W·W·W·V·V¶V¶V¶UµUµUµUµTµT´T´S´S´S´S³~R³~R³~R³~R²}Q²}Q²}Q²|Q±|P±|P±|P±{P°{O°{O°zO°zN°zN¯zN¯yN¯yM®yM®xM®xM®xL®xL­wL­wK­wK­wK¬vK¬vJ¬vJ¬uJ«uI«uI«uI«tI«tIªtHªsHªsHªsH©sG©rG©rG©rF¨qF¨qF¨qF¨qE§pE§pE§pD§oD§oD¦oD¦oC¦nC¥nC¥nB¥mB¥mB¥mB¤mA¤lA¤lA£l@£k@£k@£k@£k@¢j?¢j?¢j?¢i>¢i>¡i>¡i>¡h= h= h= g< g< g<g<f;f;f;e:e:e:e:d9d9d9c8c8c8c8b8b7b7a7a7a6a6`6`5`5_5_5_4_4^4^3^3]3]3]2]2\2\1\1[1[1[0[0Z0Z0Z/Y/Y/Y/Y.X.X.X-W-W-W-W,V,V,V+U+U+U+U*T*T*T)S)S)S)S(R(R(R(Q'Q'Q'Q'P&P&P&O%O%O%O%N$N$N$M#M#M#M#L"L"L"K!K!K!K!K"P'U-Y2^8b>gDkIlJlJlJlJlJlJlJlJlJlJlJlJlJlJlJlJlJlJlJÇiÇiÇiÇiÇiÇiÇiÇiÇiÇiÇm¼°ÃÈÆæéé×ÛÚºÁ¾½­ÅmÆh­vÇÊÈ­²°½ÃÀßáàÜÞÝ½ÄÁ÷÷÷ôõõûüûìíí³¶³¼kÄeÄeÄeÄeÃeÃdÃdÃdÂdÂdÂcÂcÂcÂcÁbÁbÁbÁbÀaÀaÀaÀaÀa¿`¿`¿`¿`¾_¾_¾_¾_¾^¾^½^½^½]½]½]¼]¼\¼\»\»\»[»[»[ºZºZºZºZ¹Y¹Y¹Y¹Y¹Y¸X¸X¸X¸X·W·W·W·V·V¶V¶V¶UµUµUµUµTµT´T´S´S´S´S³~R³~R³~R²}Q²}Q²}Q²}Q²|Q±|P±|P±{P±{P°{O°{O°zO°zN¯zN¯zN¯yN¯yM®yM®xM®xL®xL®xL­wL­wK­wK¬vK¬vJ¬vJ¬vJ¬uJ«uI«uI«tI«tI«tIªtHªsHªsH©sG©rG©rG©rG©rF¨qF¨qF¨qE§pE§pE§pE§pD§oD¦oD¦oC¦nC¦nC¥nC¥nB¥mB¥mB¤mA¤lA¤lA¤lA£l@£k@£k@£k@¢j?¢j?¢j?¢j?¢i>¡i>¡i>¡h=¡h= h= h= g< g<g<f;f;f;f;e:e:e:d9d9d9d9c8c8c8b8b8b7b7a7a6a6`6`6`5`5_5_4_4^4^4^3^3]3]2]2\2\1\1\1[1[0[0Z0Z0Z0Z/Y/Y/Y.X.X.X.X-W-W-W,V,V,V,V+U+U+U*T*T*T)T)S)S)S(R(R(R(R(Q'Q'Q'P&P&P&P&O%O%O%N$N$N$M#M#M#M#L"L"L"K!K!K!K!J J J J J J J K!O&T,Y2]8c?gDkIlJlJlJlJlJlJlJlJlJlJlJlJÈjÈjÈjÈjÈjÈjÈjÈjÈjÆs¹¶«ÚÞÝêììÅÊÈº´¨ÄyÇiÇiÇiÇi¿rµ²©ËÐÎèéèÛÝÝ´¹·¦ª§®±°¨¬©­tÄgÅfÄfÄfÄfÄeÄeÄeÃeÃdÃdÃdÂdÂdÂcÂcÂcÂcÁbÁbÁbÁbÀaÀaÀaÀaÀa¿`¿`¿`¿`¾_¾_¾_¾_¾^½^½^½]½]½]¼]¼\¼\¼\»\»[»[»[ºZºZºZºZ¹Y¹Y¹Y¹Y¹Y¸X¸X¸X¸X·W·W·W·V¶V¶V¶V¶UµUµUµTµTµT´T´S´S´S´S³~R³~R³~R²}Q²}Q²}Q²}Q²|Q±|P±|P±{P°{O°{O°{O°zO°zN¯zN¯yN¯yM¯yM®yM®xM®xL®xL­wL­wK­wK­wK¬vK¬vJ¬vJ¬uJ¬uJ«uI«uI«tI«tIªtHªsHªsHªsH©sG©rG©rG©rF¨qF¨qF¨qF¨qE§pE§pE§pD§oD§oD¦oD¦oC¦nC¥nC¥nB¥mB¥mB¥mB¤mA¤lA¤lA£l@£k@£k@£k@£k@¢j?¢j?¢j?¢i>¢i>¡i>¡i>¡h= h= h= g< g< g<g<f;f;f;e:e:e:e:d9d9d9c8c8c8c8b8b7b7a7a6a6a6`6`5`5_5_4_4_4^4^3^3]3]2]2]2\2\1\1[1[0[0[0Z0Z0Z/Y/Y/Y.Y.X.X.X-W-W-W,W,V,V,V+U+U+U*T*T*T*T)S)S)S(R(R(R(R(Q'Q'Q'P&P&P&P&O%O%O%N$N$N$N$M#M#M#L"L"L"L"K!K!K!J J J J J J J J J J J J J J K!O&T,Y2^8c?gDkIlJlJlJlJlJÈjÈjÉkÉkÉkÉkÈjÈjÇp¸·¯áääëììÂÈÆ¾«ÈkÈjÈjÇiÇjÊ¬ÍÌÆÝßßïððÒ×Õ·´¬°y¬t±r¹nÂjÆgÆgÅgÅgÅgÅfÄfÄfÄfÄeÄeÄeÃeÃdÃdÃdÂdÂcÂcÂcÂcÁbÁbÁbÁbÀaÀaÀaÀaÀa¿`¿`¿`¿`¾_¾_¾_¾_¾^½^½^½]½]½]¼]¼\¼\¼\»\»[»[»[ºZºZºZºZ¹Y¹Y¹Y¹Y¹Y¸X¸X¸X·W·W·W·W·V¶V¶V¶V¶UµUµUµTµT´T´T´S´S´S³~R³~R³~R³~R²}Q²}Q²}Q²|Q±|P±|P±|P±{P°{O°{O°zO°zN°zN¯zN¯yN¯yM®yM®xM®xM®xL®xL­wL­wK­wK¬vK¬vK¬vJ¬vJ¬uJ«uI«uI«tI«tI«tIªtHªsHªsH©sG©rG©rG©rG©rF¨qF¨qF¨qE§pE§pE§pE§pD§oD¦oD¦oC¦nC¦nC¥nC¥nB¥mB¥mB¤mA¤lA¤lA¤lA£l@£k@£k@£k@¢j?¢j?¢j?¢j?¢i>¡i>¡i>¡h= h= h= h= g< g<g<f;f;f;f;e:e:e:d9d9d9d9c8c8c8b8b7b7b7a7a6a6`6`5`5`5_5_4_4^4^3^3^3]3]2]2\2\1\1[1[1[0[0Z0Z0Z/Y/Y/Y/Y.X.X.X-W-W-W-W,V,V,V+U+U+U+U*T*T*T)S)S)S)S(R(R(R(Q'Q'Q'Q'P&P&P&O%O%O%O%N$N$N$M#M#M#L"L"L"L"K!K!K!J J J J J J J J J J J J J J J J J J J J J K!O&T,Y2^8c?ÉkÉkÉkÉkÉkÉkÉkÉk¹¹°ÐÔÓæéè¼Â½Â¥ÉkÉkÈjÉlÍ¬ÔÌÀÜßÞíïïêìëÉÏÌÂ®ÇjÇiÇiÇiÆhÆhÆhÆhÆhÆgÅgÅgÅgÅfÄfÄfÄfÄeÄeÄeÃeÃdÃdÃdÂdÂcÂcÂcÂcÁbÁbÁbÀaÀaÀaÀaÀa¿`¿`¿`¿`¾_¾_¾_¾_¾^½^½^½]½]½]¼]¼\¼\»\»\»[»[»[ºZºZºZºZ¹Y¹Y¹Y¹Y¹Y¸X¸X¸X·W·W·W·W·V¶V¶V¶UµUµUµUµTµT´T´S´S´S´S³~R³~R³~R²}Q²}Q²}Q²}Q²|Q±|P±|P±{P±{P°{O°{O°zO°zN¯zN¯yN¯yN¯yM®yM®xM®xL®xL­wL­wL­wK­wK¬vK¬vJ¬vJ¬uJ¬uJ«uI«uI«tI«tIªtHªsHªsHªsH©sG©rG©rG©rF¨qF¨qF¨qF¨qE§pE§pE§pD§oD¦oD¦oD¦oC¦nC¥nC¥nB¥mB¥mB¥mB¤mA¤lA¤lA£l@£k@£k@£k@£k@¢j?¢j?¢j?¢i>¡i>¡i>¡i>¡h= h= h= g< g<g<g<f;f;f;e:e:e:e:d9d9d9c8c8c8b8b8b7b7a7a6a6`6`6`5`5_5_4_4^4^4^3^3]3]2]2\2\1\1\1[1[0[0Z0Z0Z0Z/Y/Y/Y.X.X.X-X-W-W-W,V,V,V+V+U+U+U*T*T*T)S)S)S)S(R(R(R(Q'Q'Q'Q'P&P&P&O%O%O%O%N$N$N$M#M#M#M#L"L"L"K!K!K!K!J J J J J J J J J J J J J J J J J J J J J J J J J J ÊlÊlÊlÊlÊlÊlÊlÂ§½ÄÁçêéÀÆÃÄ¤ÉlÉkÊtÒ¹¢ÛØÓäççñòòóôôÞáàÇÄ¼Æ¤ÈjÈjÇiÇiÇiÇiÇiÆhÆhÆhÆhÆhÆgÅgÅgÅgÅfÄfÄfÄfÄeÄeÃeÃdÃdÃdÂdÂcÂcÂcÂcÁbÁbÁbÁbÀaÀaÀaÀa¿`¿`¿`¿`¾_¾_¾_¾_¾^½^½^½]½]½]¼]¼\¼\»\»[»[»[»[ºZºZºZºZ¹Y¹Y¹Y¹Y¸X¸X¸X¸X·W·W·W·V¶V¶V¶V¶UµUµUµTµTµT´T´S´S´S³~R³~R³~R³~R²}Q²}Q²}Q²|Q²|Q±|P±|P±{P°{O°{O°zO°zO°zN¯zN¯yN¯yM®yM®xM®xL®xL®xL­wL­wK­wK¬vK¬vJ¬vJ¬vJ¬uJ«uI«uI«tI«tI«tIªtHªsHªsH©sG©rG©rG©rG©rF¨qF¨qF¨qE§pE§pE§pD§pD§oD¦oD¦oC¦nC¥nC¥nB¥nB¥mB¥mB¤mA¤lA¤lA£l@£l@£k@£k@£k@¢j?¢j?¢j?¢i>¢i>¡i>¡i>¡h= h= h= g< g< g<g<f;f;f;e:e:e:e:d9d9d9c8c8c8c8b8b7b7a7a6a6a6`6`5`5_5_4_4_4^4^3^3]3]2]2]2\2\1\1[1[0[0Z0Z0Z0Z/Y/Y/Y.X.X.X.X-W-W-W,V,V,V,V+U+U+U*T*T*T*T)S)S)S(R(R(R(R(Q'Q'Q'P&P&P&P&O%O%O%N$N$N$M#M#M#M#L"L"L"K!K!K!K!J J J J J J J J J J J J J J J J J J J J J J J J J J ËmËmËmËmËmËmËm»´¦ÐÕÓÖÚÙÁÆÂÊ¬Îº¤ÖÎÃâããîïïö÷÷øøøåèçÑÓÎÉ°ÉmÈjÈjÈjÈjÈjÇiÇiÇiÇiÇiÆhÆhÆhÆhÆgÆgÅgÅgÅfÄfÄfÄfÄeÄeÃeÃeÃdÃdÂdÂcÂcÂcÂcÁbÁbÁbÁbÀaÀaÀaÀa¿`¿`¿`¿`¾_¾_¾_¾^¾^½^½^½]½]¼]¼]¼\¼\»\»[»[»[»[ºZºZºZ¹Y¹Y¹Y¹Y¹Y¸X¸X¸X·W·W·W·W·V¶V¶V¶UµUµUµUµTµT´T´S´S´S´S³~R³~R³~R²}Q²}Q²}Q²}Q²|Q±|P±|P±{P°{O°{O°{O°zO°zN¯zN¯yN¯yM¯yM®yM®xM®xL®xL­wL­wK­wK­wK¬vK¬vJ¬vJ¬uJ«uI«uI«uI«tI«tIªtHªsHªsH©sG©sG©rG©rG©rF¨qF¨qF¨qE§pE§pE§pE§pD§oD¦oD¦oC¦nC¦nC¥nC¥nB¥mB¥mB¤mA¤lA¤lA¤lA£l@£k@£k@£k@¢j?¢j?¢j?¢j?¢i>¡i>¡i>¡h= h= h= h= g< g<g<f;f;f;f;e:e:e:d9d9d9d9c8c8c8b8b7b7a7a7a6a6`6`5`5_5_5_4_4^4^3^3]3]2]2]2\2\1\1[1[0[0[0Z0Z0Z/Y/Y/Y.Y.X.X.X-W-W-W,W,V,V,V+U+U+U*T*T*T*T)S)S)S(R(R(R(R(Q'Q'Q'P&P&P&P&O%O%O%N$N$N$N$M#M#M#L"L"L"L"K!K!K!J J J J J J J J J J J J J J J J J J J J J J J J J J ËnËnËnËnËnËnËn½± ÌÐÏéëëÜàßàäãýýýþþþúûûõööèêêØ×ÒÍ¹¢ÉtÉkÉkÉkÉkÉkÈjÈjÈjÈjÇiÇiÇiÇiÇiÆhÆhÆhÆhÆgÅgÅgÅfÄfÄfÄfÄeÄeÃeÃeÃdÃdÂdÂcÂcÂcÂcÁbÁbÁbÀaÀaÀaÀaÀa¿`¿`¿`¿`¾_¾_¾_¾^½^½^½^½]½]¼]¼\¼\»\»\»[»[»[ºZºZºZºZ¹Y¹Y¹Y¹Y¸X¸X¸X¸X·W·W·W·V¶V¶V¶V¶UµUµUµTµTµT´T´S´S´S³~R³~R³~R³~R²}Q²}Q²}Q²|Q±|P±|P±|P±{P°{O°{O°zO°zN¯zN¯zN¯yN¯yM®yM®xM®xL®xL®xL­wL­wK­wK¬vK¬vJ¬vJ¬uJ¬uJ«uI«uI«tI«tIªtHªsHªsHªsH©sG©rG©rG©rF¨qF¨qF¨qF¨qE§pE§pE§pD§oD¦oD¦oD¦oC¦nC¥nC¥nB¥mB¥mB¤mA¤mA¤lA¤lA£l@£k@£k@£k@£k@¢j?¢j?¢j?¢i>¡i>¡i>¡h=¡h= h= h= g< g<g<f;f;f;f;e:e:e:d9d9d9d9c8c8c8b8b7b7b7a7a6a6`6`5`5`5_5_4_4^4^3^3^3]3]2]2\2\1\1[1[1[0[0Z0Z0Z/Y/Y/Y/Y.X.X.X-W-W-W-W,V,V,V+U+U+U*U*T*T*T)S)S)S(S(R(R(R(Q'Q'Q'P&P&P&P&O%O%O%N$N$N$N$M#M#M#L"L"L"L"K!K!K!J J J J J J J J J J J J J J J J J J J J J J J J J J ÌnÌoÌoÌoÌoÌoÌnÉ wÀÅÀÖÛÚåèçêììûüüûüüâäãÙÏÃÏ±ÊoÊlÊlÊlÉlÉkÉkÉkÉkÈjÈjÈjÈjÇiÇiÇiÇiÇiÆhÆhÆhÆhÆgÅgÅgÅfÄfÄfÄfÄeÄeÃeÃdÃdÃdÂdÂcÂcÂcÁbÁbÁbÁbÀaÀaÀaÀaÀa¿`¿`¿`¾_¾_¾_¾_¾^½^½^½]½]¼]¼]¼\¼\»\»[»[»[»[ºZºZºZ¹Y¹Y¹Y¹Y¹Y¸X¸X¸X·W·W·W·W·V¶V¶V¶UµUµUµUµTµT´T´S´S´S´S³~R³~R³~R²}Q²}Q²}Q²|Q²|Q±|P±|P±{P°{O°{O°zO°zO°zN¯zN¯yN¯yM®yM®xM®xL®xL®xL­wL­wK­wK¬vK¬vJ¬vJ¬vJ¬uJ«uI«uI«tI«tIªtHªtHªsHªsH©sG©rG©rG©rF©rF¨qF¨qF¨qE§pE§pE§pD§oD§oD¦oD¦oC¦nC¥nC¥nB¥mB¥mB¥mB¤mA¤lA¤lA£l@£k@£k@£k@£k@¢j?¢j?¢j?¢i>¡i>¡i>¡i>¡h= h= h= g< g<g<g<f;f;f;e:e:e:d9d9d9d9c8c8c8b8b8b7b7a7a6a6`6`5`5`5_5_4_4^4^3^3^3]3]2]2\2\1\1\1[1[0[0Z0Z0Z/Y/Y/Y/Y.X.X.X-W-W-W-W,V,V,V+U+U+U+U*T*T*T)S)S)S)S(R(R(R(Q'Q'Q'Q'P&P&P&O%O%O%N$N$N$N$M#M#M#L"L"L"L"K!K!K!J J J J J J J J J J J J J J J J J J J J J J J J J J ÍoÍoÍoÍoÍoÍoÍoÌoËtÆ¼­ËÁ´Ò¾¨Ó»¤Ð°Ì uËnËmËmËmÊmÊlÊlÉlÉlÉkÉkÉkÈjÈjÈjÈjÇiÇiÇiÇiÇiÆhÆhÆhÆgÆgÅgÅgÅfÄfÄfÄeÄeÄeÃeÃdÃdÂdÂcÂcÂcÂcÁbÁbÁbÀaÀaÀaÀaÀa¿`¿`¿`¿`¾_¾_¾_¾^½^½^½]½]½]¼]¼\¼\»\»[»[»[»[ºZºZºZ¹Y¹Y¹Y¹Y¹Y¸X¸X¸X·W·W·W·W·V¶V¶V¶U¶UµUµUµTµT´T´S´S´S´S³~R³~R³~R²}Q²}Q²}Q²}Q²|Q±|P±|P±{P°{O°{O°{O°zO°zN¯zN¯yN¯yM®yM®yM®xM®xL®xL­wL­wK­wK¬vK¬vK¬vJ¬vJ¬uJ«uI«uI«tI«tI«tIªtHªsHªsH©sG©rG©rG©rG©rF¨qF¨qF¨qE§pE§pE§pD§pD§oD¦oD¦oC¦nC¥nC¥nB¥nB¥mB¥mB¤mA¤lA¤lA£l@£k@£k@£k@£k@¢j?¢j?¢j?¢i>¡i>¡i>¡i>¡h= h= h= g< g< g<g<f;f;f;e:e:e:e:d9d9d9c8c8c8c8b8b7b7a7a6a6`6`6`5`5_5_4_4^4^3^3^3]3]2]2\2\1\1\1[1[0[0Z0Z0Z/Z/Y/Y/Y.X.X.X-X-W-W-W,V,V,V+U+U+U+U*T*T*T)S)S)S)S(R(R(R(Q'Q'Q'Q'P&P&P&O%O%O%O%N$N$N$M#M#M#L"L"L"L"K!K!K!J J J J J J J J J J J J J J J J J J J J J J J J J J ÍpÍpÍpÍpÍpÍpÍpÍpÍpÍoÍoÌoÌoÌoÌnËnËnËmËmËmÊmÊlÊlÉlÉlÉkÉkÉkÈjÈjÈjÈjÇiÇiÇiÇiÆhÆhÆhÆhÆgÅgÅgÅfÅfÄfÄfÄeÄeÃeÃdÃdÃdÂdÂcÂcÂcÁbÁbÁbÁbÀaÀaÀaÀa¿`¿`¿`¿`¾_¾_¾_¾^½^½^½^½]½]¼]¼\¼\¼\»\»[»[»[ºZºZºZºZ¹Y¹Y¹Y¹Y¸X¸X¸X¸X·W·W·W·V¶V¶V¶V¶UµUµUµTµT´T´S´S´S´S³~R³~R³~R²}Q²}Q²}Q²}Q²|Q±|P±|P±{P°{O°{O°{O°zO°zN¯zN¯yN¯yM¯yM®yM®xM®xL®xL­wL­wK­wK­wK¬vK¬vJ¬vJ¬uJ«uI«uI«tI«tI«tIªtHªsHªsH©sG©rG©rG©rG©rF¨qF¨qF¨qE§pE§pE§pE§pD§oD¦oD¦oC¦nC¥nC¥nB¥nB¥mB¥mB¤mA¤lA¤lA£l@£l@£k@£k@£k@¢j?¢j?¢j?¢i>¢i>¡i>¡i>¡h= h= h= g< g< g<g<f;f;f;e:e:e:e:d9d9d9c8c8c8c8b8b7b7a7a6a6a6`6`5`5_5_4_4^4^4^3^3]3]2]2\2\1\1\1[1[0[0Z0Z0Z0Z/Y/Y/Y.X.X.X-X-W-W-W,V,V,V+U+U+U+U*T*T*T)S)S)S)S(R(R(R(Q'Q'Q'Q'P&P&P&O%O%O%O%N$N$N$M#M#M#M#L"L"L"K!K!K!J J J J J J J J J J J J J J J J J J J J J J J J J J ÎqÎqÎqÎqÎqÎqÎqÍpÍpÍpÍpÍoÌoÌoÌoÌnËnËnËmËmËmÊmÊlÊlÉlÉkÉkÉkÉkÈjÈjÈjÇiÇiÇiÇiÇiÆhÆhÆhÆgÅgÅgÅgÅfÄfÄfÄeÄeÃeÃeÃdÃdÂdÂcÂcÂcÁbÁbÁbÁbÀaÀaÀaÀaÀa¿`¿`¿`¾_¾_¾_¾^¾^½^½^½]½]¼]¼\¼\¼\»\»[»[»[ºZºZºZºZ¹Y¹Y¹Y¹Y¸X¸X¸X¸X·W·W·W·V¶V¶V¶V¶UµUµUµTµT´T´T´S´S´S³~R³~R³~R²}Q²}Q²}Q²}Q²|Q±|P±|P±{P±{P°{O°{O°zO°zN¯zN¯yN¯yM¯yM®yM®xM®xL®xL­wL­wK­wK­wK¬vK¬vJ¬vJ¬uJ«uI«uI«uI«tI«tIªtHªsHªsH©sG©rG©rG©rG©rF¨qF¨qF¨qE§pE§pE§pE§pD§oD¦oD¦oC¦nC¥nC¥nC¥nB¥mB¥mB¤mA¤lA¤lA£l@£l@£k@£k@£k@¢j?¢j?¢j?¢j?¢i>¡i>¡i>¡h= h= h= g< g< g<g<f;f;f;e:e:e:e:d9d9d9c8c8c8c8b8b7b7a7a6a6a6`6`5`5_5_4_4^4^4^3^3]3]2]2\2\2\1\1[1[0[0Z0Z0Z0Z/Y/Y/Y.X.X.X-X-W-W-W,V,V,V+V+U+U+U*T*T*T)S)S)S)S(R(R(R(Q'Q'Q'Q'P&P&P&O%O%O%O%N$N$N$M#M#M#M#L"L"L"K!K!K!J J J J J J J J J J J J J J J J J J J J J J J J J J ÎqÎqÏrÏrÏrÎqÎqÎqÍpÍpÍpÍpÍoÌoÌoÌnËnËnËmËmËmÊmÊlÊlÉlÉkÉkÉkÉkÈjÈjÈjÇiÇiÇiÇiÇiÆhÆhÆhÆgÅgÅgÅgÅfÄfÄfÄeÄeÄeÃeÃdÃdÂdÂcÂcÂcÂcÁbÁbÁbÀaÀaÀaÀaÀa¿`¿`¿`¾_¾_¾_¾_¾^½^½^½]½]¼]¼\¼\¼\»\»[»[»[ºZºZºZºZ¹Y¹Y¹Y¹Y¸X¸X¸X¸X·W·W·W·V¶V¶V¶V¶UµUµUµTµT´T´T´S´S´S³~R³~R³~R³~R²}Q²}Q²}Q²|Q±|P±|P±{P±{P°{O°{O°zO°zN¯zN¯yN¯yM¯yM®yM®xM®xL®xL­wL­wK­wK­wK¬vK¬vJ¬vJ¬uJ«uI«uI«uI«tI«tIªtHªsHªsH©sG©rG©rG©rG©rF¨qF¨qF¨qE§pE§pE§pE§pD§oD¦oD¦oC¦nC¥nC¥nC¥nB¥mB¥mB¤mA¤lA¤lA£l@£l@£k@£k@£k@¢j?¢j?¢j?¢j?¢i>¡i>¡i>¡h= h= h= g< g< g<g<f;f;f;e:e:e:e:d9d9d9c8c8c8c8b8b7b7a7a6a6a6`6`5`5_5_4_4^4^4^3^3]3]2]2\2\2\1\1[1[0[0Z0Z0Z0Z/Y/Y/Y.X.X.X-X-W-W-W,V,V,V+V+U+U+U*T*T*T)S)S)S)S(R(R(R(Q'Q'Q'Q'P&P&P&O%O%O%O%N$N$N$M#M#M#M#L"L"L"K!K!K!K!J J J J J J J J J J J J J J J J J J J J J J J J J ÎqÎqÎqÎqÎqÎqÎqÍpÍpÍpÍpÍoÌoÌoÌoÌnËnËnËmËmËmÊmÊlÊlÉlÉkÉkÉkÉkÈjÈjÈjÇiÇiÇiÇiÇiÆhÆhÆhÆgÅgÅgÅgÅfÄfÄfÄeÄeÃeÃeÃdÃdÂdÂcÂcÂcÁbÁbÁbÁbÀaÀaÀaÀaÀa¿`¿`¿`¾_¾_¾_¾^¾^½^½^½]½]¼]¼\¼\¼\»\»[»[»[ºZºZºZºZ¹Y¹Y¹Y¹Y¸X¸X¸X¸X·W·W·W·V¶V¶V¶V¶UµUµUµTµT´T´T´S´S´S³~R³~R³~R²}Q²}Q²}Q²}Q²|Q±|P±|P±{P±{P°{O°{O°zO°zN¯zN¯yN¯yM¯yM®yM®xM®xL®xL­wL­wK­wK­wK¬vK¬vJ¬vJ¬uJ«uI«uI«uI«tI«tIªtHªsHªsH©sG©rG©rG©rG©rF¨qF¨qF¨qE§pE§pE§pE§pD§oD¦oD¦oC¦nC¥nC¥nC¥nB¥mB¥mB¤mA¤lA¤lA£l@£l@£k@£k@£k@¢j?¢j?¢j?¢j?¢i>¡i>¡i>¡h= h= h= g< g< g<g<f;f;f;e:e:e:e:d9d9d9c8c8c8c8b8b7b7a7a6a6a6`6`5`5_5_4_4^4^4^3^3]3]2]2\2\2\1\1[1[0[0Z0Z0Z0Z/Y/Y/Y.X.X.X-X-W-W-W,V,V,V+V+U+U+U*T*T*T)S)S)S)S(R(R(R(Q'Q'Q'Q'P&P&P&O%O%O%O%N$N$N$M#M#M#M#L"L"L"K!K!K!J J J J J J J J J J J J J J J J J J J J J J J J J J ÍpÍpÍpÍpÍpÍpÍpÍpÍpÍoÍoÌoÌoÌoÌnËnËnËmËmËmÊmÊlÊlÉlÉlÉkÉkÉkÈjÈjÈjÈjÇiÇiÇiÇiÆhÆhÆhÆhÆgÅgÅgÅfÅfÄfÄfÄeÄeÃeÃdÃdÃdÂdÂcÂcÂcÁbÁbÁbÁbÀaÀaÀaÀa¿`¿`¿`¿`¾_¾_¾_¾^½^½^½^½]½]¼]¼\¼\¼\»\»[»[»[ºZºZºZºZ¹Y¹Y¹Y¹Y¸X¸X¸X¸X·W·W·W·V¶V¶V¶V¶UµUµUµTµT´T´S´S´S´S³~R³~R³~R²}Q²}Q²}Q²}Q²|Q±|P±|P±{P°{O°{O°{O°zO°zN¯zN¯yN¯yM¯yM®yM®xM®xL®xL­wL­wK­wK­wK¬vK¬vJ¬vJ¬uJ«uI«uI«tI«tI«tIªtHªsHªsH©sG©rG©rG©rG©rF¨qF¨qF¨qE§pE§pE§pE§pD§oD¦oD¦oC¦nC¥nC¥nB¥nB¥mB¥mB¤mA¤lA¤lA£l@£l@£k@£k@£k@¢j?¢j?¢j?¢i>¢i>¡i>¡i>¡h= h= h= g< g< g<g<f;f;f;e:e:e:e:d9d9d9c8c8c8c8b8b7b7a7a6a6a6`6`5`5_5_4_4^4^4^3^3]3]2]2\2\1\1\1[1[0[0Z0Z0Z0Z/Y/Y/Y.X.X.X-X-W-W-W,V,V,V+U+U+U+U*T*T*T)S)S)S)S(R(R(R(Q'Q'Q'Q'P&P&P&O%O%O%O%N$N$N$M#M#M#M#L"L"L"K!K!K!J J J J J J J J J J J J J J J J J J J J J J J J J J 
\ No newline at end of file
+BM6,     6   (   @  <           ,              ÿêÿþéÿýéÿ ýéÿüéÿ ûèÿ ûéÿúèÿ ùçÿ ùçÿøçÿ ÷æÿöæÿõæÿõæÿõæÿóåÿóåÿòåÿñäÿðäÿðäÿïãÿîãÿîâÿíãÿìãÿëâÿëáÿëáÿéáÿèáÿèàÿèàÿçßÿæßÿåßÿåßÿäÞÿãÞÿãÞÿâÝÿáÞÿàÝÿàÝÿßÝÿÞÜÿÞÛÿÝÜÿÜÛÿÛÛÿÚÛÿÚÚÿÙÚÿØÚÿ×Úÿ×Ùÿ×ÙÿÖÙÿÕÙÿÔØÿÔØÿÒØÿÒ×ÿÒ×ÿÑ×ÿÐÖÿÐÖÿÎÖÿÎÖÿÍÕÿÌÕÿËÔÿÊÕÿËÔÿÊÔÿÉÓÿÈÓÿÇÓÿÇÒÿÅÒÿÅÑÿÅÑÿÄÑÿÃÐÿÂÐÿÂÐÿÁÐÿÀÐÿ¿Ïÿ¾Ïÿ¾Ïÿ¾Îÿ½Îÿ¼Îÿ»Íÿ»ÍÿºÍÿ¹Íÿ¸Ìÿ¸Ìÿ·Ìÿ¶ËÿµËÿ´Ëÿ´Ëÿ´Êÿ²Êÿ²Êÿ±Éÿ±Éÿ¯Éÿ¯Èÿ®Èÿ®Èÿ­Çÿ¬Çÿ«Æÿ«ÆÿªÆÿ©Æÿ¨Æÿ¨Åÿ§Åÿ¦Åÿ	¦Äÿ¥Äÿ¤Äÿ	£Äÿ	£Ãÿ	¢Ãÿ¡Ãÿ	¡Âÿ	 Âÿ	 Âÿ	Áÿ	Âÿ
+Áÿ
+Àÿ	Áÿ	Àÿ	¿ÿ	¿ÿ
+¿ÿ
+¿ÿ	¿ÿ
+¾ÿ
+¾ÿ
+¾ÿ
+¾ÿ
+½ÿ
+½ÿ
+¼ÿ
+¼ÿ¼ÿ»ÿ
+»ÿ
+»ÿ
+ºÿ
+ºÿºÿºÿ¹ÿºÿ¸ÿ¸ÿ¸ÿ·ÿ¸ÿ·ÿ·ÿ¶ÿ¶ÿ¶ÿµÿµÿ¶ÿµÿ´ÿ´ÿ~´ÿ~³ÿ}³ÿ|³ÿ|²ÿ{³ÿz²ÿy²ÿx²ÿx²ÿw±ÿv±ÿv°ÿu°ÿt°ÿt¯ÿs¯ÿr¯ÿr®ÿq®ÿp®ÿo­ÿn®ÿn­ÿm­ÿm­ÿl­ÿk«ÿj«ÿj¬ÿi«ÿh«ÿhªÿgªÿgªÿe©ÿeªÿe¨ÿc¨ÿb¨ÿb¨ÿa§ÿ`§ÿ_§ÿ_§ÿ^¦ÿ^¦ÿ]¦ÿ\¥ÿ\¥ÿZ¥ÿZ¤ÿY¥ÿX¤ÿX¤ÿW£ÿW£ÿV£ÿU£ÿT£ÿT¢ÿR¡ÿS¢ÿQ¡ÿQ¡ÿP¡ÿP ÿN ÿN ÿMÿLÿLÿKÿJÿJÿIÿHÿHÿGÿFÿEÿDÿDÿCÿBÿBÿAÿAÿ@ÿ?ÿ>ÿ>ÿ=ÿ<ÿ;ÿ;ÿ:ÿ9ÿ8ÿ8ÿ7ÿ6ÿ6ÿ5ÿ5ÿ3ÿ3ÿ2ÿ2ÿ1ÿ/ÿ/ÿ/ÿ.ÿ.ÿ-ÿ,ÿ+ÿ*ÿ*ÿ)ÿ(ÿ'ÿ&ÿ&ÿ%ÿ$ÿ$ÿ#ÿ"ÿ!ÿ!ÿ!ÿÿÿÿÿÿÿÿ ÿêÿ ÿêÿ ýêÿ ýéÿ üéÿ ûèÿ úèÿúèÿ ùèÿ øçÿøçÿ ÷çÿ÷æÿöæÿ õåÿôæÿóæÿóåÿòåÿñäÿðäÿðãÿïäÿîãÿîãÿíãÿìâÿìâÿëâÿëáÿéáÿéáÿéàÿèáÿçßÿæàÿåßÿåßÿäÞÿãÞÿâÞÿáÞÿáÝÿàÝÿàÝÿßÜÿÞÜÿÝÜÿÝÛÿÜÛÿÜÛÿÚÛÿÚÚÿÚÚÿÙÚÿ×Ùÿ×Ùÿ×ÙÿÖÙÿÕÙÿÔØÿÔØÿÓØÿÒ×ÿÑÖÿÑ×ÿÐ×ÿÏÖÿÎÕÿÍÕÿÍÕÿÍÕÿËÔÿËÔÿÊÔÿÊÓÿÈÓÿÈÓÿÇÒÿÆÓÿÆÒÿÆÒÿÄÑÿÄÑÿÃÑÿÃÑÿÁÐÿÁÐÿÀÐÿ¿Ðÿ¿Ïÿ¾Ïÿ½Ïÿ¼Îÿ¼Íÿ»Íÿ»ÍÿºÍÿ¹Ìÿ¸Ìÿ¸Ìÿ·Ìÿ¶ÌÿµËÿµËÿ´Ëÿ³Êÿ³Êÿ²Êÿ±Éÿ±Éÿ°Éÿ¯Èÿ®Èÿ®Èÿ­Çÿ¬Çÿ«Çÿ«ÆÿªÆÿ©Æÿ¨Æÿ¨Åÿ	§Åÿ§Åÿ¦Åÿ¥Äÿ	¤Äÿ	£Äÿ£Ãÿ	¢Ãÿ	¡Ãÿ	¡Ãÿ Âÿ	Âÿ	Áÿ	Áÿ	Áÿ	Áÿ
+Áÿ	Àÿ
+Àÿ	Àÿ	¿ÿ
+¾ÿ
+¿ÿ
+¾ÿ
+¾ÿ
+¾ÿ
+¾ÿ
+½ÿ
+¼ÿ
+½ÿ
+¼ÿ¼ÿ
+¼ÿ
+¼ÿ»ÿ»ÿ
+ºÿ
+ºÿ¹ÿ¹ÿ¹ÿ¹ÿ¹ÿ¸ÿ¸ÿ¸ÿ¸ÿ·ÿ¶ÿ¶ÿ¶ÿ¶ÿµÿµÿµÿ´ÿ´ÿ´ÿ~´ÿ}³ÿ|³ÿ{³ÿ{²ÿz²ÿy²ÿy²ÿy±ÿw±ÿw±ÿv°ÿu°ÿt°ÿt°ÿs¯ÿs®ÿq®ÿp®ÿp®ÿp®ÿo®ÿn­ÿm­ÿm­ÿl¬ÿk¬ÿj«ÿj«ÿi«ÿh«ÿhªÿgªÿf©ÿfªÿe©ÿd©ÿc©ÿc¨ÿb¨ÿa§ÿ`§ÿ`§ÿ_§ÿ_§ÿ^¦ÿ]¦ÿ\¦ÿ\¥ÿ[¥ÿZ¥ÿY¤ÿY¤ÿX¤ÿW£ÿW£ÿV£ÿU¢ÿT¢ÿT¢ÿS¡ÿR¢ÿQ¡ÿQ ÿP ÿO ÿN ÿNÿMÿLÿLÿKÿKÿIÿIÿHÿGÿGÿFÿFÿDÿDÿCÿBÿBÿAÿAÿ?ÿ>ÿ>ÿ=ÿ=ÿ<ÿ<ÿ;ÿ:ÿ9ÿ8ÿ8ÿ8ÿ6ÿ5ÿ5ÿ4ÿ3ÿ3ÿ2ÿ1ÿ1ÿ0ÿ/ÿ/ÿ-ÿ-ÿ,ÿ,ÿ+ÿ*ÿ)ÿ(ÿ(ÿ'ÿ'ÿ&ÿ%ÿ%ÿ#ÿ#ÿ#ÿ"ÿ!ÿ ÿ ÿÿÿÿÿÿÿ ÿêÿ ÿêÿ þêÿýéÿ üéÿ ûèÿ úèÿ úèÿ úèÿ øèÿøçÿ ÷çÿöçÿöæÿõæÿôæÿôåÿóäÿòäÿñäÿñäÿðäÿðäÿïãÿîãÿíãÿìâÿëâÿëáÿêáÿéáÿéàÿéáÿèàÿçßÿæßÿæßÿäßÿäÞÿãÞÿãÞÿáÞÿáÞÿáÝÿàÜÿßÜÿÞÝÿÝÜÿÜÜÿÜÜÿÛÛÿÚÛÿÚÛÿÚÚÿÙÚÿØÙÿ×ÚÿÖÙÿÕÙÿÕØÿÔØÿÓØÿÓØÿÒ×ÿÒ×ÿÐ×ÿÐ×ÿÐÖÿÎÖÿÎÖÿÍÕÿÍÕÿÌÔÿÊÔÿËÔÿÉÓÿÉÓÿÈÓÿÈÒÿÆÒÿÆÒÿÆÒÿÅÑÿÄÑÿÃÑÿÂÐÿÂÐÿÁÐÿÀÐÿÀÏÿ¿Ïÿ¾Îÿ½Îÿ½Îÿ¼Îÿ¼ÎÿºÍÿºÍÿ¹Íÿ¸Ìÿ·Ìÿ·Ìÿ¶Ìÿ¶ËÿµËÿ´Ëÿ´Êÿ²Êÿ²Êÿ±Éÿ±Éÿ°Éÿ¯Éÿ®Éÿ®Çÿ­Çÿ¬Çÿ¬Çÿ«ÆÿªÆÿ©Æÿ	©Æÿ¨Åÿ¨Åÿ	¦Åÿ	¦Åÿ¥Åÿ	¤Äÿ£Äÿ£Äÿ	¢Ãÿ	¢Ãÿ	¡Âÿ¡Âÿ	 Áÿ	Áÿ	Áÿ	Áÿ	Áÿ	Áÿ
+Àÿ	Àÿ	Àÿ	¿ÿ	¿ÿ
+¾ÿ
+¾ÿ
+¾ÿ
+½ÿ
+½ÿ
+½ÿ
+¼ÿ
+½ÿ
+¼ÿ
+»ÿ
+¼ÿ
+¼ÿ»ÿ
+ºÿ»ÿ
+ºÿ
+¹ÿºÿ¹ÿ¹ÿ¹ÿ¸ÿ¸ÿ¸ÿ·ÿ·ÿ·ÿ·ÿ¶ÿ¶ÿ¶ÿµÿµÿµÿµÿ´ÿ}³ÿ}³ÿ|³ÿ{³ÿ{³ÿz²ÿy²ÿx±ÿx±ÿw±ÿv±ÿv°ÿu°ÿt°ÿt°ÿs¯ÿr¯ÿr¯ÿq®ÿp®ÿp®ÿn­ÿn­ÿm­ÿm¬ÿl¬ÿk¬ÿj¬ÿj¬ÿi«ÿh«ÿhªÿgªÿgªÿeªÿe©ÿd©ÿc¨ÿb¨ÿb¨ÿa§ÿa¨ÿ`§ÿ_§ÿ_¦ÿ]¦ÿ]¥ÿ\¥ÿ\¦ÿ[¥ÿZ¤ÿY¥ÿY¤ÿX¤ÿW£ÿV£ÿV£ÿU£ÿU¢ÿT¢ÿS¡ÿR¡ÿR¡ÿQ¡ÿP ÿP ÿO ÿN ÿMÿLÿKÿKÿKÿJÿIÿHÿHÿFÿFÿEÿDÿDÿCÿBÿBÿAÿ@ÿ?ÿ?ÿ>ÿ>ÿ=ÿ<ÿ<ÿ;ÿ:ÿ9ÿ9ÿ8ÿ7ÿ6ÿ6ÿ5ÿ4ÿ3ÿ3ÿ2ÿ1ÿ1ÿ0ÿ0ÿ.ÿ.ÿ-ÿ-ÿ+ÿ+ÿ*ÿ*ÿ)ÿ(ÿ'ÿ'ÿ&ÿ&ÿ%ÿ$ÿ#ÿ"ÿ"ÿ!ÿ ÿÿÿÿÿÿÿÿg	 ÿg
+ ÿg
+ ÿg	 ÿg	ÿg	 ÿg
+ ÿg
+ ÿg	ÿg	 ÿg	 ÿg	 ÿg	ÿg	ÿg	 ÿg	 ÿg	 ÿg
+ ÿg	ÿg	 ÿg	 ÿg	 ÿg	 ÿg	 ÿg	ÿg	ÿg	 ÿg	 ÿg
+ ÿg	 ÿg	 ÿg	ÿg	ÿg	 ÿg	 ÿg	 ÿg	 ÿg
+ ÿg
+ ÿg	ÿg	ÿg	 ÿg
+ ÿg	 ÿg
+ ÿg	 ÿg	 ÿg	 ÿg	ÿg	ÿg	 ÿg	 ÿg	 ÿg	 ÿg	 ÿg	 ÿg
+ ÿg	 ÿg	ÿg
+ÿg
+ ÿg	 ÿg
+ ÿg
+ ÿg	 ÿg
+ ÿg
+ ÿgÿhÿi	ÿgÿhÿhÿgÿhÿhÿhÿhÿhÿiÿiÿh
+ÿhÿiÿiÿhÿiÿhÿiÿiÿjÿjÿjÿjÿiÿiÿjÿjÿiÿiÿjÿjÿl!ÿl"ÿl# ÿj"ÿk"ÿj#ÿk$ÿk%ÿj$ÿj%ÿk%ÿk&ÿm)'ÿl)'ÿm*'ÿk("ÿk)#ÿl)#ÿl*$ÿl+$ÿl+%ÿk,%ÿl-%ÿl-'ÿn1.ÿn1/ÿn20ÿl0)ÿl0*ÿl1*ÿl1+ÿl3,ÿm3-ÿm4-ÿm5.ÿm5/ÿl6/ÿp97ÿp:8ÿo:8ÿm72ÿm72ÿn84ÿm94ÿn95ÿm;6ÿm;7ÿm<7ÿm<7ÿn<7ÿqA?ÿqB@ÿqC@ÿn?;ÿn@;ÿn@<ÿnA=ÿnB=ÿnC>ÿoC?ÿoD?ÿoD@ÿoE@ÿsJHÿrKIÿsKIÿoHCÿoHDÿoIDÿoJEÿoJFÿoJFÿoKGÿoKHÿoKIÿoLJÿtQQÿtRQÿtSRÿoOKÿoOLÿoPMÿoPNÿpQNÿoROÿoSOÿpSPÿpTQÿpUQÿuZYÿuZZÿu\ZÿpWUÿpXUÿpXUÿpYVÿqYVÿqZXÿqZXÿq[Yÿq\Zÿwaaÿwbbÿwccÿq^\ÿr^]ÿr_]ÿq`^ÿq`^ÿra^ÿqa_ÿrbaÿrcaÿxiiÿxjiÿxkjÿredÿrfeÿrfeÿrgfÿrhfÿrhgÿsihÿsihÿrkiÿyqpÿzqqÿzrrÿsmlÿsnmÿsnmÿsonÿsonÿtooÿspoÿsppÿsqqÿ{yzÿzyzÿtssÿttsÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿ{{|ÿ{{|ÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿ|||ÿ|||ÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿ|||ÿ|||ÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿ|||ÿ|||ÿtttÿtttÿtttÿtttÿtttÿtttÿ|||ÿqqqÿgggÿkkkÿoooÿrrrÿsssÿ|||ÿ|||ÿtttÿtttÿtttÿtttÿtttÿ|||ÿtttÿtttÿtttÿtttÿ|||ÿ|||ÿtttÿtttÿtttÿ|||ÿtttÿtttÿtttÿ|||ÿtttÿtttÿtttÿtttÿg
+ ÿg	 ÿg
+ ÿg	ÿg	 ÿg	 ÿg	ÿg
+ ÿg
+ ÿg	ÿg	ÿg	ÿg	 ÿg	 ÿg	ÿg	ÿg	ÿg	 ÿg	 ÿg
+ ÿg	ÿg	ÿg
+ÿg	 ÿg	 ÿd ÿ` ÿbÿdÿg
+ÿg	 ÿg	 ÿg	 ÿg
+ ÿg	ÿg
+ÿg	ÿg
+ÿg
+ ÿg
+ ÿg	 ÿg	 ÿg	ÿg
+ÿg
+ÿg
+ÿg	ÿg
+ ÿg
+ ÿg	 ÿg	 ÿg	ÿg	ÿg	ÿg	ÿg
+ÿg
+ ÿg	 ÿg	 ÿg	 ÿg	 ÿg	ÿg
+ÿg	ÿg
+ÿh
+ÿg
+ ÿg
+ ÿgÿgÿgÿgÿhÿiÿiÿhÿiÿhÿhÿh	ÿh	ÿi
+ÿiÿiÿiÿjÿiÿjÿiÿiÿiÿiÿiÿiÿjÿkÿjÿkÿkÿk ÿjÿj ÿjÿj ÿk!ÿj!ÿl$!ÿm%"ÿm%"ÿm'#ÿm'$ÿl(%ÿm(&ÿk&ÿk&ÿk'!ÿk("ÿk)"ÿk)#ÿm-)ÿm-*ÿn.*ÿn.+ÿm/-ÿm0-ÿl-&ÿl.(ÿl/'ÿl0)ÿl0)ÿl1*ÿo41ÿp52ÿp53ÿo64ÿp74ÿp75ÿp86ÿm5/ÿm71ÿl71ÿm72ÿm72ÿn73ÿp<;ÿq=<ÿq><ÿq>=ÿq?=ÿq?>ÿn<7ÿn<7ÿn=8ÿn>9ÿn?9ÿn?:ÿo@;ÿqDCÿrECÿqFDÿrFDÿqGFÿrGFÿnD@ÿoEAÿoFAÿoFAÿoGBÿoHCÿoHDÿsLLÿsNLÿsNMÿsOMÿsOOÿtPOÿoLIÿoLIÿoMJÿoMJÿoNJÿoNKÿtTRÿtUSÿtUTÿtWUÿuWVÿtXVÿtYWÿpSQÿpTQÿpURÿpVRÿpVSÿpVTÿv]\ÿv]]ÿv^]ÿv_]ÿv__ÿv``ÿp[Yÿq\Zÿq][ÿq][ÿq]\ÿq]\ÿwddÿwedÿweeÿxffÿwggÿxggÿxhgÿrcaÿrcbÿrdcÿrecÿsedÿreeÿxllÿxmmÿxnmÿxonÿyooÿxopÿrjiÿsjjÿskjÿslkÿsllÿzstÿzttÿztuÿ{uvÿ{vwÿzvwÿtqpÿtppÿtrqÿtrrÿtssÿttsÿ{{|ÿ{{|ÿ{{|ÿ{{|ÿ{{|ÿtttÿtttÿtttÿtttÿtttÿtttÿ{{|ÿ{{|ÿ{{|ÿ{||ÿ|||ÿtttÿtttÿtttÿtttÿtttÿ|||ÿ|||ÿ|||ÿ|||ÿ|||ÿtttÿtttÿtttÿtttÿ|||ÿ|||ÿ|||ÿ|||ÿ|||ÿtttÿtttÿtttÿtttÿ|||ÿ|||ÿ|||ÿ|||ÿtttÿsssÿgggÿgggÿmmmÿmmmÿmmmÿoooÿsssÿtttÿtttÿ|||ÿ|||ÿ|||ÿtttÿtttÿtttÿ|||ÿ|||ÿ|||ÿtttÿtttÿ|||ÿ|||ÿ|||ÿtttÿtttÿ|||ÿtttÿtttÿ|||ÿtttÿtttÿtttÿg	 ÿg	 ÿg	ÿg	 ÿg	ÿg
+ÿg	 ÿg	ÿg	ÿg
+ ÿg	 ÿg
+ ÿg
+ÿg	ÿg	 ÿg	 ÿg
+ ÿg	ÿg	ÿg	ÿg
+ ÿg
+ ÿg	 ÿfÿbÿ\ÿgÿ`
+ÿd ÿg	 ÿg
+ÿg	ÿg	ÿg
+ÿg
+ ÿg
+ ÿg	 ÿg	 ÿg	ÿg	ÿg	ÿg	ÿg	 ÿg	 ÿg	 ÿg	 ÿg
+ ÿg	ÿg	ÿg
+ÿg	ÿg
+ ÿg	 ÿg	 ÿg	 ÿg
+ ÿg
+ÿg	ÿg	ÿg
+ÿg	ÿg	 ÿg	 ÿg	 ÿg	 ÿg
+ ÿhÿhÿh	ÿh	ÿh
+ÿh
+ÿhÿgÿgÿgÿhÿiÿiÿiÿiÿiÿiÿhÿhÿiÿiÿiÿiÿjÿiÿjÿjÿjÿjÿjÿjÿiÿjÿjÿk!ÿl!ÿl"ÿl"ÿl# ÿl$!ÿj#ÿk"ÿj#ÿk$ÿj$ÿk%ÿk%ÿm)&ÿm)'ÿm*'ÿm+'ÿm+(ÿm,(ÿk)#ÿl*$ÿl*$ÿk+%ÿk,%ÿl-&ÿn0-ÿn1.ÿn2/ÿn20ÿn30ÿn31ÿl1+ÿl2+ÿm3,ÿl3-ÿl3-ÿm5.ÿl5/ÿo96ÿp:7ÿp:8ÿp:9ÿp;9ÿq;:ÿm93ÿn94ÿm95ÿm:6ÿm;6ÿm<7ÿp@=ÿqA>ÿqA?ÿqB@ÿqCAÿqDAÿrDBÿoA<ÿoA<ÿnB=ÿoC=ÿnC?ÿnC?ÿsHGÿsIGÿsIHÿrJHÿsJJÿsLJÿsLJÿoIEÿoIFÿoJFÿoJGÿoJGÿoJHÿtQOÿtQPÿtRRÿtRQÿtSRÿuTRÿpOLÿpPMÿpPMÿoQNÿpQNÿoROÿoSPÿuYXÿuYXÿtZZÿu[Zÿu\[ÿu\[ÿpXUÿpYUÿqYVÿqZWÿq[Xÿq[Xÿva`ÿwaaÿwbbÿwbbÿwccÿxcdÿq^]ÿq^]ÿr_]ÿra^ÿqa_ÿra`ÿqb`ÿxihÿxjiÿxjjÿxkjÿxkkÿxlkÿrgeÿrhfÿshgÿrhgÿrihÿriiÿyppÿyqqÿzrrÿzrrÿzssÿsnmÿsnmÿsonÿsooÿtooÿspoÿ{xxÿzxxÿ{yzÿzyzÿ{z{ÿ{z|ÿtttÿtttÿtttÿtttÿtttÿ{{|ÿ{{|ÿ{{|ÿ{{|ÿ{{|ÿ{{|ÿtttÿtttÿtttÿtttÿtttÿ|||ÿ|||ÿ|||ÿ|||ÿ|||ÿtttÿtttÿtttÿtttÿtttÿ|||ÿ|||ÿ|||ÿ|||ÿtttÿtttÿtttÿtttÿtttÿ|||ÿ|||ÿ|||ÿ|||ÿtttÿrrrÿmmmÿkkkÿwwwÿxxxÿlllÿlllÿdddÿdddÿdddÿnnnÿxxxÿ{{{ÿ|||ÿtttÿtttÿtttÿ|||ÿ|||ÿ|||ÿtttÿtttÿtttÿ|||ÿ|||ÿtttÿtttÿtttÿ|||ÿ|||ÿtttÿ|||ÿ|||ÿtttÿ|||ÿtttÿtttÿg
+ ÿg	 ÿg
+ ÿg	 ÿg	ÿg	 ÿg
+ÿg
+ ÿg	ÿg	 ÿg	ÿg	 ÿg	ÿg	ÿg	 ÿg	ÿg	 ÿg
+ ÿg	ÿg
+ ÿg
+ ÿg
+ÿf	 ÿa ÿ[	ÿjÿ`ÿ_ ÿfÿg	 ÿg	 ÿg	ÿg	ÿg	 ÿg	 ÿg	 ÿg	ÿg
+ ÿg
+ ÿg	ÿg	ÿg	 ÿg
+ ÿg	 ÿg	ÿg
+ ÿg	 ÿg	 ÿg	ÿg	ÿg	 ÿg	 ÿg
+ ÿg
+ÿg	ÿg	 ÿg	 ÿg	 ÿg	ÿg
+ÿg
+ ÿg	 ÿg	 ÿg	ÿg
+ÿg	 ÿg
+ ÿg
+ ÿiÿi	ÿh
+ÿgÿgÿgÿiÿhÿgÿhÿhÿiÿiÿjÿhÿhÿiÿjÿjÿhÿiÿiÿjÿjÿjÿjÿiÿjÿjÿkÿjÿiÿjÿjÿl"ÿl" ÿl# ÿk"ÿj#ÿj#ÿl%#ÿl&$ÿk$ÿk%ÿk%ÿk&ÿm*'ÿm*(ÿm*(ÿk("ÿk(#ÿk)$ÿl*$ÿm.*ÿn.+ÿk,&ÿk-%ÿl-&ÿm1.ÿn2/ÿn20ÿn20ÿl1*ÿl1*ÿl2,ÿo63ÿp63ÿm3-ÿl4.ÿl5/ÿm5/ÿp97ÿo98ÿp:9ÿm73ÿm83ÿn83ÿm94ÿp=<ÿq?<ÿm;6ÿn;7ÿn<7ÿn<7ÿqA?ÿqB@ÿqCAÿn?:ÿn@;ÿnA<ÿnB<ÿrEDÿrGEÿoD>ÿoD?ÿoD@ÿoE@ÿsJHÿsJIÿsKJÿoHCÿoIDÿoIDÿoIEÿsOLÿsOMÿoJHÿoKHÿoKHÿoLIÿtRQÿtSQÿtSSÿoOKÿoOLÿoPMÿpPMÿtWUÿuWVÿpSOÿpSPÿpTQÿuYXÿuZYÿtZYÿv\ZÿpWTÿpWUÿqXUÿv]]ÿw^^ÿqZWÿpZYÿp[Yÿp\Zÿwbaÿvbbÿwbcÿq^]ÿq^]ÿr_]ÿq_]ÿxfgÿxggÿqb`ÿrbaÿrbaÿxjiÿxjiÿxkjÿsedÿrfeÿsgfÿrgfÿxnmÿxnnÿrihÿrihÿrjiÿypqÿzrqÿzrsÿsmlÿsnmÿsnmÿzuuÿzvvÿsooÿtpoÿsppÿ{xxÿ{xyÿzyzÿtssÿtssÿtttÿtttÿ{{|ÿtttÿtttÿtttÿ{{|ÿ{{|ÿ{{|ÿtttÿtttÿtttÿ{{|ÿ{{|ÿtttÿtttÿtttÿ|||ÿ|||ÿtttÿtttÿtttÿ|||ÿ|||ÿtttÿtttÿtttÿ|||ÿ|||ÿtttÿtttÿtttÿ|||ÿtttÿtttÿtttÿ|||ÿ|||ÿtttÿtttÿ¨¨¨ÿÿfffÿ]]]ÿiiiÿfffÿbbbÿbbbÿiiiÿbbbÿbbbÿtttÿzzzÿtttÿtttÿ|||ÿtttÿtttÿ|||ÿtttÿtttÿ|||ÿtttÿ|||ÿ|||ÿtttÿ|||ÿtttÿ|||ÿtttÿ|||ÿtttÿ|||ÿtttÿtttÿtttÿtttÿg	 ÿg	ÿg	 ÿg	ÿg	 ÿg
+ÿg
+ÿg	ÿg
+ ÿg	ÿg	ÿg	ÿg
+ ÿg	 ÿg	ÿg	ÿg	ÿg	ÿg	 ÿg	ÿg
+ÿf	ÿ`ÿ\ÿnÿhÿVÿ`ÿaÿ`ÿ`ÿ_	 ÿ_	 ÿ_	ÿ`	ÿ`	ÿbÿcÿd	ÿf ÿg	 ÿg
+ ÿg	ÿg
+ÿg	ÿg	ÿg	ÿg	ÿg	 ÿg	 ÿg	 ÿg	ÿg	ÿg	ÿg	ÿg	ÿg
+ÿg
+ ÿg	 ÿg	 ÿg
+ÿg	ÿg	ÿg	ÿg
+ÿh
+ÿhÿhÿgÿgÿgÿh
+ÿhÿiÿiÿhÿhÿiÿhÿh	ÿh
+ÿi
+ÿiÿiÿjÿiÿjÿjÿjÿjÿiÿiÿiÿjÿjÿkÿkÿkÿk ÿk ÿk!ÿl!ÿj ÿj!ÿj!ÿl# ÿl$!ÿl%"ÿl&"ÿl&#ÿm'$ÿl'%ÿm(&ÿm)&ÿk& ÿk' ÿk(!ÿm+(ÿm+)ÿm-)ÿn-*ÿm.*ÿm.+ÿn/,ÿn/-ÿm0-ÿl.'ÿl.(ÿl/(ÿl0)ÿn31ÿo42ÿo42ÿo53ÿp64ÿp74ÿp75ÿo86ÿo96ÿm60ÿm71ÿm72ÿm72ÿp;:ÿq<:ÿq=;ÿp><ÿp><ÿp?=ÿp?=ÿq@>ÿqA>ÿn>8ÿn>9ÿn?:ÿn?:ÿqDBÿqDBÿrECÿqFDÿrGEÿrGEÿrGFÿsIFÿoE@ÿoFAÿoFAÿoGBÿsKJÿtLKÿtLLÿtNLÿsNMÿsOMÿsONÿsPOÿtQPÿoMJÿoMJÿoMJÿoNKÿtTSÿtUSÿuUTÿtVTÿuVUÿtWVÿuWWÿtXWÿuYWÿoTQÿpURÿpVSÿpVTÿu\[ÿu\\ÿw]\ÿv]]ÿv^^ÿw`_ÿv__ÿwa`ÿwaaÿq]Zÿq][ÿq][ÿwddÿwddÿweeÿweeÿxfgÿxfgÿwggÿwhgÿxihÿrcbÿrdbÿqecÿxkkÿxlkÿxllÿxmlÿynmÿxnnÿyonÿypoÿyppÿrjjÿslkÿslkÿzssÿzstÿzttÿ{uvÿzuuÿzvwÿzvwÿzxxÿtqqÿtqqÿtrrÿtssÿ{{|ÿ{{|ÿ{{|ÿ{{|ÿ{{|ÿ{{|ÿ{{|ÿtttÿtttÿtttÿtttÿ{{|ÿ{{|ÿ{{|ÿ{{|ÿ{||ÿ|||ÿ|||ÿtttÿtttÿtttÿ|||ÿ|||ÿ|||ÿ|||ÿ|||ÿ|||ÿtttÿtttÿtttÿ|||ÿ|||ÿ|||ÿ|||ÿ|||ÿ|||ÿtttÿtttÿtttÿ|||ÿ~~~ÿ¿¿¿ÿÛÛÛÿÑÑÑÿÿMMMÿMMMÿaaaÿgggÿgggÿgggÿhhhÿhhhÿpppÿ|||ÿ|||ÿ|||ÿ|||ÿ|||ÿtttÿ|||ÿ|||ÿ|||ÿ|||ÿtttÿtttÿ|||ÿ|||ÿ|||ÿtttÿ|||ÿ|||ÿ|||ÿtttÿ|||ÿtttÿ|||ÿtttÿg	 ÿg	 ÿg	 ÿg	 ÿg	ÿg	 ÿg	ÿg	 ÿg	ÿg	 ÿg
+ÿg	 ÿg	ÿg
+ÿg	 ÿg
+ÿg
+ ÿg	 ÿfÿe ÿc ÿ[ÿZÿrÿrÿMÿP ÿT ÿRÿQ ÿP ÿOÿOÿO ÿP ÿQÿSÿU ÿX ÿ\ÿ`	ÿc	ÿf	 ÿg	 ÿg	ÿg	 ÿg	 ÿg
+ ÿg	ÿg	ÿg	ÿg
+ ÿg	 ÿg	ÿg	ÿg	 ÿg
+ ÿg	ÿg	ÿg	ÿg	 ÿg	 ÿg	 ÿg	ÿg
+ÿg	 ÿg
+ ÿhÿhÿhÿi	ÿhÿhÿgÿhÿhÿhÿhÿiÿiÿiÿiÿh
+ÿiÿiÿjÿiÿiÿiÿiÿjÿjÿjÿjÿiÿiÿkÿkÿjÿiÿjÿjÿl"ÿl#ÿl# ÿj"ÿk#ÿj#ÿm&#ÿm&$ÿk%ÿk%ÿk%ÿk&ÿl)&ÿm*'ÿm*(ÿk("ÿl)"ÿl*#ÿl*$ÿm.*ÿn.,ÿl,%ÿl-&ÿl-&ÿn1.ÿm1/ÿn20ÿn20ÿl1*ÿl1*ÿm2+ÿp53ÿp64ÿl4.ÿm4.ÿm5/ÿl50ÿp:7ÿo:8ÿp:8ÿp;:ÿm73ÿm84ÿn94ÿp=<ÿq>=ÿm;7ÿn;7ÿm<7ÿm=7ÿqA?ÿqB?ÿqC@ÿqDAÿn@;ÿn@<ÿnA<ÿqFDÿrGDÿoC?ÿoD?ÿoD@ÿsIGÿsIHÿsJIÿsKIÿoGCÿoHDÿoHEÿoIEÿsNMÿtONÿoJGÿoKHÿoLIÿtQPÿtQQÿtSRÿtSRÿoNKÿoOLÿoPLÿoQMÿuVUÿtVVÿpSOÿpSPÿpTPÿuZXÿuZYÿuZZÿu\ZÿpWTÿpXUÿpXVÿw]]ÿw^]ÿqZXÿpZXÿp[Yÿq\Zÿwbaÿwbbÿwccÿq^\ÿq^]ÿq_]ÿq_^ÿwffÿxggÿrb_ÿqb`ÿrbaÿwiiÿxjiÿxjjÿredÿrfdÿrfeÿsgfÿynnÿynnÿsihÿrihÿsjiÿzqqÿyqqÿzrrÿsllÿtmlÿsnnÿsnnÿ{vvÿsooÿtpoÿtppÿzxxÿzxzÿ{yzÿ{z{ÿtssÿtttÿtttÿ{{|ÿtttÿtttÿtttÿ{{|ÿ{{|ÿ{{|ÿ{{|ÿtttÿtttÿ{{|ÿ{{|ÿtttÿtttÿtttÿ|||ÿ|||ÿ|||ÿtttÿtttÿ|||ÿ|||ÿtttÿtttÿ|||ÿ|||ÿ|||ÿtttÿtttÿtttÿ|||ÿtttÿtttÿ|||ÿ|||ÿ|||ÿtttÿzzzÿÿÏÏÏÿèèèÿºººÿ|||ÿAAAÿNNNÿ\\\ÿfffÿ___ÿ```ÿhhhÿuuuÿrrrÿtttÿ|||ÿtttÿtttÿ|||ÿtttÿtttÿ|||ÿtttÿ|||ÿ|||ÿtttÿ|||ÿtttÿ|||ÿtttÿ|||ÿtttÿ|||ÿtttÿtttÿtttÿtttÿg	 ÿg	 ÿg	ÿg	 ÿg	ÿg	ÿg	 ÿg	ÿg
+ÿg	ÿg
+ ÿg
+ÿg	ÿg	ÿg	ÿf	 ÿdÿbÿ^ÿZÿQ ÿVÿs"ÿj6,ÿPIYÿ9U{ÿ:kÿ7}´ÿ6Èÿ4Óÿ4ãÿ4¡èÿ3 åÿ3Øÿ6Éÿ8{¯ÿ;eÿ@F_ÿG!*ÿLÿQÿVÿ\ÿb ÿf	 ÿg	 ÿg	ÿg
+ÿg	ÿg	ÿg	ÿg	ÿg
+ ÿg	 ÿg	 ÿg	 ÿg
+ÿg	ÿg	ÿg	ÿg	ÿg
+ÿg	 ÿg	 ÿg
+ ÿg
+ ÿh
+ÿhÿhÿi	ÿi
+ÿi
+ÿi
+ÿgÿhÿgÿhÿiÿiÿiÿiÿiÿjÿiÿiÿiÿiÿiÿjÿjÿjÿjÿjÿjÿjÿjÿiÿiÿiÿl ÿl!ÿl!ÿl!ÿl" ÿl# ÿl$ ÿl$"ÿj"ÿj$ÿk$ÿk%ÿm(%ÿl(%ÿm(&ÿm)'ÿm*(ÿm+(ÿn,(ÿm,(ÿl*#ÿk*$ÿl+%ÿl+%ÿk,%ÿm0,ÿn0-ÿn0.ÿn1/ÿn20ÿo30ÿn31ÿo42ÿl2,ÿm3,ÿm3,ÿm3.ÿo75ÿp86ÿo87ÿp97ÿp98ÿp:8ÿp;9ÿp;:ÿp=;ÿn94ÿn:5ÿn:6ÿn:6ÿq?=ÿp@=ÿp@>ÿqA?ÿqB@ÿqBAÿqCAÿqDBÿqDCÿnA<ÿoB=ÿnB>ÿoC?ÿrHFÿrHFÿsIGÿrJHÿsKIÿsJIÿsLKÿsLKÿsLLÿoIEÿoJFÿoJFÿoJGÿtPOÿtQPÿtQPÿsRQÿtRRÿtSSÿtTSÿtTSÿtUSÿpPMÿpQMÿpRNÿpROÿuXWÿuYXÿuZYÿuZYÿuZZÿu[Zÿu\\ÿu\[ÿpYUÿpYVÿpYWÿqZXÿq[Xÿwa`ÿwa`ÿwbaÿwbbÿwccÿwcdÿwddÿwddÿr_^ÿq`^ÿra_ÿqb`ÿxhhÿwhhÿxihÿxjjÿxkjÿxljÿxlkÿxmlÿrhfÿshgÿrhhÿsihÿxpoÿyppÿzqqÿzrrÿyrrÿzssÿzttÿtnmÿsooÿsooÿsooÿ{vwÿzwwÿ{xyÿzxyÿ{yzÿzyzÿ{z{ÿtttÿtttÿtttÿtttÿ{{|ÿ{{|ÿ{{|ÿ{{|ÿ{{|ÿ{{|ÿ{{|ÿtttÿtttÿtttÿtttÿ|||ÿ|||ÿ|||ÿ|||ÿ|||ÿ|||ÿtttÿtttÿtttÿtttÿ|||ÿ|||ÿ|||ÿ|||ÿ|||ÿ|||ÿtttÿtttÿtttÿ|||ÿ|||ÿ|||ÿ|||ÿ|||ÿÿªªªÿÿÌÌÌÿôôôÿÿUUUÿGGGÿWWWÿ^^^ÿ___ÿfffÿhhhÿoooÿyyyÿtttÿtttÿtttÿ|||ÿ|||ÿ|||ÿ|||ÿtttÿ|||ÿ|||ÿ|||ÿ|||ÿtttÿ|||ÿ|||ÿ|||ÿtttÿ|||ÿ|||ÿtttÿ|||ÿtttÿtttÿg	 ÿg
+ ÿg
+ ÿg	ÿg
+ ÿg
+ ÿg	ÿg	 ÿg	ÿg	 ÿg	ÿg	 ÿeÿc	 ÿ` ÿ\ÿX ÿSÿL)ÿ?D`ÿ6gÿ:Êÿ0¤óÿ.¨ùÿ.©ùÿ/©úÿ/ªúÿ/«úÿ/«úÿ0¬úÿ0¬úÿ0­úÿ0­úÿ0­úÿ0­úÿ0­úÿ0­úÿ0­úÿ0­úÿ4Úÿ;`ÿF!ÿM ÿVÿ^ÿdÿg	 ÿg
+ ÿg	ÿg
+ÿg
+ ÿg
+ ÿg	ÿg	ÿg	ÿg	ÿg	 ÿg
+ ÿg
+ÿg
+ÿg	 ÿg	 ÿg	ÿg	ÿg
+ÿg
+ÿg	 ÿg
+ ÿhÿi	ÿhÿhÿgÿhÿiÿiÿiÿhÿhÿiÿjÿh
+ÿi
+ÿhÿiÿiÿjÿjÿhÿiÿjÿjÿiÿjÿiÿjÿjÿkÿk ÿjÿiÿjÿl!ÿl"ÿk!ÿj!ÿj#ÿl%"ÿl%"ÿl&#ÿm'$ÿj%ÿk%ÿk%ÿm)'ÿm*'ÿm*(ÿk("ÿk)#ÿm-)ÿm-*ÿm-+ÿm/+ÿn/,ÿl,&ÿk-&ÿl.(ÿn1/ÿn20ÿl0)ÿl0*ÿm1+ÿo42ÿp63ÿo64ÿp74ÿl4.ÿl5/ÿm50ÿm60ÿp98ÿp;8ÿn73ÿn83ÿm93ÿp=;ÿq=<ÿp?<ÿq?=ÿm<7ÿm=7ÿn=8ÿn>8ÿqB@ÿn>:ÿn?;ÿo@;ÿn@;ÿqEDÿqFDÿqFEÿrGEÿnD?ÿoD@ÿnE@ÿnFAÿsJHÿoGCÿoGCÿoHDÿoIDÿsMLÿtNMÿtOMÿsONÿoKHÿoKIÿoLIÿtRRÿtRRÿoNJÿoOLÿpOLÿoPMÿuUTÿuVUÿtWVÿuWVÿpSPÿpTQÿpTRÿuZYÿu[ZÿpVSÿqWTÿpXUÿv]]ÿw^]ÿv^^ÿv_^ÿw`_ÿq[Yÿq\Yÿwaaÿwbbÿwccÿq^]ÿq^]ÿq_]ÿwfeÿwfgÿwggÿxhgÿqb`ÿrcaÿrdaÿxjiÿxkjÿrfcÿreeÿrgeÿymmÿynmÿynnÿyonÿsjhÿsjiÿskjÿzrrÿzrrÿsmlÿsnlÿ{tuÿ{uuÿzuvÿzvvÿsopÿsqpÿtqpÿ{yyÿ{yzÿtsrÿtssÿ{{|ÿ{{|ÿ{{|ÿ{{|ÿtttÿtttÿtttÿ{{|ÿ{{|ÿtttÿtttÿ{{|ÿ{{|ÿ{{|ÿ{{|ÿtttÿtttÿ|||ÿ|||ÿtttÿtttÿ|||ÿ|||ÿ|||ÿ|||ÿtttÿtttÿ|||ÿ|||ÿtttÿtttÿ|||ÿ|||ÿ|||ÿtttÿtttÿ|||ÿtttÿtttÿÿëëëÿÿÿ×××ÿçççÿtttÿ???ÿVVVÿdddÿfffÿ___ÿ```ÿkkkÿoooÿ{{{ÿ|||ÿ|||ÿtttÿ|||ÿtttÿtttÿ|||ÿtttÿtttÿ|||ÿtttÿ|||ÿtttÿ|||ÿtttÿ|||ÿtttÿtttÿ|||ÿtttÿtttÿtttÿg	 ÿg	ÿg	 ÿg
+ÿg	 ÿg
+ÿg	ÿg	ÿg	 ÿfÿc	ÿ`ÿ[ ÿV ÿOÿC=Zÿ9iÿ0Þÿ-¤ùÿ-¥ùÿ-¥ùÿ-¦ùÿ-§ùÿ.§ùÿ.¨ùÿ.¨ùÿ.©ùÿ/ªúÿ/ªúÿ/«úÿ/«úÿ0¬úÿ0­úÿ0­úÿ0­úÿ0­úÿ0­úÿ0­úÿ0­úÿ0­úÿ0­úÿ0ªõÿ:jÿGÿQÿ[ÿdÿg	ÿg
+ ÿg	 ÿg
+ ÿg	ÿg	ÿg
+ÿg
+ÿg	ÿg	ÿg	 ÿg	 ÿg
+ ÿg	ÿg
+ÿg	ÿg	ÿg
+ÿg
+ÿhÿg ÿgÿhÿgÿh
+ÿiÿiÿiÿhÿiÿiÿhÿh	ÿh	ÿiÿiÿjÿjÿiÿjÿiÿjÿjÿiÿiÿiÿjÿjÿjÿkÿjÿk ÿlÿk!ÿj ÿjÿj!ÿj!ÿl$!ÿl%"ÿl%"ÿm&#ÿl&#ÿm'$ÿl'%ÿl(&ÿm(&ÿk& ÿk' ÿk(!ÿm+(ÿm,)ÿn-)ÿm-*ÿn.+ÿn.,ÿn/,ÿn0,ÿm0.ÿk.'ÿl/(ÿl/(ÿl/)ÿn41ÿo41ÿp52ÿo53ÿo63ÿp75ÿp85ÿp86ÿp86ÿm60ÿm71ÿm71ÿm72ÿp<:ÿq=;ÿq=;ÿq><ÿp><ÿq>=ÿq?=ÿp@=ÿqA>ÿn=8ÿn>9ÿn?:ÿn?;ÿqDBÿqECÿqECÿrEDÿrGDÿrGFÿrHFÿrHGÿoEAÿnFAÿoFBÿoGCÿsLJÿsLKÿsMLÿsMLÿtNMÿtNNÿsONÿsPOÿsQPÿoLIÿoMJÿoMJÿoNJÿtTSÿtUSÿuUSÿuVTÿtVUÿuWVÿtXVÿuXWÿuYWÿpURÿpURÿpUSÿpWTÿu\[ÿv]\ÿv]]ÿv^]ÿv_^ÿv__ÿv`_ÿwa`ÿva`ÿq\Zÿq][ÿq][ÿwcdÿwedÿxedÿwefÿxffÿxggÿwggÿxhhÿxhhÿrdbÿrcbÿrdcÿrfdÿxklÿxllÿxmlÿxnnÿxnnÿyooÿyopÿyppÿskjÿskkÿslkÿzssÿzttÿzttÿzuvÿzuuÿzvwÿzvwÿ{wxÿtqqÿtqqÿtrrÿtssÿ{z{ÿ{{|ÿ{{|ÿ{{|ÿ{{|ÿ{{|ÿ{{|ÿtttÿtttÿtttÿtttÿ{{|ÿ{{|ÿ{{|ÿ{{|ÿ|{|ÿ|||ÿ|||ÿtttÿtttÿtttÿ|||ÿ|||ÿ|||ÿ|||ÿ|||ÿ|||ÿtttÿtttÿtttÿ|||ÿ|||ÿ|||ÿ|||ÿ|||ÿ|||ÿtttÿtttÿtttÿ|||ÿ{{{ÿÂÂÂÿåååÿÿ¤¤¤ÿñññÿ½½½ÿHHHÿXXXÿ```ÿeeeÿeeeÿ___ÿ___ÿrrrÿxxxÿ{{{ÿ|||ÿ|||ÿtttÿ|||ÿ|||ÿ|||ÿ|||ÿtttÿtttÿ|||ÿ|||ÿ|||ÿtttÿ|||ÿ|||ÿ|||ÿtttÿ|||ÿtttÿ|||ÿtttÿg	 ÿg	 ÿg	 ÿg	 ÿg
+ÿg	 ÿfÿd ÿ`ÿ\ ÿVÿNÿ@Ioÿ4z¼ÿ+ôÿ+¡ùÿ,¢ùÿ,£ùÿ,£ùÿ,¤ùÿ-¤ùÿ-¥ùÿ-¥ùÿ-¦ùÿ-§ùÿ.§ùÿ.¨ùÿ.¨ùÿ.©ùÿ/ªúÿ/ªúÿ/«úÿ/«úÿ0¬úÿ0­úÿ0­úÿ0­úÿ0­úÿ0­úÿ0­úÿ0­úÿ0­úÿ0­úÿ3ÝÿC&2ÿOÿ\ ÿe ÿg	ÿg	ÿg	ÿg	 ÿg	 ÿg
+ÿg	ÿg
+ ÿg
+ ÿg
+ÿg	ÿg	ÿg	 ÿg	 ÿg	 ÿg	ÿg	ÿg	 ÿg
+ ÿhÿi	ÿhÿh
+ÿgÿgÿhÿiÿiÿhÿhÿiÿiÿiÿiÿhÿhÿiÿjÿiÿiÿiÿiÿjÿjÿjÿjÿiÿiÿkÿjÿkÿjÿjÿl!ÿl"ÿl# ÿl# ÿj!ÿj"ÿj#ÿm&#ÿm&#ÿl'$ÿk%ÿj%ÿk&ÿm)'ÿm*'ÿm+(ÿl("ÿl)#ÿl)#ÿm-*ÿm.+ÿm.+ÿl,%ÿl-&ÿl-&ÿm1.ÿn1/ÿn20ÿn30ÿl1*ÿl1+ÿl2+ÿp52ÿo64ÿp74ÿm4.ÿm5/ÿm6/ÿp97ÿp:7ÿp:8ÿp;9ÿm83ÿm84ÿm94ÿp><ÿq>=ÿp?=ÿn;7ÿm<7ÿm=7ÿqB?ÿqB@ÿqC@ÿqCAÿn@;ÿn@<ÿqECÿqFDÿqGEÿrGEÿoD?ÿoE@ÿsIGÿsIHÿsJIÿsJIÿoGCÿoHDÿoHDÿsMLÿtNMÿsONÿoJHÿoKHÿoKIÿsQQÿtRQÿtSRÿtSRÿpOKÿoPLÿoPLÿtVUÿuVUÿtVVÿoROÿpSPÿpTQÿtYXÿuZYÿu[Zÿu\ZÿpWTÿqXTÿpXUÿw]]ÿw_^ÿv__ÿp[Xÿq\Yÿp\Yÿwbaÿwbbÿwccÿq^\ÿq_]ÿr_]ÿweeÿxfgÿwggÿra_ÿqbaÿqbaÿxihÿxjjÿxkjÿxkjÿreeÿrgeÿxmlÿynmÿxnnÿsihÿsjhÿsjjÿyqpÿzqqÿzrrÿsmlÿsnmÿsnmÿzuuÿzuvÿzvwÿspoÿtqpÿzwyÿzxyÿ{yzÿ{z{ÿtssÿtttÿ{{|ÿ{{|ÿ{{|ÿtttÿtttÿ{{|ÿ{{|ÿ{{|ÿ{{|ÿtttÿtttÿ{{|ÿ{{|ÿtttÿtttÿtttÿ|||ÿ|||ÿ|||ÿtttÿtttÿ|||ÿ|||ÿtttÿtttÿ|||ÿ|||ÿ|||ÿtttÿtttÿ|||ÿ|||ÿtttÿtttÿ|||ÿ|||ÿ|||ÿtttÿtttÿÿïïïÿÆÆÆÿÿ¼¼¼ÿøøøÿlllÿCCCÿhhhÿ]]]ÿ___ÿeeeÿeeeÿ___ÿaaaÿvvvÿrrrÿtttÿ|||ÿtttÿtttÿ|||ÿtttÿ|||ÿ|||ÿtttÿ|||ÿtttÿ|||ÿtttÿ|||ÿtttÿ|||ÿtttÿtttÿtttÿtttÿg
+ ÿg	 ÿg	ÿg	 ÿeÿcÿ^ ÿZÿSÿBEjÿ3z¿ÿ*õÿ*øÿ+øÿ+ øÿ+ øÿ+¡øÿ+¡ùÿ,¢ùÿ,£ùÿ,£ùÿ,¤ùÿ-¤ùÿ-¥ùÿ-¦ùÿ-¦ùÿ-§ùÿ.§ùÿ.¨ùÿ.¨ùÿ.©ùÿ/ªúÿ/ªúÿ/«úÿ/«úÿ0¬úÿ0­úÿ0­úÿ0­úÿ0­úÿ0­úÿ0­úÿ0­úÿ0­úÿ2¡çÿD &ÿRÿ_ÿf	ÿg	ÿg
+ÿg	ÿg
+ÿg	 ÿg
+ ÿg
+ÿg	ÿg	ÿg
+ÿg	ÿg
+ÿg	ÿg	ÿg
+ ÿg
+ ÿgÿhÿhÿhÿiÿh
+ÿi
+ÿiÿhÿhÿhÿiÿiÿjÿiÿiÿiÿiÿjÿhÿiÿhÿjÿiÿjÿjÿjÿjÿjÿjÿjÿjÿiÿiÿlÿl ÿl!ÿl"ÿl"ÿm# ÿl#!ÿm$!ÿl%"ÿk#ÿj$ÿk$ÿm'%ÿm(%ÿl(&ÿm)'ÿm*'ÿm+(ÿm+(ÿm+(ÿm-)ÿk*$ÿk+%ÿk,%ÿn/,ÿn0-ÿn0-ÿn1.ÿm2/ÿm2/ÿn30ÿn40ÿo41ÿo53ÿm2,ÿl2-ÿl3-ÿp75ÿp85ÿo86ÿp97ÿp:8ÿp:9ÿq;9ÿq;9ÿp=;ÿp=;ÿn:5ÿm;6ÿn;6ÿp@=ÿq@>ÿpA?ÿqB?ÿqB@ÿqCAÿqCAÿrDBÿqEBÿoA<ÿnB=ÿnB=ÿnC?ÿrHFÿsHFÿrIGÿrJHÿrJIÿsKJÿsLJÿsLKÿsLLÿoIEÿoJFÿoJGÿtONÿtPOÿtQPÿsQPÿtRRÿtRRÿtSRÿtTSÿtTSÿtUTÿpPMÿoRNÿoRNÿuXWÿuXWÿuYXÿuYYÿuZYÿu[Zÿu[[ÿv\[ÿv]\ÿv]\ÿpYVÿqZWÿpZWÿw`_ÿw``ÿwaaÿvbbÿwcbÿwccÿwccÿwddÿxeeÿq_]ÿq`^ÿqa^ÿwhgÿxhgÿwhhÿwihÿxjiÿxkjÿxkjÿxklÿxmlÿrgfÿrhgÿrigÿyooÿypoÿyppÿyqqÿzqqÿzrrÿzssÿzstÿztuÿsnnÿsooÿsooÿ{wxÿ{wxÿzxyÿ{yyÿ{yzÿ{zzÿ{{{ÿ{{|ÿtttÿtttÿtttÿ{{|ÿ{{|ÿ{{|ÿ{{|ÿ{{|ÿ{{|ÿ{{|ÿ{{|ÿtttÿtttÿ{{|ÿ|||ÿ|||ÿ|||ÿ|||ÿ|||ÿ|||ÿ|||ÿtttÿtttÿ|||ÿ|||ÿ|||ÿ|||ÿ|||ÿ|||ÿ|||ÿtttÿtttÿ{{{ÿ{{{ÿ{{{ÿ{{{ÿ{{{ÿ|||ÿ|||ÿsssÿÿÛÛÛÿÿ¥¥¥ÿäääÿÑÑÑÿFFFÿ[[[ÿcccÿfffÿdddÿdddÿeeeÿgggÿbbbÿvvvÿ{{{ÿ|||ÿ|||ÿ|||ÿtttÿ|||ÿ|||ÿ|||ÿ|||ÿtttÿ|||ÿ|||ÿ|||ÿtttÿ|||ÿ|||ÿtttÿ|||ÿtttÿtttÿg	 ÿg	 ÿf ÿd ÿaÿ^ÿM2Kÿ9k§ÿ*òÿ)øÿ)øÿ-ìÿ3Ôÿ7{Àÿ;r¯ÿ<gÿElÿNqÿNqÿMsÿG{¨ÿ?»ÿ1Öÿ.òÿ-¤ùÿ-¥ùÿ-¦ùÿ-¦ùÿ.§ùÿ.§ùÿ.¨ùÿ.©ùÿ.©ùÿ/ªúÿ/ªúÿ/«úÿ0¬úÿ3­úÿ7°úÿ;±úÿ=²úÿ<²úÿ9°úÿ4¯úÿ1­úÿ5ÆÿJÿX ÿdÿg	ÿg
+ÿg
+ ÿg	 ÿg	ÿg	ÿg	 ÿg	 ÿg	ÿg	ÿg	ÿg	ÿg	 ÿg
+ ÿg
+ÿg
+ÿg
+ ÿg
+ ÿhÿhÿi	ÿi
+ÿhÿgÿiÿhÿiÿhÿhÿiÿiÿjÿiÿh
+ÿiÿiÿiÿjÿhÿiÿjÿjÿjÿjÿjÿiÿiÿjÿkÿkÿjÿjÿl!ÿl"ÿl"ÿl# ÿj!ÿj"ÿk#ÿm&#ÿl&#ÿm'$ÿj%ÿk%ÿl(&ÿm)&ÿm*'ÿm*'ÿm+(ÿl)"ÿk)#ÿm-*ÿn-+ÿm.,ÿk,%ÿl-&ÿl-'ÿn1.ÿn2/ÿn20ÿn31ÿl0*ÿm1*ÿl2,ÿo53ÿp63ÿo75ÿl5.ÿl5/ÿp86ÿo97ÿp:8ÿp:9ÿp;9ÿm83ÿn94ÿm95ÿp><ÿp>=ÿn;7ÿm;7ÿn<7ÿqA>ÿqB?ÿqB?ÿqCAÿqCAÿn@;ÿnA<ÿnA=ÿrFDÿrGEÿnC>ÿoD?ÿoD?ÿsIGÿsJHÿsKIÿsJIÿsLJÿoHDÿoIEÿoJFÿsNMÿsONÿoJGÿoKHÿoKIÿtQPÿsRQÿtSRÿtSRÿtTSÿpOLÿoPMÿuUUÿuVUÿuWUÿpROÿpSPÿpTPÿtYXÿuZYÿu[Zÿv\[ÿpWTÿqWUÿpXUÿv^]ÿw^^ÿv__ÿq[Xÿq[Yÿwaaÿvbbÿwbcÿwccÿwdcÿr^]ÿq_]ÿxefÿwffÿwggÿra`ÿrb`ÿrcaÿxjhÿxjiÿxjjÿxkkÿreeÿrgeÿxmmÿxmmÿyonÿrihÿsjiÿypqÿzpqÿyqrÿzrsÿzrsÿsnmÿsnnÿzuuÿ{uvÿ{vvÿspoÿtppÿ{wyÿzyzÿ{yzÿ{y{ÿsssÿtttÿ{{|ÿ{{|ÿ{{|ÿtttÿtttÿ{{|ÿ{{|ÿ{{|ÿ{{|ÿtttÿtttÿ{{|ÿ{{|ÿtttÿtttÿ|||ÿ|||ÿ|||ÿ|||ÿtttÿtttÿ|||ÿ|||ÿtttÿtttÿ|||ÿ|||ÿ|||ÿtttÿtttÿ|||ÿwwwÿgggÿeeeÿlllÿqqqÿxxxÿsssÿtttÿ|||ÿzzzÿmmmÿÿÿÕÕÕÿëëëÿfffÿSSSÿPPPÿXXXÿbbbÿcccÿ]]]ÿ^^^ÿfffÿfffÿpppÿ{{{ÿ|||ÿtttÿ|||ÿtttÿ|||ÿ|||ÿtttÿ|||ÿtttÿ|||ÿtttÿ|||ÿtttÿ|||ÿtttÿtttÿtttÿtttÿg	 ÿg	 ÿf ÿ_ÿGLvÿ8v½ÿ:m®ÿCTÿM>ZÿV'8ÿ^ÿcÿd	 ÿe	 ÿbÿcÿ.ÿ. ÿ. ÿ- ÿ- ÿlÿWÿaÿ\$,ÿOEaÿAn£ÿ1çÿ-¦ùÿ-¦ùÿ.§ùÿ.§ùÿ.¨ùÿ.©ùÿ.©ùÿ2«úÿ;¯úÿE´ûÿL·ûÿQºûÿS»ûÿR»ûÿN¹ûÿH¶ûÿ?³úÿ5¯úÿB>TÿRÿ` ÿg	 ÿg	 ÿg
+ÿg	ÿg	ÿg
+ÿg	ÿg	ÿg
+ ÿg	 ÿg	 ÿg	 ÿg	ÿg	ÿg	ÿg	ÿg
+ÿhÿgÿgÿhÿgÿh
+ÿiÿhÿiÿiÿiÿiÿhÿi	ÿh	ÿh
+ÿjÿiÿiÿjÿiÿiÿjÿiÿhÿiÿjÿiÿjÿkÿjÿkÿkÿk ÿl!ÿjÿjÿj ÿj!ÿl$ ÿl%"ÿl%"ÿm&"ÿm&#ÿl&$ÿm'$ÿl(%ÿk&ÿk& ÿk' ÿk'!ÿk("ÿm,(ÿm-)ÿm-*ÿm.*ÿm.+ÿm/,ÿn0-ÿn0.ÿl.'ÿl/(ÿl/)ÿl0)ÿo31ÿo42ÿo52ÿo63ÿp64ÿo65ÿp75ÿp85ÿm6/ÿl60ÿl71ÿm71ÿm72ÿp<:ÿp=;ÿp=;ÿq><ÿq>=ÿp?=ÿq@=ÿp@>ÿm=7ÿn=8ÿn>9ÿn?:ÿn?:ÿqDBÿqECÿrECÿqFDÿrFEÿrGEÿrHFÿsHFÿoE@ÿoFAÿoFAÿoGCÿoGCÿtLKÿsMKÿsMLÿtNMÿtNMÿsPOÿtPOÿtQPÿoLIÿoMJÿoMJÿoOKÿoOKÿtUSÿtUTÿuUTÿtVUÿuWUÿtWWÿuXWÿuYWÿpURÿpVRÿpVRÿpWTÿv\[ÿv][ÿv]]ÿv^]ÿv^]ÿw__ÿw`_ÿw``ÿq\Zÿq]Zÿq][ÿq][ÿq]\ÿwddÿweeÿxefÿxffÿwggÿxggÿxhgÿwihÿrcbÿrdcÿqecÿredÿxlkÿxllÿxmmÿxnmÿynnÿxonÿypoÿrjiÿrkjÿsljÿslkÿsmlÿzstÿztuÿ{uuÿzvvÿzvwÿ{vwÿ{wxÿtqpÿsrqÿtrrÿtsrÿ{z{ÿ{{|ÿ{{|ÿ{{|ÿ{{|ÿ{{|ÿ{{|ÿtttÿtttÿtttÿtttÿ{{|ÿ{{|ÿ{{|ÿ{{|ÿ{||ÿ|||ÿtttÿtttÿtttÿtttÿ|||ÿ|||ÿ|||ÿ|||ÿ|||ÿ|||ÿtttÿtttÿtttÿ|||ÿ|||ÿuuuÿqqqÿnnnÿmmmÿeeeÿeeeÿdddÿvvvÿzzzÿ|||ÿ|||ÿ|||ÿÿÿ¼¼¼ÿðððÿÉÉÉÿÿMMMÿLLLÿTTTÿZZZÿbbbÿbbbÿdddÿeeeÿsssÿrrrÿtttÿ|||ÿ|||ÿ|||ÿtttÿtttÿ|||ÿ|||ÿ|||ÿtttÿ|||ÿ|||ÿ|||ÿtttÿ|||ÿtttÿtttÿtttÿg	 ÿg
+ ÿ`!ÿW.Eÿ`ÿd ÿdÿf ÿf ÿg	ÿg	ÿg	ÿg	 ÿd	 ÿaÿ/ÿ1 ÿ1 ÿ0 ÿ0 ÿ/ ÿZÿ]ÿf	 ÿg	 ÿg	 ÿf	 ÿdÿT<Tÿ;¿ÿ-¦ùÿ-¦ùÿ.§ùÿ.¨ùÿ3ªùÿA°úÿN¶úÿY»ûÿa¿ûÿgÁûÿiÃûÿhÃûÿdÁûÿ]¿ûÿS»ûÿF¶ûÿ@¶ÿM ÿ]	 ÿfÿg	 ÿg	 ÿg	ÿg	ÿg	ÿg	ÿg	 ÿg	 ÿg	ÿg	 ÿg	 ÿg	ÿg
+ÿg	ÿg
+ÿh
+ÿg
+ ÿgÿhÿh	ÿgÿgÿi
+ÿiÿiÿiÿiÿhÿhÿhÿh	ÿh
+ÿiÿjÿiÿjÿjÿjÿjÿiÿiÿjÿiÿiÿkÿkÿkÿkÿkÿk ÿjÿjÿjÿl"ÿj!ÿj"ÿl%!ÿl%"ÿl&#ÿl'$ÿl'$ÿl(%ÿk%ÿk%ÿk& ÿm*'ÿk'!ÿk("ÿk("ÿm,)ÿm-*ÿm.+ÿm.+ÿn/,ÿn/-ÿk-'ÿl.'ÿl.(ÿk/(ÿl0*ÿl0*ÿo41ÿo53ÿp53ÿp63ÿp74ÿp75ÿo86ÿm6/ÿm60ÿp98ÿm72ÿm73ÿm83ÿp<;ÿq=;ÿp=<ÿq?=ÿq?=ÿp?=ÿn<7ÿn=8ÿm=8ÿpB@ÿn?:ÿn@:ÿn?;ÿqEBÿqECÿqFDÿrGEÿrGFÿrGFÿoD@ÿoE@ÿoFAÿsJHÿoGBÿoGCÿoHDÿtMKÿsNLÿtNMÿsONÿsOOÿtPOÿoKIÿoLIÿoMJÿtSRÿoNJÿpNKÿtTRÿtUSÿtVTÿtWUÿtWVÿuXVÿuXWÿpSPÿoTQÿpURÿpVSÿpVSÿpWTÿv\\ÿw^]ÿv^^ÿw_^ÿw__ÿw`_ÿp[Yÿp\Yÿq\Zÿwbbÿq]\ÿq^\ÿr^]ÿwdeÿxefÿwffÿxfgÿwhgÿxhgÿqbaÿrcbÿxijÿrecÿrecÿreeÿxmmÿxmmÿxnmÿxnnÿyooÿyopÿsjiÿskjÿzrqÿrllÿsllÿzstÿztuÿzuuÿzvvÿzvvÿ{vwÿtppÿtqqÿtqqÿsrrÿsssÿttsÿ{{|ÿ{{|ÿ{{|ÿ{{|ÿ{{|ÿtttÿtttÿ{{|ÿtttÿtttÿtttÿ{{|ÿ{{|ÿ{{|ÿ{{|ÿ|||ÿtttÿtttÿ|||ÿtttÿtttÿ|||ÿ|||ÿ|||ÿ|||ÿtttÿtttÿ{{{ÿoooÿkkkÿpppÿoooÿiiiÿlllÿkkkÿdddÿjjjÿdddÿdddÿwwwÿ{{{ÿ|||ÿ|||ÿsssÿ¼¼¼ÿÿçççÿíííÿ«««ÿ~~~ÿAAAÿFFFÿUUUÿYYYÿaaaÿbbbÿdddÿaaaÿuuuÿsssÿ|||ÿ|||ÿ|||ÿtttÿtttÿ|||ÿ|||ÿ|||ÿtttÿtttÿ|||ÿtttÿtttÿ|||ÿtttÿtttÿtttÿg	 ÿg	 ÿg
+ ÿg	 ÿg	ÿg	 ÿg
+ ÿg	ÿg	ÿg	 ÿg	ÿg
+ ÿfÿ_
+ÿ-ÿ4 ÿ3 ÿ3 ÿ2 ÿ2 ÿ|,ÿSÿa ÿg	ÿg	ÿg	ÿg	ÿg
+ ÿg
+ÿf
+ ÿV6Lÿ5Øÿ-¦ùÿ2¨ùÿB¯úÿR·úÿ`½úÿmÃûÿvÇûÿ}ÊüÿËüÿ~ËüÿyÉüÿqÆüÿfÂûÿX½ûÿJ²óÿKÿZÿeÿg	ÿg	ÿg	 ÿg	ÿg	 ÿg	 ÿg	ÿg
+ÿg	ÿg	ÿg	ÿg	 ÿg	 ÿg	ÿg	 ÿg
+ ÿhÿhÿhÿhÿh	ÿi
+ÿgÿhÿiÿhÿgÿiÿiÿiÿiÿiÿiÿhÿiÿjÿiÿiÿiÿjÿjÿjÿkÿjÿiÿiÿjÿjÿiÿjÿl!ÿl!ÿl!ÿk" ÿl# ÿm$ ÿj"ÿk#ÿk#ÿm'$ÿj$ÿk%ÿm(%ÿm)&ÿl)'ÿm*'ÿm+(ÿm+(ÿm,)ÿk*#ÿk*$ÿn.+ÿk,%ÿl,%ÿk,%ÿm0-ÿm0.ÿn1/ÿn2/ÿn30ÿn31ÿl1+ÿm2+ÿl2,ÿo64ÿm4-ÿl4.ÿl5/ÿp97ÿp97ÿp:8ÿp;9ÿp;9ÿp;9ÿn83ÿm94ÿp><ÿp><ÿm;6ÿm<7ÿq@>ÿpA>ÿqB?ÿqB?ÿqB@ÿqCAÿqDAÿn@;ÿnA<ÿrFDÿrGEÿnC>ÿoD?ÿsHFÿsIHÿsIHÿsKIÿsKJÿsKJÿtLKÿoIDÿoJFÿsNMÿtNMÿoJGÿoKHÿsPPÿsQPÿsRRÿtSRÿtSRÿtTRÿoPLÿpPMÿoQMÿuWUÿoROÿpSOÿoSPÿuYXÿuYXÿuZYÿuZYÿu[Zÿu\[ÿpWUÿqXVÿqYVÿv^^ÿpZXÿq[Yÿv``ÿwaaÿwabÿwbbÿwccÿwccÿxddÿq_]ÿq`]ÿxfgÿqa_ÿra_ÿrb`ÿxhhÿxjiÿxjiÿxkjÿxkjÿxlkÿrfeÿsgfÿxnnÿrhgÿrihÿsihÿyppÿzqqÿzqrÿzrrÿzssÿsnmÿtnmÿsonÿzuvÿtooÿsopÿzwxÿ{xxÿ{xyÿ{zzÿ{yzÿ{z{ÿtttÿtttÿ{{|ÿtttÿtttÿ{{|ÿ{{|ÿ{{|ÿ{{|ÿ{{|ÿ{{|ÿtttÿtttÿ{{|ÿtttÿtttÿ|||ÿ|||ÿ|||ÿ|||ÿ|||ÿtttÿtttÿ|||ÿtttÿ|||ÿzzzÿÿ«««ÿªªªÿÿaaaÿWWWÿ\\\ÿbbbÿiiiÿiiiÿiiiÿhhhÿjjjÿyyyÿsssÿtttÿ|||ÿÅÅÅÿÉÉÉÿÿéééÿÑÑÑÿÿ~~~ÿ:::ÿOOOÿ\\\ÿYYYÿ```ÿ[[[ÿcccÿkkkÿvvvÿsssÿ|||ÿtttÿ|||ÿ|||ÿtttÿ|||ÿtttÿ|||ÿ|||ÿtttÿtttÿ|||ÿtttÿtttÿtttÿtttÿg	 ÿg	 ÿg	ÿg	 ÿg	ÿg
+ÿg	 ÿg	ÿg	ÿg	ÿg
+ ÿg
+ÿaÿv&ÿ7 ÿ6 ÿ6 ÿ5 ÿ4 ÿ4 ÿk ÿW ÿd ÿg	ÿg	ÿg
+ÿg	ÿg	 ÿg	 ÿg	 ÿg	ÿcÿAv¯ÿ>¬ùÿPµúÿb½úÿrÄûÿÊûÿÏüÿÒüÿÔüÿÓüÿÑüÿÍüÿwÉüÿhÃûÿX½ûÿM(1ÿXÿeÿg
+ÿg	ÿg	ÿg	 ÿg	 ÿg	ÿg
+ÿg	ÿg	ÿg
+ÿg	ÿg	ÿg	 ÿg
+ ÿg	 ÿg	 ÿhÿhÿgÿg	ÿg	ÿg
+ÿg
+ÿgÿgÿhÿhÿiÿiÿiÿjÿiÿiÿiÿiÿiÿiÿiÿiÿjÿjÿjÿjÿjÿkÿjÿiÿjÿhÿk ÿk!ÿk!ÿk"ÿk"ÿk# ÿl# ÿl%!ÿk#ÿj$ÿk$ÿk%ÿm'%ÿl(&ÿm)&ÿm)&ÿm*'ÿm+(ÿm,(ÿm,(ÿm-)ÿl*$ÿk+$ÿk+%ÿk,%ÿn/-ÿn0.ÿn1.ÿn1/ÿm20ÿm30ÿm41ÿm52ÿk2+ÿk2,ÿk3-ÿm4.ÿp75ÿo86ÿp87ÿp97ÿp:8ÿp:9ÿp;9ÿp<9ÿq=;ÿn95ÿm:5ÿm;5ÿm:7ÿp@=ÿq@=ÿqA>ÿqA@ÿqB@ÿqC@ÿqDAÿqDBÿqECÿnA<ÿmB=ÿnC>ÿnC>ÿqGFÿrIFÿrIHÿsIIÿsJHÿsKJÿsKJÿsLJÿsMLÿoJEÿoJFÿoJGÿoJGÿsPOÿtQPÿtQPÿtRQÿtSRÿtSSÿtTRÿtUSÿtUTÿoQNÿoQNÿpRNÿpRPÿsXWÿsYWÿtYXÿsZYÿt[Yÿt[Zÿt\Zÿv\\ÿqXUÿpYVÿpZWÿq[Xÿw`_ÿv``ÿwa`ÿwaaÿwbbÿwcbÿwcdÿwddÿweeÿq`^ÿr`^ÿqa_ÿqb_ÿxhgÿxihÿxiiÿxjjÿwiiÿwjiÿwjkÿxkkÿqfeÿqgfÿqgfÿrihÿyppÿypqÿzqqÿzrqÿzrsÿzssÿztsÿzttÿsonÿtooÿtooÿ{vwÿzwxÿzxxÿ{xyÿ{yzÿzyzÿ{z|ÿ{{|ÿtttÿtttÿsssÿzz{ÿzz{ÿzz{ÿzz{ÿzz{ÿzz{ÿ{{|ÿtttÿtttÿtttÿtttÿ|||ÿ|||ÿ|||ÿ|||ÿ|||ÿ|||ÿ|||ÿtttÿtttÿ|||ÿ|||ÿÿÃÃÃÿ×××ÿáááÿ¬¬¬ÿÿWWWÿJJJÿ```ÿgggÿhhhÿhhhÿhhhÿhhhÿkkkÿnnnÿxxxÿzzzÿÿÄÄÄÿÿÿÆÆÆÿ«««ÿyyyÿPPPÿBBBÿTTTÿVVVÿXXXÿYYYÿaaaÿbbbÿmmmÿwwwÿsssÿ|||ÿ|||ÿ|||ÿ|||ÿtttÿ|||ÿ|||ÿ|||ÿtttÿ|||ÿ|||ÿtttÿ|||ÿtttÿtttÿg
+ ÿg	 ÿg
+ ÿg	 ÿg	ÿg	 ÿg
+ÿg	 ÿg	ÿg
+ ÿg	ÿd ÿjÿ9ÿ9 ÿ8 ÿ8 ÿ7 ÿ7 ÿ6 ÿ]ÿ[ÿf	ÿg	 ÿg	ÿg	ÿg	 ÿg	ÿg	ÿg
+ÿg
+ ÿg	ÿf	ÿS{ªÿ]¹úÿpÂûÿÊûÿÑüÿ×üÿ¨Ûýÿ¬ÝýÿªÜýÿ¢ÙýÿÔüÿÎüÿvÈüÿdÁûÿO5?ÿXÿdÿg
+ÿg
+ ÿg
+ ÿg
+ÿg	ÿg	 ÿg	 ÿg	ÿg	ÿg	ÿg	 ÿg	 ÿg	ÿg
+ÿg
+ÿg
+ÿf	 ÿfÿhÿg	ÿg
+ÿfÿfÿgÿhÿhÿgÿhÿiÿiÿiÿiÿh
+ÿiÿiÿjÿjÿiÿiÿiÿjÿjÿjÿjÿjÿkÿiÿiÿjÿiÿhÿiÿk"ÿk" ÿk# ÿj"ÿi"ÿm$"ÿl&"ÿl'#ÿm'$ÿj%ÿk%ÿk&ÿm)'ÿm)'ÿm*(ÿk("ÿk)#ÿk*#ÿm-*ÿm.+ÿm/,ÿn/,ÿl-&ÿl-'ÿm1.ÿm2/ÿm20ÿm30ÿl1*ÿk1*ÿn42ÿn53ÿn64ÿn64ÿl4.ÿm5/ÿm5/ÿp97ÿp:8ÿp;8ÿp;9ÿn83ÿm93ÿp=;ÿq><ÿp><ÿq?=ÿm<7ÿm<7ÿn=8ÿqA?ÿqB@ÿqC@ÿn?:ÿm@;ÿm@<ÿpFCÿpFDÿpGEÿqGEÿnC?ÿmE@ÿnEAÿrIHÿrJHÿsKJÿoHCÿoHDÿoIDÿtMMÿtNMÿtNMÿsOOÿoKHÿoLIÿsQQÿtQQÿtSRÿtSRÿoOKÿoOLÿpPMÿtVUÿtVUÿsWVÿtXVÿoSPÿoTQÿtYXÿtZYÿt[Yÿt\YÿoWTÿoXUÿu]\ÿv^]ÿw^^ÿw_^ÿqZXÿq\Yÿq\Yÿwbaÿwbbÿwcbÿq^\ÿq^]ÿq_]ÿxffÿwffÿxgfÿwhgÿrb`ÿrbaÿwhhÿwihÿwjiÿqdbÿqecÿqedÿwllÿwlmÿxnmÿwnnÿqhhÿrjjÿzqqÿzqqÿzsrÿsmlÿsmmÿsnmÿztuÿ{uvÿzvwÿsooÿsqpÿzxyÿ{yyÿ{yzÿ{z{ÿtssÿtttÿzz{ÿzz{ÿzz{ÿsssÿsssÿzz{ÿzz{ÿzz{ÿsssÿsssÿzz{ÿ{{|ÿ{{|ÿ{||ÿtttÿtttÿ|||ÿ|||ÿ|||ÿtttÿtttÿ|||ÿ|||ÿtttÿtttÿÿÿÿÊÊÊÿäääÿ½½½ÿÿEEEÿLLLÿdddÿhhhÿhhhÿaaaÿaaaÿhhhÿiiiÿaaaÿlllÿwwwÿyyyÿ¶¶¶ÿqqqÿÿ···ÿÿlllÿ888ÿBBBÿVVVÿ[[[ÿ\\\ÿXXXÿ```ÿ[[[ÿdddÿvvvÿrrrÿ{{{ÿ|||ÿtttÿ|||ÿtttÿ|||ÿtttÿ|||ÿtttÿ|||ÿtttÿtttÿtttÿtttÿg
+ ÿg
+ÿg	 ÿg	ÿg
+ ÿg
+ÿg	ÿg
+ÿg
+ ÿg	ÿfÿbÿ8ÿ< ÿ; ÿ: ÿ: ÿ9 ÿ9 ÿ9ÿQ	ÿ^ÿfÿg
+ÿg	 ÿg
+ ÿg	ÿg	ÿg
+ÿg
+ÿg	ÿg	 ÿg	 ÿfÿg¡Õÿ{ÆûÿÏüÿ¡×üÿ±Þýÿ½ãýÿÂåýÿÀäýÿµàýÿ§ÛýÿÔüÿÌüÿnÄüÿR5AÿY ÿe ÿg	 ÿg	ÿg	ÿg	ÿg
+ÿg	ÿg
+ÿg	 ÿg	 ÿg	 ÿg	ÿg	ÿg	ÿg	ÿg
+ÿg
+ÿgÿgÿfÿfÿgÿh
+ÿhÿgÿhÿgÿgÿhÿhÿhÿh	ÿi
+ÿiÿiÿiÿjÿjÿiÿjÿiÿiÿiÿiÿjÿjÿjÿiÿjÿjÿj ÿj ÿk!ÿi ÿi ÿi!ÿl# ÿl$!ÿk%"ÿl&"ÿm'#ÿm'$ÿl(%ÿm(%ÿm(&ÿk& ÿk' ÿk(!ÿm+(ÿm,)ÿm-)ÿm-*ÿn-+ÿn.,ÿm/,ÿn0,ÿm0.ÿk.'ÿk/(ÿk0)ÿk/*ÿn41ÿn41ÿn52ÿn53ÿo64ÿo65ÿo85ÿn86ÿo96ÿm60ÿm71ÿm71ÿm72ÿp<:ÿp<;ÿp=;ÿp><ÿq><ÿq?=ÿq@=ÿq@>ÿqA>ÿn=9ÿn>9ÿn>9ÿpCAÿpDBÿpDBÿqFCÿpFDÿqGDÿqGFÿqHFÿqHGÿrIHÿnFAÿnFBÿnGCÿsLJÿtLKÿtLKÿtNLÿtNMÿtONÿsONÿtPOÿtQPÿoMIÿoLJÿoMJÿoNJÿtTRÿuURÿuUSÿuUTÿtVUÿsWVÿsWWÿsXVÿtYXÿoUQÿoURÿoVRÿoVSÿt\Zÿu][ÿv^\ÿu^\ÿw^^ÿw_^ÿw`_ÿv``ÿwaaÿq\[ÿq][ÿq][ÿwcdÿxedÿweeÿxfeÿxffÿwggÿwggÿwhhÿvhgÿqdaÿqdbÿqdbÿwjiÿwkkÿwkkÿwllÿwlmÿwmmÿwnnÿxnnÿxppÿrkjÿslkÿslkÿzrsÿzstÿztuÿztuÿzvvÿ{vvÿ{vwÿ{xxÿsqpÿtrrÿtrrÿtsrÿ{z{ÿzz{ÿzz{ÿzz{ÿzz{ÿzz{ÿzz{ÿsssÿsssÿsssÿzz{ÿzz{ÿzz{ÿzz{ÿ{{|ÿ{||ÿ{||ÿ|||ÿtttÿtttÿtttÿ|||ÿ|||ÿ|||ÿ|||ÿ|||ÿ|||ÿsssÿ§§§ÿÿ}}}ÿ¤¤¤ÿÕÕÕÿáááÿsssÿMMMÿXXXÿ___ÿbbbÿhhhÿgggÿhhhÿhhhÿhhhÿgggÿhhhÿkkkÿ¦¦¦ÿ¡¡¡ÿjjjÿÿÀÀÀÿ{{{ÿeeeÿ777ÿIIIÿUUUÿYYYÿ[[[ÿWWWÿ___ÿaaaÿgggÿoooÿmmmÿqqqÿzzzÿ{{{ÿ|||ÿtttÿ|||ÿ|||ÿ|||ÿtttÿ|||ÿtttÿ|||ÿtttÿg	 ÿg	 ÿg	 ÿg	ÿg	 ÿg	 ÿg	ÿg
+ ÿg	 ÿg
+ÿc	ÿz)ÿ> ÿ> ÿ= ÿ= ÿ< ÿ< ÿ; ÿ4ÿPÿ`	ÿg	ÿg
+ ÿg	 ÿg	 ÿg	ÿg	ÿg
+ÿg	ÿg	 ÿg	 ÿg	ÿg	 ÿj;GÿÉûÿÓüÿ®ÜýÿÁåýÿÑëþÿÙïþÿÔíþÿÆçýÿ´àýÿ ØüÿÏüÿvÇüÿS&)ÿ[ ÿfÿg
+ ÿg	ÿg
+ÿg	ÿg	ÿg	ÿg	 ÿg	 ÿg	ÿg
+ ÿg	 ÿg	ÿg	ÿg
+ÿf	ÿf
+ÿf
+ ÿgÿfÿg
+ÿfÿgÿgÿgÿgÿgÿhÿgÿgÿh	ÿiÿi
+ÿiÿiÿiÿjÿiÿjÿjÿiÿiÿjÿiÿiÿiÿiÿiÿiÿj ÿk!ÿhÿi ÿi!ÿk$ ÿi!ÿi"ÿk$"ÿk$"ÿk%#ÿl&$ÿm'$ÿm(%ÿl(&ÿk&ÿk& ÿm*'ÿk("ÿl("ÿk)#ÿn-*ÿm.*ÿn-+ÿm.+ÿn/,ÿl/-ÿj-&ÿj.'ÿm1/ÿm2/ÿk1)ÿk2*ÿn42ÿo42ÿo52ÿo63ÿo64ÿn75ÿo86ÿl5/ÿm71ÿp97ÿm71ÿm73ÿm83ÿp<;ÿp=<ÿp=<ÿq>=ÿp?=ÿq?=ÿm<7ÿn=8ÿn>9ÿqB?ÿm?9ÿm?:ÿm@;ÿpECÿqECÿpFDÿqFDÿqGEÿqHFÿnD@ÿnE@ÿnEAÿrJIÿnFBÿnHCÿoHDÿsMLÿsMLÿsNMÿtNNÿtPNÿtPOÿoKIÿoLJÿoLJÿtRQÿoNKÿoOKÿtTSÿtUSÿtUTÿtVUÿsWVÿtWVÿsYWÿoTQÿoTQÿtZYÿt[YÿoVTÿpWUÿt][ÿu^\ÿu^]ÿv_]ÿv__ÿw``ÿq[Yÿq\Zÿq\[ÿwcbÿq]\ÿq]\ÿwedÿxedÿwfeÿwffÿxggÿxggÿvgfÿqc`ÿqc`ÿwiiÿqdbÿqdcÿredÿwlkÿwllÿwllÿwmmÿxnnÿxooÿqihÿrjiÿzqrÿslkÿsllÿzstÿzttÿzuuÿzuvÿzvvÿzwwÿtppÿtqpÿzyyÿtrrÿssrÿsrrÿzz{ÿzz{ÿzz{ÿzz{ÿzz{ÿsssÿsssÿzz{ÿsssÿsssÿsssÿzz{ÿzz{ÿzz{ÿ{{|ÿ|||ÿtttÿtttÿ|||ÿtttÿtttÿ|||ÿ|||ÿ|||ÿ|||ÿ|||ÿtttÿÿåååÿ···ÿ~~~ÿÿÁÁÁÿÂÂÂÿvvvÿSSSÿeeeÿVVVÿYYYÿdddÿhhhÿgggÿgggÿ___ÿgggÿ___ÿoooÿ¾¾¾ÿÿÿÃÃÃÿ¶¶¶ÿ}}}ÿbbbÿ888ÿHHHÿSSSÿRRRÿZZZÿUUUÿ]]]ÿ___ÿaaaÿ\\\ÿ^^^ÿjjjÿsssÿxxxÿrrrÿsssÿ|||ÿtttÿtttÿ|||ÿtttÿtttÿtttÿg	 ÿg	 ÿg	 ÿg	 ÿg	ÿg
+ ÿg
+ ÿg	ÿg	ÿf	 ÿgÿ@ ÿ@ ÿ@ ÿ? ÿ? ÿ> ÿ> ÿ= ÿz/ÿQ ÿ`ÿg	 ÿg	ÿg
+ÿg	ÿg	 ÿg	 ÿg	ÿg	 ÿg	ÿg	ÿg	ÿg	ÿf	 ÿ¥ÉÿÕüÿ¶ßýÿÌéþÿàòþÿîøÿÿæôþÿÒìþÿ½ãýÿ§ÚüÿÑüÿyÂôÿQÿ^	ÿf	ÿg	ÿg	 ÿg	 ÿg	ÿg	ÿg
+ ÿg	ÿg	ÿg	ÿg	ÿg	ÿg	 ÿg	 ÿf
+ÿf	ÿf	 ÿfÿgÿh	ÿg
+ÿg
+ÿgÿgÿgÿhÿgÿgÿhÿhÿiÿiÿiÿiÿhÿhÿjÿiÿiÿiÿjÿjÿkÿjÿiÿhÿiÿiÿjÿhÿhÿk!ÿk"ÿk" ÿk$ ÿk$!ÿk$!ÿi"ÿi#ÿi$ÿk&$ÿk%ÿj%ÿj%ÿm(&ÿl)'ÿm*'ÿm+(ÿm+(ÿm,)ÿk*#ÿl*$ÿm.*ÿn.,ÿk,%ÿk-&ÿl1-ÿm1.ÿl2/ÿm20ÿm31ÿm41ÿl2,ÿk3,ÿl3-ÿn64ÿl3.ÿk5.ÿl5/ÿo86ÿo97ÿp98ÿp:8ÿp;9ÿp;:ÿm84ÿn94ÿp=<ÿq>=ÿm:6ÿn<7ÿq@>ÿp@?ÿqA?ÿpB@ÿpB@ÿpDAÿpDBÿnA<ÿmA=ÿpFDÿqFEÿmC>ÿmD?ÿrIGÿrIGÿrIHÿrJIÿrKIÿrLJÿrMKÿoHDÿoJEÿsNMÿtOMÿoKHÿoKHÿtQPÿsQPÿtRQÿtSQÿtSRÿtTSÿoOLÿnPMÿnPNÿsWUÿoRNÿnSOÿnSPÿtYXÿsZXÿtZYÿtZYÿt[Zÿt\ZÿpXUÿpXUÿu^\ÿv_]ÿoZXÿpZXÿwa`ÿwa`ÿvbaÿwbbÿwccÿwddÿq_]ÿq^]ÿr`^ÿwffÿr`^ÿpa_ÿpb`ÿwhgÿwihÿwihÿwjiÿwjjÿwkjÿqfeÿrfeÿxmmÿqgfÿqhgÿqigÿxooÿypoÿypqÿyrrÿzrsÿsnmÿsnmÿsonÿzuvÿtooÿtooÿ{wxÿ{xyÿzxyÿzyzÿzxzÿzz{ÿsssÿsssÿzz{ÿsssÿsssÿzz{ÿzz{ÿzz{ÿzz{ÿzz{ÿsssÿsssÿzz{ÿzz{ÿsssÿtttÿ|||ÿ|||ÿ|||ÿ|||ÿ|||ÿtttÿ|||ÿ|||ÿtttÿtttÿ|||ÿzzzÿÿ¼¼¼ÿÞÞÞÿÿÿ¼¼¼ÿÆÆÆÿ¹¹¹ÿ¨¨¨ÿVVVÿVVVÿ```ÿcccÿ^^^ÿ^^^ÿeeeÿeeeÿdddÿgggÿ±±±ÿ¿¿¿ÿÿ¿¿¿ÿàààÿÿÿeeeÿ678ÿ@@@ÿPPPÿUUUÿVVVÿSSSÿ[[[ÿWWWÿ___ÿaaaÿ\\\ÿdddÿ___ÿmmmÿwwwÿrrrÿsssÿ|||ÿtttÿtttÿtttÿtttÿg
+ ÿg	 ÿg
+ÿg	 ÿg
+ÿg	ÿg	 ÿg	ÿg	ÿcÿ1ÿC ÿC ÿB ÿB ÿA ÿA ÿ@ ÿ? ÿw-ÿQÿa ÿg
+ÿg	ÿg	ÿg	ÿg
+ÿg	 ÿg
+ ÿg	ÿg	ÿg	ÿg	ÿg	ÿg	ÿyevÿ Õüÿ·ßýÿÎéþÿãóþÿôúÿÿéöþÿÔíþÿ¾ãýÿ§ÚýÿÑüÿrÄÿSÿaÿg	ÿg	ÿg	ÿg	ÿg
+ ÿg	 ÿg	ÿg	ÿg	ÿg	ÿg
+ÿg	ÿg	ÿg	ÿf
+ ÿf
+ ÿfÿjÿnÿw($ÿ{,)ÿ}0-ÿz.*ÿw+'ÿnÿiÿgÿhÿhÿhÿhÿiÿiÿiÿjÿiÿhÿiÿjÿjÿjÿjÿjÿkÿjÿjÿjÿk!ÿp(ÿy7/ÿ}=:ÿA=ÿ}>;ÿ{;8ÿq.*ÿm($ÿk%!ÿk%!ÿk%"ÿi#ÿj$ÿk%ÿm(%ÿm(&ÿm('ÿm)'ÿm*'ÿm*'ÿm+(ÿm,)ÿm,*ÿl*$ÿl+%ÿk,%ÿm/,ÿl0,ÿl0.ÿo52ÿs:8ÿ|IFÿMJÿPNÿNKÿ}KIÿq<6ÿm71ÿk5.ÿn75ÿo86ÿn97ÿo98ÿp:8ÿp:8ÿp;9ÿp<:ÿp<;ÿq=<ÿm95ÿm:6ÿm;7ÿp?=ÿq@>ÿq@>ÿqA?ÿpB@ÿpBAÿpCAÿrFEÿwLKÿ}VQÿZUÿ]Yÿ[Wÿ\ZÿxPOÿtLJÿrIHÿrJHÿrKJÿrLJÿrLKÿsMKÿoIEÿoJFÿoJGÿsONÿtPOÿsQPÿtQQÿtRQÿtRRÿtSSÿtSSÿtTSÿsUTÿoQMÿoQNÿpTQÿz_]ÿjhÿnlÿpoÿnmÿlkÿzcaÿv^]ÿu][ÿu][ÿoYVÿoYVÿpZWÿw``ÿw``ÿva`ÿvbaÿwbbÿwcbÿwccÿwddÿweeÿq_^ÿq`^ÿra_ÿwgfÿwgfÿwggÿykjÿ}pnÿyyÿ}|ÿÿ~}ÿwuÿwnlÿtjhÿxnnÿwnnÿxooÿxppÿyqqÿzrrÿzssÿztsÿzttÿsooÿsooÿtooÿ{vwÿ{wxÿ{xxÿ{yyÿ{zzÿzxzÿzyzÿzz{ÿuuuÿyyyÿÿÿÿÿÿÿ|||ÿzz{ÿzz{ÿsssÿsssÿz{{ÿ|||ÿ|||ÿ|||ÿ|||ÿ|||ÿ|||ÿ|||ÿtttÿtttÿ|||ÿ|||ÿ|||ÿ|||ÿ{{{ÿwwwÿÿãããÿÇÇÇÿÿÆÆÆÿôôôÿÿÿÿÿ½½½ÿdddÿ\\\ÿRRRÿSSSÿ```ÿcccÿcccÿcccÿgggÿºººÿÙÙÙÿ®®®ÿÿØØØÿæææÿÿÂÂÂÿjprÿC4/ÿS<5ÿMDAÿIIIÿNNNÿNNNÿWWWÿZZZÿ]]]ÿ^^^ÿZZZÿbbbÿeeeÿfffÿiiiÿxxxÿ{{{ÿtttÿ|||ÿtttÿtttÿg	 ÿg
+ ÿg	 ÿg	 ÿg	ÿg
+ ÿg	ÿg	 ÿg	ÿhÿFÿE ÿE ÿD ÿD ÿC ÿCÿCÿB ÿx.ÿP ÿ`ÿg	 ÿg	 ÿg	ÿg
+ÿg	 ÿg	ÿg	ÿg	 ÿg
+ ÿg
+ÿg	ÿg	ÿg	 ÿo9BÿÓüÿ±ÜüÿÅæýÿ×íþÿàòþÿÛïþÿËèýÿ¸àýÿ£×üÿÎüÿee{ÿX ÿd	ÿg	ÿg	ÿg	 ÿg	 ÿg	ÿg	ÿg	 ÿg
+ ÿg	ÿg	ÿg	ÿg	ÿg	 ÿf
+ ÿf
+ÿf	ÿhÿs!ÿ{,(ÿ|/+ÿ|/+ÿ|/,ÿ|/'ÿ}1(ÿ|0,ÿu(#ÿjÿgÿg	ÿhÿhÿhÿiÿh
+ÿhÿjÿiÿjÿiÿiÿjÿjÿjÿjÿjÿhÿkÿu30ÿ}<:ÿ?;ÿ~>6ÿ~?8ÿ@>ÿA>ÿ~A=ÿx85ÿn(%ÿi$ÿi$ÿl%#ÿk&#ÿk&$ÿj%ÿj%ÿm(&ÿm)'ÿm*'ÿm+'ÿm+(ÿk)#ÿk*#ÿm-*ÿm.*ÿm/+ÿj,%ÿk,%ÿm0)ÿyC@ÿLJÿOMÿPNÿNHÿNHÿNIÿPNÿ{IFÿp:8ÿl5.ÿl4/ÿo97ÿo97ÿo:8ÿo;8ÿp;9ÿm83ÿm84ÿn94ÿp=<ÿp>=ÿq?=ÿn<7ÿm<7ÿpA>ÿpA@ÿpB@ÿpBAÿrFCÿyQLÿZUÿ`^ÿ`^ÿ`_ÿa_ÿ]Zÿ]Yÿ}YXÿsLJÿrJIÿrKJÿrLJÿnHDÿnIEÿtNLÿsNMÿtONÿoKGÿoKHÿoLHÿtQQÿtRQÿtRRÿtSRÿtTSÿnOLÿoOMÿtUTÿuYVÿecÿieÿkhÿliÿppÿqpÿrqÿpoÿ{ecÿqYVÿpXVÿu^]ÿu_]ÿv`^ÿoZXÿq\Yÿwaaÿwbaÿwbbÿwccÿwcdÿq_]ÿr_]ÿxffÿwffÿwffÿqa_ÿqb`ÿxiiÿttÿ|{ÿ~ÿÿ{yÿ{zÿÿÿyyÿsjhÿqhhÿxooÿxppÿxpqÿyqqÿzssÿsmmÿsnmÿztuÿzvuÿzvwÿsooÿsppÿzwyÿ{xyÿzxyÿzyyÿrrrÿuutÿÿÿÿÿÿÿÿÿÿtttÿsssÿzz{ÿzz{ÿsssÿsssÿ|||ÿ|||ÿ|||ÿ|||ÿtttÿtttÿ|||ÿ|||ÿtttÿtttÿ|||ÿ|||ÿ|||ÿtttÿrrrÿzzzÿÿÿÿ°°°ÿôôôÿûûûÿÄÄÄÿÿcccÿHHHÿIIIÿXXXÿYYYÿ[[[ÿWWWÿ   ÿÝÝÝÿæææÿÿ©©©ÿãããÿÆÆÆÿÿÀËÐÿ«ÿ¿Iÿ¹Iÿ=ÿh5%ÿN?:ÿCCCÿOOOÿUUUÿTTTÿ\\\ÿXXXÿaaaÿ]]]ÿgggÿdddÿwwwÿsssÿtttÿtttÿtttÿg	 ÿg	 ÿg	 ÿg	ÿg	 ÿg	 ÿg
+ÿg	 ÿe	 ÿ},ÿH ÿH ÿHÿJÿNÿQÿRÿRÿPÿ:ÿMÿ]ÿf	ÿg
+ÿg	 ÿg	 ÿg
+ÿg	ÿg	ÿg	ÿg
+ÿg	 ÿg
+ ÿg
+ ÿg	ÿi #ÿÎûÿ¦×üÿ·ßýÿÄåýÿÊçýÿÆæýÿ»áýÿ«ÛýÿÓüÿÉúÿW#)ÿ^ÿf ÿg	 ÿg	 ÿg	ÿg	ÿg
+ÿg	ÿg	ÿg	ÿg
+ ÿg	 ÿg	 ÿg	 ÿg
+ÿf	ÿf
+ÿhÿpÿy*&ÿy+!ÿy+"ÿy,#ÿz-%ÿ{.*ÿz.+ÿz/+ÿy/+ÿr% ÿjÿhÿgÿgÿg
+ÿh
+ÿiÿiÿiÿjÿiÿiÿjÿhÿiÿiÿhÿiÿl ÿt0,ÿ{:7ÿ{<8ÿ}=9ÿ}=:ÿ~=;ÿ|<5ÿ|=5ÿ|=7ÿ{=6ÿs4,ÿm(&ÿk%"ÿl&#ÿk&$ÿk'$ÿl'$ÿm(%ÿk&ÿk& ÿk'!ÿk("ÿk("ÿm,(ÿn,)ÿm-*ÿm-+ÿm.+ÿm/,ÿn30ÿv@>ÿ|HAÿ}IBÿ}KCÿ~KEÿNLÿOLÿOLÿOMÿOMÿxGCÿp;8ÿo86ÿk60ÿk60ÿl61ÿm71ÿm73ÿp<:ÿp<;ÿp=;ÿp=<ÿq>=ÿp?=ÿq@=ÿp@>ÿn=7ÿm=8ÿm>9ÿoB<ÿvMHÿZWÿ\Yÿ\[ÿ^[ÿ^]ÿ^\ÿ_]ÿ_^ÿ\WÿvSNÿoIEÿnGCÿnHDÿrLKÿrMKÿsMMÿtNMÿsOMÿtOOÿsPOÿtQPÿoMJÿoMJÿoMJÿoNJÿoOKÿsUSÿtUTÿuXVÿ|a`ÿjhÿkjÿlkÿmlÿjhÿjgÿkgÿkhÿonÿ|gfÿw_^ÿu^]ÿu^]ÿu_^ÿv`^ÿva`ÿp\Zÿp\Zÿq][ÿq][ÿq]]ÿwedÿwdeÿxefÿwffÿwffÿvgfÿyiiÿzljÿtsÿutÿwuÿxvÿ~~ÿ}ÿ~~ÿÿ~ÿwvÿyppÿrihÿqiiÿrkjÿrkjÿsllÿzstÿ{uuÿ{tuÿ{uvÿ{vvÿzwwÿzwwÿtqpÿtrrÿsqqÿrrrÿ||{ÿÿÿÿÿÿÿÿÿÿÿÿ{{|ÿzz{ÿzz{ÿzz{ÿ{z{ÿtttÿtttÿtttÿtttÿ|||ÿ|||ÿ|||ÿ|||ÿ|||ÿ|||ÿtttÿtttÿtttÿ|||ÿ|||ÿ{{{ÿyyyÿuuuÿ|||ÿ¥¥¥ÿÿ¸¸¸ÿÝÝÝÿ×××ÿ¨¨¨ÿzzzÿkkkÿqqqÿEEEÿBBBÿSSSÿlllÿ×ØÙÿïïïÿáááÿÿµ»½ÿíîïÿÒÄÂÿÚ¨ÿÖdÿÖq.ÿâHÿâBÿÙq+ÿÄYÿ>ÿW4+ÿ@@@ÿNNNÿUUUÿZZZÿWWWÿZZZÿdddÿ```ÿfffÿxxxÿsssÿtttÿtttÿg
+ ÿg
+ ÿg	 ÿg	ÿg	 ÿg	 ÿg	ÿg	 ÿc ÿCÿJ ÿMÿUÿ£\ÿ¥a"ÿ§d(ÿ¨f+ÿ¨e+ÿ¦c(ÿX"ÿJÿYÿe	ÿg	ÿg	 ÿg
+ ÿg	ÿg	ÿg	ÿg
+ÿg	ÿg
+ ÿg	 ÿg	 ÿg
+ÿhÿÇûÿÏüÿ¤Öüÿ¯Ûüÿ³Ýüÿ°Üüÿ¨ÙýÿÓüÿÌüÿpºÿVÿb ÿg	 ÿg	 ÿg	 ÿg
+ÿg	ÿg	ÿg	ÿg	ÿg	ÿg	 ÿg
+ ÿg
+ ÿg
+ ÿg	ÿf	ÿf	ÿiÿt%!ÿw(#ÿv(ÿw*!ÿx+"ÿx+#ÿy-)ÿy-)ÿx,)ÿx-)ÿu+'ÿkÿhÿgÿg	ÿg
+ÿh
+ÿiÿjÿjÿiÿjÿjÿjÿiÿiÿiÿhÿhÿl$ ÿw52ÿy85ÿz95ÿ{;7ÿ{;8ÿ|<9ÿz;4ÿz;4ÿy:3ÿy;3ÿv82ÿn+'ÿk&#ÿk%#ÿl&#ÿl'$ÿl'%ÿl(%ÿk%ÿk& ÿl*'ÿk("ÿk)"ÿm,(ÿm,*ÿn-*ÿn-+ÿm.,ÿl/-ÿp63ÿzECÿzF?ÿ{F@ÿ|IBÿ|ICÿ~LJÿ~MKÿ~MJÿ}LJÿ~MJÿzKHÿp=:ÿn86ÿl50ÿl60ÿl61ÿm71ÿm72ÿp<:ÿp<;ÿq=;ÿp><ÿp?<ÿp?=ÿq@=ÿp@>ÿn<8ÿm=9ÿpB@ÿpC?ÿzSMÿ~XUÿZWÿ[Yÿ\Zÿ\[ÿ][ÿ][ÿ\[ÿ}YUÿyXSÿtNMÿnGBÿnHDÿsLKÿrLLÿsMLÿsNMÿsNMÿtONÿtPOÿsPPÿoMIÿoMJÿoMJÿoNKÿoOKÿsUSÿsUSÿvZWÿedÿhfÿigÿkiÿljÿifÿifÿifÿ~hfÿmkÿjiÿw`_ÿv^\ÿu_]ÿv_^ÿv_^ÿwa`ÿq\Zÿq]Zÿwcbÿq][ÿq^]ÿwddÿweeÿxffÿxffÿwffÿwffÿxjjÿ}pnÿ~sqÿtrÿutÿvuÿ}|ÿ||ÿ||ÿ|{ÿ}|ÿzyÿzqqÿqihÿrjiÿrjjÿrkkÿsmlÿzttÿztuÿzuuÿzuvÿzvvÿ{wwÿzxxÿtqqÿtrqÿrrqÿsqrÿ|||ÿÿÿÿÿÿÿÿÿÿÿÿ|||ÿzz{ÿzz{ÿzz{ÿ{{{ÿtttÿtttÿtttÿtttÿ|||ÿ|||ÿ|||ÿ|||ÿ|||ÿ|||ÿtttÿtttÿtttÿtttÿ|||ÿ|||ÿ|||ÿ|||ÿ{{{ÿÿÜÜÜÿÿuuuÿÿ¶¶¶ÿ´´´ÿ}}}ÿ}}}ÿÿ@@@ÿ???ÿQQQÿÿðôöÿòõöÿåÞÝÿÛ±£ÿÐbÿÎs6ÿÑhÿÞsÿçy!ÿð(ÿõ7ÿõGÿî¦fÿáUÿÕ|AÿC ÿK82ÿFFFÿRRRÿTTTÿWWWÿaaaÿ^^^ÿ```ÿtttÿrrrÿtttÿtttÿg	 ÿg	 ÿg
+ ÿg	 ÿg	ÿg	 ÿg
+ÿg	 ÿkÿKÿQ	ÿ£[ÿ¨e&ÿ­m1ÿ°s:ÿ²w@ÿ³yCÿ³yCÿ²v@ÿ¯r;ÿXÿSÿa	 ÿg
+ ÿg	ÿg
+ÿg
+ ÿg	ÿg	ÿg	 ÿg
+ ÿg	ÿg
+ÿg	ÿg	 ÿf ÿuÀúÿÇûÿÌûÿÐüÿÒüÿÒüÿÏûÿÊûÿ{Åûÿ[=Kÿ\ ÿf	ÿg	ÿg	ÿg	ÿg
+ ÿg	 ÿg	ÿg	ÿg	 ÿg	 ÿg
+ÿg	ÿg	ÿg	ÿg	 ÿf	 ÿf	ÿlÿr$ÿt%ÿv(#ÿw)%ÿw*&ÿw*&ÿw*!ÿv* ÿv*&ÿv*'ÿt*%ÿm!ÿgÿhÿhÿhÿiÿhÿiÿiÿjÿiÿiÿiÿjÿjÿjÿiÿjÿn)!ÿu2*ÿw62ÿx74ÿy96ÿy90ÿy:1ÿ{;8ÿz;8ÿy:7ÿx:7ÿw:6ÿn0(ÿi$ÿl&#ÿl&#ÿl&$ÿk%ÿk%ÿm)'ÿm*&ÿm*'ÿn+'ÿm+(ÿl(#ÿl)#ÿm-*ÿm.+ÿm.,ÿj,%ÿp:3ÿwA:ÿzFCÿ{HEÿ|IGÿ|JGÿ|HBÿ{IBÿzIBÿ|KHÿ{JHÿzJFÿp@9ÿl5.ÿo86ÿo97ÿn:8ÿp:9ÿp;:ÿm83ÿm83ÿm94ÿq><ÿp>=ÿq?=ÿm;7ÿm<7ÿq@>ÿpB?ÿpB@ÿuMIÿ{TQÿ{SNÿ|UOÿ~YXÿZXÿ\Yÿ[Yÿ|XSÿ|XSÿ~ZXÿ|ZWÿvTQÿrKIÿrKJÿnHDÿnIEÿtMLÿtNMÿsONÿoJGÿoKHÿoKHÿsQQÿtRQÿtSRÿtSRÿtSSÿoOLÿnPLÿx][ÿ~dbÿfeÿ|c`ÿ}ebÿ}fcÿkjÿkjÿkjÿljÿ{fcÿ{ebÿt`[ÿu^\ÿv_]ÿv_]ÿp[Xÿp[Yÿwaaÿwbbÿwcbÿwccÿwccÿq^]ÿq_]ÿweeÿxffÿvefÿqb_ÿvheÿtrÿvtÿwvÿyxÿzyÿvtÿvtÿ{zÿ{zÿ{yÿ|srÿvnmÿxopÿxppÿypqÿyqqÿzrsÿsmmÿsnmÿzuuÿzuvÿzvvÿspoÿtppÿzxyÿ{yyÿyxyÿzyyÿxxvÿ}}|ÿÿÿÿÿÿÿÿÿÿ}}|ÿwwvÿzz{ÿzz{ÿsssÿsssÿ|||ÿ|||ÿ|||ÿ|||ÿtttÿtttÿ|||ÿ|||ÿtttÿtttÿ|||ÿ|||ÿ|||ÿ|||ÿtttÿ|||ÿ|||ÿtttÿtttÿ}}}ÿ«««ÿÐÐÐÿ¦¦¦ÿjjjÿtttÿ¦¦¦ÿÁÁÁÿÿwwwÿmmmÿ79:ÿ?>>ÿH.ÿÔ¢ÿÍmÿÃs=ÿÂbÿÌkÿÙrÿä}"ÿî&ÿ÷)ÿü,ÿÿ1ÿý;ÿü¢Rÿ÷´sÿð½ÿãªwÿÆpAÿb4$ÿ>>>ÿQQQÿTTTÿ___ÿ\\\ÿgggÿeeeÿpppÿsssÿtttÿg
+ ÿg
+ ÿg
+ÿg
+ ÿg	ÿg
+ÿg	 ÿg
+ÿw"ÿQ
+ÿ¤]ÿªi,ÿ°s:ÿµ|Gÿ¹Qÿ¼Xÿ¾\ÿ¾\ÿ¼Xÿ¹QÿK-ÿK ÿZÿd	ÿg
+ÿg	ÿg	ÿg
+ ÿg
+ ÿg	ÿg
+ÿg	ÿg
+ÿg
+ÿg
+ÿb-4ÿc·úÿp½úÿ{ÂûÿÆûÿÇûÿÇûÿ~ÅûÿuÁúÿfÃÿVÿb	ÿg
+ÿg	ÿg
+ÿg	ÿg
+ÿg
+ÿg
+ ÿg	 ÿg	ÿg	ÿg	ÿg
+ÿg	ÿg	ÿg
+ÿf	ÿf	 ÿmÿp"ÿs$ÿt%!ÿu'#ÿv'$ÿu($ÿv)%ÿv(%ÿt(ÿs(ÿq&ÿm# ÿhÿhÿhÿhÿiÿiÿiÿhÿiÿhÿjÿjÿjÿjÿjÿiÿiÿo.)ÿs3.ÿu3*ÿu4,ÿv5-ÿy84ÿy85ÿy96ÿx95ÿw95ÿv95ÿt74ÿp40ÿk&#ÿj#ÿj$ÿi%ÿl'%ÿl(%ÿm(&ÿm)'ÿm*'ÿm*(ÿm,'ÿn,)ÿm,*ÿk*$ÿl+%ÿj+%ÿl/,ÿs>:ÿvB>ÿxEAÿyFCÿzGDÿzHEÿ{IFÿ{IGÿ{IFÿwF@ÿwF@ÿtE>ÿtDAÿo85ÿn87ÿo97ÿo:8ÿp;8ÿp;9ÿp;:ÿp=;ÿp=<ÿn:5ÿm:6ÿm;7ÿq@=ÿpA>ÿq@>ÿpA?ÿpB@ÿuMJÿyRPÿ{URÿ}WTÿzTOÿ{UPÿ{UQÿ{WQÿ}ZWÿ|YVÿ|YVÿzXUÿvTQÿrJJÿsLJÿrLKÿrMLÿoJFÿoJFÿoJFÿsONÿsPOÿsPPÿtQQÿtQQÿtRRÿtSRÿtTSÿsTSÿsUSÿtZVÿw^Zÿya\ÿfdÿgeÿigÿihÿjhÿjhÿigÿ~igÿ}heÿydbÿoYVÿpYWÿpZXÿv`^ÿw``ÿwa`ÿvbbÿwbbÿwcbÿwccÿxddÿxeeÿq`^ÿq`^ÿqa^ÿwgfÿznkÿ~rpÿtsÿvtÿwvÿxwÿywÿzxÿ}trÿ|srÿ{sqÿ~wvÿ{tsÿxooÿxppÿxqqÿyqrÿzssÿzttÿzttÿtonÿtooÿsooÿzwwÿzwwÿzwyÿ{xyÿzxyÿzyyÿ~}}ÿÿ}}|ÿ~~}ÿ~ÿÿÿÿÿÿÿÿ}}}ÿsssÿsssÿ{z{ÿ{{{ÿ|||ÿ|||ÿ|||ÿ|||ÿ|||ÿ|||ÿtttÿtttÿ|||ÿ|||ÿ|||ÿ|||ÿ|||ÿ|||ÿ|||ÿtttÿtttÿ|||ÿ|||ÿ{{{ÿxxxÿÿ±±±ÿ»»»ÿÿsssÿ§§§ÿ×××ÿÕÕÕÿ ÿurÿ:ÿ°Bÿ¯Sÿº`ÿÈjÿÕw#ÿÞ~(ÿç-ÿé1ÿê0ÿí5ÿñ=ÿóMÿù¯gÿþ¿|ÿÿÇÿýÌÿøÑ¤ÿíÅÿÍ}MÿQ1(ÿFFFÿVVVÿWWWÿaaaÿfffÿbbbÿvvvÿsssÿtttÿg	 ÿg	 ÿg
+ ÿg	 ÿg
+ÿg	 ÿg	 ÿg	ÿ/ÿ£\ÿ«i,ÿ²v>ÿ¸Nÿ¾\ÿÂhÿÆpÿÇtÿÇtÿÆpÿÃhÿºZÿVÿP ÿ\	ÿdÿg	ÿg	ÿg
+ ÿg	ÿg
+ ÿg	ÿg
+ÿg	ÿg	ÿf ÿYE]ÿP­ùÿ\³úÿe·úÿk»úÿm¼úÿl¼úÿgºúÿ`¶ùÿV2?ÿ]	 ÿf	 ÿg	ÿg	ÿg
+ÿg	ÿg
+ÿg	 ÿg	ÿg	ÿg
+ ÿg	ÿg	ÿg	ÿg
+ÿg	ÿg
+ ÿf	 ÿf
+ÿkÿoÿq#ÿr$ÿt&!ÿt'"ÿu'#ÿt(#ÿs'ÿr&ÿr&#ÿo%ÿk!ÿhÿhÿiÿhÿiÿiÿiÿiÿiÿiÿhÿiÿjÿjÿjÿiÿjÿm+"ÿp.&ÿs1(ÿu50ÿt3,ÿu5-ÿw73ÿv84ÿv84ÿv74ÿt73ÿr61ÿm0(ÿj$ÿj$ÿk&#ÿj%ÿk%ÿm(&ÿm)&ÿm)'ÿm*'ÿm+'ÿm+(ÿm,(ÿk)#ÿk*$ÿm.*ÿl/,ÿk,%ÿo:3ÿt@<ÿvB?ÿwEAÿxEBÿyFDÿyGDÿwE?ÿvE?ÿvE?ÿxGCÿrB=ÿp@9ÿk5/ÿo96ÿn97ÿo98ÿp:9ÿp;:ÿp;:ÿm83ÿm94ÿp><ÿp>=ÿn;6ÿn<7ÿq@>ÿqA>ÿpA@ÿpB@ÿtLIÿwPMÿyRPÿxQKÿxRMÿ|WTÿ|XTÿyTOÿxTOÿ|WUÿyWUÿxUSÿuRPÿrKJÿrKJÿrLJÿnIDÿoJEÿsOMÿtOMÿoKGÿoKHÿtPOÿtQPÿtRQÿtSRÿtSRÿtSSÿnOKÿnPLÿsYTÿz`^ÿw_Zÿya\ÿza^ÿgeÿheÿ~hfÿ~hfÿ}hfÿ|geÿvb^ÿr^Zÿv^\ÿv_]ÿpZWÿp[Xÿv``ÿvaaÿwbaÿwbbÿwcbÿwddÿwddÿq_]ÿq`^ÿxffÿqa^ÿpa^ÿugdÿ}pnÿsqÿtrÿvtÿvuÿwvÿ|spÿ{rpÿwwÿzroÿwonÿuljÿxopÿyppÿypqÿxqqÿzssÿsnmÿsnnÿsonÿzvvÿtooÿspoÿ{wxÿ{xxÿzyzÿzxxÿzyzÿ{|{ÿzzyÿ{{zÿÿ}}|ÿ~~}ÿÿÿÿÿÿÿvvtÿzz{ÿzz{ÿsssÿsssÿ|||ÿ|||ÿ|||ÿ|||ÿ|||ÿtttÿ|||ÿ|||ÿtttÿ|||ÿ|||ÿ|||ÿ|||ÿ|||ÿtttÿtttÿ|||ÿtttÿtttÿ|||ÿ|||ÿzzzÿwwwÿÿÎÎÎÿ¸¸¸ÿÿÿÊÊÊÿïòõÿÄy\ÿ¨5ÿ±Qÿ¼eÿËr#ÿØ{(ÿÛ|/ÿÕq'ÿÕq'ÿÕq'ÿ×t+ÿÛ~3ÿÝCÿßUÿã£kÿé¶ÿñÈÿüÞ´ÿýÛ«ÿûÖ¥ÿïÇÿE'ÿ<;:ÿOOOÿUUUÿZZZÿfffÿbbbÿnnnÿsssÿtttÿg	 ÿg	 ÿg	 ÿg
+ÿg	 ÿg	 ÿg	ÿg	 ÿ:ÿ©f'ÿ±t;ÿ¸NÿÀ`ÿÆpÿË£~ÿÏªÿÑ®ÿÑ®ÿÏªÿË¤~ÿÆqÿ§tQÿKÿQ ÿ\ÿc ÿf ÿg
+ÿg	ÿg	ÿg	 ÿg	 ÿg	ÿg
+ ÿeÿFcÿ<£ùÿF¨ùÿN¬ùÿT¯ùÿV°ùÿU°ùÿQ¯ùÿQt£ÿXÿd	ÿg
+ÿg	 ÿg	 ÿg	ÿg	 ÿg
+ ÿg
+ÿg	ÿg
+ÿg	ÿg	 ÿg
+ ÿg	ÿg	 ÿg	 ÿg	ÿf	ÿf
+ÿiÿmÿp!ÿr#ÿu'"ÿu(#ÿt(ÿu(ÿt($ÿr(#ÿp&!ÿn#ÿk!ÿfÿgÿhÿhÿh
+ÿhÿiÿiÿjÿjÿjÿiÿiÿiÿjÿhÿhÿm+&ÿo.*ÿs2.ÿu41ÿw73ÿw84ÿv6.ÿv7/ÿv7/ÿv84ÿr4,ÿo2*ÿn1.ÿk%"ÿk%"ÿk&#ÿl'%ÿm(%ÿk%ÿk&ÿk& ÿm*'ÿk'!ÿl("ÿk)"ÿm,)ÿm-*ÿn.*ÿl.,ÿl/,ÿo:7ÿp<4ÿt@9ÿxDBÿyGCÿxE?ÿxE?ÿ{IFÿzIEÿyHEÿwFCÿtCAÿqA?ÿn86ÿl6/ÿl61ÿo:8ÿp:8ÿn72ÿm83ÿp<:ÿp=;ÿp=<ÿq>=ÿp?=ÿq@=ÿn<7ÿn=7ÿm>8ÿpB@ÿoHAÿsLEÿvOIÿzTRÿ|WTÿ|XUÿ}XVÿ}YWÿ|YVÿxTPÿvSNÿtQLÿtQOÿnGCÿnGCÿnIDÿrMLÿtNMÿsNMÿtONÿsONÿtOOÿoKHÿoMJÿsRQÿtSRÿoNJÿoOLÿsTSÿsUTÿt[Xÿx^\ÿ|b`ÿ~ecÿheÿ{d`ÿ{daÿigÿigÿzc`ÿwb^ÿydbÿva_ÿv]\ÿv_]ÿv_^ÿu`^ÿq[Yÿp\Yÿq]Zÿwbbÿq]\ÿq]]ÿq^]ÿwdeÿwfeÿxffÿwfeÿwffÿxjhÿuifÿymkÿusÿ}roÿ}sqÿ}sqÿywÿxwÿwwÿ~utÿ|trÿypoÿrjiÿrjiÿyqqÿrkjÿsmlÿzssÿzttÿzuuÿ{uvÿ{uwÿ{vwÿtqpÿtqpÿ{yyÿzxyÿsrqÿttrÿ~~}ÿÿÿÿÿ~ÿ~ÿÿÿz{yÿxxwÿz{zÿzz{ÿzz{ÿzz{ÿ{{{ÿtttÿtttÿ|||ÿtttÿtttÿ|||ÿ|||ÿ|||ÿ|||ÿtttÿtttÿ|||ÿtttÿtttÿ|||ÿ|||ÿ|||ÿ|||ÿ|||ÿtttÿ|||ÿtttÿsssÿwwwÿÿÞÞÞÿåååÿ¬ªªÿËÓÕÿÝ±£ÿ >ÿ©Cÿ·YÿÉl!ÿÖ{*ÿÑt)ÿÊh ÿÏjÿÖo$ÿÛz+ÿß7ÿáGÿãYÿå¥mÿç°ÿèºÿéÃÿíË§ÿùÜ·ÿýÝ«ÿüÖ ÿÑaÿR/$ÿDDDÿYYYÿ[[[ÿ___ÿjjjÿoooÿsssÿtttÿg	 ÿg	ÿg	 ÿg	ÿg
+ ÿg	ÿg	ÿg	ÿ;ÿ­n3ÿ¶}Hÿ¾]ÿÆqÿÍ§ÿÔ²ÿØºÿÛ¿¥ÿÛ¿¥ÿÙ»ÿÔ³ÿÎ¨ÿÇrÿ lJÿM
+ÿO ÿX ÿ`ÿdÿf	ÿg	ÿg	ÿg	 ÿg	 ÿg	ÿc	ÿ2×ÿ*÷ÿ0÷ÿ7¡øÿ<£ùÿ>¥ùÿ=¥ùÿ=æÿTÿ`	ÿfÿg	ÿg
+ÿg	 ÿg
+ ÿg	ÿg
+ÿg	ÿg	ÿg	ÿg	ÿg	ÿg	ÿg	 ÿg	 ÿg	ÿg	ÿg	ÿf	ÿiÿkÿq!ÿt&!ÿu&ÿu'ÿu($ÿu)%ÿu(%ÿt)#ÿr&"ÿl"ÿjÿhÿhÿg	ÿh
+ÿiÿiÿiÿiÿiÿiÿjÿjÿjÿiÿiÿiÿiÿl)$ÿn,'ÿs2.ÿv52ÿw73ÿx84ÿy86ÿy96ÿv8/ÿu7.ÿr5-ÿo2-ÿn0+ÿk%"ÿk%#ÿk&$ÿl'$ÿl(%ÿm(%ÿm(&ÿk& ÿk' ÿk("ÿm,(ÿm,(ÿm,)ÿm-*ÿn.*ÿm.+ÿm/,ÿn85ÿp=8ÿt@9ÿvD=ÿxE?ÿyF@ÿ{IFÿ{IGÿzIFÿzIEÿwFDÿrB>ÿp@=ÿo85ÿo86ÿl61ÿl71ÿm72ÿp;9ÿp<:ÿp<:ÿp=<ÿp><ÿp><ÿq?=ÿq@=ÿq@=ÿqA?ÿn=8ÿm>9ÿoE@ÿsMIÿxRPÿ|VTÿ}WUÿ~YVÿ~YWÿ~YXÿ}YWÿ|XVÿzWUÿrNIÿpMHÿnGCÿrLJÿrLKÿsMLÿtMLÿtNMÿtNNÿtONÿsPOÿtQPÿsQPÿoMJÿoMJÿoNJÿtSSÿuUSÿsUTÿtZWÿv]Zÿ|caÿ~fdÿgfÿigÿ|dbÿ|ebÿ{ebÿzdaÿ|geÿxc`ÿva^ÿu^\ÿu_]ÿv_^ÿw__ÿw``ÿva`ÿq]Zÿq][ÿq]\ÿwdcÿwddÿweeÿxffÿwggÿwgfÿwffÿwjiÿymjÿymkÿ|qnÿ|rpÿxwÿywÿyxÿyxÿxwÿvuÿzrpÿyqoÿxooÿqjiÿrjjÿsllÿzssÿzttÿztuÿzuuÿzuvÿzvwÿ{vwÿ{wxÿ{xyÿsrqÿtrrÿyyzÿzzyÿ||{ÿÿÿÿÿÿÿ~ÿ}}|ÿÿ||{ÿz{zÿzz{ÿzz{ÿzz{ÿ|||ÿ|||ÿtttÿtttÿ|||ÿ|||ÿ|||ÿ|||ÿ|||ÿ|||ÿ|||ÿ|||ÿtttÿtttÿ|||ÿ|||ÿ|||ÿ|||ÿ|||ÿ|||ÿ|||ÿtttÿtttÿ|||ÿ|||ÿyyyÿÿÕÕÕÿ÷úûÿêÙÖÿ½Sÿ§Hÿ²GÿÂ^ÿÕu'ÿÍm'ÿÉfÿÓl!ÿØs(ÿÞz0ÿá;ÿâLÿå_ÿè«tÿì¹ÿïÆÿðË¤ÿïÌ§ÿðÐªÿñÒ­ÿúÜ²ÿýÓÿì°ÿo8(ÿCCCÿXXXÿbbbÿ___ÿpppÿqqqÿ|||ÿtttÿg	 ÿg	 ÿg
+ ÿg	 ÿg	 ÿg
+ ÿg	ÿg
+ ÿ5ÿ±u<ÿºSÿÃiÿÌ¤ÿÔ³ÿÛÀ¥ÿáÊ´ÿäÐ½ÿåÐ½ÿáÊµÿÜÀ¦ÿÔ³ÿÌ¥ÿÄkÿªuJÿ`$ÿJÿQ ÿYÿ^ÿbÿe ÿfÿg
+ÿf ÿX&2ÿ'÷ÿ'÷ÿ(÷ÿ(÷ÿ)÷ÿ*øÿ+øÿH<Vÿ\ÿeÿg
+ÿg
+ ÿg	 ÿg
+ÿg	ÿg
+ ÿg	 ÿg	ÿg	ÿg	ÿg	ÿg
+ ÿg	 ÿg
+ÿg	ÿg	 ÿg
+ ÿg	ÿf	ÿgÿiÿq"ÿv'ÿv($ÿv)$ÿv) ÿu) ÿv*&ÿu*&ÿp&!ÿk!ÿiÿgÿgÿhÿiÿh
+ÿh
+ÿhÿjÿjÿiÿjÿiÿiÿjÿjÿjÿiÿi ÿl,'ÿt3/ÿx84ÿx85ÿz95ÿx90ÿx81ÿy97ÿx97ÿt61ÿl/&ÿj( ÿl%"ÿk%#ÿl&$ÿl'%ÿm($ÿk%ÿk&ÿm)'ÿm*'ÿm*'ÿl("ÿk)#ÿm,*ÿm-*ÿn.+ÿm.,ÿm.,ÿl1)ÿn91ÿvC?ÿ{HEÿ{HEÿ|IFÿzGAÿzGBÿ{JGÿzIGÿwFCÿpA>ÿp;8ÿk5/ÿk5/ÿo97ÿp98ÿp:8ÿm72ÿm82ÿm84ÿq<;ÿp><ÿp>=ÿq?=ÿp@=ÿm<7ÿn=8ÿqA?ÿpB@ÿqEBÿpHBÿwPJÿ{TPÿ~XVÿ~ZWÿ~[Wÿ~ZXÿ{WRÿyVRÿuSNÿtQNÿsLJÿrJIÿnHCÿnHCÿsMLÿsMMÿsNMÿsONÿsONÿoKHÿoLIÿoLJÿtRQÿtSQÿtSRÿoNKÿoPLÿsUSÿtWUÿt[Yÿ|caÿhfÿ}daÿ|fbÿkhÿjiÿjhÿihÿwa^ÿq]Yÿv^^ÿu]\ÿu^]ÿu_^ÿv`_ÿp[Yÿq\Yÿwbbÿwbbÿwccÿq]\ÿq^]ÿweeÿweeÿwffÿxggÿwgfÿqcaÿsecÿrqÿwwÿywÿuqÿurÿyyÿzyÿzyÿ~vuÿypnÿsjhÿriiÿxppÿyqpÿyssÿsmlÿsmmÿzttÿztuÿzuvÿ{vwÿspoÿtppÿtqqÿ{yyÿzyyÿsrrÿttrÿz{zÿÿÿÿÿÿÿÿÿz{yÿtusÿzz{ÿzz{ÿzz{ÿ{z{ÿtttÿtttÿ|||ÿ|||ÿtttÿtttÿ|||ÿ|||ÿ|||ÿ|||ÿtttÿtttÿ|||ÿ|||ÿtttÿtttÿ|||ÿ|||ÿ|||ÿtttÿtttÿ|||ÿ|||ÿtttÿ|||ÿ|||ÿzzzÿyz{ÿÉÎÐÿÅiEÿ¼Nÿ°Tÿ¸IÿÎdÿÓq)ÿÉfÿÓn#ÿÙs)ÿß1ÿá?ÿåOÿð¨hÿö¸ÿñ¾ÿâ»ÿÜ»ÿìÍ¨ÿùÚ³ÿô×²ÿö×°ÿ÷Ø¯ÿûËÿó¸ÿ}G4ÿ>>>ÿYYYÿ]]]ÿbbbÿnnnÿsssÿtttÿtttÿg	 ÿg	 ÿg
+ÿg	 ÿg	ÿg	ÿg	 ÿg	ÿv!ÿ´yCÿ½[ÿÇrÿÐ¬ÿÙ¼ ÿáËµÿéØÈÿîáÔÿîáÕÿéÙÉÿâË¶ÿÙ¼¡ÿÐ¬ÿÇsÿ¾\ÿ³zDÿL$ÿZÿI ÿO ÿT ÿYÿ\ÿ_ÿ`ÿ@[ÿ'÷ÿ'÷ÿ'÷ÿ'÷ÿ(÷ÿ(÷ÿ:eÿXÿc ÿe ÿe	 ÿeÿdÿd	ÿcÿcÿdÿe ÿg	 ÿg	 ÿg	 ÿg	ÿg	ÿg	ÿg
+ÿg
+ÿg	ÿg	 ÿg	 ÿgÿiÿnÿw(%ÿy+(ÿy+'ÿy+'ÿy,(ÿw,#ÿu) ÿm#ÿiÿh
+ÿhÿhÿiÿjÿiÿiÿiÿhÿiÿiÿhÿjÿiÿjÿjÿjÿjÿj ÿj&ÿo-%ÿx8/ÿ{;3ÿy:2ÿ{<8ÿ{<9ÿ{=9ÿy;8ÿq3/ÿm.*ÿm'#ÿi#ÿi#ÿj$ÿj$ÿk%ÿm(&ÿl)&ÿm)'ÿl)'ÿm*(ÿm+(ÿn,)ÿk)$ÿk*$ÿk+%ÿk+%ÿl,%ÿn2/ÿo85ÿs?<ÿ|IFÿ~LIÿ}KHÿ}KIÿ~MIÿ|JEÿyIBÿq@:ÿn;5ÿm60ÿn86ÿo86ÿp97ÿp:8ÿp:8ÿp;9ÿp<:ÿq<:ÿm95ÿm:5ÿn:6ÿn;6ÿn;7ÿq@>ÿqA?ÿqA?ÿqB?ÿqDAÿqIFÿuOLÿZWÿXTÿ~XSÿ~YTÿ}YTÿ][ÿ~ZXÿvSQÿrOLÿsLJÿrKIÿrLJÿsLKÿoIDÿoIEÿoJEÿoJGÿoJGÿtPOÿsQPÿtQQÿtRQÿsSQÿtSRÿtSRÿtTSÿoPMÿoQOÿpURÿt[Wÿ~eaÿmkÿliÿkkÿlkÿmlÿjiÿxcbÿv`^ÿpYUÿpYVÿpYWÿqZXÿq[Yÿwa`ÿva`ÿwabÿwbbÿwcbÿxccÿxddÿr_]ÿq_]ÿq`^ÿr`_ÿqa`ÿxhhÿxkhÿ{omÿyxÿ|{ÿ{zÿ{zÿwuÿwuÿ~utÿvmlÿrkhÿyppÿxopÿxpoÿzrrÿzrsÿzrsÿzssÿsnnÿsonÿsooÿsooÿzvwÿzwxÿ{xxÿzyyÿ{yzÿzz{ÿ{zzÿttsÿxxwÿÿÿÿÿÿÿÿ}~}ÿzzzÿttsÿsssÿsssÿtttÿ|||ÿ|||ÿ|||ÿ|||ÿ|||ÿ|||ÿtttÿtttÿtttÿtttÿ|||ÿ|||ÿ|||ÿ|||ÿ|||ÿ|||ÿtttÿtttÿtttÿ|||ÿ|||ÿ|||ÿ|||ÿ|||ÿtttÿtttÿtttÿ{{{ÿlcÿ¸EÿÇ_ÿ·Yÿ½LÿÕbÿÎg"ÿÒm"ÿÛv+ÿà4ÿâ@ÿêVÿðªlÿ«}UÿaL7ÿNA6ÿ@=8ÿ ÿÿ¥ÿþá¼ÿùÝµÿùÚ±ÿùÆÿê dÿq;+ÿGGGÿUUUÿdddÿtttÿrrrÿ|||ÿtttÿtttÿg	 ÿg	 ÿg	ÿg
+ ÿg	ÿg	ÿg	 ÿg
+ÿgÿ¬oAÿ¿_ÿÉwÿÒ°ÿÜÁ¨ÿæÒ¿ÿïâÖÿ÷ðêÿ÷ðêÿïã×ÿæÓÀÿÝÂ©ÿÓ±ÿÉ yÿÀ`ÿ¶}Hÿ¬l0ÿ¢[ÿAÿn*ÿXÿJÿMÿOÿMÿ*çÿ&÷ÿ&÷ÿ'÷ÿ'÷ÿ'÷ÿ.ÐÿLÿVÿ[ ÿZ ÿZ ÿYÿXÿXÿYÿ\ÿ`	ÿd ÿf ÿg
+ ÿg	 ÿg	ÿg	ÿg	ÿg
+ÿg	ÿg	ÿg	 ÿg	 ÿg	 ÿgÿjÿo"ÿv($ÿ{-)ÿ{.+ÿz-)ÿv)%ÿo$ÿjÿhÿhÿgÿiÿiÿjÿiÿiÿiÿhÿhÿiÿhÿiÿjÿjÿjÿkÿjÿjÿjÿl(ÿq0'ÿw6/ÿ{;4ÿ~?<ÿ}=9ÿx:6ÿr50ÿm.*ÿl%"ÿk$!ÿj#ÿk#ÿk$ÿk%ÿk%ÿl(%ÿm(&ÿm)'ÿm*'ÿm*(ÿm+(ÿm,(ÿk*$ÿk*$ÿl+%ÿl,%ÿl,%ÿm0-ÿn1/ÿo:6ÿuB>ÿ{HFÿMJÿNLÿMJÿxGAÿrA;ÿn<4ÿm4/ÿk5.ÿo85ÿp86ÿo97ÿp98ÿp:8ÿp;:ÿp<:ÿq=;ÿn84ÿm:5ÿn:5ÿn;6ÿn;7ÿq@>ÿqA>ÿqA?ÿqB@ÿqCAÿqDBÿrKHÿwRNÿ{UPÿZUÿ[Xÿ~ZUÿ}YWÿwTRÿtOMÿsKHÿrJIÿrKJÿsKJÿsLJÿoIDÿoIEÿoJFÿoJGÿoKHÿsPOÿtQPÿtQQÿsRQÿtSRÿtSSÿtSSÿtTSÿoPLÿpPMÿpQNÿqWRÿu^Zÿigÿmlÿonÿnlÿigÿzdbÿu`^ÿt]\ÿoYVÿpYVÿqYWÿpZXÿqZXÿw``ÿwaaÿwbbÿwbbÿwcbÿwdcÿwddÿq_]ÿq_^ÿq`^ÿra_ÿra`ÿxhhÿwihÿwkjÿ}qoÿxwÿ||ÿ~ÿyvÿ}tsÿwolÿsjhÿrihÿwnnÿxooÿzqqÿzqrÿyrsÿzssÿztsÿsnmÿsonÿsooÿsooÿ{vwÿzwxÿzwyÿ{yyÿ{yzÿ{z{ÿ{z{ÿzz{ÿtusÿzzyÿÿÿÿÿÿÿ{{zÿzz{ÿsssÿsssÿtttÿtttÿ|||ÿ|||ÿ|||ÿ|||ÿ|||ÿ|||ÿtttÿtttÿtttÿtttÿ|||ÿ|||ÿ|||ÿ|||ÿ|||ÿ|||ÿtttÿtttÿtttÿ|||ÿ|||ÿ|||ÿ|||ÿ|||ÿtttÿtttÿtttÿ|||ÿoiÿºFÿÌ`ÿ¿d!ÿ·MÿÙ`ÿÑi#ÿ×s)ÿà6ÿâFÿêZÿÒ`ÿ=-ÿ!%'ÿ`dhÿÿÿklmÿVWXÿÿøÛ¶ÿýà·ÿøÒ¦ÿõ¶sÿ°^5ÿG95ÿQQQÿZZZÿqqqÿyyyÿsssÿ|||ÿtttÿtttÿg	 ÿg	 ÿg
+ ÿg	 ÿg	 ÿg	 ÿg
+ÿg	 ÿg
+ÿ;!ÿ¿_ÿÉxÿÓ°ÿÜÂ©ÿæÓÁÿðäÙÿøóîÿùôïÿðåÚÿçÔÂÿÝÃªÿÓ±ÿÉ yÿÀaÿ¶}Hÿ¬l0ÿ¢[ÿLÿJ ÿJ ÿHÿ<ÿw1ÿcC6ÿI}«ÿ?Âÿ6Ôÿ0âÿ-êÿ.âÿA",ÿK
+ÿO ÿSÿXÿZÿ`ÿhÿp$ÿw*ÿy(ÿiÿdÿfÿg
+ÿg	ÿg	 ÿg
+ ÿg	ÿg
+ÿg	 ÿg	 ÿg	ÿg	ÿg
+ÿg
+ÿgÿhÿmÿn!ÿlÿm!ÿmÿjÿhÿhÿgÿhÿhÿiÿiÿh
+ÿh
+ÿiÿiÿiÿjÿiÿiÿiÿjÿjÿjÿiÿiÿkÿk ÿl$ ÿo.*ÿp1-ÿo.&ÿo0(ÿp0-ÿm(%ÿl%"ÿi"ÿi"ÿm%"ÿl%#ÿm&#ÿl&$ÿl(%ÿk%ÿk&ÿm)'ÿm)'ÿm+'ÿk("ÿk)#ÿm-)ÿn-*ÿn.+ÿm/,ÿm/,ÿl,&ÿl-'ÿn3/ÿo53ÿr>;ÿsA=ÿp?7ÿr?8ÿsA>ÿo96ÿp75ÿo65ÿn75ÿl5/ÿm50ÿp98ÿp:8ÿp:9ÿm72ÿm73ÿn84ÿp=;ÿq><ÿq><ÿq?=ÿq@=ÿm<7ÿn=7ÿqA?ÿqB@ÿqC@ÿn?;ÿnA;ÿoC>ÿuOMÿvQNÿuQNÿvROÿrNHÿnGCÿnFBÿrJHÿrJIÿsKIÿoHCÿoIDÿsMLÿtMLÿsNLÿsNMÿsONÿoKHÿoLHÿoLIÿsRQÿtSRÿtTSÿoOKÿoOKÿtUTÿtVTÿtVUÿuWVÿtZXÿt[Wÿt]Yÿx`_ÿyb`ÿxb_ÿv][ÿpWTÿoXUÿu^\ÿv^]ÿw^]ÿv__ÿw`_ÿq[Yÿp\Zÿwaaÿvbbÿwccÿq]]ÿr^]ÿxeeÿweeÿwffÿwfgÿwhgÿqb`ÿrcaÿwiiÿxkiÿ{omÿvliÿukhÿ{qpÿzqpÿxomÿxnnÿwnnÿqihÿsjiÿzqqÿzrrÿzrrÿsmlÿsmmÿ{tuÿztuÿzuvÿzvvÿsppÿtppÿsqqÿzyyÿ{yzÿtssÿstsÿtttÿzz{ÿ{{{ÿ}}}ÿxxwÿwwvÿxxwÿ}}}ÿ{{{ÿttsÿsssÿzz{ÿ{{|ÿ{{|ÿ{{|ÿtttÿtttÿ|||ÿ|||ÿtttÿtttÿ|||ÿ|||ÿ|||ÿ|||ÿtttÿtttÿ|||ÿ|||ÿtttÿtttÿ|||ÿ|||ÿ|||ÿtttÿtttÿ|||ÿ|||ÿtttÿ|||ÿ|||ÿ|||ÿtttÿtqpÿ³IÿÎ\ÿÊi"ÿ¥L!ÿÕRÿÞk&ÿÖt2ÿàDÿåYÿõ±uÿtWÿ"(ÿÿ¾¼¼ÿµµ·ÿ¸ººÿ¼ººÿÿÿùß¹ÿþÚ°ÿó¸ÿæRÿ_3%ÿIIIÿUUUÿcccÿkkkÿrrrÿtttÿtttÿtttÿtttÿg	 ÿg	ÿg
+ ÿg	ÿg	 ÿg	ÿg	ÿg
+ÿg	 ÿhÿ©mJÿÇtÿÑ­ÿÚ¾£ÿãÍ¹ÿëÜÍÿñæÛÿñæÜÿëÜÎÿäÎºÿÛ¿¤ÿÑ®ÿÈuÿ¾^ÿµ{Fÿ«j.ÿ¢YÿKÿJ ÿJ ÿJ ÿJ ÿJ ÿJ ÿJ ÿJ ÿJ ÿJ ÿJÿKÿKÿJÿJ ÿJ ÿJ ÿJ ÿJ ÿIÿ8ÿqÿb	ÿeÿg	ÿg	ÿg	ÿg	ÿg	ÿg
+ÿg	 ÿg	 ÿg
+ÿg	ÿg	ÿg	ÿg
+ÿh
+ÿhÿhÿfÿgÿg	ÿg
+ÿhÿgÿhÿiÿiÿiÿiÿhÿh
+ÿiÿjÿiÿjÿiÿjÿiÿjÿjÿiÿiÿiÿjÿjÿjÿjÿjÿjÿj ÿk ÿk!ÿiÿi!ÿi!ÿl$ ÿl$"ÿm%"ÿl&#ÿl'$ÿm'$ÿm'%ÿm)%ÿm(&ÿk' ÿk' ÿk(!ÿm,'ÿm,)ÿm-)ÿn-*ÿm-+ÿn/+ÿn/,ÿm/-ÿn0-ÿl.'ÿl.(ÿk/(ÿk0*ÿm41ÿm51ÿn42ÿn53ÿn64ÿp75ÿp75ÿp76ÿp86ÿm60ÿm71ÿm72ÿp;9ÿp<:ÿp=:ÿq=<ÿp=<ÿq>=ÿp>=ÿq?=ÿp@=ÿqA?ÿn=8ÿn>8ÿn?9ÿqCAÿqDAÿqECÿpEDÿpFDÿpFEÿqGEÿqHFÿrIGÿrIGÿoEAÿoFBÿoFBÿsKJÿsLKÿsLKÿtMLÿtNMÿtNNÿtOOÿtPOÿsQPÿtQQÿoMJÿoMJÿoNKÿtSRÿtTRÿtUSÿtVTÿuWUÿtWVÿtWVÿtYWÿsYXÿnTQÿoURÿoUSÿoVSÿt\Zÿu]\ÿv]\ÿw^]ÿv^^ÿv_^ÿw``ÿv``ÿwaaÿq\[ÿq][ÿq]\ÿxddÿwddÿweeÿwefÿwffÿxgfÿxhgÿwhhÿwihÿqcaÿrdcÿqdbÿwjjÿwkjÿwkkÿwllÿwmmÿxmmÿyooÿxpoÿypqÿsjjÿrlkÿrlkÿzssÿzssÿztuÿzuuÿ{vvÿ{vwÿ{wwÿ{wxÿzxxÿtqrÿtrrÿ{y{ÿ{z{ÿ{{|ÿ{{|ÿ{{|ÿzz{ÿzz{ÿzz{ÿzz{ÿsssÿsssÿzz{ÿ{{|ÿ{{|ÿ{{|ÿ{{|ÿ{{|ÿ|||ÿ|||ÿtttÿtttÿ|||ÿ|||ÿ|||ÿ|||ÿ|||ÿ|||ÿ|||ÿ|||ÿtttÿtttÿ|||ÿ|||ÿ|||ÿ|||ÿ|||ÿ|||ÿ|||ÿtttÿtttÿ|||ÿ|||ÿ|||ÿ|||ÿ|||ÿ|||ÿ£F%ÿÍWÿÕi!ÿ£_1ÿ±EÿãbÿÝy7ÿÝSÿå¢kÿíµÿ×µÿÿxyzÿtuvÿzyxÿÿÿ¹¹¹ÿÿÿñ¹ÿêNÿ<"ÿDDDÿRRRÿaaaÿfffÿlllÿoooÿ{{{ÿtttÿ|||ÿtttÿg
+ ÿg	 ÿg	 ÿg	ÿg	 ÿg	 ÿg	ÿg	 ÿg
+ÿg	 ÿnÿµ]ÿÍ§ÿÖ¶ÿÝÃ«ÿäÎ»ÿçÕÄÿèÕÄÿäÏ»ÿÞÄ¬ÿÖ¶ÿÎ¨ÿÅnÿ¼Wÿ²w@ÿ©g(ÿ VÿJÿJ ÿJ ÿJ ÿJ ÿJ ÿJ ÿJ ÿJ ÿJ ÿJ ÿJ ÿJ ÿJ ÿJ ÿJ ÿJ ÿJ ÿAÿ{*ÿhÿc ÿfÿg
+ ÿg	 ÿg	ÿg	ÿg	ÿg	ÿg	 ÿg
+ ÿg	ÿg	ÿg
+ ÿg	ÿg	ÿg
+ÿg
+ÿh
+ÿg
+ ÿgÿhÿh	ÿgÿgÿhÿiÿiÿiÿiÿhÿhÿiÿjÿh
+ÿiÿjÿjÿjÿjÿiÿiÿhÿiÿjÿiÿiÿjÿjÿjÿjÿkÿlÿjÿjÿjÿl"ÿj!ÿj"ÿl$!ÿl%"ÿl&#ÿl&#ÿm'$ÿl'%ÿj%ÿk&ÿj' ÿm*'ÿk'!ÿl("ÿk(#ÿm-)ÿm-*ÿn-+ÿn.+ÿm/,ÿm0-ÿl.&ÿl.'ÿn1/ÿn2/ÿl0)ÿm0*ÿn42ÿo43ÿo63ÿp64ÿp64ÿp75ÿm5/ÿl60ÿl60ÿp:7ÿp:8ÿm73ÿm83ÿp<;ÿp=;ÿq><ÿp><ÿp?=ÿq@=ÿm<7ÿn=8ÿn>8ÿqB@ÿn?:ÿo@:ÿn@;ÿqECÿqECÿqFDÿqFEÿrGEÿrHFÿoE@ÿnE@ÿnEAÿsJIÿoGBÿoGCÿoHDÿtLLÿsMLÿtNMÿsNNÿsPNÿtOOÿoKHÿoLJÿsQQÿtSRÿoOKÿoOKÿoPLÿtUTÿtVTÿtVUÿtWVÿuXVÿuXWÿpTPÿoTRÿuZYÿu[YÿpVTÿpWTÿv\[ÿv]]ÿw]]ÿw^^ÿv__ÿw`_ÿq\Yÿq\Zÿq]Zÿwbbÿq][ÿq^]ÿr^]ÿxeeÿwefÿwffÿxggÿxggÿxhhÿrcaÿrcbÿxjiÿrecÿredÿredÿxllÿxmmÿxnmÿxonÿyooÿyppÿrjiÿrkjÿzqrÿrlkÿsllÿsmmÿztuÿzuuÿ{vuÿ{vvÿ{wwÿtqpÿsqpÿ{yyÿ{yzÿtsrÿtssÿ{{|ÿ{{|ÿ{{|ÿ{{|ÿ{{|ÿtttÿtttÿ{{|ÿ{{|ÿtttÿtttÿ{{|ÿ{{|ÿ{{|ÿ{{|ÿ{||ÿtttÿ|||ÿ|||ÿtttÿtttÿ|||ÿ|||ÿ|||ÿ|||ÿtttÿtttÿ|||ÿtttÿtttÿ|||ÿ|||ÿ|||ÿ|||ÿtttÿtttÿ|||ÿtttÿtttÿ|||ÿ|||ÿ|||ÿ|||ÿtttÿ_RÿÇPÿÖk$ÿÉx=ÿdDÿºO ÿÞj*ÿãSÿã¡qÿæ³ÿïÄÿíÉ¥ÿÛÀ£ÿÙÀ¥ÿêÎ®ÿèÌªÿÿÿ¸¸¸ÿÿpÿQ9ÿPNNÿ[[[ÿaaaÿ___ÿgggÿaaaÿmmmÿzzzÿtttÿtttÿtttÿg
+ ÿg	 ÿg
+ ÿg
+ ÿg	ÿg	 ÿg	 ÿg	ÿg	ÿg	 ÿg	ÿmÿ«tWÿÐ«ÿÖ¶ÿÛ¿¥ÿÞÄ¬ÿÞÄ¬ÿÛÀ¦ÿÖ·ÿÐ«ÿÈwÿÀbÿ¸Mÿ¯q7ÿ¦a!ÿQ
+ÿJ ÿJ ÿJ ÿJ ÿJ ÿJ ÿJ ÿJ ÿJ ÿJ ÿJ ÿJ ÿJ ÿJ ÿJ ÿCÿ.ÿmÿc
+ ÿe ÿg
+ÿg	ÿg	ÿg	ÿg	ÿg
+ ÿg	 ÿg	 ÿg
+ ÿg	ÿg	ÿg
+ÿg	ÿg	ÿg	 ÿg	 ÿg	ÿg	 ÿg	 ÿhÿiÿhÿh	ÿh	ÿi
+ÿhÿgÿhÿhÿhÿiÿiÿiÿiÿjÿiÿhÿhÿjÿiÿiÿjÿjÿjÿjÿjÿkÿiÿiÿjÿkÿiÿiÿk ÿl!ÿk!ÿl#ÿl# ÿl# ÿk"ÿj#ÿj#ÿl&$ÿj%ÿk%ÿm(&ÿm)&ÿm)'ÿm)'ÿn+'ÿm+(ÿn,)ÿk)$ÿl*$ÿm.+ÿk+%ÿl,&ÿl,&ÿm0.ÿn1/ÿn2/ÿn20ÿn30ÿn31ÿl1*ÿl2+ÿl2,ÿo64ÿm3-ÿm4.ÿp86ÿp86ÿp98ÿp98ÿp;9ÿp;9ÿp<:ÿn84ÿm94ÿm:5ÿp><ÿm;7ÿm;7ÿp@=ÿqA?ÿpA?ÿqB@ÿqB@ÿqCBÿqDBÿn@<ÿoA=ÿqFDÿqFEÿnC>ÿnD?ÿsHFÿsIHÿsJHÿsJIÿsJJÿsLJÿsMJÿoHDÿoJEÿsNMÿoJGÿoJHÿoKHÿtPPÿtRPÿtRQÿtSRÿtSRÿtTRÿtTSÿpPMÿpPMÿtVUÿpROÿpSOÿpSPÿtXWÿtZYÿuZYÿu[Zÿu[Zÿu\[ÿpWTÿpXUÿpYVÿw_^ÿqZWÿp[Xÿwa`ÿvaaÿwbaÿwbbÿwccÿwdcÿwddÿq_]ÿq_]ÿxggÿqa_ÿqb`ÿrb`ÿxihÿwihÿwjiÿxkjÿxkkÿxlkÿrfeÿrhfÿxmnÿshgÿrihÿsjhÿyqpÿzpqÿzrqÿzrrÿzssÿztsÿtnnÿsonÿ{uvÿsooÿtpoÿzwxÿzxxÿzxyÿ{yzÿ{z{ÿz{{ÿtttÿtttÿ{{|ÿtttÿtttÿ{{|ÿ{{|ÿ{{|ÿ{{|ÿ{{|ÿ{{|ÿtttÿtttÿ{{|ÿtttÿtttÿ|||ÿ|||ÿ|||ÿ|||ÿ|||ÿtttÿtttÿtttÿtttÿ|||ÿ|||ÿ|||ÿ|||ÿ|||ÿtttÿtttÿ|||ÿtttÿ|||ÿ|||ÿ|||ÿ|||ÿ|||ÿtttÿ|||ÿtttÿtttÿ|||ÿ{yyÿ°I ÿÎg(ÿÚ>ÿÅ]ÿ§{]ÿ°W4ÿÏe1ÿáSÿæ¡nÿé±ÿíºÿòÆÿõÉÿôÇÿô¿ÿî­tÿ nÿ¡¤ÿ½½½ÿÿxuuÿTTTÿhhhÿkkkÿgggÿbbbÿcccÿpppÿqqqÿtttÿtttÿtttÿg	 ÿg	 ÿg	ÿg	 ÿg	ÿg	ÿg	 ÿg	ÿg	ÿg
+ÿg	 ÿg	ÿg	ÿB2ÿÁvÿÒ¯ÿÔ³ÿÔ³ÿÒ¯ÿÎ¨ÿÉwÿÂgÿ»Tÿ³xAÿ«i,ÿ¢ZÿLÿJ ÿJ ÿJ ÿJ ÿJ ÿJ ÿJ ÿJ ÿJ ÿJ ÿJ ÿIÿ=ÿ}+ÿmÿc	ÿe ÿf ÿg
+ ÿg
+ÿg	ÿg	ÿg	ÿg	ÿg	ÿg	ÿg	 ÿg	 ÿg	ÿg	ÿg	ÿg	ÿg	ÿg	ÿg	ÿg	 ÿg	 ÿg	 ÿg
+ÿh
+ÿhÿiÿh	ÿh
+ÿiÿiÿhÿgÿhÿhÿiÿiÿiÿiÿiÿjÿjÿhÿiÿhÿjÿiÿjÿjÿjÿjÿjÿjÿjÿjÿiÿjÿk ÿl ÿl!ÿl"ÿk#ÿl# ÿl$!ÿl%!ÿl%"ÿk$ÿk$ÿk%ÿm(%ÿl(&ÿm(&ÿm)'ÿm*'ÿm*'ÿm+(ÿm,)ÿm-)ÿk*$ÿl+%ÿk+%ÿk,%ÿn0,ÿn0.ÿn1.ÿn2/ÿn20ÿn21ÿo40ÿo41ÿm1+ÿm2,ÿl3-ÿm3-ÿo85ÿp86ÿo86ÿp97ÿp97ÿp;8ÿp;9ÿp;:ÿq<;ÿm94ÿm95ÿm:5ÿn;7ÿq?=ÿq@>ÿqA>ÿqA?ÿqB@ÿqC@ÿqCAÿqDBÿqDCÿnA<ÿnB=ÿoC=ÿoC?ÿrHFÿrIGÿsIHÿsIIÿsJIÿsKIÿsLJÿsLKÿsMKÿoIEÿoJFÿoJGÿoJHÿtPOÿtQPÿtQPÿtRQÿtSRÿtSRÿuTRÿuTSÿtUTÿpQMÿoQMÿpRNÿoSPÿuXWÿuYWÿtYYÿtZYÿuZZÿu\[ÿu\[ÿu]\ÿpXVÿpYVÿqYWÿqZWÿv`_ÿv``ÿwaaÿvbaÿvbbÿwcbÿwddÿwddÿwedÿr_^ÿq`^ÿqa_ÿxggÿxhgÿwihÿxiiÿxjiÿxjjÿxkkÿxllÿyllÿsgfÿshgÿsigÿxooÿxooÿyqpÿyppÿzrrÿzrsÿzssÿzstÿzttÿsonÿsonÿsooÿzwwÿ{wxÿzwxÿzyyÿ{yzÿ{zzÿzz{ÿ{{|ÿtttÿtttÿtttÿ{{|ÿ{{|ÿ{{|ÿ{{|ÿ{{|ÿ{{|ÿ{{|ÿ{{|ÿtttÿtttÿtttÿ|||ÿ|||ÿ|||ÿ|||ÿ|||ÿ|||ÿ|||ÿtttÿtttÿ|||ÿ|||ÿ|||ÿ|||ÿ|||ÿ|||ÿ|||ÿtttÿtttÿtttÿ|||ÿ|||ÿ|||ÿ|||ÿ|||ÿ|||ÿtttÿtttÿ|||ÿ|||ÿ|||ÿbWÿÄW"ÿÑy?ÿ×[ÿÏ}ÿÁÿµgÿ¸fBÿÃlAÿÑyIÿ×{IÿÙKÿÛMÿÙ~GÿÍn:ÿ¸[-ÿC%ÿxpnÿ¯±³ÿ¼¼¼ÿÿfffÿdddÿvvvÿgggÿcccÿkkkÿlllÿoooÿ{{{ÿtttÿtttÿg
+ ÿg	 ÿg
+ ÿg	 ÿg	ÿg	 ÿg
+ÿg	 ÿg	ÿg	 ÿg
+ÿg	 ÿg
+ÿg	ÿiÿ>/ÿ®x[ÿÇxÿÉwÿÅoÿÁcÿ»Uÿ´zDÿ­m2ÿ¥`ÿQ
+ÿJ ÿJ ÿJ ÿJ ÿJ ÿJ ÿJ ÿJ ÿNÿEÿ|-ÿrÿgÿdÿfÿg
+ÿg	 ÿg	ÿg
+ÿg
+ÿg	 ÿg	 ÿg	ÿg
+ÿg	ÿg	 ÿg	 ÿg	ÿg
+ÿg	 ÿg	 ÿg	ÿg	ÿg	ÿg	 ÿg	 ÿg	ÿg	ÿg
+ÿg	 ÿg
+ ÿiÿhÿh	ÿi
+ÿhÿhÿhÿiÿhÿhÿhÿiÿiÿjÿiÿiÿhÿjÿiÿjÿiÿiÿhÿjÿjÿjÿiÿiÿiÿjÿkÿkÿjÿjÿl"ÿl"ÿl"ÿl# ÿk"ÿj"ÿj#ÿl%"ÿm&$ÿl&%ÿj%ÿk%ÿk%ÿm)'ÿm*'ÿm*(ÿk("ÿl)#ÿk)#ÿm-*ÿm-+ÿm/+ÿn/,ÿl-%ÿl-'ÿn1.ÿn2/ÿm30ÿn30ÿl1*ÿl1+ÿp52ÿo53ÿp64ÿo65ÿl4.ÿl4.ÿm5/ÿp97ÿp:8ÿp;8ÿp;9ÿm73ÿm84ÿq=;ÿq=<ÿp>=ÿp>=ÿm<7ÿn<7ÿn=8ÿqA?ÿqB@ÿqC@ÿqDAÿn@;ÿnA;ÿqECÿrEDÿqGEÿrGFÿoD?ÿoE@ÿsIHÿrJHÿsJIÿsKIÿoHCÿoHCÿoIEÿsMLÿsNMÿtOMÿtOOÿoKHÿoLIÿtRQÿtRQÿtSRÿtSRÿpNKÿpOLÿoPMÿtUUÿuVUÿtWVÿtXVÿpSPÿpTPÿuYXÿuZYÿu[Zÿu[[ÿpWTÿqXUÿv]]ÿw^]ÿv^^ÿw_^ÿp[Yÿq[Yÿq\Yÿvbbÿwcbÿwccÿq]]ÿq^]ÿq_]ÿwfeÿwffÿwfgÿrb_ÿrbaÿrcaÿwjiÿxijÿxkjÿxkjÿrfdÿrgeÿxmmÿxnnÿxnnÿsihÿsiiÿrjjÿyqqÿzrqÿyrsÿsllÿtmmÿtnmÿzuvÿzvuÿzvwÿsooÿsppÿ{xxÿ{yyÿzyzÿ{y{ÿttsÿtttÿ{{|ÿ{{|ÿ{{|ÿtttÿtttÿ{{|ÿ{{|ÿ{{|ÿ{{|ÿtttÿtttÿ{{|ÿ{{|ÿ{{|ÿtttÿtttÿ|||ÿ|||ÿ|||ÿtttÿtttÿ|||ÿ|||ÿtttÿtttÿ|||ÿ|||ÿ|||ÿtttÿtttÿ|||ÿ|||ÿ|||ÿtttÿ|||ÿ|||ÿ|||ÿtttÿtttÿ|||ÿ|||ÿtttÿtttÿ|||ÿ{{{ÿM6ÿÈk8ÿÓOÿÖpÿÝ²ÿÞº ÿÓµÿÁ£ÿ¸ÿ·wÿ·qÿ§a;ÿ§EÿQ3+ÿEEEÿWWWÿVVUÿÿ½½½ÿ©©©ÿÿOOOÿpppÿgggÿkkkÿeeeÿkkkÿnnnÿsssÿtttÿtttÿg	 ÿg
+ÿg	 ÿg	ÿg
+ ÿg
+ÿg	ÿg
+ÿg	 ÿg
+ÿg	ÿg
+ÿg	 ÿg
+ ÿg	ÿg	ÿg	ÿjÿ/ÿH1ÿY8ÿ¡`7ÿ£`/ÿ¡]#ÿPÿFÿGÿEÿ@ÿBÿhdeÿXmÿGw«ÿ3Ôÿ3kµÿWÿbÿfÿg
+ÿg	 ÿg	 ÿg	 ÿg
+ÿg	ÿg	ÿg	ÿg
+ÿg	ÿg
+ ÿg	 ÿg	 ÿg	ÿg	ÿg
+ÿg	ÿg	ÿg	ÿg	 ÿg	 ÿg
+ ÿg	ÿg
+ÿg	ÿg
+ÿg	ÿg
+ÿhÿg
+ÿgÿgÿhÿhÿiÿiÿhÿiÿiÿiÿhÿi	ÿh	ÿh
+ÿiÿjÿjÿjÿjÿjÿjÿjÿiÿiÿiÿjÿjÿkÿjÿkÿkÿk ÿl ÿjÿj ÿj ÿj!ÿl# ÿl%!ÿl%"ÿm%#ÿm&#ÿm'%ÿl'%ÿl(&ÿm(&ÿk' ÿk'!ÿk'!ÿm+(ÿm+(ÿn,)ÿn.*ÿm.*ÿm.,ÿm/-ÿn0-ÿn0-ÿl.'ÿk/(ÿl0(ÿl0)ÿo41ÿo42ÿo52ÿo63ÿo63ÿp65ÿo75ÿo85ÿp86ÿl60ÿl71ÿm71ÿm72ÿp;:ÿp<:ÿq=<ÿq><ÿq><ÿq?=ÿq@=ÿq@>ÿqA>ÿm=8ÿn>9ÿn>9ÿn?:ÿqDBÿqEBÿrECÿqEDÿrFEÿrGEÿrHFÿrHGÿoE@ÿnEAÿoGBÿoGBÿsLJÿtLKÿsMLÿtMLÿsNMÿtNNÿtONÿsPOÿtQPÿoLIÿoLJÿoMJÿoNJÿtSSÿtTSÿtUTÿtVTÿuVUÿuWUÿuWVÿuXWÿtYXÿpTRÿpURÿpVSÿpVTÿv\[ÿu\\ÿv]\ÿv^^ÿv_^ÿv__ÿw`_ÿva`ÿwaaÿq\Zÿq][ÿq]\ÿwcdÿwdeÿxeeÿwfeÿxffÿwggÿwggÿxhhÿxihÿrcaÿrdbÿrecÿrecÿxllÿxllÿxmmÿymnÿynnÿxonÿxpoÿypqÿskiÿslkÿsmkÿzssÿzssÿztuÿzuuÿzvvÿ{vvÿzvwÿzwxÿtqqÿtqqÿsrrÿsssÿ{{{ÿ{{|ÿ{{|ÿ{{|ÿ{{|ÿ{{|ÿ{{|ÿtttÿtttÿtttÿtttÿ{{|ÿ{{|ÿ{{|ÿ{{|ÿ|{|ÿ|||ÿ|||ÿtttÿtttÿtttÿ|||ÿ|||ÿ|||ÿ|||ÿ|||ÿ|||ÿtttÿtttÿtttÿ|||ÿ|||ÿ|||ÿ|||ÿ|||ÿ|||ÿtttÿtttÿtttÿ|||ÿ|||ÿ|||ÿ|||ÿ|||ÿ|||ÿtttÿtttÿ|vtÿ«N*ÿÉuCÿÒTÿØvÿâº ÿéÈ¯ÿêË´ÿæÍ¸ÿáÇ³ÿÐpÿÁe-ÿr4 ÿSSSÿmmmÿeeeÿgggÿaaaÿªªªÿÅÅÅÿÿ[[[ÿaaaÿvvvÿkkkÿmmmÿeeeÿvvvÿsssÿ|||ÿtttÿg	 ÿg	 ÿg	 ÿg	ÿg	 ÿg	 ÿg	ÿg	 ÿg	 ÿg
+ÿg	ÿg
+ÿg	 ÿg	 ÿg	ÿg	ÿg	ÿg
+ ÿg	ÿg	 ÿg
+ÿfÿfÿe ÿe ÿe	 ÿe	 ÿdÿ^ÿ5a©ÿ"õÿ"õÿ"öÿ1j·ÿXÿbÿg	ÿg
+ÿg	 ÿg	 ÿg
+ÿg
+ ÿg	ÿg	ÿg	ÿg
+ÿg	ÿg
+ ÿg
+ ÿg	ÿg	 ÿg
+ ÿg
+ÿg	ÿg	ÿg	ÿg
+ ÿg	 ÿg	ÿg	 ÿg	 ÿg	ÿg	ÿg	ÿg	ÿg
+ÿhÿg
+ ÿgÿh	ÿgÿhÿhÿiÿiÿiÿhÿhÿhÿh	ÿiÿi
+ÿiÿiÿjÿiÿjÿjÿjÿiÿiÿjÿjÿiÿjÿkÿkÿkÿkÿk ÿjÿiÿi ÿl#ÿj!ÿj"ÿm%!ÿl$"ÿl&#ÿl&#ÿl&$ÿm(%ÿk%ÿk% ÿk& ÿm*'ÿk(!ÿk)"ÿk)"ÿm-*ÿm-*ÿm.+ÿm.+ÿn/,ÿn0,ÿk-&ÿk.'ÿn1/ÿn2/ÿl0)ÿl0*ÿo42ÿo52ÿo53ÿo64ÿo75ÿp85ÿl5.ÿl6/ÿl60ÿp:8ÿm71ÿm82ÿm73ÿp<;ÿp=;ÿp><ÿp?<ÿq?=ÿp@=ÿn<7ÿn=7ÿn=8ÿqB?ÿn?9ÿn?:ÿn@:ÿqECÿqECÿqEDÿrFEÿrGEÿrHFÿoE@ÿnE@ÿoEAÿsKIÿoGCÿoGCÿoHDÿtLLÿsMLÿsNMÿsNMÿtONÿtPOÿoLHÿoMIÿoMJÿtSRÿoNJÿoOLÿpOLÿuUSÿuUTÿtVUÿuWVÿtXWÿuYWÿpTQÿpURÿuZYÿuZZÿpWTÿpWTÿu]\ÿv]\ÿv^^ÿv^^ÿw_^ÿw``ÿq[Yÿq\Yÿq\Zÿwbbÿq]\ÿq^]ÿr^]ÿweeÿxeeÿwffÿwfgÿxggÿxhgÿqcaÿrcaÿxjjÿrdcÿrfdÿrfeÿxmlÿymlÿxnmÿxnnÿyonÿyopÿsjiÿsjiÿzqrÿsllÿsmlÿzstÿztuÿztuÿzuvÿzvwÿ{wwÿsppÿtqqÿ{yyÿtrrÿtrrÿsssÿ{{|ÿ{{|ÿ{{|ÿ{{|ÿ{{|ÿtttÿtttÿ{{|ÿtttÿtttÿ{{|ÿ{{|ÿ{{|ÿ{{|ÿ|{|ÿ|||ÿtttÿtttÿ|||ÿtttÿtttÿ|||ÿ|||ÿ|||ÿ|||ÿtttÿtttÿ|||ÿtttÿtttÿ|||ÿ|||ÿ|||ÿ|||ÿ|||ÿtttÿ|||ÿtttÿtttÿ|||ÿ|||ÿ|||ÿ|||ÿtttÿtttÿtttÿsssÿ}qmÿ§N+ÿÇm;ÿÏIÿÔ^ÿÜ¦ÿá³ÿÜ¤~ÿ×QÿÉ`'ÿ^LÿKJJÿ]]]ÿwwwÿvvvÿjjjÿbbbÿ}}}ÿÉÉÉÿ¦¦¦ÿuuuÿYYYÿmmmÿjjjÿgggÿeeeÿvvvÿsssÿtttÿtttÿg	 ÿg	 ÿg	 ÿg	 ÿg	ÿg
+ ÿg	 ÿg	ÿg
+ÿg	 ÿg	ÿg
+ ÿg	ÿg	ÿg
+ ÿg	ÿg	 ÿg	ÿg	ÿg	ÿg	 ÿg	ÿg	 ÿg	ÿg	ÿg	ÿg	 ÿb ÿF?kÿ!õÿ!õÿ!õÿ2g´ÿXÿb	 ÿg	 ÿg	 ÿg	 ÿg	ÿg	ÿg	ÿg	ÿg	 ÿg	 ÿg
+ÿg	 ÿg	 ÿg
+ÿg
+ÿg	ÿg	ÿg	ÿg	 ÿg	 ÿg	 ÿg	 ÿg	ÿg	ÿg	ÿg	ÿg	ÿg	 ÿg	 ÿg	 ÿg
+ ÿg	 ÿg
+ ÿhÿhÿh	ÿh
+ÿhÿgÿhÿhÿhÿhÿiÿiÿiÿjÿjÿiÿiÿhÿiÿiÿiÿiÿjÿjÿjÿjÿkÿjÿiÿjÿjÿjÿiÿk!ÿl!ÿl"ÿl"ÿl# ÿl$!ÿj"ÿj#ÿj$ÿl&$ÿj%ÿk%ÿm(%ÿm)&ÿl)'ÿm*'ÿm+'ÿm+(ÿm,)ÿk)#ÿk*$ÿm-*ÿk+%ÿl,%ÿl,&ÿn0.ÿn1.ÿn1.ÿn20ÿn30ÿn30ÿl2+ÿl1+ÿl2,ÿo64ÿm4-ÿl4.ÿo86ÿp97ÿp97ÿp98ÿp;8ÿp;:ÿp;:ÿm83ÿm94ÿn95ÿp>=ÿm:6ÿn<7ÿq@>ÿqA?ÿpB?ÿqB@ÿqCAÿqDAÿqDBÿn@<ÿnA<ÿoB=ÿoB>ÿoC?ÿoD?ÿsHFÿsIGÿsJHÿsKIÿsJJÿsLKÿsLKÿoIEÿoIFÿsNMÿoJFÿoJHÿoKHÿtPPÿtQQÿtRQÿtRRÿtSRÿtTSÿtUSÿoPMÿoPMÿtVUÿpROÿpROÿoSPÿuXXÿuZYÿuZYÿu[Zÿu[Zÿv\[ÿpXUÿpXVÿpYVÿw^^ÿq[Wÿq[Xÿv``ÿvaaÿwaaÿwcbÿwccÿwdcÿwedÿq_]ÿq`]ÿwffÿqa_ÿrb`ÿrb`ÿxihÿxihÿxjiÿxkjÿxkkÿxllÿsgeÿrgfÿxnmÿshgÿsihÿrihÿyppÿypqÿyrqÿzsrÿzssÿsmmÿsnmÿsonÿzuvÿtooÿspoÿzxwÿzxyÿ{xyÿ{yyÿ{z{ÿ{{|ÿtttÿtttÿ{{|ÿtttÿtttÿ{{|ÿ{{|ÿ{{|ÿ{{|ÿ{{|ÿtttÿtttÿtttÿtttÿtttÿtttÿ|||ÿ|||ÿ|||ÿ|||ÿ|||ÿtttÿtttÿtttÿtttÿ|||ÿ|||ÿ|||ÿ|||ÿ|||ÿtttÿtttÿ|||ÿtttÿtttÿ|||ÿ|||ÿ|||ÿ|||ÿtttÿtttÿtttÿtttÿ|||ÿ|||ÿ|||ÿ|||ÿsssÿyusÿN:ÿ°R(ÿÃ]+ÿÆd.ÿÇc-ÿÀU!ÿ G%ÿwnÿrx|ÿtuuÿ^^^ÿmmmÿ{{{ÿjjjÿmmmÿhhhÿ¹¹¹ÿ½½½ÿ|||ÿXXXÿrrrÿdddÿgggÿnnnÿpppÿsssÿtttÿtttÿg	 ÿg	 ÿg	ÿg
+ ÿg	ÿg
+ÿg
+ ÿg	ÿg	ÿg	ÿg
+ ÿg	ÿg	ÿg	ÿg	ÿg
+ ÿg	 ÿg	ÿg	ÿg	ÿg	 ÿg	 ÿg
+ ÿg	ÿg	ÿg	ÿcÿQ%4ÿ"îÿ!õÿ!õÿ4b¬ÿYÿcÿg
+ÿg	 ÿg	 ÿg	 ÿg	ÿg
+ÿg
+ÿg
+ÿg	ÿg	 ÿg	 ÿg	 ÿg	ÿg	ÿg	ÿg	ÿg	ÿg
+ÿg	 ÿg	 ÿg	 ÿg
+ ÿg	ÿg	ÿg
+ÿg	ÿg	ÿg	ÿg	 ÿg	 ÿg
+ ÿg	 ÿhÿhÿiÿh	ÿi	ÿh
+ÿhÿhÿgÿhÿiÿiÿiÿiÿiÿiÿjÿiÿhÿiÿiÿiÿiÿjÿjÿjÿjÿjÿkÿiÿiÿjÿiÿlÿl ÿk!ÿk"ÿl" ÿl# ÿl$!ÿl%!ÿk#ÿk#ÿk$ÿj%ÿk%ÿm(%ÿm(&ÿm)'ÿm*'ÿm+'ÿm+(ÿm,(ÿn-)ÿk+$ÿl*%ÿk,%ÿl,%ÿm0-ÿm0.ÿn1.ÿn2.ÿn2/ÿn30ÿn40ÿo42ÿl1+ÿl2,ÿl3,ÿl4-ÿm4.ÿo86ÿp86ÿp98ÿp:8ÿp:9ÿp;9ÿp<:ÿq<:ÿm95ÿn:5ÿn:6ÿm;7ÿq?=ÿp@=ÿq@?ÿqA?ÿqB@ÿqCAÿqCAÿqDBÿqEBÿnA<ÿoB=ÿnC>ÿnC>ÿrGFÿrIGÿsIGÿsJIÿsJIÿsKJÿsKJÿsLKÿsLLÿoIEÿoJFÿoJGÿoJGÿsPOÿsPPÿtQQÿtRQÿtRRÿtSRÿtTSÿtTSÿoPLÿpQMÿoRNÿoQNÿpSOÿuXWÿtYXÿuYXÿtZYÿuZZÿu[Zÿv\[ÿv]\ÿpXVÿpXVÿqZWÿqZWÿw__ÿva`ÿwa`ÿvaaÿwbbÿwccÿwccÿxddÿr^]ÿr`]ÿq`^ÿqa^ÿqb_ÿwhhÿxihÿxihÿxiiÿwjjÿxkjÿxkkÿxllÿrgfÿrggÿrhgÿsigÿyppÿyppÿzqqÿzqrÿzsrÿzssÿzttÿsnnÿsonÿsooÿsooÿzwxÿzwxÿ{xxÿ{yyÿ{yzÿ{y{ÿ{z|ÿ{{|ÿtttÿtttÿtttÿ{{|ÿ{{|ÿ{{|ÿ{{|ÿ{{|ÿ{{|ÿ{{|ÿtttÿtttÿtttÿtttÿ{||ÿ|||ÿ|||ÿ|||ÿ|||ÿ|||ÿtttÿtttÿtttÿtttÿ|||ÿ|||ÿ|||ÿ|||ÿ|||ÿ|||ÿtttÿtttÿtttÿ|||ÿ|||ÿ|||ÿ|||ÿ|||ÿtttÿtttÿtttÿ|||ÿ|||ÿ|||ÿ|||ÿ|||ÿtttÿsssÿqqqÿurrÿ|_VÿQAÿO@ÿgTNÿa__ÿdloÿÿsssÿ___ÿ___ÿoooÿ{{{ÿoooÿkkkÿªªªÿÏÏÏÿÿPPPÿdddÿgggÿnnnÿsssÿrrrÿ|||ÿtttÿtttÿg	 ÿg	 ÿg	 ÿg	 ÿg	 ÿg
+ ÿg	ÿg	 ÿg	ÿg	 ÿg
+ÿg	 ÿg
+ÿg	 ÿg	 ÿg	ÿg	ÿg	 ÿg
+ÿg	 ÿg	ÿg	ÿg	ÿg	 ÿg	ÿd	ÿXÿ(vÙÿ õÿ õÿ7YÿZ
+
+ÿcÿg
+ ÿg	 ÿg	ÿg
+ÿg	ÿg	 ÿg	ÿg
+ÿg
+ ÿg	 ÿg	ÿg	ÿg	ÿg
+ ÿg	 ÿg
+ÿg
+ÿg	 ÿg	 ÿg	ÿg	ÿg	ÿg	ÿg	 ÿg	 ÿg	ÿg	ÿg	 ÿg	 ÿg
+ÿg	ÿg
+ÿg
+ÿg
+ ÿg
+ ÿhÿh	ÿgÿgÿhÿiÿhÿiÿhÿhÿhÿiÿiÿh
+ÿh
+ÿhÿjÿiÿjÿjÿiÿiÿjÿjÿkÿiÿjÿjÿkÿjÿkÿjÿiÿjÿl"ÿl# ÿm# ÿk"ÿj#ÿl%"ÿm%#ÿm&#ÿm'%ÿl(%ÿk%ÿk%ÿm*'ÿm*'ÿm*(ÿl("ÿl)#ÿk)#ÿn-*ÿm.*ÿm/,ÿm/,ÿk,&ÿl-'ÿl-'ÿn2/ÿn20ÿl0)ÿl1*ÿm2+ÿo52ÿo63ÿp64ÿo74ÿo75ÿm5/ÿm5/ÿp:7ÿp:8ÿp;8ÿm72ÿm83ÿm93ÿq=;ÿq><ÿp>=ÿq?=ÿm<7ÿn<7ÿn=7ÿqB?ÿqB?ÿqC@ÿn?:ÿn@;ÿnA;ÿqECÿrEDÿqFEÿqGFÿnC?ÿnD@ÿnE@ÿsJHÿsJIÿsKIÿoGCÿoHDÿoHDÿtMLÿsNMÿtONÿsONÿoKHÿoLIÿoLJÿtRQÿtSQÿtSSÿoOKÿoOLÿtUSÿuVTÿtVUÿtWVÿtXVÿoTPÿpTPÿpTRÿuZYÿuZZÿpWTÿpWTÿpXUÿv]\ÿw^]ÿv_^ÿw__ÿq[Xÿq[Yÿq\Yÿwaaÿwbbÿwccÿq^\ÿq^]ÿxeeÿwfeÿwffÿwggÿxhgÿrbaÿqcaÿwihÿxjjÿxjjÿredÿreeÿrffÿxmmÿxnmÿynnÿyonÿsjiÿsjiÿzqqÿzrrÿzssÿsmlÿsmmÿztuÿzuuÿzuvÿzvwÿtpoÿtppÿtqpÿzyzÿ{yzÿtrsÿtssÿtttÿ{{|ÿ{{|ÿ{{|ÿtttÿtttÿtttÿ{{|ÿ{{|ÿtttÿtttÿ{{|ÿ{{|ÿ{{|ÿ{{|ÿtttÿtttÿ|||ÿ|||ÿtttÿtttÿ|||ÿ|||ÿ|||ÿ|||ÿtttÿtttÿ|||ÿ|||ÿtttÿtttÿ|||ÿ|||ÿ|||ÿtttÿtttÿ|||ÿ|||ÿtttÿ|||ÿ|||ÿ|||ÿtttÿtttÿ|||ÿ|||ÿtttÿ|||ÿ|||ÿ|||ÿtttÿ{{{ÿxxxÿnnnÿwwwÿyyyÿmooÿÿÿzzzÿ[[[ÿiiiÿoooÿsssÿpppÿÿÛÛÛÿÿNNNÿ```ÿpppÿhhhÿpppÿsssÿtttÿtttÿtttÿg	 ÿg
+ÿg	 ÿg	ÿg	 ÿg	ÿg	ÿg	ÿg	 ÿg
+ÿg	ÿg	ÿg	 ÿg	ÿg	ÿg	ÿg	ÿg	ÿg	 ÿg	ÿg	ÿg	ÿg	ÿg
+ÿe ÿ\ÿ/h¾ÿõÿõÿ<Oÿ\	ÿd ÿg	 ÿg	ÿg	ÿg	ÿg	ÿg	ÿg	ÿg
+ ÿg
+ ÿg
+ÿg	ÿg
+ÿg	ÿg
+ÿg	ÿg
+ÿg	 ÿg
+ ÿg
+ÿg
+ÿg	ÿg	ÿg	ÿg
+ÿg
+ÿg	ÿg
+ ÿg	 ÿg	ÿg	ÿg
+ÿg	ÿg
+ÿhÿhÿhÿhÿhÿh
+ÿi
+ÿiÿiÿiÿhÿiÿiÿiÿh	ÿh	ÿiÿjÿiÿiÿjÿjÿjÿjÿjÿiÿiÿiÿjÿjÿkÿkÿkÿkÿk ÿk!ÿk!ÿj ÿj ÿj!ÿm$!ÿl$!ÿl%"ÿl&#ÿl&$ÿm'%ÿm'%ÿm(%ÿm)&ÿk&ÿk' ÿk(!ÿm+(ÿm,(ÿn,)ÿm-*ÿm.+ÿn/+ÿn/,ÿm/-ÿn0-ÿm1.ÿl.(ÿl/(ÿn30ÿn30ÿn41ÿo42ÿo53ÿo64ÿo74ÿp75ÿo86ÿp97ÿm70ÿm60ÿm72ÿp;9ÿp<9ÿp<:ÿq=;ÿp><ÿq><ÿq>=ÿp@=ÿq@>ÿqA?ÿm>8ÿn>9ÿn>9ÿqCAÿqCBÿqDCÿqECÿqFDÿrFDÿrGEÿrGFÿsHGÿsIGÿnEAÿoFBÿoGCÿtLJÿsLKÿtMLÿtMMÿsNMÿtONÿtONÿsPOÿsQOÿtRPÿoMJÿoNJÿoOKÿtTRÿuTSÿtUTÿtVTÿtVUÿuWVÿuXWÿuXWÿuYWÿuZXÿpURÿpVSÿv[Zÿu\\ÿv]\ÿv]\ÿw^]ÿv^^ÿv__ÿw`_ÿwa`ÿvaaÿq]Zÿq][ÿq]\ÿxdcÿwddÿwdeÿxffÿxffÿxggÿxggÿwhgÿwihÿrcbÿrdbÿredÿxkjÿxllÿymlÿymmÿymmÿxnnÿxooÿypoÿyppÿskjÿrlkÿsllÿzssÿzttÿztuÿzuuÿ{uvÿ{vwÿzwwÿ{wxÿzxxÿsrqÿsrrÿ{z{ÿ{{{ÿ{{|ÿ{{|ÿ{{|ÿ{{|ÿ{{|ÿ{{|ÿ{{|ÿtttÿtttÿ{{|ÿ{{|ÿ{{|ÿ{{|ÿ{{|ÿ{||ÿ|||ÿ|||ÿtttÿtttÿ|||ÿ|||ÿ|||ÿ|||ÿ|||ÿ|||ÿ|||ÿ|||ÿtttÿtttÿ|||ÿ|||ÿ|||ÿ|||ÿ|||ÿ|||ÿ|||ÿtttÿtttÿ|||ÿ|||ÿ|||ÿ|||ÿ|||ÿ|||ÿtttÿtttÿ|||ÿ|||ÿ|||ÿ|||ÿ|||ÿtttÿtttÿ|||ÿ|||ÿ|||ÿ{{{ÿfffÿÿÿ}}}ÿbbbÿfffÿsssÿpppÿµµµÿÞÞÞÿwwwÿPPPÿhhhÿqqqÿyyyÿsssÿ|||ÿtttÿ|||ÿtttÿg	 ÿg	 ÿg	 ÿg	 ÿg
+ ÿg
+ ÿg
+ÿg	 ÿg	ÿg	 ÿg
+ÿg	 ÿg	ÿg	 ÿg	 ÿg
+ÿg
+ ÿg	 ÿg	ÿg	 ÿg
+ÿg
+ÿg
+ÿe ÿ^	ÿ6WÿôÿòÿAAqÿ]	ÿd ÿg
+ÿg
+ÿg	 ÿg
+ ÿg	ÿg	ÿg
+ ÿg	 ÿg	ÿg	ÿg
+ ÿg	 ÿg	ÿg	ÿg	ÿg
+ ÿg	 ÿg	ÿg	ÿg
+ ÿg	 ÿg	 ÿg	ÿg	ÿg	 ÿg	 ÿg
+ ÿg
+ÿg	ÿg	 ÿg	 ÿg	ÿg	ÿg	ÿh
+ÿg
+ ÿg
+ÿhÿh	ÿgÿgÿhÿiÿiÿiÿhÿhÿhÿiÿiÿh
+ÿh
+ÿiÿjÿjÿjÿjÿiÿiÿiÿjÿjÿiÿiÿjÿjÿkÿk ÿjÿjÿj ÿl"ÿl"ÿm# ÿj!ÿk#ÿm%"ÿm%#ÿl'#ÿm'$ÿk%ÿk%ÿj%ÿm)'ÿm*'ÿm+'ÿk(!ÿl)#ÿk)#ÿm-*ÿm.*ÿn.+ÿn/,ÿl-&ÿl-&ÿl.'ÿn2/ÿn20ÿl0)ÿl0*ÿm1+ÿp42ÿo53ÿp63ÿo64ÿm4.ÿm5/ÿm50ÿp98ÿp:8ÿp:8ÿm73ÿm83ÿm84ÿp=;ÿq=<ÿp><ÿp?=ÿm;7ÿn<7ÿn=7ÿpA?ÿqB@ÿqCAÿn?:ÿn@:ÿn@;ÿqECÿqFDÿqFDÿrGEÿoD?ÿoE?ÿoEAÿsJHÿsJHÿsKIÿoGCÿoIDÿoHDÿsMLÿsNMÿtONÿsONÿoKHÿoKIÿoLJÿtQQÿsSRÿtSRÿoOKÿoPLÿoPMÿuVTÿtVUÿuWVÿuWWÿpTPÿoSQÿpTQÿuZYÿu[ZÿpVSÿqWTÿqWTÿv^\ÿv]]ÿw_^ÿw__ÿp[Yÿq\Yÿq\Zÿwbaÿwcbÿwccÿq^]ÿq^]ÿq_]ÿwefÿxffÿwgfÿwggÿrb`ÿrb`ÿxihÿxjjÿxjjÿrecÿrfdÿrgeÿxmlÿynmÿynoÿyooÿsjiÿrkjÿypqÿzqrÿyrrÿsllÿtnmÿzttÿzuuÿzvuÿ{vwÿtooÿtppÿtqqÿ{yyÿ{yzÿtrrÿtstÿtttÿ{{|ÿ{{|ÿ{{|ÿtttÿtttÿtttÿ{{|ÿ{{|ÿtttÿtttÿ{{|ÿ{{|ÿ{{|ÿ|||ÿtttÿtttÿ|||ÿ|||ÿtttÿtttÿtttÿ|||ÿ|||ÿtttÿtttÿtttÿ|||ÿ|||ÿtttÿtttÿ|||ÿ|||ÿ|||ÿtttÿtttÿ|||ÿ|||ÿtttÿtttÿ|||ÿ|||ÿtttÿtttÿ|||ÿ|||ÿtttÿ|||ÿ|||ÿ|||ÿtttÿ|||ÿ|||ÿtttÿ|||ÿ|||ÿ|||ÿrrrÿbbbÿÿÿtttÿzzzÿiiiÿÿòòòÿÆÆÆÿOOOÿ___ÿjjjÿzzzÿsssÿtttÿtttÿtttÿtttÿtttÿg	 ÿg	 ÿg	ÿg
+ ÿg
+ÿg
+ÿg	 ÿg	ÿg	ÿg
+ÿg	 ÿg	ÿg
+ÿg	ÿg	ÿg
+ ÿg
+ÿg
+ÿg	ÿg	ÿg	 ÿg	 ÿf ÿ_ÿ>Hÿôÿ |ëÿH1Pÿ^ ÿe ÿg
+ÿg
+ÿg	ÿg	ÿg	ÿg	 ÿg	 ÿg	ÿg	ÿg	ÿg	ÿg	ÿg	ÿg	 ÿg
+ ÿg	 ÿg	ÿg	ÿg
+ÿg
+ÿg	ÿg	ÿg	ÿg	 ÿg	 ÿg
+ÿg	ÿg	ÿg	ÿg	ÿg	ÿg	ÿg
+ ÿg	 ÿg	 ÿg	 ÿhÿhÿhÿh	ÿh
+ÿhÿhÿhÿhÿhÿiÿiÿiÿiÿiÿiÿiÿiÿhÿhÿiÿhÿjÿjÿjÿjÿjÿjÿjÿiÿjÿiÿiÿk ÿk ÿk!ÿl!ÿl" ÿm# ÿl$!ÿl%"ÿj#ÿk#ÿj$ÿj%ÿl'$ÿm(&ÿm)&ÿm)&ÿm*'ÿm+'ÿm+(ÿm,)ÿn,)ÿk*$ÿl+$ÿk,%ÿl,%ÿn0-ÿn0-ÿn1/ÿm1/ÿn20ÿn31ÿn31ÿo42ÿl2+ÿm2,ÿl3-ÿm3.ÿp75ÿp85ÿp86ÿp98ÿp98ÿo:8ÿq;9ÿp;:ÿp=:ÿm94ÿm:5ÿm;6ÿn;6ÿp@=ÿq@>ÿq@?ÿqB?ÿqB?ÿqBAÿqCAÿqDBÿrDCÿoA=ÿoA=ÿoC>ÿnC>ÿrHFÿrHGÿsIGÿsIHÿsKIÿsJIÿsKJÿsLKÿsMLÿoJFÿoJFÿoJFÿoJGÿtPOÿsPOÿtQPÿtRRÿtSRÿtSRÿuSRÿuUSÿtUSÿoQMÿpQNÿoRNÿpRPÿtXWÿuYXÿuZYÿtZYÿu[Zÿu[Zÿu\[ÿv]\ÿpXUÿqYVÿqZWÿqZWÿv`_ÿv``ÿwaaÿvaaÿwbbÿwccÿwdcÿwddÿxeeÿq_^ÿqa^ÿqa_ÿrb_ÿwhhÿxihÿxjiÿxjiÿxkjÿxkkÿyllÿxmmÿsgfÿrgfÿshgÿrihÿyopÿyppÿyqqÿyrrÿzrrÿzrsÿzttÿsnnÿtonÿsonÿsooÿ{vwÿ{wxÿzwxÿ{yyÿ{zzÿ{zzÿ{z|ÿ{{|ÿtttÿtttÿtttÿ{{|ÿ{{|ÿ{{|ÿ{{|ÿ{{|ÿ{{|ÿ{{|ÿtttÿtttÿtttÿtttÿ|||ÿ|||ÿ|||ÿ|||ÿ|||ÿ|||ÿ|||ÿtttÿtttÿ|||ÿ|||ÿ|||ÿ|||ÿ|||ÿ|||ÿ|||ÿtttÿtttÿtttÿ|||ÿ|||ÿ|||ÿ|||ÿ|||ÿ|||ÿtttÿtttÿ|||ÿ|||ÿ|||ÿ|||ÿ|||ÿtttÿtttÿtttÿ|||ÿ|||ÿ|||ÿ|||ÿtttÿtttÿtttÿ|||ÿzzzÿbbbÿrrrÿÿ}}}ÿÿØØØÿØØØÿuuuÿaaaÿtttÿzzzÿtttÿ|||ÿ|||ÿtttÿ|||ÿtttÿtttÿg	 ÿg	 ÿg	 ÿg	 ÿg	ÿg	 ÿg
+ ÿg	 ÿg
+ÿg
+ ÿg
+ÿg	 ÿg	ÿg	ÿg
+ ÿg
+ÿg	 ÿg	ÿg	ÿg	 ÿg	 ÿfÿ` ÿC;gÿ~ôÿ$tÝÿN$6ÿ` ÿfÿg
+ ÿg
+ ÿg
+ÿg	ÿg	ÿg	 ÿg	ÿg	ÿg	 ÿg	 ÿg	ÿg
+ÿg
+ÿg	 ÿg	 ÿg
+ÿg
+ ÿg	 ÿg	 ÿg	ÿg	ÿg	ÿg	 ÿg	 ÿg	ÿg	ÿg	 ÿg	 ÿg	ÿg
+ÿg
+ÿg	ÿg	 ÿg
+ ÿg	ÿg
+ÿg
+ ÿg
+ ÿiÿhÿh	ÿh
+ÿgÿgÿhÿhÿhÿgÿhÿiÿiÿjÿiÿhÿhÿhÿiÿiÿhÿiÿiÿjÿjÿjÿiÿiÿjÿkÿkÿjÿjÿiÿk"ÿl!ÿl#ÿl# ÿj!ÿj"ÿj#ÿm%"ÿl&$ÿj%ÿk%ÿk%ÿm(&ÿm)'ÿm*'ÿm+(ÿn+(ÿl)#ÿk*#ÿk*$ÿm.+ÿn.+ÿk,&ÿl-&ÿl.'ÿn1/ÿn2/ÿn20ÿn30ÿl0*ÿl1*ÿl2+ÿo53ÿo64ÿm3.ÿm4.ÿm5/ÿm6/ÿp97ÿp:7ÿp;8ÿp;:ÿn73ÿn84ÿn94ÿp><ÿp>=ÿm;7ÿn;7ÿn<7ÿqA?ÿqA?ÿqB@ÿqB@ÿqCAÿo@;ÿnA;ÿnB<ÿqFDÿqGEÿoC>ÿoD?ÿoD@ÿsIHÿsJHÿsJHÿsKIÿsKJÿoHDÿoIEÿoIEÿsNMÿtONÿoJHÿoJHÿoLIÿtQQÿtRQÿtRRÿtSRÿoNKÿpOLÿoPLÿoQMÿtVUÿtWUÿpSPÿpSPÿpTPÿuZYÿuZYÿuZZÿu[ZÿpVUÿpWUÿpXUÿv]]ÿv^^ÿq[Wÿp[Xÿq[Yÿva`ÿvabÿwcbÿwccÿwccÿr^]ÿq_]ÿr_^ÿxffÿwggÿqb_ÿrbaÿqcaÿxihÿxjiÿxjjÿxkkÿreeÿrfeÿrgeÿxnmÿyonÿrihÿrjiÿsjiÿzqqÿzqrÿzssÿzrtÿsmmÿsnmÿtnnÿ{uvÿtooÿspoÿtppÿzwyÿ{yyÿ{yzÿ{zzÿtssÿtttÿtttÿ{{|ÿtttÿtttÿtttÿ{{|ÿ{{|ÿ{{|ÿ{{|ÿtttÿtttÿ{{|ÿ{{|ÿtttÿtttÿ|||ÿ|||ÿ|||ÿ|||ÿtttÿtttÿ|||ÿ|||ÿtttÿtttÿ|||ÿ|||ÿ|||ÿtttÿtttÿtttÿ|||ÿtttÿtttÿ|||ÿ|||ÿ|||ÿtttÿtttÿ|||ÿ|||ÿtttÿ|||ÿ|||ÿ|||ÿtttÿtttÿ|||ÿtttÿtttÿ|||ÿ|||ÿtttÿtttÿ|||ÿtttÿtttÿ|||ÿzzzÿgggÿ___ÿnnnÿÿyyyÿZZZÿbbbÿkkkÿzzzÿtttÿtttÿtttÿ|||ÿtttÿtttÿtttÿtttÿg	 ÿg	ÿg
+ ÿg
+ÿg
+ ÿg	ÿg
+ÿg
+ÿg
+ ÿg	ÿg
+ÿg	ÿg	 ÿg
+ ÿg	ÿg	ÿg
+ÿg	 ÿg	 ÿg	ÿf	ÿ`ÿG2Yÿ{òÿ*hÇÿTÿaÿfÿg
+ÿg	ÿg	ÿg	 ÿg	 ÿg	 ÿg	ÿg	ÿg	ÿg	ÿg	ÿg	 ÿg	 ÿg
+ ÿg	ÿg	ÿg	ÿg	ÿg
+ÿg	ÿg	 ÿg	 ÿg	 ÿg	ÿg	ÿg
+ÿg	ÿg	ÿg	ÿg	 ÿg
+ ÿg
+ ÿg	 ÿg	ÿg	ÿg	ÿg	ÿg
+ÿhÿg
+ÿgÿgÿgÿh
+ÿi
+ÿiÿiÿhÿhÿiÿhÿh	ÿh	ÿi
+ÿiÿiÿjÿjÿjÿjÿjÿiÿiÿiÿiÿjÿjÿkÿkÿkÿkÿkÿl!ÿiÿj ÿj ÿj!ÿl$ ÿl$!ÿl%"ÿl&#ÿm&#ÿl'$ÿm(%ÿm(&ÿk&ÿj' ÿk' ÿk(!ÿk("ÿm,)ÿm-)ÿm-*ÿn-+ÿn/+ÿm/,ÿm/-ÿm0-ÿl-'ÿl/(ÿl/(ÿl0)ÿn31ÿo42ÿo42ÿo53ÿo63ÿp65ÿo85ÿo85ÿp86ÿm60ÿm71ÿm71ÿn72ÿp;:ÿp<:ÿq=<ÿp><ÿp>=ÿq?=ÿq?=ÿp@>ÿn<7ÿn=8ÿn>9ÿn?9ÿn@:ÿrDBÿqECÿrFCÿqFCÿrFEÿrGEÿrHFÿrHGÿoEAÿoFAÿoFBÿoFCÿoGCÿsLKÿsMKÿtNMÿtNMÿtONÿtPNÿtPOÿtPOÿoMJÿoMJÿoMJÿoNKÿtSRÿtUSÿtUTÿuUTÿuVUÿuWUÿuWWÿuXWÿuYXÿpTRÿpURÿpUSÿpWSÿu[\ÿu][ÿv]\ÿv^]ÿv_^ÿw_^ÿw`_ÿv``ÿq\Zÿq\Zÿq][ÿq][ÿq]\ÿwddÿwedÿxfeÿwffÿwggÿxggÿxhgÿxihÿrcbÿrdbÿrdcÿredÿylkÿxmlÿymmÿxnmÿynnÿxooÿxooÿyppÿskjÿskkÿsmkÿsmlÿzstÿztuÿzuuÿzvvÿzvwÿ{wwÿ{wxÿtqpÿtrqÿtrrÿsssÿ{z|ÿ{{|ÿ{{|ÿ{{|ÿ{{|ÿ{{|ÿ{{|ÿtttÿtttÿtttÿtttÿ{{|ÿ{{|ÿ{{|ÿ{{|ÿ{{|ÿ|||ÿtttÿtttÿtttÿtttÿ|||ÿ|||ÿ|||ÿ|||ÿ|||ÿ|||ÿtttÿtttÿtttÿ|||ÿ|||ÿ|||ÿ|||ÿ|||ÿ|||ÿtttÿtttÿtttÿ|||ÿ|||ÿ|||ÿ|||ÿ|||ÿtttÿtttÿtttÿ|||ÿ|||ÿ|||ÿ|||ÿ|||ÿtttÿtttÿ|||ÿ|||ÿ|||ÿ|||ÿ|||ÿtttÿtttÿ{{{ÿvvvÿhhhÿ```ÿ]]]ÿiiiÿuuuÿ{{{ÿtttÿ|||ÿ|||ÿ|||ÿtttÿ|||ÿtttÿ|||ÿtttÿg	 ÿg	 ÿg	 ÿg	ÿg	 ÿg	 ÿg
+ÿg	 ÿg	ÿg	 ÿg	ÿg	 ÿg
+ÿg
+ ÿg	 ÿg
+ÿg	 ÿg	 ÿg	ÿf ÿ`ÿI-Oÿxïÿ3W£ÿYÿc ÿf ÿg	ÿg	ÿg
+ ÿg
+ ÿg
+ ÿg	ÿg	 ÿg	 ÿg	ÿg	ÿg	 ÿg
+ ÿg
+ ÿg	ÿg	 ÿg	 ÿg	ÿg
+ÿg
+ÿg	 ÿg	 ÿg	 ÿg	ÿg	 ÿg	 ÿg	 ÿg	ÿg	ÿg	 ÿg
+ ÿg	 ÿg	ÿg
+ÿg
+ ÿg
+ ÿg	ÿg	ÿg
+ÿg
+ÿg
+ ÿg
+ ÿhÿh	ÿhÿgÿhÿhÿiÿhÿhÿhÿhÿiÿiÿh
+ÿhÿhÿjÿjÿjÿiÿiÿiÿjÿjÿiÿiÿiÿiÿjÿkÿkÿiÿjÿjÿl"ÿl#ÿj!ÿj"ÿk"ÿm%"ÿl%"ÿm&#ÿl'%ÿk%ÿk%ÿk%ÿm)'ÿm*(ÿm+'ÿk)"ÿl)"ÿk*#ÿn-*ÿm.+ÿm/,ÿm/,ÿl-&ÿl.&ÿl.'ÿm1.ÿn2/ÿl0*ÿm0)ÿl1*ÿo42ÿo53ÿo64ÿp74ÿm4.ÿm5/ÿm50ÿm60ÿp98ÿp;8ÿm72ÿm72ÿm84ÿp=;ÿp><ÿp>=ÿp?<ÿn<7ÿn<7ÿm<7ÿn=8ÿqB@ÿn?9ÿn?:ÿn@;ÿnA<ÿqEDÿqFDÿrGEÿqGFÿnD?ÿnE@ÿoE@ÿoEAÿsJIÿoGCÿoHCÿoIDÿoIEÿsMLÿsNMÿtNNÿtPNÿoKHÿoKIÿoLIÿtRQÿtRQÿoNJÿoOKÿoOLÿoPMÿtUTÿuWTÿtWVÿtWVÿpTPÿpTQÿpTRÿtZYÿuZZÿpVSÿpWTÿpXUÿv^\ÿv^]ÿv_^ÿw`_ÿq[Yÿp[Yÿq\Zÿwaaÿwbbÿwccÿq^\ÿq^]ÿq_]ÿweeÿwffÿwfgÿwhgÿrb`ÿqcaÿrcbÿxjiÿwkjÿrfdÿrfeÿrfeÿymmÿxnnÿxnoÿsihÿsjhÿsjjÿrkjÿzqqÿzrsÿsllÿsmlÿsnnÿzuuÿzuvÿzvwÿtpoÿsppÿtqqÿzxzÿ{yzÿsssÿtssÿtttÿ{{|ÿ{{|ÿ{{|ÿtttÿtttÿtttÿ{{|ÿ{{|ÿtttÿtttÿ{{|ÿ{{|ÿ{{|ÿ|{|ÿtttÿtttÿ|||ÿ|||ÿtttÿtttÿtttÿ|||ÿ|||ÿtttÿtttÿtttÿ|||ÿtttÿtttÿtttÿ|||ÿ|||ÿ|||ÿtttÿtttÿ|||ÿtttÿtttÿtttÿ|||ÿ|||ÿtttÿtttÿ|||ÿtttÿtttÿtttÿ|||ÿ|||ÿtttÿtttÿ|||ÿtttÿtttÿ|||ÿ|||ÿtttÿ|||ÿtttÿtttÿ{{{ÿrrrÿoooÿuuuÿpppÿ{{{ÿtttÿ|||ÿtttÿ|||ÿtttÿtttÿ|||ÿtttÿtttÿtttÿg	 ÿg
+ ÿg	ÿg	 ÿg	ÿg	ÿg	 ÿg	ÿg	ÿg	ÿg
+ ÿg	ÿg
+ÿg	ÿg	ÿg	 ÿg	ÿg	ÿfÿ`ÿK+Gÿuéÿ?@wÿ]ÿdÿg	ÿg
+ÿg	 ÿg	 ÿg	ÿg	ÿg	ÿg	ÿg	ÿg	ÿg	 ÿg	 ÿg	ÿg
+ÿg
+ÿg	ÿg	ÿg	ÿg	 ÿg
+ ÿg
+ ÿg
+ÿg	ÿg	ÿg	ÿg	ÿg
+ÿg	ÿg
+ ÿg	 ÿg
+ÿg	ÿg
+ÿg	ÿg
+ÿg	ÿg	ÿg	 ÿg	 ÿg	 ÿg	 ÿh
+ÿhÿhÿiÿh	ÿh
+ÿhÿgÿgÿhÿiÿiÿiÿiÿiÿiÿjÿjÿiÿiÿhÿiÿjÿiÿjÿjÿjÿjÿjÿjÿjÿjÿjÿk ÿk!ÿl!ÿk"ÿl"ÿl# ÿl$ ÿl$!ÿj#ÿk$ÿk$ÿk%ÿl'$ÿm(%ÿl('ÿm*'ÿm*'ÿm+(ÿm+(ÿm,(ÿm,*ÿl*%ÿk*%ÿk+%ÿk,%ÿn/-ÿn1.ÿn1/ÿn2/ÿn20ÿn30ÿn31ÿn42ÿl2,ÿl2,ÿm3-ÿl3-ÿo75ÿo86ÿp96ÿp97ÿp:8ÿp;8ÿp;9ÿq<:ÿp=;ÿm94ÿm95ÿn:6ÿn;6ÿq?=ÿq@>ÿqA?ÿpB?ÿqB@ÿqCAÿqCAÿqCBÿqDCÿnA<ÿoA=ÿoC>ÿoC>ÿrHFÿsIFÿsIGÿrJHÿsKIÿsKJÿsLJÿsLKÿsMLÿoJFÿoJFÿoJGÿoJGÿtPOÿtQPÿtRQÿtRQÿtSRÿtSRÿtTSÿuUSÿuUSÿpPNÿoRNÿpRNÿpROÿtXWÿuYXÿuYYÿuZYÿu[Yÿu\Zÿu\[ÿv]\ÿqXVÿpYVÿqZWÿqZXÿv__ÿw``ÿvaaÿwbbÿwbbÿwccÿwdcÿxddÿweeÿr_]ÿq`_ÿra^ÿqb`ÿxhgÿxihÿxihÿxiiÿxkjÿxkkÿxllÿxmlÿrgfÿsgfÿsigÿyooÿyooÿyppÿyqqÿzrqÿzsrÿzssÿzstÿzttÿsonÿsooÿsooÿzvwÿzwxÿzxxÿzxyÿzyyÿ{z{ÿ{z{ÿ{{|ÿtttÿtttÿtttÿ{{|ÿ{{|ÿ{{|ÿ{{|ÿ{{|ÿ{{|ÿ{{|ÿtttÿtttÿtttÿtttÿ|||ÿ|||ÿ|||ÿ|||ÿ|||ÿ|||ÿ|||ÿtttÿtttÿ|||ÿ|||ÿ|||ÿ|||ÿ|||ÿ|||ÿ|||ÿtttÿtttÿtttÿ|||ÿ|||ÿ|||ÿ|||ÿ|||ÿ|||ÿtttÿtttÿ|||ÿ|||ÿ|||ÿ|||ÿ|||ÿ|||ÿtttÿtttÿ|||ÿ|||ÿ|||ÿ|||ÿ|||ÿtttÿtttÿ|||ÿ|||ÿ|||ÿ|||ÿtttÿ|||ÿ|||ÿ|||ÿ|||ÿtttÿ|||ÿ|||ÿ|||ÿtttÿ|||ÿ|||ÿtttÿ|||ÿtttÿtttÿg	 ÿg
+ ÿg	 ÿg	 ÿg	 ÿg	 ÿg	ÿg
+ ÿg	ÿg
+ ÿg
+ÿg	 ÿg
+ ÿg
+ ÿg	 ÿg	ÿg	 ÿf	 ÿa	ÿL*Gÿ$mÙÿL*Iÿ_ ÿe ÿg	ÿg	 ÿg	 ÿg
+ÿg	ÿg	 ÿg
+ ÿg	 ÿg	ÿg	 ÿg
+ ÿg	ÿg	ÿg	 ÿg
+ ÿg
+ ÿg	ÿg
+ ÿg	 ÿg	ÿg
+ÿg	ÿg	 ÿg	 ÿg	ÿg	ÿg
+ ÿg
+ ÿg	 ÿg	ÿg	ÿg
+ ÿg
+ ÿg
+ ÿg	ÿg
+ÿg	 ÿg	 ÿg
+ ÿg
+ÿg
+ÿg	 ÿg
+ ÿg ÿhÿi	ÿgÿhÿhÿiÿiÿiÿhÿhÿhÿiÿjÿh
+ÿiÿiÿiÿiÿjÿhÿhÿhÿiÿjÿiÿiÿiÿiÿkÿkÿk ÿjÿjÿiÿj ÿl" ÿj!ÿj"ÿj"ÿj#ÿl&#ÿm&#ÿm'$ÿj%ÿk%ÿj&ÿk& ÿl*(ÿk(!ÿl("ÿk)#ÿk)$ÿm.*ÿn.*ÿn.,ÿl,%ÿk-&ÿl.'ÿk.'ÿm1/ÿn2/ÿl0)ÿl0*ÿl2+ÿl2+ÿo53ÿo64ÿo75ÿl4.ÿm5.ÿm5/ÿm61ÿp:7ÿp;8ÿm73ÿm83ÿn84ÿp=;ÿp=<ÿp>=ÿq?=ÿn<7ÿn<7ÿn=8ÿn=8ÿqB@ÿqC@ÿn?:ÿn@;ÿn@<ÿrECÿqFDÿqGEÿrGEÿnD?ÿoD@ÿoE@ÿsJHÿrJHÿoGCÿoGCÿoHDÿoIDÿtNLÿsNMÿtONÿsPNÿoKHÿoKIÿoLIÿtRQÿtSQÿoNJÿoNLÿoPLÿoPMÿtVUÿuVUÿtWVÿpROÿpTPÿpTQÿpTQÿuZYÿuZZÿpVSÿpWTÿpWUÿpXVÿv^]ÿv_^ÿw_^ÿq[Xÿp[Yÿq\Zÿq][ÿwcbÿq]\ÿq^]ÿq^]ÿq^]ÿwefÿwffÿwggÿra_ÿrbaÿrcaÿrdaÿxjiÿrdcÿredÿrfdÿrfeÿxmmÿynmÿyonÿsihÿsihÿsjjÿrkjÿyrrÿslkÿsllÿsmlÿsnmÿztuÿzvuÿzvvÿsooÿtppÿtqqÿ{xyÿ{yzÿtsrÿtstÿtttÿ{{|ÿ{{|ÿ{{|ÿtttÿtttÿtttÿ{{|ÿ{{|ÿtttÿtttÿtttÿ{{|ÿ{{|ÿtttÿtttÿtttÿ|||ÿ|||ÿtttÿtttÿtttÿ|||ÿ|||ÿtttÿtttÿtttÿ|||ÿ|||ÿtttÿtttÿ|||ÿ|||ÿ|||ÿtttÿtttÿ|||ÿtttÿtttÿtttÿ|||ÿ|||ÿtttÿtttÿ|||ÿtttÿtttÿtttÿ|||ÿ|||ÿtttÿtttÿ|||ÿtttÿtttÿ|||ÿtttÿtttÿ|||ÿtttÿtttÿ|||ÿtttÿtttÿtttÿtttÿ|||ÿtttÿ|||ÿtttÿ|||ÿtttÿtttÿtttÿtttÿtttÿtttÿg
+ ÿg	 ÿg
+ ÿg	ÿg	 ÿg
+ ÿg	ÿg	 ÿg
+ ÿg	ÿg	ÿg	ÿg	 ÿg	 ÿg	ÿg	ÿf	ÿb ÿM,Kÿ-^ºÿV#ÿbÿf	ÿg	 ÿg	 ÿg	 ÿg	ÿg
+ÿg	ÿg	ÿg
+ ÿg	 ÿg
+ ÿg	 ÿg	ÿg	ÿg
+ÿg	ÿg	 ÿg	 ÿg	 ÿg
+ ÿg
+ ÿg	ÿg	ÿg	ÿg	ÿg
+ ÿg	 ÿg	 ÿg	 ÿg	 ÿg	ÿg	ÿg	ÿg
+ÿg	 ÿg	 ÿg	 ÿg	 ÿg	 ÿg	 ÿg	ÿg	ÿg	ÿg
+ÿhÿg
+ÿhÿgÿgÿgÿiÿiÿiÿhÿiÿhÿhÿi	ÿh
+ÿi
+ÿhÿjÿiÿjÿjÿjÿjÿiÿiÿiÿiÿiÿjÿjÿjÿjÿkÿl ÿjÿjÿj ÿj ÿj!ÿj!ÿl$"ÿl%"ÿl&#ÿl'#ÿm'$ÿm'$ÿj%ÿk&ÿk& ÿk'!ÿk(!ÿk("ÿk)"ÿm-)ÿm-*ÿm.+ÿm.,ÿn/,ÿn0,ÿl-&ÿl.(ÿl/(ÿl/(ÿl0*ÿl0*ÿo41ÿo52ÿo53ÿo64ÿo65ÿp75ÿm5/ÿm50ÿm60ÿm71ÿm72ÿn73ÿm83ÿp<;ÿp=;ÿq><ÿp>=ÿq>=ÿp?=ÿn<7ÿn=7ÿn=8ÿn>9ÿn?:ÿn?:ÿn@;ÿqECÿrECÿqEDÿqGDÿqGEÿrHFÿoD@ÿoE@ÿoEAÿoFAÿoGBÿoHCÿoHDÿsLLÿsMMÿtNMÿsOMÿtPNÿtPOÿoLIÿoMJÿoLJÿoNJÿoNJÿpNKÿoOLÿuUSÿtVUÿtVUÿuVVÿtWVÿtXWÿpTQÿpUQÿpURÿpVSÿpVSÿqWTÿu\[ÿv^\ÿw^]ÿv_^ÿw__ÿw`_ÿq[Yÿq\Yÿq]Zÿq][ÿq]\ÿq^]ÿq^]ÿwedÿwffÿwfgÿwfgÿxhgÿwhhÿrbaÿrdbÿrdbÿrecÿredÿreeÿxllÿxmmÿymmÿynoÿxooÿxopÿrjjÿskjÿskkÿslkÿsmlÿzstÿzttÿzuuÿzvvÿ{vvÿzwwÿtqpÿsppÿtqqÿsrrÿtsrÿtssÿ{{|ÿ{{|ÿ{{|ÿ{{|ÿ{{|ÿtttÿtttÿtttÿtttÿtttÿ{{|ÿ{{|ÿ{{|ÿ{{|ÿ{{|ÿtttÿtttÿtttÿtttÿtttÿtttÿ|||ÿ|||ÿ|||ÿ|||ÿtttÿtttÿtttÿtttÿtttÿ|||ÿ|||ÿ|||ÿ|||ÿtttÿtttÿtttÿtttÿtttÿ|||ÿ|||ÿ|||ÿ|||ÿtttÿtttÿtttÿtttÿ|||ÿ|||ÿ|||ÿ|||ÿtttÿtttÿtttÿ|||ÿ|||ÿ|||ÿtttÿtttÿtttÿ|||ÿ|||ÿ|||ÿtttÿtttÿ|||ÿ|||ÿ|||ÿtttÿtttÿ|||ÿtttÿtttÿ|||ÿtttÿtttÿtttÿg
+ ÿg	 ÿg	ÿg
+ ÿg
+ÿg
+ÿg	 ÿg	ÿg
+ÿg	 ÿg	 ÿg	 ÿg
+ÿg	ÿg
+ ÿf ÿc ÿM/Uÿ=Hÿ^ÿd	 ÿg
+ ÿg	 ÿg	ÿg	ÿg	ÿg	 ÿg	 ÿg	 ÿg	 ÿg	ÿg
+ÿg
+ÿg
+ÿg	 ÿg	 ÿg	 ÿg	 ÿg	ÿg
+ÿg	ÿg	ÿg
+ÿg
+ ÿg	 ÿg	 ÿg	 ÿg
+ÿg	ÿg	ÿg
+ÿg	ÿg	 ÿg	 ÿg	 ÿg	 ÿg	ÿg	ÿg	ÿg	ÿg	ÿg
+ÿg	 ÿg	 ÿg	 ÿg
+ ÿh
+ ÿhÿhÿi	ÿh
+ÿh
+ÿhÿhÿgÿhÿhÿiÿiÿiÿiÿjÿiÿhÿiÿhÿiÿhÿiÿjÿjÿjÿjÿjÿjÿiÿiÿjÿiÿiÿl!ÿl!ÿl"ÿl"ÿm# ÿl$ ÿk"ÿj#ÿj$ÿk$ÿk%ÿk%ÿm(%ÿl)&ÿm)'ÿm*'ÿm+'ÿm+(ÿn,)ÿk*#ÿl*$ÿl+$ÿl+%ÿl,%ÿk,&ÿn1-ÿm1.ÿn1/ÿn20ÿn20ÿn41ÿl1*ÿl2+ÿm2,ÿl3-ÿl4-ÿl4/ÿp86ÿo87ÿp97ÿp:8ÿp:8ÿp;9ÿq<9ÿm93ÿm94ÿn95ÿn:5ÿn:6ÿm;7ÿp@>ÿpA>ÿqA?ÿqB@ÿqCAÿqDAÿqDBÿo@;ÿnA=ÿoA=ÿoC=ÿoC?ÿnC?ÿsHGÿsIHÿsJIÿsKIÿsKIÿsLJÿsMKÿoIDÿoJEÿoJFÿoJGÿoJGÿoKHÿtQPÿtQPÿsRQÿtRRÿtSRÿtSSÿtTSÿpPMÿpQMÿpRNÿoROÿpROÿoSPÿuYXÿuYXÿuZYÿu[Zÿu[[ÿu\[ÿpWUÿpYVÿqYVÿqYWÿpZXÿp[Yÿva`ÿwa`ÿwbbÿwcbÿwccÿwdcÿwddÿq_]ÿq_]ÿr`^ÿqa_ÿqa_ÿqb`ÿxhhÿxiiÿxjiÿxkjÿxljÿylkÿsfeÿsgfÿshgÿsigÿsihÿsjiÿyppÿyqqÿzrrÿzrsÿzssÿsmlÿsnmÿtonÿsooÿsooÿtooÿzwxÿ{xyÿzyyÿ{yzÿzz{ÿ{z|ÿtttÿtttÿtttÿtttÿtttÿ{{|ÿ{{|ÿ{{|ÿ{{|ÿ{{|ÿtttÿtttÿtttÿtttÿtttÿ|||ÿ|||ÿ|||ÿ|||ÿ|||ÿ|||ÿtttÿtttÿtttÿtttÿ|||ÿ|||ÿ|||ÿ|||ÿ|||ÿtttÿtttÿtttÿtttÿ|||ÿ|||ÿ|||ÿ|||ÿ|||ÿtttÿtttÿtttÿtttÿ|||ÿ|||ÿ|||ÿ|||ÿtttÿtttÿtttÿtttÿ|||ÿ|||ÿ|||ÿtttÿtttÿtttÿ|||ÿ|||ÿ|||ÿtttÿtttÿtttÿ|||ÿ|||ÿtttÿtttÿtttÿ|||ÿ|||ÿtttÿ|||ÿ|||ÿtttÿ|||ÿtttÿtttÿg	 ÿg
+ ÿg	 ÿg	 ÿg
+ ÿg
+ ÿg
+ÿg	 ÿg	 ÿg	 ÿg
+ÿg	 ÿg
+ ÿg	 ÿf ÿeÿP/PÿO-Mÿb ÿe ÿg	 ÿg	ÿg	 ÿg	 ÿg	 ÿg
+ ÿg	 ÿg	 ÿg	ÿg	 ÿg	 ÿg
+ ÿg	 ÿg
+ ÿg	 ÿg
+ÿg	ÿg
+ ÿg	 ÿg
+ ÿg
+ ÿg	 ÿg	 ÿg	 ÿg
+ÿg	ÿg
+ ÿg	 ÿg	 ÿg	 ÿg	 ÿg	 ÿg	 ÿg
+ÿg	ÿg	 ÿg
+ ÿg	 ÿg	 ÿg
+ ÿg	 ÿg	 ÿg	 ÿg	ÿg	ÿg	 ÿg
+ ÿg
+ ÿgÿgÿgÿgÿgÿiÿiÿiÿgÿhÿhÿhÿh	ÿh
+ÿh
+ÿhÿjÿiÿjÿiÿhÿhÿiÿiÿiÿiÿiÿjÿkÿjÿkÿiÿjÿjÿj ÿj ÿj!ÿj!ÿj"ÿj#ÿm&#ÿl'#ÿl'$ÿk%ÿj%ÿk%ÿk& ÿk' ÿk'!ÿk("ÿl)"ÿk)#ÿn-*ÿm-+ÿn.,ÿl,%ÿl-&ÿl-&ÿl.'ÿl/(ÿl/(ÿl0)ÿl1*ÿl1+ÿl2+ÿo63ÿo63ÿo74ÿl4.ÿl5/ÿm5/ÿl60ÿm70ÿm72ÿm72ÿm83ÿn83ÿm94ÿp><ÿq><ÿq><ÿm<7ÿm<7ÿn=7ÿn>8ÿn>9ÿn?:ÿn?;ÿn?;ÿnA<ÿqEDÿrFDÿrFDÿrGEÿoD?ÿoE?ÿnEAÿoEBÿoFAÿoFBÿoHCÿoHCÿoIEÿsMLÿsNMÿsONÿoJGÿoKHÿoKIÿoMIÿoMJÿoMJÿoNJÿoNKÿoPLÿoPMÿtUTÿuWUÿuWUÿpRPÿpSPÿoTQÿoUQÿoUSÿpVSÿqVSÿpWTÿpWUÿqXVÿv^]ÿw^^ÿw_^ÿqZXÿp[Xÿq\Yÿq\Zÿq][ÿq]\ÿq^\ÿq^]ÿq_]ÿwfeÿxffÿwggÿqa`ÿrb`ÿrcaÿrcbÿrdbÿrecÿredÿrfeÿrgeÿxmlÿxnmÿynnÿrihÿrjhÿrjiÿrkjÿskkÿslkÿsmmÿsnlÿtnmÿztuÿzuvÿ{vwÿspoÿtpoÿtqpÿsrqÿtrrÿtssÿtssÿtttÿ{{|ÿ{{|ÿ{{|ÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿ{{|ÿ{{|ÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿ|||ÿ|||ÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿ|||ÿ|||ÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿ|||ÿ|||ÿtttÿtttÿtttÿtttÿtttÿtttÿ|||ÿtttÿtttÿtttÿtttÿtttÿtttÿ|||ÿtttÿtttÿtttÿtttÿtttÿ|||ÿtttÿtttÿtttÿtttÿ|||ÿtttÿtttÿtttÿ|||ÿtttÿtttÿtttÿtttÿtttÿtttÿg	 ÿg	 ÿg	 ÿg	 ÿg	 ÿg	 ÿg	 ÿg
+ ÿg
+ ÿg
+ ÿg
+ÿg	 ÿg	 ÿg
+ ÿf ÿY'Aÿ]ÿd ÿfÿg	 ÿg
+ ÿg	ÿg	 ÿg	 ÿg	 ÿg	 ÿg	 ÿg
+ ÿg	 ÿg	 ÿg	 ÿg	 ÿg	 ÿg	 ÿg	 ÿg
+ ÿg	 ÿg	 ÿg
+ ÿg	 ÿg	 ÿg	 ÿg
+ ÿg	 ÿg
+ ÿg	 ÿg	 ÿg	 ÿg	 ÿg
+ ÿg	 ÿg	 ÿg	 ÿg
+ ÿg	 ÿg	 ÿg	 ÿg	 ÿg	 ÿg	 ÿg	 ÿg	 ÿg	 ÿg	 ÿg	 ÿg	 ÿg
+ ÿg ÿhÿhÿgÿgÿgÿhÿhÿhÿhÿhÿhÿh	ÿh
+ÿh
+ÿiÿhÿhÿiÿiÿhÿiÿiÿiÿjÿiÿiÿiÿiÿiÿjÿjÿiÿjÿjÿi ÿl#ÿj!ÿj"ÿk"ÿk#ÿk$ÿl&$ÿj%ÿk%ÿk%ÿj&ÿk&ÿm*'ÿk(!ÿk)"ÿl)"ÿl*#ÿk*$ÿk+%ÿl+%ÿk,%ÿl-%ÿl-&ÿl.'ÿl/(ÿl/)ÿl0)ÿl0*ÿl1+ÿl2,ÿl2,ÿl3,ÿl3-ÿm4.ÿm5/ÿm5/ÿl60ÿm71ÿm72ÿm72ÿn83ÿn84ÿm94ÿn:4ÿn:5ÿm;6ÿn;7ÿn<7ÿn=8ÿn=8ÿn>9ÿn?:ÿn?:ÿn?;ÿnA;ÿnA<ÿnB=ÿoB>ÿoC>ÿoD?ÿnD?ÿoE@ÿoFAÿoGBÿoGCÿoHCÿoIDÿoIEÿoIEÿoJEÿoJGÿoJGÿoKHÿoLHÿoLJÿoMJÿoNJÿoNKÿoOKÿoOLÿoPMÿoQMÿpQNÿpROÿoSOÿpSPÿpTQÿpUQÿoURÿpVRÿpVSÿpWTÿqXUÿpXVÿpYVÿqZWÿp[Xÿq[Xÿq[Yÿq\Yÿp]Zÿwcbÿq]\ÿq^\ÿq^]ÿr^]ÿr_^ÿwffÿqa_ÿqa_ÿqb`ÿqbaÿrdaÿxjiÿrecÿredÿrfeÿrgfÿsgfÿxnnÿshgÿsihÿrjhÿrkiÿskjÿzrqÿsllÿsmlÿtmmÿsnnÿsonÿzuvÿsooÿsooÿtppÿtqpÿsrrÿtsrÿtrsÿttsÿtttÿtttÿ{{|ÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿ|||ÿtttÿtttÿ|||ÿtttÿtttÿ|||ÿtttÿtttÿtttÿtttÿ|||ÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿg
+ ÿg
+ ÿg
+ ÿg	 ÿg	 ÿg	 ÿg	 ÿg	 ÿg
+ ÿg	 ÿg	 ÿg	 ÿg
+ ÿg	 ÿfÿeÿf	 ÿg	 ÿg	 ÿg	 ÿg
+ ÿg	 ÿg
+ ÿg	 ÿg	 ÿg	 ÿg	 ÿg	 ÿg
+ ÿg
+ ÿg	 ÿg	 ÿg	 ÿg	 ÿg
+ ÿg
+ ÿg
+ ÿg
+ ÿg
+ ÿg	 ÿg	 ÿg	 ÿg	 ÿg	 ÿg	 ÿg	 ÿg
+ ÿg	 ÿg	 ÿg
+ ÿg	 ÿg
+ ÿg	 ÿg	 ÿg	 ÿg
+ ÿg	 ÿg	 ÿg	 ÿg	 ÿg	 ÿg	 ÿg	 ÿg	 ÿg
+ ÿg	 ÿg
+ ÿgÿhÿhÿgÿhÿgÿhÿgÿhÿhÿhÿhÿhÿh	ÿh
+ÿhÿiÿiÿhÿiÿhÿiÿiÿiÿiÿiÿiÿjÿiÿiÿjÿiÿjÿjÿiÿi ÿj ÿj!ÿk"ÿj"ÿj#ÿj$ÿj$ÿj%ÿk%ÿk%ÿk& ÿk& ÿk'!ÿk'"ÿk("ÿk)#ÿk*#ÿk*$ÿl*$ÿk,%ÿk,%ÿk,&ÿl-'ÿk.'ÿl/'ÿl/)ÿl0)ÿl1*ÿl1*ÿl1+ÿm3,ÿm3-ÿl4-ÿl4.ÿl5.ÿm5/ÿm60ÿm61ÿm72ÿm73ÿm82ÿm84ÿn94ÿm95ÿm:5ÿm;6ÿn;7ÿn=7ÿm=7ÿn=8ÿm>9ÿn>9ÿn?:ÿn@;ÿnA<ÿoA<ÿnB=ÿnB=ÿoC>ÿoD?ÿoD?ÿnEAÿoEAÿoFAÿoGBÿoHCÿoHDÿoIEÿoJEÿoJFÿoJGÿoJGÿoKHÿoLIÿoLJÿoMJÿoMJÿoNKÿoOKÿoOLÿoPMÿpQMÿoQNÿpROÿpROÿpSPÿpTQÿpUQÿpVRÿpVSÿpVTÿpWTÿqWUÿpXVÿpYVÿpYVÿpZWÿp[Xÿp\Yÿq\Zÿq]Zÿq][ÿq]\ÿq^]ÿq_]ÿr_]ÿq_^ÿq`^ÿqa_ÿqa`ÿqbaÿrcaÿrcaÿrccÿqdcÿrecÿreeÿrgeÿrgfÿrgfÿsigÿsihÿrjiÿsjjÿskjÿrljÿslkÿsmlÿsmlÿsnmÿsnnÿsooÿsooÿsooÿsppÿtqqÿtrqÿtrrÿtsrÿtssÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿg	 ÿg	 ÿg	 ÿg	 ÿg	 ÿg	 ÿg
+ ÿg	 ÿg	 ÿg	 ÿg	 ÿg	 ÿg	 ÿg	 ÿg	 ÿg	 ÿg	 ÿg
+ ÿg	 ÿg	 ÿg	 ÿg	 ÿg	 ÿg	 ÿg	 ÿg
+ ÿg
+ ÿg	 ÿg	 ÿg	 ÿg	 ÿg
+ ÿg
+ ÿg
+ ÿg	 ÿg	 ÿg	 ÿg	 ÿg	 ÿg	 ÿg	 ÿg
+ ÿg	 ÿg
+ ÿg	 ÿg
+ ÿg
+ ÿg
+ ÿg	 ÿg
+ ÿg	 ÿg	 ÿg
+ ÿg	 ÿg	 ÿg	 ÿg	 ÿg
+ ÿg	 ÿg	 ÿg
+ ÿg	 ÿg	 ÿg
+ ÿg	 ÿg	 ÿg
+ ÿg
+ ÿhÿhÿgÿgÿgÿgÿhÿhÿhÿgÿhÿh	ÿh
+ÿh
+ÿhÿiÿiÿiÿhÿiÿhÿiÿiÿiÿiÿiÿiÿiÿiÿiÿjÿiÿiÿjÿj ÿj ÿj!ÿj"ÿj#ÿj#ÿj#ÿk%ÿj%ÿk%ÿk%ÿj&ÿj&ÿk'!ÿk'!ÿk)"ÿk)#ÿk*#ÿk*$ÿl+%ÿk+%ÿk,%ÿk,%ÿl.'ÿl.'ÿl.(ÿl/(ÿl0)ÿm0*ÿl1+ÿl2+ÿl2,ÿl3,ÿm4.ÿm4.ÿm5/ÿm6/ÿm60ÿm70ÿm72ÿm72ÿm72ÿm83ÿm95ÿm95ÿm:6ÿn;7ÿm;7ÿn<7ÿm=8ÿn>8ÿn>9ÿn?9ÿn?:ÿn@;ÿn@;ÿoA<ÿoB<ÿnC=ÿoC>ÿnD?ÿnE@ÿoEAÿoEAÿnGBÿoGBÿoGCÿoHDÿoIDÿoJFÿoJFÿoJGÿoJHÿoKHÿoKHÿoLIÿoMJÿoMJÿpOKÿoOKÿoPLÿoPMÿpQNÿoRNÿoROÿpSOÿoSPÿpSQÿoTRÿpURÿpVSÿpVTÿpWTÿqWUÿpYUÿqYVÿqYWÿqZXÿq[Xÿq\Yÿq\Zÿp\Zÿq][ÿq][ÿq]\ÿq_]ÿr_]ÿq_]ÿq`_ÿqa_ÿrb`ÿqbaÿrcaÿrcbÿrccÿrecÿredÿreeÿrfeÿrgeÿshfÿshhÿrhgÿrjhÿsjjÿsjjÿskjÿslkÿsmlÿsmmÿsnmÿsnnÿsooÿsooÿtopÿsqpÿsqqÿtqrÿtrrÿtrsÿttsÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿtttÿ
\ No newline at end of file
diff -Naur wine-2.0a/dlls/credui/credui_main.c wine-2.0b/dlls/credui/credui_main.c
--- wine-2.0a/dlls/credui/credui_main.c	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/credui/credui_main.c	2017-07-11 20:37:49.000000000 +0100
@@ -910,23 +910,45 @@
     if (!(ret = CredUIPromptForCredentialsW( cred_info, target, NULL, error, username,
                                              len_username, password, len_password, save, flags )))
     {
-        DWORD size = sizeof(*id);
-        WCHAR *ptr;
+        DWORD size = sizeof(*id), len_domain = 0;
+        WCHAR *ptr, *user = username, *domain = NULL;
 
-        len_username = strlenW( username );
+        if ((ptr = strchrW( username, '\\' )))
+        {
+            user = ptr + 1;
+            len_username = strlenW( user );
+            if (!strcmpiW( package, ntlmW ) || !strcmpiW( package, negotiateW ))
+            {
+                domain = username;
+                len_domain = ptr - username;
+            }
+            *ptr = 0;
+        }
+        else len_username = strlenW( username );
         len_password = strlenW( password );
 
         size += (len_username + 1) * sizeof(WCHAR);
+        size += (len_domain + 1) * sizeof(WCHAR);
         size += (len_password + 1) * sizeof(WCHAR);
         if (!(id = HeapAlloc( GetProcessHeap(), 0, size ))) return ERROR_OUTOFMEMORY;
         ptr = (WCHAR *)(id + 1);
 
-        memcpy( ptr, username, (len_username + 1) * sizeof(WCHAR) );
+        memcpy( ptr, user, (len_username + 1) * sizeof(WCHAR) );
         id->User           = ptr;
         id->UserLength     = len_username;
         ptr += len_username + 1;
-        id->Domain         = NULL;
-        id->DomainLength   = 0;
+        if (len_domain)
+        {
+            memcpy( ptr, domain, (len_domain + 1) * sizeof(WCHAR) );
+            id->Domain         = ptr;
+            id->DomainLength   = len_domain;
+            ptr += len_domain + 1;
+        }
+        else
+        {
+            id->Domain         = NULL;
+            id->DomainLength   = 0;
+        }
         memcpy( ptr, password, (len_password + 1) * sizeof(WCHAR) );
         id->Password       = ptr;
         id->PasswordLength = len_password;
diff -Naur wine-2.0a/dlls/d2d1/brush.c wine-2.0b/dlls/d2d1/brush.c
--- wine-2.0a/dlls/d2d1/brush.c	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/d2d1/brush.c	2017-07-11 20:37:49.000000000 +0100
@@ -841,6 +841,22 @@
         return TRUE;
     }
 
+    if (brush->type == D2D_BRUSH_TYPE_LINEAR)
+    {
+        D2D1_GRADIENT_STOP stop;
+        color = cb;
+
+        ID2D1GradientStopCollection_GetGradientStops(brush->u.linear.gradient, &stop, 1);
+
+        *color = stop.color;
+        color->a *= brush->opacity;
+        color->r *= color->a;
+        color->g *= color->a;
+        color->b *= color->a;
+
+        return TRUE;
+    }
+
     FIXME("Unhandled brush type %#x.\n", brush->type);
     return FALSE;
 }
@@ -856,7 +872,7 @@
     static const size_t brush_sizes[] =
     {
         /* D2D_BRUSH_TYPE_SOLID */  sizeof(D2D1_COLOR_F),
-        /* D2D_BRUSH_TYPE_LINEAR */ 0,
+        /* D2D_BRUSH_TYPE_LINEAR */ sizeof(D2D1_COLOR_F),
         /* D2D_BRUSH_TYPE_BITMAP */ sizeof(struct d2d_bitmap_brush_cb),
     };
 
@@ -950,12 +966,17 @@
     static const float blend_factor[] = {1.0f, 1.0f, 1.0f, 1.0f};
     unsigned int resource_idx = 0, sampler_idx = 0;
     ID3D10Device *device = render_target->device;
-    enum d2d_brush_type opacity_brush_type;
+    enum d2d_brush_type opacity_brush_type, brush_type;
     ID3D10PixelShader *ps;
 
     ID3D10Device_OMSetBlendState(device, render_target->bs, blend_factor, D3D10_DEFAULT_SAMPLE_MASK);
     opacity_brush_type = opacity_brush ? opacity_brush->type : D2D_BRUSH_TYPE_COUNT;
-    if (!(ps = render_target->shape_resources[shape_type].ps[brush->type][opacity_brush_type]))
+
+    brush_type = brush->type;
+    if (brush_type == D2D_BRUSH_TYPE_LINEAR)
+        brush_type = D2D_BRUSH_TYPE_SOLID;
+
+    if (!(ps = render_target->shape_resources[shape_type].ps[brush_type][opacity_brush_type]))
         FIXME("No pixel shader for shape type %#x and brush types %#x/%#x.\n",
                 shape_type, brush->type, opacity_brush_type);
     ID3D10Device_PSSetShader(device, ps);
diff -Naur wine-2.0a/dlls/d2d1/d2d1_private.h wine-2.0b/dlls/d2d1/d2d1_private.h
--- wine-2.0a/dlls/d2d1/d2d1_private.h	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/d2d1/d2d1_private.h	2017-07-11 20:37:49.000000000 +0100
@@ -40,6 +40,8 @@
 
 enum d2d_shape_type
 {
+    D2D_SHAPE_TYPE_OUTLINE,
+    D2D_SHAPE_TYPE_BEZIER_OUTLINE,
     D2D_SHAPE_TYPE_TRIANGLE,
     D2D_SHAPE_TYPE_BEZIER,
     D2D_SHAPE_TYPE_COUNT,
@@ -299,6 +301,29 @@
     UINT16 v[3];
 };
 
+struct d2d_vec3
+{
+    float x, y, z;
+};
+
+struct d2d_vec4
+{
+    float x, y, z, w;
+};
+
+struct d2d_outline_vertex
+{
+    float x, y;
+    float dx, dy;
+};
+
+struct d2d_bezier_outline_vertex
+{
+    float x, y;
+    float dx, dy;
+    struct d2d_vec3 tx, ty;
+};
+
 struct d2d_geometry
 {
     ID2D1Geometry ID2D1Geometry_iface;
@@ -321,6 +346,25 @@
         size_t bezier_vertex_count;
     } fill;
 
+    struct
+    {
+        struct d2d_outline_vertex *vertices;
+        size_t vertices_size;
+        size_t vertex_count;
+
+        struct d2d_face *faces;
+        size_t faces_size;
+        size_t face_count;
+
+        struct d2d_bezier_outline_vertex *beziers;
+        size_t beziers_size;
+        size_t bezier_count;
+
+        struct d2d_face *bezier_faces;
+        size_t bezier_faces_size;
+        size_t bezier_face_count;
+    } outline;
+
     union
     {
         struct
diff -Naur wine-2.0a/dlls/d2d1/geometry.c wine-2.0b/dlls/d2d1/geometry.c
--- wine-2.0a/dlls/d2d1/geometry.c	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/d2d1/geometry.c	2017-07-11 20:37:49.000000000 +0100
@@ -127,6 +127,32 @@
     b->texcoord.sign = sign;
 }
 
+static void d2d_face_set(struct d2d_face *f, UINT16 v0, UINT16 v1, UINT16 v2)
+{
+    f->v[0] = v0;
+    f->v[1] = v1;
+    f->v[2] = v2;
+}
+
+static void d2d_outline_vertex_set(struct d2d_outline_vertex *v, float x, float y, float dx, float dy)
+{
+    v->x = x;
+    v->y = y;
+    v->dx = dx;
+    v->dy = dy;
+}
+
+static void d2d_bezier_outline_vertex_set(struct d2d_bezier_outline_vertex *b, const D2D1_POINT_2F *position,
+        float dx, float dy, struct d2d_vec3 *tx, struct d2d_vec3 *ty)
+{
+    b->x = position->x;
+    b->y = position->y;
+    b->dx = dx;
+    b->dy = dy;
+    b->tx = *tx;
+    b->ty = *ty;
+}
+
 static void d2d_fp_two_sum(float *out, float a, float b)
 {
     float a_virt, a_round, b_virt, b_round;
@@ -341,6 +367,53 @@
     out->y = a->y - b->y;
 }
 
+static void d2d_point_scale(D2D1_POINT_2F *p, float scale)
+{
+    p->x *= scale;
+    p->y *= scale;
+}
+
+static void d2d_point_lerp(D2D1_POINT_2F *out,
+        const D2D1_POINT_2F *a, const D2D1_POINT_2F *b, float t)
+{
+    out->x = a->x * (1.0f - t) + b->x * t;
+    out->y = a->y * (1.0f - t) + b->y * t;
+}
+
+static float d2d_point_dot(const D2D1_POINT_2F *p0, const D2D1_POINT_2F *p1)
+{
+    return p0->x * p1->x + p0->y * p1->y;
+}
+
+static void d2d_point_normalise(D2D1_POINT_2F *p)
+{
+    float l;
+
+    if ((l = sqrtf(d2d_point_dot(p, p))) != 0.0f)
+        d2d_point_scale(p, 1.0f / l);
+}
+
+/* Given two unit vectors, vÌ and wÌ, at angle Î¸, calculate tan(Â½Î¸):
+ *
+ *   tan(Â½Î¸) = sin(Î¸) / (1 + cos(Î¸))
+ *           = (vÌâ¥ Â· wÌ) / (1 + (vÌ Â· Åµ))
+ *
+ * Â±â is flushed to zero. */
+static float d2d_point_tan_half(const D2D1_POINT_2F *v, const D2D1_POINT_2F *w)
+{
+    D2D1_POINT_2F v_p;
+    float t;
+
+    v_p.x = -v->y;
+    v_p.y = v->x;
+
+    t = 1.0f + d2d_point_dot(v, w);
+    if (t != 0.0f)
+        t = d2d_point_dot(&v_p, w) / t;
+
+    return t;
+}
+
 /* This implementation is based on the paper "Adaptive Precision
  * Floating-Point Arithmetic and Fast Robust Geometric Predicates" and
  * associated (Public Domain) code by Jonathan Richard Shewchuk. */
@@ -498,6 +571,10 @@
 
 static BOOL d2d_figure_add_vertex(struct d2d_figure *figure, D2D1_POINT_2F vertex)
 {
+    if (figure->vertex_count && !memcmp(&figure->vertices[figure->vertex_count - 1],
+            &vertex, sizeof(vertex)))
+        return TRUE;
+
     if (!d2d_array_reserve((void **)&figure->vertices, &figure->vertices_size,
             figure->vertex_count + 1, sizeof(*figure->vertices)))
     {
@@ -1181,7 +1258,7 @@
     const D2D1_POINT_2F *p0, *p1;
     D2D1_POINT_2F v_p, v_probe;
     unsigned int score;
-    size_t i, j;
+    size_t i, j, last;
 
     for (i = 0, score = 0; i < geometry->u.path.figure_count; ++i)
     {
@@ -1191,8 +1268,14 @@
                 || probe->y < figure->bounds.top || probe->y > figure->bounds.bottom)
             continue;
 
-        p0 = &figure->vertices[figure->vertex_count - 1];
-        for (j = 0; j < figure->vertex_count; ++j)
+        last = figure->vertex_count - 1;
+        if (!triangles_only)
+        {
+            while (last && figure->vertex_types[last] == D2D_VERTEX_TYPE_NONE)
+                --last;
+        }
+        p0 = &figure->vertices[last];
+        for (j = 0; j <= last; ++j)
         {
             if (!triangles_only && figure->vertex_types[j] == D2D_VERTEX_TYPE_NONE)
                 continue;
@@ -1686,8 +1769,280 @@
     return TRUE;
 }
 
+/* The lines Pâáµ£âáµ¥Pâ and PâPââââ, both offset by Â±Â½w, intersect each other at:
+ *
+ *   Páµ¢ = Pâ Â± w Â· Â½qâáµ¢.
+ *
+ * Where:
+ *
+ *   qâáµ¢ = qÌâáµ£âáµ¥â¥ + tan(Â½Î¸) Â· -qÌâáµ£âáµ¥
+ *   Î¸  = â Pâáµ£âáµ¥PâPââââ
+ *   qââáµ£âáµ¥ = Pâ - Pâáµ£âáµ¥ */
+static BOOL d2d_geometry_outline_add_join(struct d2d_geometry *geometry,
+        const D2D1_POINT_2F *prev, const D2D1_POINT_2F *p0, const D2D1_POINT_2F *next)
+{
+    D2D1_POINT_2F q_i, q_prev, q_next;
+    struct d2d_outline_vertex *v;
+    struct d2d_face *f;
+    size_t base_idx;
+    float l;
+
+    if (!d2d_array_reserve((void **)&geometry->outline.vertices, &geometry->outline.vertices_size,
+            geometry->outline.vertex_count + 4, sizeof(*geometry->outline.vertices)))
+    {
+        ERR("Failed to grow outline vertices array.\n");
+        return FALSE;
+    }
+    base_idx = geometry->outline.vertex_count;
+    v = &geometry->outline.vertices[base_idx];
+
+    if (!d2d_array_reserve((void **)&geometry->outline.faces, &geometry->outline.faces_size,
+            geometry->outline.face_count + 2, sizeof(*geometry->outline.faces)))
+    {
+        ERR("Failed to grow outline faces array.\n");
+        return FALSE;
+    }
+    f = &geometry->outline.faces[geometry->outline.face_count];
+
+    d2d_point_subtract(&q_prev, p0, prev);
+    d2d_point_subtract(&q_next, next, p0);
+
+    d2d_point_normalise(&q_prev);
+    d2d_point_normalise(&q_next);
+
+    l = -d2d_point_tan_half(&q_prev, &q_next);
+    q_i.x = l * q_prev.x - q_prev.y;
+    q_i.y = l * q_prev.y + q_prev.x;
+
+    if (l < 0.0f)
+    {
+        d2d_point_scale(&q_prev, -0.5f);
+        d2d_point_scale(&q_i, -0.5f);
+        d2d_point_scale(&q_next, -0.5f);
+    }
+    else
+    {
+        d2d_point_scale(&q_prev, 0.5f);
+        d2d_point_scale(&q_i, 0.5f);
+        d2d_point_scale(&q_next, 0.5f);
+    }
+
+    d2d_outline_vertex_set(&v[0], p0->x, p0->y, 0.0f,  0.0f);
+    d2d_outline_vertex_set(&v[1], p0->x, p0->y, -q_prev.y, q_prev.x);
+    d2d_outline_vertex_set(&v[2], p0->x, p0->y, q_i.x, q_i.y);
+    d2d_outline_vertex_set(&v[3], p0->x, p0->y, -q_next.y, q_next.x);
+    geometry->outline.vertex_count += 4;
+
+    d2d_face_set(&f[0], base_idx + 1, base_idx + 0, base_idx + 2);
+    d2d_face_set(&f[1], base_idx + 2, base_idx + 0, base_idx + 3);
+    geometry->outline.face_count += 2;
+
+    return TRUE;
+}
+
+static BOOL d2d_geometry_outline_add_line_segment(struct d2d_geometry *geometry,
+        const D2D1_POINT_2F *p0, const D2D1_POINT_2F *next)
+{
+    D2D1_POINT_2F q_next, q_next_p;
+    struct d2d_outline_vertex *v;
+    struct d2d_face *f;
+    size_t base_idx;
+
+    if (!d2d_array_reserve((void **)&geometry->outline.vertices, &geometry->outline.vertices_size,
+            geometry->outline.vertex_count + 4, sizeof(*geometry->outline.vertices)))
+    {
+        ERR("Failed to grow outline vertices array.\n");
+        return FALSE;
+    }
+    base_idx = geometry->outline.vertex_count;
+    v = &geometry->outline.vertices[base_idx];
+
+    if (!d2d_array_reserve((void **)&geometry->outline.faces, &geometry->outline.faces_size,
+            geometry->outline.face_count + 2, sizeof(*geometry->outline.faces)))
+    {
+        ERR("Failed to grow outline faces array.\n");
+        return FALSE;
+    }
+    f = &geometry->outline.faces[geometry->outline.face_count];
+
+    d2d_point_subtract(&q_next, next, p0);
+    d2d_point_normalise(&q_next);
+    q_next_p.x = 0.5f * -q_next.y;
+    q_next_p.y = 0.5f * q_next.x;
+
+    d2d_outline_vertex_set(&v[0], p0->x, p0->y,  q_next_p.x,  q_next_p.y);
+    d2d_outline_vertex_set(&v[1], p0->x, p0->y, -q_next_p.x, -q_next_p.y);
+    d2d_outline_vertex_set(&v[2], next->x, next->y,  q_next_p.x,  q_next_p.y);
+    d2d_outline_vertex_set(&v[3], next->x, next->y, -q_next_p.x, -q_next_p.y);
+    geometry->outline.vertex_count += 4;
+
+    d2d_face_set(&f[0], base_idx + 0, base_idx + 1, base_idx + 2);
+    d2d_face_set(&f[1], base_idx + 2, base_idx + 1, base_idx + 3);
+    geometry->outline.face_count += 2;
+
+    return TRUE;
+}
+
+static BOOL d2d_geometry_outline_add_bezier_segment(struct d2d_geometry *geometry,
+        const D2D1_POINT_2F *p0, const D2D1_POINT_2F *p1, const D2D1_POINT_2F *p2)
+{
+    struct d2d_bezier_outline_vertex *b;
+    D2D1_POINT_2F r0, r1, r2, r3, r4;
+    D2D1_POINT_2F q0, q1, q2;
+    struct d2d_vec3 tx, ty;
+    struct d2d_face *f;
+    size_t base_idx;
+    float s;
+
+    if (!d2d_array_reserve((void **)&geometry->outline.beziers, &geometry->outline.beziers_size,
+            geometry->outline.bezier_count + 7, sizeof(*geometry->outline.beziers)))
+    {
+        ERR("Failed to grow outline beziers array.\n");
+        return FALSE;
+    }
+    base_idx = geometry->outline.bezier_count;
+    b = &geometry->outline.beziers[base_idx];
+
+    if (!d2d_array_reserve((void **)&geometry->outline.bezier_faces, &geometry->outline.bezier_faces_size,
+            geometry->outline.bezier_face_count + 5, sizeof(*geometry->outline.bezier_faces)))
+    {
+        ERR("Failed to grow outline faces array.\n");
+        return FALSE;
+    }
+    f = &geometry->outline.bezier_faces[geometry->outline.bezier_face_count];
+
+    /* Calculate the object-space to texture-space transformation matrix. */
+    s = (p0->y - p1->y) * p2->x + (p1->x - p0->x) * p2->y + (p0->x * p1->y - p0->y * p1->x);
+
+    tx.x = ((p0->y - p1->y) / s) + ((p2->y - p0->y) / s) * 0.5f;
+    tx.y = ((p1->x - p0->x) / s) + ((p0->x - p2->x) / s) * 0.5f;
+    tx.z = ((p0->x * p1->y - p0->y * p1->x) / s) + ((p2->x * p0->y - p2->y * p0->x) / s) * 0.5f;
+
+    ty.x = (p0->y - p1->y) / s;
+    ty.y = (p1->x - p0->x) / s;
+    ty.z = (p0->x * p1->y - p0->y * p1->x) / s;
+
+    d2d_point_lerp(&q0, p0, p1, 0.5f);
+    d2d_point_lerp(&q1, p1, p2, 0.5f);
+    d2d_point_lerp(&q2, &q0, &q1, 0.5f);
+
+    d2d_point_subtract(&r0, &q0, p0);
+    d2d_point_subtract(&r1, &q1, &q0);
+    d2d_point_subtract(&r2, p2, &q1);
+
+    d2d_point_normalise(&r0);
+    d2d_point_normalise(&r1);
+    d2d_point_normalise(&r2);
+
+    if (d2d_point_ccw(p0, p1, p2) > 0.0f)
+    {
+        d2d_point_scale(&r0, -1.0f);
+        d2d_point_scale(&r1, -1.0f);
+        d2d_point_scale(&r2, -1.0f);
+    }
+
+    s = -d2d_point_tan_half(&r0, &r1);
+    d2d_point_set(&r3, s * r0.x - r0.y, s * r0.y + r0.x);
+    s = -d2d_point_tan_half(&r1, &r2);
+    d2d_point_set(&r4, s * r1.x - r1.y, s * r1.y + r1.x);
+
+    d2d_bezier_outline_vertex_set(&b[0],  p0, -r0.y,  r0.x, &tx, &ty);
+    d2d_bezier_outline_vertex_set(&b[1],  p0,  r0.y, -r0.x, &tx, &ty);
+    d2d_bezier_outline_vertex_set(&b[2], &q0,  r3.x,  r3.y, &tx, &ty);
+    d2d_bezier_outline_vertex_set(&b[3], &q2,  r1.y, -r1.x, &tx, &ty);
+    d2d_bezier_outline_vertex_set(&b[4], &q1,  r4.x,  r4.y, &tx, &ty);
+    d2d_bezier_outline_vertex_set(&b[5],  p2,  r2.y, -r2.x, &tx, &ty);
+    d2d_bezier_outline_vertex_set(&b[6],  p2, -r2.y,  r2.x, &tx, &ty);
+    geometry->outline.bezier_count += 7;
+
+    d2d_face_set(&f[0], base_idx + 0, base_idx + 1, base_idx + 2);
+    d2d_face_set(&f[1], base_idx + 2, base_idx + 1, base_idx + 3);
+    d2d_face_set(&f[2], base_idx + 3, base_idx + 4, base_idx + 2);
+    d2d_face_set(&f[3], base_idx + 5, base_idx + 4, base_idx + 3);
+    d2d_face_set(&f[4], base_idx + 5, base_idx + 6, base_idx + 4);
+    geometry->outline.bezier_face_count += 5;
+
+    return TRUE;
+}
+
+static BOOL d2d_geometry_add_figure_outline(struct d2d_geometry *geometry,
+        struct d2d_figure *figure, D2D1_FIGURE_END figure_end)
+{
+    const D2D1_POINT_2F *prev, *p0, *next;
+    enum d2d_vertex_type prev_type, type;
+    size_t bezier_idx, i;
+
+    for (i = 0, bezier_idx = 0; i < figure->vertex_count; ++i)
+    {
+        type = figure->vertex_types[i];
+        if (type == D2D_VERTEX_TYPE_NONE)
+            continue;
+
+        p0 = &figure->vertices[i];
+
+        if (!i)
+        {
+            prev_type = figure->vertex_types[figure->vertex_count - 1];
+            if (prev_type == D2D_VERTEX_TYPE_BEZIER)
+                prev = &figure->bezier_controls[figure->bezier_control_count - 1];
+            else
+                prev = &figure->vertices[figure->vertex_count - 1];
+        }
+        else
+        {
+            prev_type = figure->vertex_types[i - 1];
+            if (prev_type == D2D_VERTEX_TYPE_BEZIER)
+                prev = &figure->bezier_controls[bezier_idx - 1];
+            else
+                prev = &figure->vertices[i - 1];
+        }
+
+        if (type == D2D_VERTEX_TYPE_BEZIER)
+            next = &figure->bezier_controls[bezier_idx++];
+        else if (i == figure->vertex_count - 1)
+            next = &figure->vertices[0];
+        else
+            next = &figure->vertices[i + 1];
+
+        if ((figure_end == D2D1_FIGURE_END_CLOSED || (i && i < figure->vertex_count - 1))
+                && !d2d_geometry_outline_add_join(geometry, prev, p0, next))
+        {
+            ERR("Failed to add join.\n");
+            return FALSE;
+        }
+
+        if (type == D2D_VERTEX_TYPE_LINE && (figure_end == D2D1_FIGURE_END_CLOSED || i < figure->vertex_count - 1)
+                && !d2d_geometry_outline_add_line_segment(geometry, p0, next))
+        {
+            ERR("Failed to add line segment.\n");
+            return FALSE;
+        }
+        else if (type == D2D_VERTEX_TYPE_BEZIER)
+        {
+            const D2D1_POINT_2F *p2;
+
+            if (i == figure->vertex_count - 1)
+                p2 = &figure->vertices[0];
+            else
+                p2 = &figure->vertices[i + 1];
+
+            if (!d2d_geometry_outline_add_bezier_segment(geometry, p0, next, p2))
+            {
+                ERR("Failed to add bezier segment.\n");
+                return FALSE;
+            }
+        }
+    }
+
+    return TRUE;
+}
+
 static void d2d_geometry_cleanup(struct d2d_geometry *geometry)
 {
+    HeapFree(GetProcessHeap(), 0, geometry->outline.bezier_faces);
+    HeapFree(GetProcessHeap(), 0, geometry->outline.beziers);
+    HeapFree(GetProcessHeap(), 0, geometry->outline.faces);
+    HeapFree(GetProcessHeap(), 0, geometry->outline.vertices);
     HeapFree(GetProcessHeap(), 0, geometry->fill.bezier_vertices);
     HeapFree(GetProcessHeap(), 0, geometry->fill.faces);
     HeapFree(GetProcessHeap(), 0, geometry->fill.vertices);
@@ -1880,8 +2235,16 @@
 
     figure = &geometry->u.path.figures[geometry->u.path.figure_count - 1];
     figure->vertex_types[figure->vertex_count - 1] = D2D_VERTEX_TYPE_LINE;
-    if (figure_end != D2D1_FIGURE_END_CLOSED)
-        FIXME("Ignoring figure_end %#x.\n", figure_end);
+    if (figure_end == D2D1_FIGURE_END_CLOSED && !memcmp(&figure->vertices[0],
+            &figure->vertices[figure->vertex_count - 1], sizeof(*figure->vertices)))
+        --figure->vertex_count;
+
+    if (!d2d_geometry_add_figure_outline(geometry, figure, figure_end))
+    {
+        ERR("Failed to add figure outline.\n");
+        geometry->u.path.state = D2D_GEOMETRY_STATE_ERROR;
+        return;
+    }
 
     geometry->u.path.state = D2D_GEOMETRY_STATE_OPEN;
 }
@@ -2602,6 +2965,8 @@
 
 HRESULT d2d_rectangle_geometry_init(struct d2d_geometry *geometry, ID2D1Factory *factory, const D2D1_RECT_F *rect)
 {
+    struct d2d_outline_vertex *ov;
+    struct d2d_face *f;
     D2D1_POINT_2F *fv;
     float l, r, t, b;
 
@@ -2613,14 +2978,24 @@
         d2d_geometry_cleanup(geometry);
         return E_OUTOFMEMORY;
     }
-    geometry->fill.vertex_count = 4;
     if (!d2d_array_reserve((void **)&geometry->fill.faces,
             &geometry->fill.faces_size, 2, sizeof(*geometry->fill.faces)))
     {
         d2d_geometry_cleanup(geometry);
         return E_OUTOFMEMORY;
     }
-    geometry->fill.face_count = 2;
+    if (!d2d_array_reserve((void **)&geometry->outline.vertices,
+            &geometry->outline.vertices_size, 8, sizeof(*geometry->outline.vertices)))
+    {
+        d2d_geometry_cleanup(geometry);
+        return E_OUTOFMEMORY;
+    }
+    if (!d2d_array_reserve((void **)&geometry->outline.faces,
+            &geometry->outline.faces_size, 8, sizeof(*geometry->outline.faces)))
+    {
+        d2d_geometry_cleanup(geometry);
+        return E_OUTOFMEMORY;
+    }
 
     l = min(rect->left, rect->right);
     r = max(rect->left, rect->right);
@@ -2632,13 +3007,34 @@
     d2d_point_set(&fv[1], l, b);
     d2d_point_set(&fv[2], r, t);
     d2d_point_set(&fv[3], r, b);
+    geometry->fill.vertex_count = 4;
+
+    f = geometry->fill.faces;
+    d2d_face_set(&f[0], 0, 2, 1);
+    d2d_face_set(&f[1], 1, 2, 3);
+    geometry->fill.face_count = 2;
 
-    geometry->fill.faces[0].v[0] = 0;
-    geometry->fill.faces[0].v[1] = 2;
-    geometry->fill.faces[0].v[2] = 1;
-    geometry->fill.faces[1].v[0] = 1;
-    geometry->fill.faces[1].v[1] = 2;
-    geometry->fill.faces[1].v[2] = 3;
+    ov = geometry->outline.vertices;
+    d2d_outline_vertex_set(&ov[0], l, t, -0.5f, -0.5f);
+    d2d_outline_vertex_set(&ov[1], l, t,  0.5f,  0.5f);
+    d2d_outline_vertex_set(&ov[2], l, b, -0.5f,  0.5f);
+    d2d_outline_vertex_set(&ov[3], l, b,  0.5f, -0.5f);
+    d2d_outline_vertex_set(&ov[4], r, b,  0.5f,  0.5f);
+    d2d_outline_vertex_set(&ov[5], r, b, -0.5f, -0.5f);
+    d2d_outline_vertex_set(&ov[6], r, t,  0.5f, -0.5f);
+    d2d_outline_vertex_set(&ov[7], r, t, -0.5f,  0.5f);
+    geometry->outline.vertex_count = 8;
+
+    f = geometry->outline.faces;
+    d2d_face_set(&f[0], 0, 1, 2);
+    d2d_face_set(&f[1], 2, 1, 3);
+    d2d_face_set(&f[2], 2, 3, 4);
+    d2d_face_set(&f[3], 4, 3, 5);
+    d2d_face_set(&f[4], 4, 5, 6);
+    d2d_face_set(&f[5], 6, 5, 7);
+    d2d_face_set(&f[6], 6, 7, 0);
+    d2d_face_set(&f[7], 0, 7, 1);
+    geometry->outline.face_count = 8;
 
     return S_OK;
 }
@@ -2688,6 +3084,10 @@
 
     if (!refcount)
     {
+        geometry->outline.bezier_faces = NULL;
+        geometry->outline.beziers = NULL;
+        geometry->outline.faces = NULL;
+        geometry->outline.vertices = NULL;
         geometry->fill.bezier_vertices = NULL;
         geometry->fill.faces = NULL;
         geometry->fill.vertices = NULL;
@@ -2895,6 +3295,7 @@
     ID2D1Geometry_AddRef(geometry->u.transformed.src_geometry = src_geometry);
     src_impl = unsafe_impl_from_ID2D1Geometry(src_geometry);
     geometry->fill = src_impl->fill;
+    geometry->outline = src_impl->outline;
 }
 
 struct d2d_geometry *unsafe_impl_from_ID2D1Geometry(ID2D1Geometry *iface)
diff -Naur wine-2.0a/dlls/d2d1/render_target.c wine-2.0b/dlls/d2d1/render_target.c
--- wine-2.0a/dlls/d2d1/render_target.c	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/d2d1/render_target.c	2017-07-11 20:37:49.000000000 +0100
@@ -614,11 +614,151 @@
     ID2D1EllipseGeometry_Release(geometry);
 }
 
+static void d2d_rt_draw_geometry(struct d2d_d3d_render_target *render_target,
+        const struct d2d_geometry *geometry, struct d2d_brush *brush, float stroke_width)
+{
+    ID3D10Buffer *ib, *vb, *vs_cb, *ps_cb;
+    D3D10_SUBRESOURCE_DATA buffer_data;
+    D3D10_BUFFER_DESC buffer_desc;
+    const D2D1_MATRIX_3X2_F *w;
+    float tmp_x, tmp_y;
+    HRESULT hr;
+    struct
+    {
+        struct
+        {
+            float _11, _21, _31, pad0;
+            float _12, _22, _32, stroke_width;
+        } transform_geometry;
+        struct d2d_vec4 transform_rtx;
+        struct d2d_vec4 transform_rty;
+    } vs_cb_data;
+
+    vs_cb_data.transform_geometry._11 = geometry->transform._11;
+    vs_cb_data.transform_geometry._21 = geometry->transform._21;
+    vs_cb_data.transform_geometry._31 = geometry->transform._31;
+    vs_cb_data.transform_geometry.pad0 = 0.0f;
+    vs_cb_data.transform_geometry._12 = geometry->transform._12;
+    vs_cb_data.transform_geometry._22 = geometry->transform._22;
+    vs_cb_data.transform_geometry._32 = geometry->transform._32;
+    vs_cb_data.transform_geometry.stroke_width = stroke_width;
+
+    w = &render_target->drawing_state.transform;
+
+    tmp_x = render_target->desc.dpiX / 96.0f;
+    vs_cb_data.transform_rtx.x = w->_11 * tmp_x;
+    vs_cb_data.transform_rtx.y = w->_21 * tmp_x;
+    vs_cb_data.transform_rtx.z = w->_31 * tmp_x;
+    vs_cb_data.transform_rtx.w = 2.0f / render_target->pixel_size.width;
+
+    tmp_y = render_target->desc.dpiY / 96.0f;
+    vs_cb_data.transform_rty.x = w->_12 * tmp_y;
+    vs_cb_data.transform_rty.y = w->_22 * tmp_y;
+    vs_cb_data.transform_rty.z = w->_32 * tmp_y;
+    vs_cb_data.transform_rty.w = -2.0f / render_target->pixel_size.height;
+
+    buffer_desc.ByteWidth = sizeof(vs_cb_data);
+    buffer_desc.Usage = D3D10_USAGE_DEFAULT;
+    buffer_desc.BindFlags = D3D10_BIND_CONSTANT_BUFFER;
+    buffer_desc.CPUAccessFlags = 0;
+    buffer_desc.MiscFlags = 0;
+
+    buffer_data.pSysMem = &vs_cb_data;
+    buffer_data.SysMemPitch = 0;
+    buffer_data.SysMemSlicePitch = 0;
+
+    if (FAILED(hr = ID3D10Device_CreateBuffer(render_target->device, &buffer_desc, &buffer_data, &vs_cb)))
+    {
+        WARN("Failed to create constant buffer, hr %#x.\n", hr);
+        return;
+    }
+
+    if (FAILED(hr = d2d_brush_get_ps_cb(brush, NULL, render_target, &ps_cb)))
+    {
+        WARN("Failed to get ps constant buffer, hr %#x.\n", hr);
+        ID3D10Buffer_Release(vs_cb);
+        return;
+    }
+
+    if (geometry->outline.face_count)
+    {
+        buffer_desc.ByteWidth = geometry->outline.face_count * sizeof(*geometry->outline.faces);
+        buffer_desc.BindFlags = D3D10_BIND_INDEX_BUFFER;
+        buffer_data.pSysMem = geometry->outline.faces;
+
+        if (FAILED(hr = ID3D10Device_CreateBuffer(render_target->device, &buffer_desc, &buffer_data, &ib)))
+        {
+            WARN("Failed to create index buffer, hr %#x.\n", hr);
+            goto done;
+        }
+
+        buffer_desc.ByteWidth = geometry->outline.vertex_count * sizeof(*geometry->outline.vertices);
+        buffer_desc.BindFlags = D3D10_BIND_VERTEX_BUFFER;
+        buffer_data.pSysMem = geometry->outline.vertices;
+
+        if (FAILED(hr = ID3D10Device_CreateBuffer(render_target->device, &buffer_desc, &buffer_data, &vb)))
+        {
+            ERR("Failed to create vertex buffer, hr %#x.\n", hr);
+            ID3D10Buffer_Release(ib);
+            goto done;
+        }
+
+        d2d_rt_draw(render_target, D2D_SHAPE_TYPE_OUTLINE, ib, 3 * geometry->outline.face_count, vb,
+                sizeof(*geometry->outline.vertices), vs_cb, ps_cb, brush, NULL);
+
+        ID3D10Buffer_Release(vb);
+        ID3D10Buffer_Release(ib);
+    }
+
+    if (geometry->outline.bezier_face_count)
+    {
+        buffer_desc.ByteWidth = geometry->outline.bezier_face_count * sizeof(*geometry->outline.bezier_faces);
+        buffer_desc.BindFlags = D3D10_BIND_INDEX_BUFFER;
+        buffer_data.pSysMem = geometry->outline.bezier_faces;
+
+        if (FAILED(hr = ID3D10Device_CreateBuffer(render_target->device, &buffer_desc, &buffer_data, &ib)))
+        {
+            WARN("Failed to create beziers index buffer, hr %#x.\n", hr);
+            goto done;
+        }
+
+        buffer_desc.ByteWidth = geometry->outline.bezier_count * sizeof(*geometry->outline.beziers);
+        buffer_desc.BindFlags = D3D10_BIND_VERTEX_BUFFER;
+        buffer_data.pSysMem = geometry->outline.beziers;
+
+        if (FAILED(hr = ID3D10Device_CreateBuffer(render_target->device, &buffer_desc, &buffer_data, &vb)))
+        {
+            ERR("Failed to create beziers vertex buffer, hr %#x.\n", hr);
+            ID3D10Buffer_Release(ib);
+            goto done;
+        }
+
+        d2d_rt_draw(render_target, D2D_SHAPE_TYPE_BEZIER_OUTLINE, ib, 3 * geometry->outline.bezier_face_count, vb,
+                sizeof(*geometry->outline.beziers), vs_cb, ps_cb, brush, NULL);
+
+        ID3D10Buffer_Release(vb);
+        ID3D10Buffer_Release(ib);
+    }
+
+done:
+    ID3D10Buffer_Release(ps_cb);
+    ID3D10Buffer_Release(vs_cb);
+}
+
 static void STDMETHODCALLTYPE d2d_d3d_render_target_DrawGeometry(ID2D1RenderTarget *iface,
         ID2D1Geometry *geometry, ID2D1Brush *brush, float stroke_width, ID2D1StrokeStyle *stroke_style)
 {
-    FIXME("iface %p, geometry %p, brush %p, stroke_width %.8e, stroke_style %p stub!\n",
+    const struct d2d_geometry *geometry_impl = unsafe_impl_from_ID2D1Geometry(geometry);
+    struct d2d_d3d_render_target *render_target = impl_from_ID2D1RenderTarget(iface);
+    struct d2d_brush *brush_impl = unsafe_impl_from_ID2D1Brush(brush);
+
+    TRACE("iface %p, geometry %p, brush %p, stroke_width %.8e, stroke_style %p.\n",
             iface, geometry, brush, stroke_width, stroke_style);
+
+    if (stroke_style)
+        FIXME("Ignoring stoke style %p.\n", stroke_style);
+
+    d2d_rt_draw_geometry(render_target, geometry_impl, brush_impl, stroke_width);
 }
 
 static void d2d_rt_fill_geometry(struct d2d_d3d_render_target *render_target,
@@ -1770,15 +1910,63 @@
     unsigned int i, j, k;
     HRESULT hr;
 
+    static const D3D10_INPUT_ELEMENT_DESC il_desc_outline[] =
+    {
+        {"POSITION", 0, DXGI_FORMAT_R32G32_FLOAT, 0, 0, D3D10_INPUT_PER_VERTEX_DATA, 0},
+        {"OFFSET", 0, DXGI_FORMAT_R32G32_FLOAT, 0, 8, D3D10_INPUT_PER_VERTEX_DATA, 0},
+    };
     static const D3D10_INPUT_ELEMENT_DESC il_desc_triangle[] =
     {
         {"POSITION", 0, DXGI_FORMAT_R32G32_FLOAT, 0, 0, D3D10_INPUT_PER_VERTEX_DATA, 0},
     };
+    static const D3D10_INPUT_ELEMENT_DESC il_desc_bezier_outline[] =
+    {
+        {"POSITION", 0, DXGI_FORMAT_R32G32_FLOAT, 0, 0, D3D10_INPUT_PER_VERTEX_DATA, 0},
+        {"OFFSET", 0, DXGI_FORMAT_R32G32_FLOAT, 0, 8, D3D10_INPUT_PER_VERTEX_DATA, 0},
+        {"TX", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, 16, D3D10_INPUT_PER_VERTEX_DATA, 0},
+        {"TY", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, 28, D3D10_INPUT_PER_VERTEX_DATA, 0},
+    };
     static const D3D10_INPUT_ELEMENT_DESC il_desc_bezier[] =
     {
         {"POSITION", 0, DXGI_FORMAT_R32G32_FLOAT,    0, 0, D3D10_INPUT_PER_VERTEX_DATA, 0},
         {"TEXCOORD", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, 8, D3D10_INPUT_PER_VERTEX_DATA, 0},
     };
+    static const DWORD vs_code_outline[] =
+    {
+#if 0
+        float3x2 transform_geometry;
+        float stroke_width;
+        float4 transform_rtx;
+        float4 transform_rty;
+
+        float4 main(float2 position : POSITION, float2 offset : OFFSET) : SV_POSITION
+        {
+            position.xy = mul(float3(position.xy, 1.0f), transform_geometry) + offset.xy * stroke_width;
+            return float4(mul(float2x3(transform_rtx.xyz * transform_rtx.w, transform_rty.xyz * transform_rty.w),
+                    float3(position.xy, 1.0f)) + float2(-1.0f, 1.0f), 0.0f, 1.0f);
+        }
+#endif
+        0x43425844, 0xb2890107, 0x0ff7a115, 0x027ddea9, 0x0cba856a, 0x00000001, 0x00000270, 0x00000003,
+        0x0000002c, 0x0000007c, 0x000000b0, 0x4e475349, 0x00000048, 0x00000002, 0x00000008, 0x00000038,
+        0x00000000, 0x00000000, 0x00000003, 0x00000000, 0x00000303, 0x00000041, 0x00000000, 0x00000000,
+        0x00000003, 0x00000001, 0x00000303, 0x49534f50, 0x4e4f4954, 0x46464f00, 0x00544553, 0x4e47534f,
+        0x0000002c, 0x00000001, 0x00000008, 0x00000020, 0x00000000, 0x00000001, 0x00000003, 0x00000000,
+        0x0000000f, 0x505f5653, 0x5449534f, 0x004e4f49, 0x52444853, 0x000001b8, 0x00010040, 0x0000006e,
+        0x04000059, 0x00208e46, 0x00000000, 0x00000004, 0x0300005f, 0x00101032, 0x00000000, 0x0300005f,
+        0x00101032, 0x00000001, 0x04000067, 0x001020f2, 0x00000000, 0x00000001, 0x02000068, 0x00000003,
+        0x05000036, 0x00100032, 0x00000000, 0x00101046, 0x00000000, 0x05000036, 0x00100042, 0x00000000,
+        0x00004001, 0x3f800000, 0x08000010, 0x00100012, 0x00000001, 0x00100246, 0x00000000, 0x00208246,
+        0x00000000, 0x00000000, 0x08000010, 0x00100022, 0x00000001, 0x00100246, 0x00000000, 0x00208246,
+        0x00000000, 0x00000001, 0x0a000032, 0x00100032, 0x00000000, 0x00101046, 0x00000001, 0x00208ff6,
+        0x00000000, 0x00000001, 0x00100046, 0x00000001, 0x09000038, 0x00100072, 0x00000001, 0x00208ff6,
+        0x00000000, 0x00000002, 0x00208246, 0x00000000, 0x00000002, 0x05000036, 0x00100042, 0x00000000,
+        0x00004001, 0x3f800000, 0x07000010, 0x00100012, 0x00000001, 0x00100246, 0x00000001, 0x00100246,
+        0x00000000, 0x09000038, 0x00100072, 0x00000002, 0x00208ff6, 0x00000000, 0x00000003, 0x00208246,
+        0x00000000, 0x00000003, 0x07000010, 0x00100022, 0x00000001, 0x00100246, 0x00000002, 0x00100246,
+        0x00000000, 0x0a000000, 0x00102032, 0x00000000, 0x00100046, 0x00000001, 0x00004002, 0xbf800000,
+        0x3f800000, 0x00000000, 0x00000000, 0x08000036, 0x001020c2, 0x00000000, 0x00004002, 0x00000000,
+        0x00000000, 0x00000000, 0x3f800000, 0x0100003e,
+    };
     static const DWORD vs_code_triangle[] =
     {
         /* float3x2 transform;
@@ -1798,6 +1986,61 @@
         0x00000000, 0x00208246, 0x00000000, 0x00000001, 0x05000036, 0x001020c2, 0x00000000, 0x00101ea6,
         0x00000000, 0x0100003e,
     };
+    static const DWORD vs_code_bezier_outline[] =
+    {
+#if 0
+        float3x2 transform_geometry;
+        float stroke_width;
+        float4 transform_rtx;
+        float4 transform_rty;
+
+        float4 main(float2 position : POSITION, float2 offset : OFFSET, float3 tx : TX, float3 ty : TY,
+                out float2 texcoord : UV, out float2x2 stroke_transform : STROKE_TRANSFORM) : SV_POSITION
+        {
+            stroke_transform = float2x2(transform_rtx.xy, transform_rty.xy) * 0.5f * stroke_width;
+            position.xy = mul(float3(position.xy, 1.0f), transform_geometry) + offset.xy * stroke_width;
+            texcoord.x = position.x * tx.x + position.y * tx.y + tx.z;
+            texcoord.y = position.x * ty.x + position.y * ty.y + ty.z;
+            return float4(mul(float2x3(transform_rtx.xyz, transform_rty.xyz), float3(position.xy, 1.0f))
+                    * float2(transform_rtx.w, transform_rty.w) + float2(-1.0f, 1.0f), 0.0f, 1.0f);
+        }
+#endif
+        0x43425844, 0xa6662ccc, 0x77c5ae54, 0xb35a2d98, 0x582e52b5, 0x00000001, 0x00000450, 0x00000003,
+        0x0000002c, 0x000000b4, 0x00000144, 0x4e475349, 0x00000080, 0x00000004, 0x00000008, 0x00000068,
+        0x00000000, 0x00000000, 0x00000003, 0x00000000, 0x00000303, 0x00000071, 0x00000000, 0x00000000,
+        0x00000003, 0x00000001, 0x00000303, 0x00000078, 0x00000000, 0x00000000, 0x00000003, 0x00000002,
+        0x00000707, 0x0000007b, 0x00000000, 0x00000000, 0x00000003, 0x00000003, 0x00000707, 0x49534f50,
+        0x4e4f4954, 0x46464f00, 0x00544553, 0x54005854, 0xabab0059, 0x4e47534f, 0x00000088, 0x00000004,
+        0x00000008, 0x00000068, 0x00000000, 0x00000001, 0x00000003, 0x00000000, 0x0000000f, 0x00000074,
+        0x00000000, 0x00000000, 0x00000003, 0x00000001, 0x00000c03, 0x00000077, 0x00000000, 0x00000000,
+        0x00000003, 0x00000002, 0x00000c03, 0x00000077, 0x00000001, 0x00000000, 0x00000003, 0x00000003,
+        0x00000c03, 0x505f5653, 0x5449534f, 0x004e4f49, 0x53005655, 0x4b4f5254, 0x52545f45, 0x46534e41,
+        0x004d524f, 0x52444853, 0x00000304, 0x00010040, 0x000000c1, 0x04000059, 0x00208e46, 0x00000000,
+        0x00000004, 0x0300005f, 0x00101032, 0x00000000, 0x0300005f, 0x00101032, 0x00000001, 0x0300005f,
+        0x00101072, 0x00000002, 0x0300005f, 0x00101072, 0x00000003, 0x04000067, 0x001020f2, 0x00000000,
+        0x00000001, 0x03000065, 0x00102032, 0x00000001, 0x03000065, 0x00102032, 0x00000002, 0x03000065,
+        0x00102032, 0x00000003, 0x02000068, 0x00000002, 0x05000036, 0x00100032, 0x00000000, 0x00101046,
+        0x00000000, 0x05000036, 0x00100042, 0x00000000, 0x00004001, 0x3f800000, 0x08000010, 0x00100012,
+        0x00000001, 0x00100246, 0x00000000, 0x00208246, 0x00000000, 0x00000000, 0x08000010, 0x00100022,
+        0x00000001, 0x00100246, 0x00000000, 0x00208246, 0x00000000, 0x00000001, 0x0a000032, 0x00100032,
+        0x00000000, 0x00101046, 0x00000001, 0x00208ff6, 0x00000000, 0x00000001, 0x00100046, 0x00000001,
+        0x05000036, 0x00100042, 0x00000000, 0x00004001, 0x3f800000, 0x08000010, 0x00100082, 0x00000000,
+        0x00208246, 0x00000000, 0x00000002, 0x00100246, 0x00000000, 0x08000010, 0x00100042, 0x00000000,
+        0x00208246, 0x00000000, 0x00000003, 0x00100246, 0x00000000, 0x08000038, 0x00100022, 0x00000001,
+        0x0010002a, 0x00000000, 0x0020803a, 0x00000000, 0x00000003, 0x08000038, 0x00100012, 0x00000001,
+        0x0010003a, 0x00000000, 0x0020803a, 0x00000000, 0x00000002, 0x0a000000, 0x00102032, 0x00000000,
+        0x00100046, 0x00000001, 0x00004002, 0xbf800000, 0x3f800000, 0x00000000, 0x00000000, 0x08000036,
+        0x001020c2, 0x00000000, 0x00004002, 0x00000000, 0x00000000, 0x00000000, 0x3f800000, 0x0700000f,
+        0x00100042, 0x00000000, 0x00100046, 0x00000000, 0x00101046, 0x00000002, 0x0700000f, 0x00100012,
+        0x00000000, 0x00100046, 0x00000000, 0x00101046, 0x00000003, 0x07000000, 0x00102022, 0x00000001,
+        0x0010000a, 0x00000000, 0x0010102a, 0x00000003, 0x07000000, 0x00102012, 0x00000001, 0x0010002a,
+        0x00000000, 0x0010102a, 0x00000002, 0x06000036, 0x00100032, 0x00000000, 0x00208046, 0x00000000,
+        0x00000002, 0x06000036, 0x001000c2, 0x00000000, 0x00208406, 0x00000000, 0x00000003, 0x08000038,
+        0x001000f2, 0x00000000, 0x00100e46, 0x00000000, 0x00208ff6, 0x00000000, 0x00000001, 0x0a000038,
+        0x001000f2, 0x00000000, 0x00100e46, 0x00000000, 0x00004002, 0x3f000000, 0x3f000000, 0x3f000000,
+        0x3f000000, 0x05000036, 0x00102032, 0x00000002, 0x00100086, 0x00000000, 0x05000036, 0x00102032,
+        0x00000003, 0x001005d6, 0x00000000, 0x0100003e,
+    };
     static const DWORD vs_code_bezier[] =
     {
 #if 0
@@ -2028,6 +2271,55 @@
         0x00000000, 0x00000001, 0x0010003a, 0x00000001, 0x07000038, 0x001020f2, 0x00000000, 0x00100006,
         0x00000000, 0x00100e46, 0x00000001, 0x0100003e,
     };
+    /* Evaluate the implicit form of the curve (uÂ² - v = 0) in texture space,
+     * using the screen-space partial derivatives to convert the calculated
+     * distance to object space.
+     *
+     * d = |f(x, y)| / ââf(x, y)â
+     *   = |f(x, y)| / â((âf/âx)Â² + (âf/ây)Â²)
+     * f(x, y) = u(x, y)Â² - v(x, y)
+     * âf/âx = 2u Â· âu/âx - âv/âx
+     * âf/ây = 2u Â· âu/ây - âv/ây */
+    static const DWORD ps_code_bezier_solid_outline[] =
+    {
+#if 0
+        float4 color;
+
+        float4 main(float4 position : SV_POSITION, float2 uv : UV,
+                nointerpolation float2x2 stroke_transform : STROKE_TRANSFORM) : SV_Target
+        {
+            float2 du, dv, df;
+
+            du = float2(ddx(uv.x), ddy(uv.x));
+            dv = float2(ddx(uv.y), ddy(uv.y));
+            df = (2 * uv.xx) * du - dv;
+            clip(length(mul(stroke_transform, df)) - abs((uv.x * uv.x - uv.y)));
+            return color;
+        }
+#endif
+        0x43425844, 0xacc0cbff, 0xe90aba03, 0xf07761b4, 0x96232de8, 0x00000001, 0x000002b0, 0x00000003,
+        0x0000002c, 0x000000bc, 0x000000f0, 0x4e475349, 0x00000088, 0x00000004, 0x00000008, 0x00000068,
+        0x00000000, 0x00000001, 0x00000003, 0x00000000, 0x0000000f, 0x00000074, 0x00000000, 0x00000000,
+        0x00000003, 0x00000001, 0x00000303, 0x00000077, 0x00000000, 0x00000000, 0x00000003, 0x00000002,
+        0x00000303, 0x00000077, 0x00000001, 0x00000000, 0x00000003, 0x00000003, 0x00000303, 0x505f5653,
+        0x5449534f, 0x004e4f49, 0x53005655, 0x4b4f5254, 0x52545f45, 0x46534e41, 0x004d524f, 0x4e47534f,
+        0x0000002c, 0x00000001, 0x00000008, 0x00000020, 0x00000000, 0x00000000, 0x00000003, 0x00000000,
+        0x0000000f, 0x545f5653, 0x65677261, 0xabab0074, 0x52444853, 0x000001b8, 0x00000040, 0x0000006e,
+        0x04000059, 0x00208e46, 0x00000000, 0x00000001, 0x03001062, 0x00101032, 0x00000001, 0x03000862,
+        0x00101032, 0x00000002, 0x03000862, 0x00101032, 0x00000003, 0x03000065, 0x001020f2, 0x00000000,
+        0x02000068, 0x00000002, 0x0500000b, 0x00100032, 0x00000000, 0x00101046, 0x00000001, 0x0500000c,
+        0x001000c2, 0x00000000, 0x00101406, 0x00000001, 0x07000000, 0x00100012, 0x00000001, 0x0010100a,
+        0x00000001, 0x0010100a, 0x00000001, 0x0a000032, 0x00100032, 0x00000000, 0x00100006, 0x00000001,
+        0x00100086, 0x00000000, 0x801005d6, 0x00000041, 0x00000000, 0x07000038, 0x00100062, 0x00000000,
+        0x00100556, 0x00000000, 0x00101106, 0x00000003, 0x09000032, 0x00100032, 0x00000000, 0x00101046,
+        0x00000002, 0x00100006, 0x00000000, 0x00100596, 0x00000000, 0x0700000f, 0x00100012, 0x00000000,
+        0x00100046, 0x00000000, 0x00100046, 0x00000000, 0x0500004b, 0x00100012, 0x00000000, 0x0010000a,
+        0x00000000, 0x0a000032, 0x00100022, 0x00000000, 0x0010100a, 0x00000001, 0x0010100a, 0x00000001,
+        0x8010101a, 0x00000041, 0x00000001, 0x08000000, 0x00100012, 0x00000000, 0x8010001a, 0x000000c1,
+        0x00000000, 0x0010000a, 0x00000000, 0x07000031, 0x00100012, 0x00000000, 0x0010000a, 0x00000000,
+        0x00004001, 0x00000000, 0x0304000d, 0x0010000a, 0x00000000, 0x06000036, 0x001020f2, 0x00000000,
+        0x00208e46, 0x00000000, 0x00000000, 0x0100003e,
+    };
     /* The basic idea here is to evaluate the implicit form of the curve in
      * texture space. "t.z" determines which side of the curve is shaded. */
     static const DWORD ps_code_bezier_solid[] =
@@ -2067,7 +2359,7 @@
         {ps_code_triangle_solid, sizeof(ps_code_triangle_solid),
                 D2D_SHAPE_TYPE_TRIANGLE, D2D_BRUSH_TYPE_SOLID, D2D_BRUSH_TYPE_COUNT},
         {ps_code_triangle_solid_bitmap, sizeof(ps_code_triangle_solid_bitmap),
-            D2D_SHAPE_TYPE_TRIANGLE, D2D_BRUSH_TYPE_SOLID, D2D_BRUSH_TYPE_BITMAP},
+                D2D_SHAPE_TYPE_TRIANGLE, D2D_BRUSH_TYPE_SOLID, D2D_BRUSH_TYPE_BITMAP},
         {ps_code_triangle_bitmap, sizeof(ps_code_triangle_bitmap),
                 D2D_SHAPE_TYPE_TRIANGLE, D2D_BRUSH_TYPE_BITMAP, D2D_BRUSH_TYPE_COUNT},
         {ps_code_triangle_bitmap_solid, sizeof(ps_code_triangle_bitmap_solid),
@@ -2076,6 +2368,8 @@
                 D2D_SHAPE_TYPE_TRIANGLE, D2D_BRUSH_TYPE_BITMAP, D2D_BRUSH_TYPE_BITMAP},
         {ps_code_bezier_solid, sizeof(ps_code_bezier_solid),
                 D2D_SHAPE_TYPE_BEZIER, D2D_BRUSH_TYPE_SOLID, D2D_BRUSH_TYPE_COUNT},
+        {ps_code_bezier_solid_outline, sizeof(ps_code_bezier_solid_outline),
+                D2D_SHAPE_TYPE_BEZIER_OUTLINE, D2D_BRUSH_TYPE_SOLID, D2D_BRUSH_TYPE_COUNT},
     };
     static const struct
     {
@@ -2154,6 +2448,14 @@
         goto err;
     }
 
+    if (FAILED(hr = ID3D10Device_CreateInputLayout(render_target->device, il_desc_outline,
+            sizeof(il_desc_outline) / sizeof(*il_desc_outline), vs_code_outline, sizeof(vs_code_outline),
+            &render_target->shape_resources[D2D_SHAPE_TYPE_OUTLINE].il)))
+    {
+        WARN("Failed to create triangle input layout, hr %#x.\n", hr);
+        goto err;
+    }
+
     if (FAILED(hr = ID3D10Device_CreateInputLayout(render_target->device, il_desc_triangle,
             sizeof(il_desc_triangle) / sizeof(*il_desc_triangle), vs_code_triangle, sizeof(vs_code_triangle),
             &render_target->shape_resources[D2D_SHAPE_TYPE_TRIANGLE].il)))
@@ -2162,6 +2464,15 @@
         goto err;
     }
 
+    if (FAILED(hr = ID3D10Device_CreateInputLayout(render_target->device, il_desc_bezier_outline,
+            sizeof(il_desc_bezier_outline) / sizeof(*il_desc_bezier_outline),
+            vs_code_bezier_outline, sizeof(vs_code_bezier_outline),
+            &render_target->shape_resources[D2D_SHAPE_TYPE_BEZIER_OUTLINE].il)))
+    {
+        WARN("Failed to create bezier input layout, hr %#x.\n", hr);
+        goto err;
+    }
+
     if (FAILED(hr = ID3D10Device_CreateInputLayout(render_target->device, il_desc_bezier,
             sizeof(il_desc_bezier) / sizeof(*il_desc_bezier), vs_code_bezier, sizeof(vs_code_bezier),
             &render_target->shape_resources[D2D_SHAPE_TYPE_BEZIER].il)))
@@ -2170,6 +2481,20 @@
         goto err;
     }
 
+    if (FAILED(hr = ID3D10Device_CreateVertexShader(render_target->device, vs_code_outline,
+            sizeof(vs_code_outline), &render_target->shape_resources[D2D_SHAPE_TYPE_OUTLINE].vs)))
+    {
+        WARN("Failed to create triangle vertex shader, hr %#x.\n", hr);
+        goto err;
+    }
+
+    if (FAILED(hr = ID3D10Device_CreateVertexShader(render_target->device, vs_code_bezier_outline,
+            sizeof(vs_code_bezier_outline), &render_target->shape_resources[D2D_SHAPE_TYPE_BEZIER_OUTLINE].vs)))
+    {
+        WARN("Failed to create triangle vertex shader, hr %#x.\n", hr);
+        goto err;
+    }
+
     if (FAILED(hr = ID3D10Device_CreateVertexShader(render_target->device, vs_code_triangle,
             sizeof(vs_code_triangle), &render_target->shape_resources[D2D_SHAPE_TYPE_TRIANGLE].vs)))
     {
@@ -2196,6 +2521,18 @@
         }
     }
 
+    for (j = 0; j < D2D_BRUSH_TYPE_COUNT; ++j)
+    {
+        for (k = 0; k < D2D_BRUSH_TYPE_COUNT + 1; ++k)
+        {
+            struct d2d_shape_resources *outline = &render_target->shape_resources[D2D_SHAPE_TYPE_OUTLINE];
+            struct d2d_shape_resources *triangle = &render_target->shape_resources[D2D_SHAPE_TYPE_TRIANGLE];
+
+            if (triangle->ps[j][k])
+                ID3D10PixelShader_AddRef(outline->ps[j][k] = triangle->ps[j][k]);
+        }
+    }
+
     buffer_desc.ByteWidth = sizeof(indices);
     buffer_desc.Usage = D3D10_USAGE_DEFAULT;
     buffer_desc.BindFlags = D3D10_BIND_INDEX_BUFFER;
diff -Naur wine-2.0a/dlls/d3d11/state.c wine-2.0b/dlls/d3d11/state.c
--- wine-2.0a/dlls/d3d11/state.c	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/d3d11/state.c	2017-07-11 20:37:49.000000000 +0100
@@ -1210,7 +1210,7 @@
     wined3d_desc.comparison_func = wined3d_cmp_func_from_d3d11(desc->ComparisonFunc);
     wined3d_desc.srgb_decode = TRUE;
 
-    if (FAILED(hr = wined3d_sampler_create(device->wined3d_device, &wined3d_desc, state, &state->wined3d_sampler)))
+    if (FAILED(hr = wined3d_sampler_create(device->wined3d_device, &wined3d_desc, state, &state->wined3d_sampler, FALSE)))
     {
         WARN("Failed to create wined3d sampler, hr %#x.\n", hr);
         wined3d_private_store_cleanup(&state->private_store);
diff -Naur wine-2.0a/dlls/ddraw/ddraw.c wine-2.0b/dlls/ddraw/ddraw.c
--- wine-2.0a/dlls/ddraw/ddraw.c	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/ddraw/ddraw.c	2017-07-11 20:37:49.000000000 +0100
@@ -779,6 +779,13 @@
             restore_mode_on_normal);
     DDRAW_dump_cooperativelevel(cooplevel);
 
+    /* hack for WA/WWP/Diablo, wine bug 2082
+     *
+     * These programs use dialog boxes containing standard controls, which they
+     * draw over using directdraw. If we draw to the given window, the draw will
+     * be clipped by the dialog. Instead, draw to the desktop window. */
+    if (use_desktop_hack) window = GetDesktopWindow();
+
     wined3d_mutex_lock();
 
     if (ddraw->flags & DDRAW_SCL_RECURSIVE)
diff -Naur wine-2.0a/dlls/ddraw/ddraw_private.h wine-2.0b/dlls/ddraw/ddraw_private.h
--- wine-2.0a/dlls/ddraw/ddraw_private.h	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/ddraw/ddraw_private.h	2017-07-11 20:37:49.000000000 +0100
@@ -61,7 +61,7 @@
 
 #define DDRAW_WINED3D_FLAGS     (WINED3D_LEGACY_DEPTH_BIAS | WINED3D_VIDMEM_ACCOUNTING \
         | WINED3D_RESTORE_MODE_ON_ACTIVATE | WINED3D_FOCUS_MESSAGES | WINED3D_PIXEL_CENTER_INTEGER \
-        | WINED3D_LEGACY_UNBOUND_RESOURCE_COLOR | WINED3D_NO_PRIMITIVE_RESTART)
+        | WINED3D_LEGACY_UNBOUND_RESOURCE_COLOR | WINED3D_NO_PRIMITIVE_RESTART | WINED3D_NO_CSMT)
 
 enum ddraw_device_state
 {
@@ -142,6 +142,9 @@
 void DDRAW_Convert_DDDEVICEIDENTIFIER_2_To_1(const DDDEVICEIDENTIFIER2 *pIn, DDDEVICEIDENTIFIER *pOut) DECLSPEC_HIDDEN;
 struct wined3d_vertex_declaration *ddraw_find_decl(struct ddraw *ddraw, DWORD fvf) DECLSPEC_HIDDEN;
 
+/* hack for WA/WWP/Diablo */
+extern int use_desktop_hack;
+
 struct ddraw_surface
 {
     /* IUnknown fields */
diff -Naur wine-2.0a/dlls/ddraw/main.c wine-2.0b/dlls/ddraw/main.c
--- wine-2.0a/dlls/ddraw/main.c	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/ddraw/main.c	2017-07-11 20:37:49.000000000 +0100
@@ -33,6 +33,9 @@
 
 WINE_DEFAULT_DEBUG_CHANNEL(ddraw);
 
+/* hack for WA/WWP/Diablo */
+int use_desktop_hack = 0;
+
 static struct list global_ddraw_list = LIST_INIT(global_ddraw_list);
 
 static HINSTANCE instance;
@@ -811,6 +814,22 @@
 }
 
 /***********************************************************************
+ * get_config_key
+ *
+ * Reads a config key from the registry. Taken from WineD3D
+ *
+ ***********************************************************************/
+static inline DWORD get_config_key(HKEY defkey, HKEY appkey, const char* name, char* buffer, DWORD size)
+{
+    if (0 != appkey && !RegQueryValueExA( appkey, name, 0, NULL, (LPBYTE) buffer, &size )) return 0;
+    if (0 != defkey && !RegQueryValueExA( defkey, name, 0, NULL, (LPBYTE) buffer, &size )) return 0;
+    return ERROR_FILE_NOT_FOUND;
+}
+
+#define IS_OPTION_TRUE(ch) \
+    ((ch) == 'y' || (ch) == 'Y' || (ch) == 't' || (ch) == 'T' || (ch) == '1')
+
+/***********************************************************************
  * DllMain (DDRAW.0)
  *
  * Could be used to register DirectDraw drivers, if we have more than
@@ -825,8 +844,12 @@
     case DLL_PROCESS_ATTACH:
     {
         static HMODULE ddraw_self;
+        char buffer[MAX_PATH+10];
+        DWORD size = sizeof(buffer);
         HKEY hkey = 0;
+        HKEY appkey = 0;
         WNDCLASSA wc;
+        DWORD len;
 
         /* Register the window class. This is used to create a hidden window
          * for D3D rendering, if the application didn't pass one. It can also
@@ -847,6 +870,33 @@
             return FALSE;
         }
 
+       /* @@ Wine registry key: HKCU\Software\Wine\Direct3D */
+       if ( RegOpenKeyA( HKEY_CURRENT_USER, "Software\\Wine\\Direct3D", &hkey ) ) hkey = 0;
+
+       len = GetModuleFileNameA( 0, buffer, MAX_PATH );
+       if (len && len < MAX_PATH)
+       {
+            HKEY tmpkey;
+            /* @@ Wine registry key: HKCU\Software\Wine\AppDefaults\app.exe\Direct3D */
+            if (!RegOpenKeyA( HKEY_CURRENT_USER, "Software\\Wine\\AppDefaults", &tmpkey ))
+            {
+                char *p, *appname = buffer;
+                if ((p = strrchr( appname, '/' ))) appname = p + 1;
+                if ((p = strrchr( appname, '\\' ))) appname = p + 1;
+                strcat( appname, "\\Direct3D" );
+                TRACE("appname = [%s]\n", appname);
+                if (RegOpenKeyA( tmpkey, appname, &appkey )) appkey = 0;
+                RegCloseKey( tmpkey );
+            }
+       }
+
+       if ( 0 != hkey || 0 != appkey )
+       {
+            /* hack for WA/WWP/Diablo */
+            if ( !get_config_key( hkey, appkey, "DDrawDesktopHack", buffer, size) )
+                use_desktop_hack = IS_OPTION_TRUE( buffer[0] );
+        }
+
         /* On Windows one can force the refresh rate that DirectDraw uses by
          * setting an override value in dxdiag.  This is documented in KB315614
          * (main article), KB230002, and KB217348.  By comparing registry dumps
diff -Naur wine-2.0a/dlls/dinput/dinput_main.c wine-2.0b/dlls/dinput/dinput_main.c
--- wine-2.0a/dlls/dinput/dinput_main.c	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/dinput/dinput_main.c	2017-07-11 20:37:49.000000000 +0100
@@ -90,7 +90,8 @@
     &keyboard_device,
     &joystick_linuxinput_device,
     &joystick_linux_device,
-    &joystick_osx_device
+    &joystick_osx_device,
+    &joystick_driver_device
 };
 #define NB_DINPUT_DEVICES (sizeof(dinput_devices)/sizeof(dinput_devices[0]))
 
diff -Naur wine-2.0a/dlls/dinput/dinput_private.h wine-2.0b/dlls/dinput/dinput_private.h
--- wine-2.0a/dlls/dinput/dinput_private.h	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/dinput/dinput_private.h	2017-07-11 20:37:49.000000000 +0100
@@ -58,6 +58,7 @@
 
 extern const struct dinput_device mouse_device DECLSPEC_HIDDEN;
 extern const struct dinput_device keyboard_device DECLSPEC_HIDDEN;
+extern const struct dinput_device joystick_driver_device DECLSPEC_HIDDEN;
 extern const struct dinput_device joystick_linux_device DECLSPEC_HIDDEN;
 extern const struct dinput_device joystick_linuxinput_device DECLSPEC_HIDDEN;
 extern const struct dinput_device joystick_osx_device DECLSPEC_HIDDEN;
diff -Naur wine-2.0a/dlls/dinput/joystick_driver.c wine-2.0b/dlls/dinput/joystick_driver.c
--- wine-2.0a/dlls/dinput/joystick_driver.c	1970-01-01 01:00:00.000000000 +0100
+++ wine-2.0b/dlls/dinput/joystick_driver.c	2017-07-11 20:37:49.000000000 +0100
@@ -0,0 +1,1348 @@
+/*  DirectInput Joystick device for the Graphics Driver
+ *
+ * Copyright 2015 CodeWeavers, Aric Stewart
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include "config.h"
+
+#include "wine/port.h"
+#include <stdio.h>
+#include "wine/debug.h"
+#include "wine/unicode.h"
+#include "windef.h"
+#include "winbase.h"
+#include "winerror.h"
+#include "winreg.h"
+#include "winternl.h"
+#include "dinput.h"
+
+#include "dinput_private.h"
+#include "device_private.h"
+#include "joystick_private.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(dinput);
+
+/* Driver interfaces */
+
+enum { DRIVER_AXIS_X = 0,
+       DRIVER_AXIS_Y,
+       DRIVER_AXIS_Z,
+       DRIVER_AXIS_RX,
+       DRIVER_AXIS_RY,
+       DRIVER_AXIS_RZ,
+       DRIVER_AXIS_OTHER};
+
+enum {
+    DRIVER_CONSTANTFORCE = 0x00000001,
+    DRIVER_RAMPFORCE = 0x00000002,
+    DRIVER_SQUARE = 0x00000004,
+    DRIVER_SINE = 0x00000008,
+    DRIVER_TRIANGLE = 0x00000010,
+    DRIVER_SAWTOOTHUP = 0x00000020,
+    DRIVER_SAWTOOTHDOWN = 0x00000040,
+    DRIVER_SPRING = 0x00000080,
+    DRIVER_DAMPER = 0x00000100,
+    DRIVER_INERTIA = 0x00000200,
+    DRIVER_FRICTION = 0x00000400,
+};
+
+typedef struct tagGAMEPAD_DRIVER {
+    INT (CDECL *pGamePadCount)(void);
+    VOID (CDECL *pGamePadName)(int id, char *name, int length);
+    VOID (CDECL *pGamePadElementCount)(int id, DWORD *axis, DWORD *buttons, DWORD* povs, int axis_map[8]);
+    VOID (CDECL *pGamePadElementProps)(int id, int element, int *min, int *max);
+    VOID (CDECL *pGamePadPollValues)(int id, int *values);
+
+    /* Aid in driver management */
+    BOOL (CDECL *pGamePadAlloc)(int id);
+    VOID (CDECL *pGamePadDealloc)(int id);
+
+    /* Force feedback interfaces */
+    BOOL    (CDECL *pGamePadHasForceFeedback)(int id, DWORD *effects);
+    BOOL    (CDECL *pGamePadElementHasForceFeedback)(int id, int element);
+    VOID    (CDECL *pGamePadGetForceFeedbackState)(int id, DWORD *state);
+    HRESULT (CDECL *pGamePadSetAutocenter)(int id, DWORD data);
+    HRESULT (CDECL *pGamePadGetAutocenter)(int id, DWORD *data);
+    HRESULT (CDECL *pGamePadSetFFGain)(int id, DWORD data);
+    HRESULT (CDECL *pGamePadGetFFGain)(int id, DWORD *data);
+    HRESULT (CDECL *pGamePadSendForceFeedbackCommand)(int id, DWORD flags);
+    DWORD   (CDECL *pGamePadCreateDinputEffect)(int id, const GUID *type, const DIEFFECT *params, IDirectInputEffect **out, IUnknown *outer);
+    VOID    (CDECL *pGamePadStopAllForceFeedbackEffects) (int id, int release);
+} GAMEPAD_DRIVER;
+
+static GAMEPAD_DRIVER null_driver, lazy_load_driver;
+
+const GAMEPAD_DRIVER *GAMEPAD_Driver = &lazy_load_driver;
+
+typedef struct JoystickImpl JoystickImpl;
+static const IDirectInputDevice8AVtbl JoystickAvt;
+static const IDirectInputDevice8WVtbl JoystickWvt;
+
+/* Driver interfaces */
+static void polldev(LPDIRECTINPUTDEVICE8A iface);
+
+struct JoystickImpl
+{
+    struct JoystickGenericImpl generic;
+
+    /* private */
+    int id;
+    int axis_map[8];
+    int *values;
+};
+
+static inline JoystickImpl *impl_from_IDirectInputDevice8A(IDirectInputDevice8A *iface)
+{
+    return CONTAINING_RECORD(CONTAINING_RECORD(CONTAINING_RECORD(iface, IDirectInputDeviceImpl, IDirectInputDevice8A_iface),
+           JoystickGenericImpl, base), JoystickImpl, generic);
+}
+static inline JoystickImpl *impl_from_IDirectInputDevice8W(IDirectInputDevice8W *iface)
+{
+    return CONTAINING_RECORD(CONTAINING_RECORD(CONTAINING_RECORD(iface, IDirectInputDeviceImpl, IDirectInputDevice8W_iface),
+           JoystickGenericImpl, base), JoystickImpl, generic);
+}
+
+static const GUID DInput_Wine_driver_Joystick_GUID = { /* B7C30F45-1F2C-4C79-8FD3-12A4E10C7646*/
+  0xB7C30F45, 0x1F2C, 0x4C79, {0x8F, 0xD3, 0x12, 0xA4, 0xE1, 0x0C, 0x76, 0x46}
+};
+
+static INT find_joystick_devices(void)
+{
+    static INT joystick_devices_count = -1;
+
+    if (joystick_devices_count != -1) return joystick_devices_count;
+
+    joystick_devices_count = GAMEPAD_Driver->pGamePadCount();
+
+    return  joystick_devices_count;
+}
+
+static HRESULT joydev_enum_deviceA(DWORD dwDevType, DWORD dwFlags, LPDIDEVICEINSTANCEA lpddi, DWORD version, int id)
+{
+    TRACE("dwDevType %u dwFlags 0x%08x version 0x%04x id %d\n", dwDevType, dwFlags, version, id);
+
+    if (id >= find_joystick_devices()) return E_FAIL;
+
+    if ((dwDevType == 0) ||
+    ((dwDevType == DIDEVTYPE_JOYSTICK) && (version > 0x0300 && version < 0x0800)) ||
+    (((dwDevType == DI8DEVCLASS_GAMECTRL) || (dwDevType == DI8DEVTYPE_JOYSTICK)) && (version >= 0x0800)))
+    {
+        if (dwFlags & DIEDFL_FORCEFEEDBACK) {
+            if (!GAMEPAD_Driver->pGamePadHasForceFeedback(id, NULL))
+                return S_FALSE;
+        }
+        /* Return joystick */
+        lpddi->guidInstance = DInput_Wine_driver_Joystick_GUID;
+        lpddi->guidInstance.Data3 = id;
+        lpddi->guidProduct = DInput_Wine_driver_Joystick_GUID;
+        /* we only support traditional joysticks for now */
+        if (version >= 0x0800)
+            lpddi->dwDevType = DI8DEVTYPE_JOYSTICK | (DI8DEVTYPEJOYSTICK_STANDARD << 8);
+        else
+            lpddi->dwDevType = DIDEVTYPE_JOYSTICK | (DIDEVTYPEJOYSTICK_TRADITIONAL << 8);
+        sprintf(lpddi->tszInstanceName, "Joystick %d", id);
+
+        /* get the device name */
+        GAMEPAD_Driver->pGamePadName(id, lpddi->tszProductName, MAX_PATH);
+
+        lpddi->guidFFDriver = GUID_NULL;
+        return S_OK;
+    }
+
+    return S_FALSE;
+}
+
+static HRESULT joydev_enum_deviceW(DWORD dwDevType, DWORD dwFlags, LPDIDEVICEINSTANCEW lpddi, DWORD version, int id)
+{
+    char name[MAX_PATH];
+    char friendly[32];
+
+    TRACE("dwDevType %u dwFlags 0x%08x version 0x%04x id %d\n", dwDevType, dwFlags, version, id);
+
+    if (id >= find_joystick_devices()) return E_FAIL;
+    if ((dwDevType == 0) ||
+    ((dwDevType == DIDEVTYPE_JOYSTICK) && (version > 0x0300 && version < 0x0800)) ||
+    (((dwDevType == DI8DEVCLASS_GAMECTRL) || (dwDevType == DI8DEVTYPE_JOYSTICK)) && (version >= 0x0800)))
+    {
+        if (dwFlags & DIEDFL_FORCEFEEDBACK) {
+            if (!GAMEPAD_Driver->pGamePadHasForceFeedback(id, NULL))
+                return S_FALSE;
+        }
+        /* Return joystick */
+        lpddi->guidInstance = DInput_Wine_driver_Joystick_GUID;
+        lpddi->guidInstance.Data3 = id;
+        lpddi->guidProduct = DInput_Wine_driver_Joystick_GUID;
+        /* we only support traditional joysticks for now */
+        if (version >= 0x0800)
+            lpddi->dwDevType = DI8DEVTYPE_JOYSTICK | (DI8DEVTYPEJOYSTICK_STANDARD << 8);
+        else
+            lpddi->dwDevType = DIDEVTYPE_JOYSTICK | (DIDEVTYPEJOYSTICK_TRADITIONAL << 8);
+        sprintf(friendly, "Joystick %d", id);
+        MultiByteToWideChar(CP_ACP, 0, friendly, -1, lpddi->tszInstanceName, MAX_PATH);
+        /* get the device name */
+        GAMEPAD_Driver->pGamePadName(id, name, MAX_PATH);
+
+        MultiByteToWideChar(CP_ACP, 0, name, -1, lpddi->tszProductName, MAX_PATH);
+        lpddi->guidFFDriver = GUID_NULL;
+        return S_OK;
+    }
+
+    return S_FALSE;
+}
+
+static HRESULT alloc_device(REFGUID rguid, IDirectInputImpl *dinput,
+                            JoystickImpl **pdev, unsigned short index)
+{
+    DWORD i;
+    JoystickImpl* newDevice;
+    char name[MAX_PATH];
+    HRESULT hr;
+    LPDIDATAFORMAT df = NULL;
+    int idx = 0;
+    int slider_count = 0;
+
+    TRACE("%s %p %p %hu\n", debugstr_guid(rguid), dinput, pdev, index);
+
+    if (!GAMEPAD_Driver->pGamePadAlloc(index))
+    {
+        WARN("Driver gamepad alloc failed\n");
+        *pdev = 0;
+        return DIERR_OUTOFMEMORY;
+    }
+
+    newDevice = HeapAlloc(GetProcessHeap(),HEAP_ZERO_MEMORY,sizeof(JoystickImpl));
+    if (newDevice == 0) {
+        WARN("out of memory\n");
+        *pdev = 0;
+        return DIERR_OUTOFMEMORY;
+    }
+
+    newDevice->id = index;
+
+    newDevice->generic.guidInstance = DInput_Wine_driver_Joystick_GUID;
+    newDevice->generic.guidInstance.Data3 = index;
+    newDevice->generic.guidProduct = DInput_Wine_driver_Joystick_GUID;
+    newDevice->generic.joy_polldev = polldev;
+
+    /* get the device name */
+    GAMEPAD_Driver->pGamePadName(index, name, MAX_PATH);
+    TRACE("Name %s\n",name);
+
+    /* copy the device name */
+    newDevice->generic.name = HeapAlloc(GetProcessHeap(),0,strlen(name) + 1);
+    strcpy(newDevice->generic.name, name);
+
+    GAMEPAD_Driver->pGamePadElementCount(index,
+        &newDevice->generic.devcaps.dwAxes,
+        &newDevice->generic.devcaps.dwButtons,
+        &newDevice->generic.devcaps.dwPOVs, newDevice->axis_map);
+
+    if (GAMEPAD_Driver->pGamePadHasForceFeedback(index, NULL))
+        newDevice->generic.devcaps.dwFlags |= DIDC_FORCEFEEDBACK;
+
+    TRACE("%i axes %i buttons %i povs\n",newDevice->generic.devcaps.dwAxes,newDevice->generic.devcaps.dwButtons,newDevice->generic.devcaps.dwPOVs);
+
+    if (newDevice->generic.devcaps.dwButtons > 128)
+    {
+        WARN("Can't support %d buttons. Clamping down to 128\n", newDevice->generic.devcaps.dwButtons);
+        newDevice->generic.devcaps.dwButtons = 128;
+    }
+
+    newDevice->generic.base.IDirectInputDevice8A_iface.lpVtbl = &JoystickAvt;
+    newDevice->generic.base.IDirectInputDevice8W_iface.lpVtbl = &JoystickWvt;
+    newDevice->generic.base.ref = 1;
+    newDevice->generic.base.dinput = dinput;
+    newDevice->generic.base.guid = *rguid;
+    InitializeCriticalSection(&newDevice->generic.base.crit);
+    newDevice->generic.base.crit.DebugInfo->Spare[0] = (DWORD_PTR)(__FILE__ ": JoystickImpl*->generic.base.crit");
+
+    /* Create copy of default data format */
+    if (!(df = HeapAlloc(GetProcessHeap(), 0, c_dfDIJoystick2.dwSize))) goto FAILED;
+    memcpy(df, &c_dfDIJoystick2, c_dfDIJoystick2.dwSize);
+
+    df->dwNumObjs = newDevice->generic.devcaps.dwAxes + newDevice->generic.devcaps.dwPOVs + newDevice->generic.devcaps.dwButtons;
+    if (!(df->rgodf = HeapAlloc(GetProcessHeap(), 0, df->dwNumObjs * df->dwObjSize))) goto FAILED;
+
+    newDevice->values = HeapAlloc(GetProcessHeap(), 0, sizeof(int) * df->dwNumObjs);
+
+    for (i = 0; i < newDevice->generic.devcaps.dwAxes; i++)
+    {
+        int wine_obj = newDevice->axis_map[i];
+        if (wine_obj == DRIVER_AXIS_OTHER)
+        {
+            wine_obj = DRIVER_AXIS_OTHER + slider_count;
+            slider_count++;
+        }
+        if (wine_obj < 0 ) continue;
+
+        memcpy(&df->rgodf[idx], &c_dfDIJoystick2.rgodf[wine_obj], df->dwObjSize);
+        df->rgodf[idx].dwType = DIDFT_MAKEINSTANCE(wine_obj) | DIDFT_ABSAXIS;
+        if (GAMEPAD_Driver->pGamePadElementHasForceFeedback(index, idx))
+            df->rgodf[idx].dwFlags |= DIDOI_FFACTUATOR;
+        ++idx;
+    }
+
+    for (i = 0; i < newDevice->generic.devcaps.dwPOVs; i++)
+    {
+        memcpy(&df->rgodf[idx], &c_dfDIJoystick2.rgodf[i + 8], df->dwObjSize);
+        df->rgodf[idx++].dwType = DIDFT_MAKEINSTANCE(i) | DIDFT_POV;
+    }
+
+    for (i = 0; i < newDevice->generic.devcaps.dwButtons; i++)
+    {
+        memcpy(&df->rgodf[idx], &c_dfDIJoystick2.rgodf[i + 12], df->dwObjSize);
+        df->rgodf[idx  ].pguid = &GUID_Button;
+        df->rgodf[idx++].dwType = DIDFT_MAKEINSTANCE(i) | DIDFT_PSHBUTTON;
+    }
+    newDevice->generic.base.data_format.wine_df = df;
+
+    /* initialize properties */
+    for (i = 0; i < df->dwNumObjs; i++)
+    {
+        int min, max;
+        GAMEPAD_Driver->pGamePadElementProps(index, i, &min, &max);
+        newDevice->generic.props[i].lDevMin = min;
+        newDevice->generic.props[i].lDevMax = max;
+        newDevice->generic.props[i].lMin =  0;
+        newDevice->generic.props[i].lMax =  0xffff;
+        newDevice->generic.props[i].lDeadZone = 0;
+        newDevice->generic.props[i].lSaturation = 0;
+    }
+
+    IDirectInput_AddRef(&newDevice->generic.base.dinput->IDirectInput7A_iface);
+
+    EnterCriticalSection(&dinput->crit);
+    list_add_tail(&dinput->devices_list, &newDevice->generic.base.entry);
+    LeaveCriticalSection(&dinput->crit);
+
+    newDevice->generic.devcaps.dwSize = sizeof(newDevice->generic.devcaps);
+    newDevice->generic.devcaps.dwFlags |= DIDC_ATTACHED;
+    if (newDevice->generic.base.dinput->dwVersion >= 0x0800)
+        newDevice->generic.devcaps.dwDevType = DI8DEVTYPE_JOYSTICK | (DI8DEVTYPEJOYSTICK_STANDARD << 8);
+    else
+        newDevice->generic.devcaps.dwDevType = DIDEVTYPE_JOYSTICK | (DIDEVTYPEJOYSTICK_TRADITIONAL << 8);
+    newDevice->generic.devcaps.dwFFSamplePeriod = 0;
+    newDevice->generic.devcaps.dwFFMinTimeResolution = 0;
+    newDevice->generic.devcaps.dwFirmwareRevision = 0;
+    newDevice->generic.devcaps.dwHardwareRevision = 0;
+    newDevice->generic.devcaps.dwFFDriverVersion = 0;
+
+    if (TRACE_ON(dinput)) {
+        TRACE("allocated device %p\n", newDevice);
+        _dump_DIDATAFORMAT(newDevice->generic.base.data_format.wine_df);
+        _dump_DIDEVCAPS(&newDevice->generic.devcaps);
+    }
+
+    *pdev = newDevice;
+
+    return DI_OK;
+
+FAILED:
+    hr = DIERR_OUTOFMEMORY;
+    if (df) HeapFree(GetProcessHeap(), 0, df->rgodf);
+    HeapFree(GetProcessHeap(), 0, df);
+    release_DataFormat(&newDevice->generic.base.data_format);
+    HeapFree(GetProcessHeap(),0,newDevice->generic.name);
+    HeapFree(GetProcessHeap(),0,newDevice);
+    *pdev = 0;
+
+    return hr;
+}
+
+/******************************************************************************
+  *     get_joystick_index : Get the joystick index from a given GUID
+  */
+static unsigned short get_joystick_index(REFGUID guid)
+{
+    GUID wine_joystick = DInput_Wine_driver_Joystick_GUID;
+    GUID dev_guid = *guid;
+
+    wine_joystick.Data3 = 0;
+    dev_guid.Data3 = 0;
+
+    /* for the standard joystick GUID use index 0 */
+    if(IsEqualGUID(&GUID_Joystick,guid)) return 0;
+
+    /* for the wine joystick GUIDs use the index stored in Data3 */
+    if(IsEqualGUID(&wine_joystick, &dev_guid)) return guid->Data3;
+
+    return 0xffff;
+}
+
+static HRESULT joydev_create_device(IDirectInputImpl *dinput, REFGUID rguid, REFIID riid, LPVOID *pdev, int unicode)
+{
+    unsigned short index;
+    int joystick_devices_count;
+
+    TRACE("%p %s %s %p %i\n", dinput, debugstr_guid(rguid), debugstr_guid(riid), pdev, unicode);
+    *pdev = NULL;
+
+    if ((joystick_devices_count = find_joystick_devices()) == 0)
+        return DIERR_DEVICENOTREG;
+
+    if ((index = get_joystick_index(rguid)) < 0xffff &&
+        joystick_devices_count && index < joystick_devices_count)
+    {
+        JoystickImpl *This;
+        HRESULT hr;
+
+        if (riid == NULL)
+            ;/* nothing */
+        else if (IsEqualGUID(&IID_IDirectInputDeviceA,  riid) ||
+                 IsEqualGUID(&IID_IDirectInputDevice2A, riid) ||
+                 IsEqualGUID(&IID_IDirectInputDevice7A, riid) ||
+                 IsEqualGUID(&IID_IDirectInputDevice8A, riid))
+        {
+            unicode = 0;
+        }
+        else if (IsEqualGUID(&IID_IDirectInputDeviceW,  riid) ||
+                 IsEqualGUID(&IID_IDirectInputDevice2W, riid) ||
+                 IsEqualGUID(&IID_IDirectInputDevice7W, riid) ||
+                 IsEqualGUID(&IID_IDirectInputDevice8W, riid))
+        {
+            unicode = 1;
+        }
+        else
+        {
+            WARN("no interface\n");
+            return DIERR_NOINTERFACE;
+        }
+
+        hr = alloc_device(rguid, dinput, &This, index);
+        if (!This) return hr;
+
+        if (unicode)
+            *pdev = &This->generic.base.IDirectInputDevice8W_iface;
+        else
+            *pdev = &This->generic.base.IDirectInputDevice8A_iface;
+        return hr;
+    }
+
+    return DIERR_DEVICENOTREG;
+}
+
+static ULONG WINAPI JoystickAImpl_Release(LPDIRECTINPUTDEVICE8A iface)
+{
+    JoystickImpl *This = impl_from_IDirectInputDevice8A(iface);
+    INT id = This->id;
+    ULONG ref = IDirectInputDevice2AImpl_Release(iface);
+
+    if (!ref)
+        GAMEPAD_Driver->pGamePadDealloc(id);
+
+    return ref;
+}
+
+static ULONG WINAPI JoystickWImpl_Release(LPDIRECTINPUTDEVICE8W iface)
+{
+    JoystickImpl *This = impl_from_IDirectInputDevice8W(iface);
+    INT id = This->id;
+    ULONG ref = IDirectInputDevice2WImpl_Release(iface);
+
+    if (!ref)
+        GAMEPAD_Driver->pGamePadDealloc(id);
+
+    return ref;
+}
+
+static HRESULT WINAPI JoystickWImpl_GetProperty(LPDIRECTINPUTDEVICE8W iface, REFGUID rguid, LPDIPROPHEADER pdiph)
+{
+    HRESULT hr = DI_OK;
+    JoystickImpl *This = impl_from_IDirectInputDevice8W(iface);
+
+    TRACE("(this=%p,%s,%p)\n", iface, debugstr_guid(rguid), pdiph);
+    _dump_DIPROPHEADER(pdiph);
+
+    if (!IS_DIPROP(rguid)) return DI_OK;
+
+    switch (LOWORD(rguid)) {
+
+       case (DWORD_PTR) DIPROP_JOYSTICKID:
+        {
+            LPDIPROPDWORD pd = (LPDIPROPDWORD)pdiph;
+
+            pd->dwData = This->id;
+            TRACE("DIPROP_JOYSTICKID(%d)\n", pd->dwData);
+            break;
+        }
+
+        case (DWORD_PTR)DIPROP_AUTOCENTER:
+        {
+            LPDIPROPDWORD pd = (LPDIPROPDWORD)pdiph;
+            hr = GAMEPAD_Driver->pGamePadGetAutocenter(This->id, &pd->dwData);
+            break;
+        }
+
+        case (DWORD_PTR)DIPROP_FFGAIN:
+        {
+            LPDIPROPDWORD pd = (LPDIPROPDWORD)pdiph;
+            hr = GAMEPAD_Driver->pGamePadGetFFGain(This->id, &pd->dwData);
+            break;
+        }
+
+    default:
+        return JoystickWGenericImpl_GetProperty(iface, rguid, pdiph);
+    }
+
+    return hr;
+}
+
+static HRESULT WINAPI JoystickWImpl_SetProperty(IDirectInputDevice8W *iface,
+        const GUID *prop, const DIPROPHEADER *header)
+{
+    JoystickImpl *This = impl_from_IDirectInputDevice8W(iface);
+
+    TRACE("%p %s %p\n", This, debugstr_guid(prop), header);
+    switch(LOWORD(prop))
+    {
+    case (DWORD_PTR)DIPROP_AUTOCENTER:
+        return GAMEPAD_Driver->pGamePadSetAutocenter(This->id,
+            ((const DIPROPDWORD *)header)->dwData);
+    case (DWORD_PTR)DIPROP_FFGAIN:
+        return GAMEPAD_Driver->pGamePadSetFFGain(This->id,
+            ((const DIPROPDWORD *)header)->dwData);
+    }
+
+    return JoystickWGenericImpl_SetProperty(iface, prop, header);
+}
+
+static HRESULT WINAPI JoystickAImpl_GetProperty(LPDIRECTINPUTDEVICE8A iface, REFGUID rguid, LPDIPROPHEADER pdiph)
+{
+    JoystickImpl *This = impl_from_IDirectInputDevice8A(iface);
+    return JoystickWImpl_GetProperty(&This->generic.base.IDirectInputDevice8W_iface, rguid, pdiph);
+}
+
+
+static HRESULT WINAPI JoystickAImpl_SetProperty(IDirectInputDevice8A *iface,
+        const GUID *prop, const DIPROPHEADER *header)
+{
+    JoystickImpl *This = impl_from_IDirectInputDevice8A(iface);
+
+    TRACE("%p %s %p\n", This, debugstr_guid(prop), header);
+
+    switch(LOWORD(prop))
+    {
+    case (DWORD_PTR)DIPROP_AUTOCENTER:
+        return GAMEPAD_Driver->pGamePadSetAutocenter(This->id,
+            ((const DIPROPDWORD *)header)->dwData);
+    case (DWORD_PTR)DIPROP_FFGAIN:
+        return GAMEPAD_Driver->pGamePadSetFFGain(This->id,
+            ((const DIPROPDWORD *)header)->dwData);
+    }
+
+    return JoystickAGenericImpl_SetProperty(iface, prop, header);
+}
+
+static HRESULT WINAPI JoystickWImpl_Unacquire(LPDIRECTINPUTDEVICE8W iface)
+{
+    JoystickImpl *This = impl_from_IDirectInputDevice8W(iface);
+    HRESULT res;
+
+    TRACE("(this=%p)\n",This);
+    res = IDirectInputDevice2WImpl_Unacquire(iface);
+    if (res==DI_OK) {
+        GAMEPAD_Driver->pGamePadStopAllForceFeedbackEffects(This->id, FALSE);
+        /* Enable autocenter. */
+        GAMEPAD_Driver->pGamePadSetAutocenter(This->id, DIPROPAUTOCENTER_ON);
+    }
+    return res;
+}
+
+static HRESULT WINAPI JoystickAImpl_Unacquire(LPDIRECTINPUTDEVICE8A iface)
+{
+    JoystickImpl *This = impl_from_IDirectInputDevice8A(iface);
+    return JoystickWImpl_Unacquire(&This->generic.base.IDirectInputDevice8W_iface);
+}
+
+
+static HRESULT WINAPI JoystickWImpl_CreateEffect(IDirectInputDevice8W *iface,
+        const GUID *type, const DIEFFECT *params, IDirectInputEffect **out,
+        IUnknown *outer)
+{
+    JoystickImpl *This = impl_from_IDirectInputDevice8W(iface);
+    TRACE("%p %s %p %p %p\n", iface, debugstr_guid(type), params, out, outer);
+    dump_DIEFFECT(params, type, 0);
+
+    return GAMEPAD_Driver->pGamePadCreateDinputEffect(This->id, type, params,
+        out, outer);
+}
+
+static HRESULT WINAPI JoystickAImpl_CreateEffect(IDirectInputDevice8A *iface,
+        const GUID *type, const DIEFFECT *params, IDirectInputEffect **out,
+        IUnknown *outer)
+{
+    JoystickImpl *This = impl_from_IDirectInputDevice8A(iface);
+
+    TRACE("%p %s %p %p %p\n", iface, debugstr_guid(type), params, out, outer);
+
+    return JoystickWImpl_CreateEffect(&This->generic.base.IDirectInputDevice8W_iface,
+            type, params, out, outer);
+}
+
+static HRESULT WINAPI JoystickWImpl_SendForceFeedbackCommand(IDirectInputDevice8W *iface,
+        DWORD flags)
+{
+    JoystickImpl *This = impl_from_IDirectInputDevice8W(iface);
+
+    TRACE("%p 0x%x\n", This, flags);
+    return GAMEPAD_Driver->pGamePadSendForceFeedbackCommand(This->id, flags);
+}
+
+static HRESULT WINAPI JoystickAImpl_SendForceFeedbackCommand(IDirectInputDevice8A *iface,
+        DWORD flags)
+{
+    JoystickImpl *This = impl_from_IDirectInputDevice8A(iface);
+
+    TRACE("%p 0x%x\n", This, flags);
+
+    return JoystickWImpl_SendForceFeedbackCommand(&This->generic.base.IDirectInputDevice8W_iface, flags);
+}
+
+static HRESULT WINAPI JoystickAImpl_EnumEffects(LPDIRECTINPUTDEVICE8A iface,
+                                                LPDIENUMEFFECTSCALLBACKA lpCallback,
+                                                LPVOID pvRef,
+                                                DWORD dwEffType)
+{
+    DIEFFECTINFOA dei; /* feif */
+    DWORD type = DIEFT_GETTYPE(dwEffType);
+    DWORD effects;
+    JoystickImpl* This = impl_from_IDirectInputDevice8A(iface);
+
+    TRACE("(this=%p,%p,%d) type=%d\n", This, pvRef, dwEffType, type);
+
+    if (GAMEPAD_Driver->pGamePadHasForceFeedback(This->id, &effects))
+    {
+        dei.dwSize = sizeof(DIEFFECTINFOA);
+
+        if ((type == DIEFT_ALL || type == DIEFT_CONSTANTFORCE) &&
+            effects & DRIVER_CONSTANTFORCE)
+        {
+            IDirectInputDevice8_GetEffectInfo(iface, &dei, &GUID_ConstantForce);
+            (*lpCallback)(&dei, pvRef);
+        }
+
+        if ((type == DIEFT_ALL || type == DIEFT_PERIODIC))
+        {
+            if (effects & DRIVER_SQUARE)
+            {
+                IDirectInputDevice8_GetEffectInfo(iface, &dei, &GUID_Square);
+                (*lpCallback)(&dei, pvRef);
+            }
+            if (effects & DRIVER_SINE)
+            {
+                IDirectInputDevice8_GetEffectInfo(iface, &dei, &GUID_Sine);
+                (*lpCallback)(&dei, pvRef);
+            }
+            if (effects & DRIVER_TRIANGLE)
+            {
+                IDirectInputDevice8_GetEffectInfo(iface, &dei, &GUID_Triangle);
+                (*lpCallback)(&dei, pvRef);
+            }
+            if (effects & DRIVER_SAWTOOTHUP)
+            {
+                IDirectInputDevice8_GetEffectInfo(iface, &dei, &GUID_SawtoothUp);
+                (*lpCallback)(&dei, pvRef);
+            }
+            if (effects & DRIVER_SAWTOOTHDOWN)
+            {
+                IDirectInputDevice8_GetEffectInfo(iface, &dei, &GUID_SawtoothDown);
+                (*lpCallback)(&dei, pvRef);
+            }
+        }
+
+        if ((type == DIEFT_ALL || type == DIEFT_RAMPFORCE) &&
+            effects & DRIVER_RAMPFORCE)
+        {
+            IDirectInputDevice8_GetEffectInfo(iface, &dei, &GUID_RampForce);
+            (*lpCallback)(&dei, pvRef);
+        }
+
+        if (type == DIEFT_ALL || type == DIEFT_CONDITION) {
+            if (effects & DRIVER_SPRING)
+            {
+                IDirectInputDevice8_GetEffectInfo(iface, &dei, &GUID_Spring);
+                (*lpCallback)(&dei, pvRef);
+            }
+            if (effects & DRIVER_DAMPER)
+            {
+                IDirectInputDevice8_GetEffectInfo(iface, &dei, &GUID_Damper);
+                (*lpCallback)(&dei, pvRef);
+            }
+            if (effects & DRIVER_INERTIA)
+            {
+                IDirectInputDevice8_GetEffectInfo(iface, &dei, &GUID_Inertia);
+                (*lpCallback)(&dei, pvRef);
+            }
+            if (effects & DRIVER_FRICTION)
+            {
+                IDirectInputDevice8_GetEffectInfo(iface, &dei, &GUID_Friction);
+                (*lpCallback)(&dei, pvRef);
+            }
+        }
+    }
+    return DI_OK;
+}
+
+static HRESULT WINAPI JoystickWImpl_EnumEffects(LPDIRECTINPUTDEVICE8W iface,
+                                                LPDIENUMEFFECTSCALLBACKW lpCallback,
+                                                LPVOID pvRef,
+                                                DWORD dwEffType)
+{
+    /* seems silly to duplicate all this code but all the structures and functions
+     * are actually different (A/W) */
+    DIEFFECTINFOW dei; /* feif */
+    DWORD type = DIEFT_GETTYPE(dwEffType);
+    DWORD effects;
+    JoystickImpl* This = impl_from_IDirectInputDevice8W(iface);
+
+    TRACE("(this=%p,%p,%d) type=%d\n", This, pvRef, dwEffType, type);
+
+    if (GAMEPAD_Driver->pGamePadHasForceFeedback(This->id, &effects))
+    {
+        dei.dwSize = sizeof(DIEFFECTINFOW);
+
+        if ((type == DIEFT_ALL || type == DIEFT_CONSTANTFORCE) &&
+            effects & DRIVER_CONSTANTFORCE)
+        {
+            IDirectInputDevice8_GetEffectInfo(iface, &dei, &GUID_ConstantForce);
+            (*lpCallback)(&dei, pvRef);
+        }
+
+        if ((type == DIEFT_ALL || type == DIEFT_PERIODIC))
+        {
+            if (effects & DRIVER_SQUARE)
+            {
+                IDirectInputDevice8_GetEffectInfo(iface, &dei, &GUID_Square);
+                (*lpCallback)(&dei, pvRef);
+            }
+            if (effects & DRIVER_SINE)
+            {
+                IDirectInputDevice8_GetEffectInfo(iface, &dei, &GUID_Sine);
+                (*lpCallback)(&dei, pvRef);
+            }
+            if (effects & DRIVER_TRIANGLE)
+            {
+                IDirectInputDevice8_GetEffectInfo(iface, &dei, &GUID_Triangle);
+                (*lpCallback)(&dei, pvRef);
+            }
+            if (effects & DRIVER_SAWTOOTHUP)
+            {
+                IDirectInputDevice8_GetEffectInfo(iface, &dei, &GUID_SawtoothUp);
+                (*lpCallback)(&dei, pvRef);
+            }
+            if (effects & DRIVER_SAWTOOTHDOWN)
+            {
+                IDirectInputDevice8_GetEffectInfo(iface, &dei, &GUID_SawtoothDown);
+                (*lpCallback)(&dei, pvRef);
+            }
+        }
+
+        if ((type == DIEFT_ALL || type == DIEFT_RAMPFORCE) &&
+            effects & DRIVER_RAMPFORCE)
+        {
+            IDirectInputDevice8_GetEffectInfo(iface, &dei, &GUID_RampForce);
+            (*lpCallback)(&dei, pvRef);
+        }
+
+        if (type == DIEFT_ALL || type == DIEFT_CONDITION) {
+            if (effects & DRIVER_SPRING)
+            {
+                IDirectInputDevice8_GetEffectInfo(iface, &dei, &GUID_Spring);
+                (*lpCallback)(&dei, pvRef);
+            }
+            if (effects & DRIVER_DAMPER)
+            {
+                IDirectInputDevice8_GetEffectInfo(iface, &dei, &GUID_Damper);
+                (*lpCallback)(&dei, pvRef);
+            }
+            if (effects & DRIVER_INERTIA)
+            {
+                IDirectInputDevice8_GetEffectInfo(iface, &dei, &GUID_Inertia);
+                (*lpCallback)(&dei, pvRef);
+            }
+            if (effects & DRIVER_FRICTION)
+            {
+                IDirectInputDevice8_GetEffectInfo(iface, &dei, &GUID_Friction);
+                (*lpCallback)(&dei, pvRef);
+            }
+        }
+    }
+    return DI_OK;
+}
+
+static HRESULT WINAPI JoystickAImpl_GetEffectInfo(LPDIRECTINPUTDEVICE8A iface,
+                                                  LPDIEFFECTINFOA pdei,
+                                                  REFGUID guid)
+{
+    JoystickImpl *This = impl_from_IDirectInputDevice8A(iface);
+
+    TRACE("(this=%p,%p,%s)\n", This, pdei, _dump_dinput_GUID(guid));
+
+    if (GAMEPAD_Driver->pGamePadHasForceFeedback(This->id, NULL))
+    {
+        DWORD type = typeFromGUID(guid);
+
+        TRACE("(%s, %p) type=%d\n", _dump_dinput_GUID(guid), pdei, type);
+
+        if (!pdei) return E_POINTER;
+
+        if (pdei->dwSize != sizeof(DIEFFECTINFOA)) return DIERR_INVALIDPARAM;
+
+        pdei->guid = *guid;
+
+        pdei->dwEffType = type;
+        /* the event device API does not support querying for all these things
+         * therefore we assume that we have support for them
+         * that's not as dangerous as it sounds, since drivers are allowed to
+         * ignore parameters they claim to support anyway */
+        pdei->dwEffType |= DIEFT_DEADBAND | DIEFT_FFATTACK | DIEFT_FFFADE
+                        | DIEFT_POSNEGCOEFFICIENTS | DIEFT_POSNEGSATURATION
+                        | DIEFT_SATURATION | DIEFT_STARTDELAY;
+
+        /* again, assume we have support for everything */
+        pdei->dwStaticParams = DIEP_ALLPARAMS;
+        pdei->dwDynamicParams = pdei->dwStaticParams;
+
+        /* yes, this is windows behavior (print the GUID_Name for name) */
+        strcpy(pdei->tszName, _dump_dinput_GUID(guid));
+    }
+
+    return DI_OK;
+}
+
+
+static HRESULT WINAPI JoystickWImpl_GetEffectInfo(LPDIRECTINPUTDEVICE8W iface,
+                                                  LPDIEFFECTINFOW pdei,
+                                                  REFGUID guid)
+{
+    JoystickImpl *This = impl_from_IDirectInputDevice8W(iface);
+
+    TRACE("(this=%p,%p,%s)\n", This, pdei, _dump_dinput_GUID(guid));
+
+    if (GAMEPAD_Driver->pGamePadHasForceFeedback(This->id, NULL))
+    {
+        DWORD type = typeFromGUID(guid);
+
+        TRACE("(%s, %p) type=%d\n", _dump_dinput_GUID(guid), pdei, type);
+
+        if (!pdei) return E_POINTER;
+
+        if (pdei->dwSize != sizeof(DIEFFECTINFOW)) return DIERR_INVALIDPARAM;
+
+        pdei->guid = *guid;
+
+        pdei->dwEffType = type;
+        /* the event device API does not support querying for all these things
+         * therefore we assume that we have support for them
+         * that's not as dangerous as it sounds, since drivers are allowed to
+         * ignore parameters they claim to support anyway */
+        pdei->dwEffType |= DIEFT_DEADBAND | DIEFT_FFATTACK | DIEFT_FFFADE
+                        | DIEFT_POSNEGCOEFFICIENTS | DIEFT_POSNEGSATURATION
+                        | DIEFT_SATURATION | DIEFT_STARTDELAY;
+
+        /* again, assume we have support for everything */
+        pdei->dwStaticParams = DIEP_ALLPARAMS;
+        pdei->dwDynamicParams = pdei->dwStaticParams;
+
+        /* yes, this is windows behavior (print the GUID_Name for name) */
+        MultiByteToWideChar(CP_ACP, 0, _dump_dinput_GUID(guid), -1,
+                            pdei->tszName, MAX_PATH);
+    }
+
+    return DI_OK;
+}
+
+static HRESULT WINAPI JoystickWImpl_GetForceFeedbackState(LPDIRECTINPUTDEVICE8W iface, LPDWORD pdwOut)
+{
+    JoystickImpl* This = impl_from_IDirectInputDevice8W(iface);
+
+    TRACE("(this=%p,%p)\n", This, pdwOut);
+
+    (*pdwOut) = 0;
+    GAMEPAD_Driver->pGamePadGetForceFeedbackState(This->id, pdwOut);
+
+    return DI_OK;
+}
+
+static HRESULT WINAPI JoystickAImpl_GetForceFeedbackState(LPDIRECTINPUTDEVICE8A iface, LPDWORD pdwOut)
+{
+    JoystickImpl* This = impl_from_IDirectInputDevice8A(iface);
+
+    TRACE("(this=%p,%p)\n", This, pdwOut);
+
+    (*pdwOut) = 0;
+    GAMEPAD_Driver->pGamePadGetForceFeedbackState(This->id, pdwOut);
+
+    return DI_OK;
+}
+
+const struct dinput_device joystick_driver_device = {
+  "Wine Graphic Driver joystick driver",
+  joydev_enum_deviceA,
+  joydev_enum_deviceW,
+  joydev_create_device
+};
+
+static const IDirectInputDevice8AVtbl JoystickAvt =
+{
+    IDirectInputDevice2AImpl_QueryInterface,
+    IDirectInputDevice2AImpl_AddRef,
+    JoystickAImpl_Release,
+    JoystickAGenericImpl_GetCapabilities,
+    IDirectInputDevice2AImpl_EnumObjects,
+    JoystickAImpl_GetProperty,
+    JoystickAImpl_SetProperty,
+    IDirectInputDevice2AImpl_Acquire,
+    JoystickAImpl_Unacquire,
+    JoystickAGenericImpl_GetDeviceState,
+    IDirectInputDevice2AImpl_GetDeviceData,
+    IDirectInputDevice2AImpl_SetDataFormat,
+    IDirectInputDevice2AImpl_SetEventNotification,
+    IDirectInputDevice2AImpl_SetCooperativeLevel,
+    JoystickAGenericImpl_GetObjectInfo,
+    JoystickAGenericImpl_GetDeviceInfo,
+    IDirectInputDevice2AImpl_RunControlPanel,
+    IDirectInputDevice2AImpl_Initialize,
+    JoystickAImpl_CreateEffect,
+    JoystickAImpl_EnumEffects,
+    JoystickAImpl_GetEffectInfo,
+    JoystickAImpl_GetForceFeedbackState,
+    JoystickAImpl_SendForceFeedbackCommand,
+    IDirectInputDevice2AImpl_EnumCreatedEffectObjects,
+    IDirectInputDevice2AImpl_Escape,
+    JoystickAGenericImpl_Poll,
+    IDirectInputDevice2AImpl_SendDeviceData,
+    IDirectInputDevice7AImpl_EnumEffectsInFile,
+    IDirectInputDevice7AImpl_WriteEffectToFile,
+    JoystickAGenericImpl_BuildActionMap,
+    JoystickAGenericImpl_SetActionMap,
+    IDirectInputDevice8AImpl_GetImageInfo
+};
+
+static const IDirectInputDevice8WVtbl JoystickWvt =
+{
+    IDirectInputDevice2WImpl_QueryInterface,
+    IDirectInputDevice2WImpl_AddRef,
+    JoystickWImpl_Release,
+    JoystickWGenericImpl_GetCapabilities,
+    IDirectInputDevice2WImpl_EnumObjects,
+    JoystickWImpl_GetProperty,
+    JoystickWImpl_SetProperty,
+    IDirectInputDevice2WImpl_Acquire,
+    JoystickWImpl_Unacquire,
+    JoystickWGenericImpl_GetDeviceState,
+    IDirectInputDevice2WImpl_GetDeviceData,
+    IDirectInputDevice2WImpl_SetDataFormat,
+    IDirectInputDevice2WImpl_SetEventNotification,
+    IDirectInputDevice2WImpl_SetCooperativeLevel,
+    JoystickWGenericImpl_GetObjectInfo,
+    JoystickWGenericImpl_GetDeviceInfo,
+    IDirectInputDevice2WImpl_RunControlPanel,
+    IDirectInputDevice2WImpl_Initialize,
+    JoystickWImpl_CreateEffect,
+    JoystickWImpl_EnumEffects,
+    JoystickWImpl_GetEffectInfo,
+    JoystickWImpl_GetForceFeedbackState,
+    JoystickWImpl_SendForceFeedbackCommand,
+    IDirectInputDevice2WImpl_EnumCreatedEffectObjects,
+    IDirectInputDevice2WImpl_Escape,
+    JoystickWGenericImpl_Poll,
+    IDirectInputDevice2WImpl_SendDeviceData,
+    IDirectInputDevice7WImpl_EnumEffectsInFile,
+    IDirectInputDevice7WImpl_WriteEffectToFile,
+    JoystickWGenericImpl_BuildActionMap,
+    JoystickWGenericImpl_SetActionMap,
+    IDirectInputDevice8WImpl_GetImageInfo
+};
+
+static void polldev(LPDIRECTINPUTDEVICE8A iface)
+{
+    int inst_id, i, driver_index = 0;
+    int  oldVal = 0, newVal = 0;
+    int slider_idx = 0;
+    int pov_idx = 0;
+    int button_idx = 0;
+    JoystickImpl *device = impl_from_IDirectInputDevice8A(iface);
+
+    TRACE("device %p device->id %i\n", device, device->id);
+    GAMEPAD_Driver->pGamePadPollValues(device->id, device->values);
+
+    for (i = 0; i < device->generic.devcaps.dwAxes; i++)
+    {
+        int wine_obj = device->axis_map[i];
+        newVal = joystick_map_axis(&device->generic.props[i],
+                    device->values[driver_index++]);
+        switch (device->axis_map[i])
+        {
+            case DRIVER_AXIS_X:
+                oldVal = device->generic.js.lX;
+                device->generic.js.lX = newVal;
+                break;
+            case DRIVER_AXIS_Y:
+                oldVal = device->generic.js.lY;
+                device->generic.js.lY = newVal;
+                break;
+            case DRIVER_AXIS_Z:
+                oldVal = device->generic.js.lZ;
+                device->generic.js.lZ = newVal;
+                break;
+            case DRIVER_AXIS_RX:
+                oldVal = device->generic.js.lRx;
+                device->generic.js.lRx = newVal;
+                break;
+            case DRIVER_AXIS_RY:
+                oldVal = device->generic.js.lRy;
+                device->generic.js.lRy = newVal;
+                break;
+            case DRIVER_AXIS_RZ:
+                oldVal = device->generic.js.lRz;
+                device->generic.js.lRz = newVal;
+                break;
+            case DRIVER_AXIS_OTHER:
+                wine_obj += slider_idx;
+                oldVal = device->generic.js.rglSlider[slider_idx];
+                device->generic.js.rglSlider[slider_idx] = newVal;
+                slider_idx ++;
+        }
+        TRACE("oldVal %d newVal %d\n", oldVal, newVal);
+        if ((wine_obj != -1) && (oldVal != newVal))
+        {
+            inst_id = DIDFT_MAKEINSTANCE(wine_obj) | DIDFT_ABSAXIS;
+            queue_event(iface,inst_id,newVal,GetCurrentTime(),device->generic.base.dinput->evsequence++);
+        }
+    }
+    for (i = 0; i < device->generic.devcaps.dwPOVs; i++)
+    {
+        POINTL  pov_val;
+        pov_val.x = device->values[driver_index++];
+        pov_val.y = device->values[driver_index++];
+        newVal = joystick_map_pov(&pov_val);
+        oldVal = device->generic.js.rgdwPOV[pov_idx];
+        device->generic.js.rgdwPOV[pov_idx] = newVal;
+        TRACE("oldVal %d newVal %d\n", oldVal, newVal);
+        if (oldVal != newVal)
+        {
+            inst_id = DIDFT_MAKEINSTANCE(pov_idx) | DIDFT_POV;
+            queue_event(iface,inst_id,newVal,GetCurrentTime(),device->generic.base.dinput->evsequence++);
+        }
+        pov_idx ++;
+        break;
+    }
+    for (i = 0; i < device->generic.devcaps.dwButtons; i++)
+    {
+        newVal = device->values[driver_index++] ? 0x80 : 0x0;
+        oldVal = device->generic.js.rgbButtons[button_idx];
+        device->generic.js.rgbButtons[button_idx] = newVal;
+        TRACE("oldVal %d newVal %d\n", oldVal, newVal);
+        if (oldVal != newVal)
+        {
+            inst_id = DIDFT_MAKEINSTANCE(0) | DIDFT_PSHBUTTON;
+            queue_event(iface,inst_id,newVal,GetCurrentTime(),device->generic.base.dinput->evsequence++);
+        }
+        button_idx ++;
+    }
+
+    return;
+}
+
+static HMODULE load_graphics_driver(void)
+{
+    static const WCHAR display_device_guid_propW[] = {
+        '_','_','w','i','n','e','_','d','i','s','p','l','a','y','_',
+        'd','e','v','i','c','e','_','g','u','i','d',0 };
+    static const WCHAR key_pathW[] = {
+        'S','y','s','t','e','m','\\',
+        'C','u','r','r','e','n','t','C','o','n','t','r','o','l','S','e','t','\\',
+        'C','o','n','t','r','o','l','\\',
+        'V','i','d','e','o','\\','{',0};
+    static const WCHAR displayW[] = {'}','\\','0','0','0','0',0};
+    static const WCHAR driverW[] = {'G','r','a','p','h','i','c','s','D','r','i','v','e','r',0};
+
+    HMODULE ret = 0;
+    HKEY hkey;
+    DWORD size;
+    WCHAR path[MAX_PATH];
+    WCHAR key[(sizeof(key_pathW) + sizeof(displayW)) / sizeof(WCHAR) + 40];
+    UINT guid_atom = HandleToULong( GetPropW( GetDesktopWindow(), display_device_guid_propW ));
+
+    if (!guid_atom) return 0;
+    memcpy( key, key_pathW, sizeof(key_pathW) );
+    if (!GlobalGetAtomNameW( guid_atom, key + strlenW(key), 40 )) return 0;
+    strcatW( key, displayW );
+    if (RegOpenKeyW( HKEY_LOCAL_MACHINE, key, &hkey )) return 0;
+    size = sizeof(path);
+    if (!RegQueryValueExW( hkey, driverW, NULL, NULL, (BYTE *)path, &size )) ret = LoadLibraryW( path );
+    RegCloseKey( hkey );
+    TRACE( "%s %p\n", debugstr_w(path), ret );
+
+    return ret;
+}
+
+static const GAMEPAD_DRIVER *load_driver(void)
+{
+    void *ptr;
+    HMODULE graphics_driver;
+    GAMEPAD_DRIVER *driver, *prev;
+
+    driver = HeapAlloc( GetProcessHeap(), 0 , sizeof(*driver) );
+    *driver = null_driver;
+
+    graphics_driver = load_graphics_driver();
+    if (graphics_driver)
+    {
+#define GET_USER_FUNC(name) \
+    do { if ((ptr = GetProcAddress( graphics_driver, #name ))) driver->p##name = ptr; } while(0)
+    GET_USER_FUNC(GamePadCount);
+    GET_USER_FUNC(GamePadName);
+    GET_USER_FUNC(GamePadElementCount);
+    GET_USER_FUNC(GamePadElementProps);
+    GET_USER_FUNC(GamePadPollValues);
+    GET_USER_FUNC(GamePadAlloc);
+    GET_USER_FUNC(GamePadDealloc);
+    GET_USER_FUNC(GamePadHasForceFeedback);
+    GET_USER_FUNC(GamePadGetForceFeedbackState);
+    GET_USER_FUNC(GamePadElementHasForceFeedback);
+    GET_USER_FUNC(GamePadSetAutocenter);
+    GET_USER_FUNC(GamePadGetAutocenter);
+    GET_USER_FUNC(GamePadSetFFGain);
+    GET_USER_FUNC(GamePadGetFFGain);
+    GET_USER_FUNC(GamePadSendForceFeedbackCommand);
+    GET_USER_FUNC(GamePadCreateDinputEffect);
+    GET_USER_FUNC(GamePadStopAllForceFeedbackEffects);
+#undef GET_USER_FUNC
+    }
+
+    prev = InterlockedCompareExchangePointer( (void **)&GAMEPAD_Driver, driver, &lazy_load_driver );
+    if (prev != &lazy_load_driver)
+    {
+        /* another thread beat us to it */
+        HeapFree( GetProcessHeap(), 0, driver);
+        driver = prev;
+    }
+    else
+        LdrAddRefDll(0, graphics_driver);
+
+    return driver;
+}
+
+static INT CDECL loaderdrv_GamePadCount(void)
+{
+    return load_driver()->pGamePadCount();
+}
+
+static VOID CDECL loaderdrv_GamePadName(int id, char *name, int length)
+{
+    load_driver()->pGamePadName(id, name, length);
+}
+
+static VOID CDECL loaderdrv_GamePadElementCount(int id, DWORD *axis, DWORD *buttons, DWORD *povs, int axis_map[8])
+{
+    load_driver()->pGamePadElementCount(id, axis, buttons, povs, axis_map);
+}
+
+static VOID CDECL loaderdrv_GamePadElementProps(int id, int element, int *min, int* max)
+{
+    load_driver()->pGamePadElementProps(id, element, min, max);
+}
+
+static VOID CDECL loaderdrv_GamePadPollValues(int id, int* values)
+{
+    load_driver()->pGamePadPollValues(id, values);
+}
+
+static BOOL CDECL loaderdrv_GamePadAlloc(int id)
+{
+    return load_driver()->pGamePadAlloc(id);
+}
+
+static VOID CDECL loaderdrv_GamePadDealloc(int id)
+{
+    load_driver()->pGamePadDealloc(id);
+}
+
+static BOOL CDECL loaderdrv_GamePadHasForceFeedback(int id, DWORD *effects)
+{
+    return load_driver()->pGamePadHasForceFeedback(id, effects);
+}
+
+static BOOL CDECL loaderdrv_GamePadElementHasForceFeedback(int id, int element)
+{
+    return load_driver()->pGamePadElementHasForceFeedback(id, element);
+}
+
+static VOID CDECL loaderdrv_GamePadGetForceFeedbackState(int id, DWORD *state)
+{
+    load_driver()->pGamePadGetForceFeedbackState(id, state);
+}
+
+static HRESULT CDECL loaderdrv_GamePadSetAutocenter(int id, DWORD data)
+{
+    return load_driver()->pGamePadSetAutocenter(id, data);
+}
+
+static HRESULT CDECL loaderdrv_GamePadGetAutocenter(int id, DWORD *data)
+{
+    return load_driver()->pGamePadGetAutocenter(id, data);
+}
+
+static HRESULT CDECL loaderdrv_GamePadSetFFGain(int id, DWORD data)
+{
+    return load_driver()->pGamePadSetFFGain(id, data);
+}
+
+static HRESULT CDECL loaderdrv_GamePadGetFFGain(int id, DWORD *data)
+{
+    return load_driver()->pGamePadGetFFGain(id, data);
+}
+
+static HRESULT CDECL loaderdrv_GamePadSendForceFeedbackCommand(int id, DWORD flags)
+{
+    return load_driver()->pGamePadSendForceFeedbackCommand(id, flags);
+}
+
+static DWORD CDECL loaderdrv_GamePadCreateDinputEffect(int id, const GUID *type, const DIEFFECT *params, IDirectInputEffect **out, IUnknown *outer)
+{
+    return load_driver()->pGamePadCreateDinputEffect(id, type, params, out, outer);
+}
+
+static VOID CDECL loaderdrv_GamePadStopAllForceFeedbackEffects(int id, int release)
+{
+    load_driver()->pGamePadStopAllForceFeedbackEffects(id, release);
+}
+
+static GAMEPAD_DRIVER lazy_load_driver =
+{
+    loaderdrv_GamePadCount,
+    loaderdrv_GamePadName,
+    loaderdrv_GamePadElementCount,
+    loaderdrv_GamePadElementProps,
+    loaderdrv_GamePadPollValues,
+    loaderdrv_GamePadAlloc,
+    loaderdrv_GamePadDealloc,
+    loaderdrv_GamePadHasForceFeedback,
+    loaderdrv_GamePadElementHasForceFeedback,
+    loaderdrv_GamePadGetForceFeedbackState,
+    loaderdrv_GamePadSetAutocenter,
+    loaderdrv_GamePadGetAutocenter,
+    loaderdrv_GamePadSetFFGain,
+    loaderdrv_GamePadGetFFGain,
+    loaderdrv_GamePadSendForceFeedbackCommand,
+    loaderdrv_GamePadCreateDinputEffect,
+    loaderdrv_GamePadStopAllForceFeedbackEffects
+};
+
+static INT CDECL nulldrv_GamePadCount(void)
+{
+    return 0;
+}
+
+static VOID CDECL nulldrv_GamePadName(int id, char *name, int length)
+{
+}
+
+static VOID CDECL nulldrv_GamePadElementCount(int id, DWORD *axis, DWORD *buttons, DWORD *povs, int axis_map[8])
+{
+}
+
+static VOID CDECL nulldrv_GamePadElementProps(int id, int element, int *min, int* max)
+{
+}
+
+static VOID CDECL nulldrv_GamePadPollValues(int id, int* values)
+{
+}
+
+static BOOL CDECL nulldrv_GamePadAlloc(int id)
+{
+    return TRUE;
+}
+
+static VOID CDECL nulldrv_GamePadDealloc(int id)
+{
+}
+
+static BOOL CDECL nulldrv_GamePadHasForceFeedback(int id, DWORD *effects)
+{
+    return FALSE;
+}
+
+static VOID CDECL nulldrv_GamePadGetForceFeedbackState(int id, DWORD *state)
+{
+    *state = 0;
+}
+
+static BOOL CDECL nulldrv_GamePadElementHasForceFeedback(int id, int element)
+{
+    return FALSE;
+}
+
+static HRESULT CDECL nulldrv_GamePadSetAutocenter(int id, DWORD data)
+{
+    return DIERR_UNSUPPORTED;
+}
+
+static HRESULT CDECL nulldrv_GamePadGetAutocenter(int id, DWORD *data)
+{
+    return DIERR_UNSUPPORTED;
+}
+
+static HRESULT CDECL nulldrv_GamePadSetFFGain(int id, DWORD data)
+{
+    return DIERR_UNSUPPORTED;
+}
+
+static HRESULT CDECL nulldrv_GamePadGetFFGain(int id, DWORD *data)
+{
+    return DIERR_UNSUPPORTED;
+}
+
+static HRESULT CDECL nulldrv_GamePadSendForceFeedbackCommand(int id, DWORD flags)
+{
+    return DI_NOEFFECT;
+}
+
+static DWORD CDECL nulldrv_GamePadCreateDinputEffect(int id, const GUID *type, const DIEFFECT *params, IDirectInputEffect **out, IUnknown *outer)
+{
+    TRACE("No effects support\n");
+    *out = NULL;
+    return DI_NOEFFECT;
+}
+
+static VOID CDECL nulldrv_GamePadStopAllForceFeedbackEffects(int id, int release)
+{
+}
+
+static GAMEPAD_DRIVER null_driver =
+{
+    nulldrv_GamePadCount,
+    nulldrv_GamePadName,
+    nulldrv_GamePadElementCount,
+    nulldrv_GamePadElementProps,
+    nulldrv_GamePadPollValues,
+    nulldrv_GamePadAlloc,
+    nulldrv_GamePadDealloc,
+    nulldrv_GamePadHasForceFeedback,
+    nulldrv_GamePadElementHasForceFeedback,
+    nulldrv_GamePadGetForceFeedbackState,
+    nulldrv_GamePadSetAutocenter,
+    nulldrv_GamePadGetAutocenter,
+    nulldrv_GamePadSetFFGain,
+    nulldrv_GamePadGetFFGain,
+    nulldrv_GamePadSendForceFeedbackCommand,
+    nulldrv_GamePadCreateDinputEffect,
+    nulldrv_GamePadStopAllForceFeedbackEffects
+};
diff -Naur wine-2.0a/dlls/dinput/Makefile.in wine-2.0b/dlls/dinput/Makefile.in
--- wine-2.0a/dlls/dinput/Makefile.in	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/dinput/Makefile.in	2017-07-11 20:37:49.000000000 +0100
@@ -10,6 +10,7 @@
 	dinput_main.c \
 	effect_linuxinput.c \
 	joystick.c \
+	joystick_driver.c \
 	joystick_linux.c \
 	joystick_linuxinput.c \
 	joystick_osx.c \
diff -Naur wine-2.0a/dlls/dinput/mouse.c wine-2.0b/dlls/dinput/mouse.c
--- wine-2.0a/dlls/dinput/mouse.c	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/dinput/mouse.c	2017-07-11 20:37:49.000000000 +0100
@@ -55,7 +55,8 @@
 {
     WARP_DEFAULT,
     WARP_DISABLE,
-    WARP_FORCE_ON
+    WARP_FORCE_ON,
+    WARP_FORCE_EDGE
 } WARP_MOUSE;
 
 struct SysMouseImpl
@@ -219,6 +220,8 @@
             newDevice->warp_override = WARP_DISABLE;
         else if (!strcasecmp(buffer, "force"))
             newDevice->warp_override = WARP_FORCE_ON;
+        else if (!strcasecmp(buffer, "force_edge"))
+            newDevice->warp_override = WARP_FORCE_EDGE;
     }
     if (appkey) RegCloseKey(appkey);
     if (hkey) RegCloseKey(hkey);
@@ -353,7 +356,16 @@
                 wdata = pt1.y;
             }
 
-            if (pt.x || pt.y)
+            if (This->warp_override == WARP_FORCE_EDGE)
+            {
+                RECT rect;
+                /* CW HACK 6615 */
+                GetWindowRect(This->base.win, &rect);
+                if (hook->pt.x < rect.left+2 || hook->pt.y < rect.top+2 ||
+                    hook->pt.x > rect.right-2 || hook->pt.y > rect.bottom-2)
+                    This->need_warp = TRUE;
+            }
+            else if (pt.x || pt.y)
             {
                 if ((This->warp_override == WARP_FORCE_ON) ||
                     (This->warp_override != WARP_DISABLE && (This->base.dwCoopLevel & DISCL_EXCLUSIVE)))
@@ -484,7 +496,7 @@
         ShowCursor(FALSE); /* hide cursor */
         warp_check( This, TRUE );
     }
-    else if (This->warp_override == WARP_FORCE_ON)
+    else if (This->warp_override >= WARP_FORCE_ON)
     {
         /* Need a window to warp mouse in. */
         if (!This->base.win) This->base.win = GetDesktopWindow();
@@ -525,7 +537,7 @@
     }
 
     /* And put the mouse cursor back where it was at acquire time */
-    if (This->base.dwCoopLevel & DISCL_EXCLUSIVE || This->warp_override == WARP_FORCE_ON)
+    if (This->base.dwCoopLevel & DISCL_EXCLUSIVE || This->warp_override >= WARP_FORCE_ON)
     {
         TRACE("warping mouse back to %s\n", wine_dbgstr_point(&This->org_coords));
         SetCursorPos(This->org_coords.x, This->org_coords.y);
diff -Naur wine-2.0a/dlls/dwrite/font.c wine-2.0b/dlls/dwrite/font.c
--- wine-2.0a/dlls/dwrite/font.c	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/dwrite/font.c	2017-07-11 20:37:49.000000000 +0100
@@ -714,7 +714,8 @@
 
     ppem = emSize * ppdip;
 
-    if (ppem >= RECOMMENDED_OUTLINE_AA_THRESHOLD) {
+    /* CXHACK: disable outline rendering mode to workaround d2d issue, see bug 14558, bug 14721 */
+    if (0 && ppem >= RECOMMENDED_OUTLINE_AA_THRESHOLD) {
         *mode = DWRITE_RENDERING_MODE_OUTLINE;
         return S_OK;
     }
@@ -3530,6 +3531,10 @@
     WCHAR *name;
     void *data;
     HKEY hkey;
+#ifdef __ANDROID__
+    WCHAR meiryoW[] = {'M','e','i','r','y','o',0};
+    WCHAR meiryo_replacement[] = {'D','r','o','i','d',' ','S','a','n','s',' ','F','a','l','l','b','a','c','k',0};
+#endif
 
     if (RegOpenKeyA(HKEY_CURRENT_USER, "Software\\Wine\\Fonts\\Replacements", &hkey))
         return;
@@ -3568,6 +3573,11 @@
     heap_free(data);
     heap_free(name);
     RegCloseKey(hkey);
+
+#ifdef __ANDROID__
+    /* CROSSOVER HACK - bug 14034 */
+    fontcollection_add_replacement(collection, meiryoW, meiryo_replacement);
+#endif
 }
 
 HRESULT create_font_collection(IDWriteFactory4 *factory, IDWriteFontFileEnumerator *enumerator, BOOL is_system,
diff -Naur wine-2.0a/dlls/gdi32/driver.c wine-2.0b/dlls/gdi32/driver.c
--- wine-2.0a/dlls/gdi32/driver.c	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/gdi32/driver.c	2017-07-11 20:37:49.000000000 +0100
@@ -110,6 +110,34 @@
 
 
 /**********************************************************************
+ *	     is_display_device
+ *
+ * CrossOver Hack 13441
+ */
+static BOOL is_display_device( LPCWSTR name )
+{
+    static const WCHAR display_deviceW[] = {'\\','\\','.','\\','D','I','S','P','L','A','Y'};
+    const WCHAR *p = name;
+
+    if (strncmpiW( name, display_deviceW, sizeof(display_deviceW) / sizeof(WCHAR) ))
+        return FALSE;
+
+    p += sizeof(display_deviceW) / sizeof(WCHAR);
+
+    if (!isdigitW( *p++ ))
+        return FALSE;
+
+    for (; *p; p++)
+    {
+        if (!isdigitW( *p ))
+            return FALSE;
+    }
+
+    return TRUE;
+}
+
+
+/**********************************************************************
  *	     DRIVER_load_driver
  */
 const struct gdi_dc_funcs *DRIVER_load_driver( LPCWSTR name )
@@ -117,10 +145,10 @@
     HMODULE module;
     struct graphics_driver *driver, *new_driver;
     static const WCHAR displayW[] = { 'd','i','s','p','l','a','y',0 };
-    static const WCHAR display1W[] = {'\\','\\','.','\\','D','I','S','P','L','A','Y','1',0};
 
     /* display driver is a special case */
-    if (!strcmpiW( name, displayW ) || !strcmpiW( name, display1W )) return get_display_driver();
+    /* CrossOver Hack 13441 */
+    if (!strcmpiW( name, displayW ) || is_display_device( name )) return get_display_driver();
 
     if ((module = GetModuleHandleW( name )))
     {
@@ -770,13 +798,12 @@
 {
     static const WCHAR displayW[] = { 'd','i','s','p','l','a','y',0 };
     static const WCHAR devicesW[] = { 'd','e','v','i','c','e','s',0 };
-    static const WCHAR display1W[] = {'\\','\\','.','\\','D','I','S','P','L','A','Y','1',0};
     static const WCHAR empty_strW[] = { 0 };
     WCHAR *p;
 
     /* display is a special case */
     if (!strcmpiW( device, displayW ) ||
-        !strcmpiW( device, display1W ))
+        is_display_device( device )) /* CrossOver Hack 13441 */
     {
         lstrcpynW( driver, displayW, size );
         return TRUE;
diff -Naur wine-2.0a/dlls/gdi32/font.c wine-2.0b/dlls/gdi32/font.c
--- wine-2.0a/dlls/gdi32/font.c	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/gdi32/font.c	2017-07-11 20:37:49.000000000 +0100
@@ -2101,14 +2101,16 @@
     LPWSTR p;
     BOOL ret;
     LPINT lpDxW = NULL;
+    unsigned int i;
 
     if (flags & ETO_GLYPH_INDEX)
         return ExtTextOutW( hdc, x, y, flags, lprect, (LPCWSTR)str, count, lpDx );
 
-    p = FONT_mbtowc(hdc, str, count, &wlen, &codepage);
+    if(GetObjectType(hdc) != OBJ_METADC) {
+        p = FONT_mbtowc(hdc, str, count, &wlen, &codepage);
 
-    if (lpDx) {
-        unsigned int i = 0, j = 0;
+        if (lpDx) {
+            unsigned int i = 0, j = 0;
 
         /* allocate enough for a ETO_PDY */
         lpDxW = HeapAlloc( GetProcessHeap(), 0, 2*wlen*sizeof(INT));
@@ -2136,6 +2138,18 @@
                 i = i + 1;
             }
         }
+        }
+    } else { /* Special case for metafiles.  Just do a straight copy */
+        p = HeapAlloc(GetProcessHeap(), 0, (count + 1) * sizeof(WCHAR));
+	for(i = 0; i < count; i++)
+            p[i] = (BYTE)str[i];
+        p[count] = '\0';
+        wlen = count;
+        if(lpDx) {
+            lpDxW = HeapAlloc(GetProcessHeap(), 0, count * sizeof(INT));
+            for(i = 0; i < count; i++)
+                lpDxW[i] = lpDx[i];
+        }
     }
 
     ret = ExtTextOutW( hdc, x, y, flags, lprect, p, wlen, lpDxW );
diff -Naur wine-2.0a/dlls/gdi32/freetype.c wine-2.0b/dlls/gdi32/freetype.c
--- wine-2.0a/dlls/gdi32/freetype.c	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/gdi32/freetype.c	2017-07-11 20:37:49.000000000 +0100
@@ -2282,6 +2282,28 @@
             return 0;
         }
 
+        /* CROSSOVER HACK - bug 4862 */
+        if(!strcmp(ft_face->family_name, "AR PL ZenKai Uni") || !strcmp(ft_face->family_name, "Samyak Oriya"))
+        {
+            /* These fonts (ukai.ttf, samyak-oriya.ttf) cause native gdiplus to crash */
+            TRACE("Skipping %s\n", ft_face->family_name);
+            pFT_Done_Face(ft_face);
+            return 0;
+        }
+
+        /* Ignore Apple's Symbol font */
+        if(!strcasecmp( ft_face->family_name, "symbol" ) && FT_IS_SFNT( ft_face ))
+        {
+            FONTSIGNATURE fs;
+            get_fontsig( ft_face, &fs );
+            if(!(fs.fsCsb[0] & 0x80000000))
+            {
+                TRACE( "Skipping Apple's Symbol font\n" );
+                pFT_Done_Face( ft_face );
+                return 0;
+            }
+        }
+
         AddFaceToList(ft_face, file, font_data_ptr, font_data_size, face_index, flags);
         ++ret;
 
@@ -2382,6 +2404,64 @@
     LPWSTR value;
     LPVOID data;
 
+/* CROSSOVER HACK - bug 13095 and 13610 */
+    static const WCHAR atSimSun[] = {'@','S','i','m','S','u','n',0};
+    static const WCHAR NSimSun[] = {'N','S','i','m','S','u','n',0};
+    static const WCHAR atNSimSun[] = {'@','N','S','i','m','S','u','n',0};
+    static const WCHAR SongTi[] = {0x5b8b,0x4f53,0};
+    static const WCHAR atSongTi[] = {'@',0x5b8b,0x4f53,0};
+    static const WCHAR XinSongTi[] = {0x65B0,0x5b8b,0x4f53,0};
+    static const WCHAR atXinSongTi[] = {'@',0x65B0,0x5b8b,0x4f53,0};
+    static const WCHAR *cn_font_replacement[] = {
+        SimSun,
+        NSimSun,
+        SongTi,
+        XinSongTi,
+        atSimSun,
+        atNSimSun,
+        atSongTi,
+        atXinSongTi
+    };
+    int replacement_count = sizeof(cn_font_replacement)/sizeof(cn_font_replacement[0]);
+    BOOL *cn_font_seen = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, replacement_count * sizeof(BOOL));
+#ifdef __APPLE__
+    static const WCHAR STSong[] = {'S','T','S','o','n','g',0};
+    static const WCHAR atSTSong[] = {'@','S','T','S','o','n','g',0};
+    static const WCHAR new_cn_font[] = {
+        'H','i','r','a','g','i','n','o',' ','S','a','n','s',' ','G','B',' ','W','3',0,
+        'S','T','S','o','n','g',0,
+        0
+    };
+    static const WCHAR vertical_new_cn_font[] = {
+        '@','H','i','r','a','g','i','n','o',' ','S','a','n','s',' ','G','B',' ','W','3',0,
+        '@','S','T','S','o','n','g',0,
+        0
+    };
+#else
+    static const WCHAR new_cn_font[] = {
+        /* WenQuanYi Micro Hei - popular open source Simplified Chinese font */
+        'W','e','n','Q','u','a','n','Y','i',' ','M','i','c','r','o',' ','H','e','i',0,
+        /* Noto Sans CJK SC Regular - default Simplified Chinese font for Ubuntu 16.04 or later */
+        'N','o','t','o',' ','S','a','n','s',' ','C','J','K',' ','S','C',' ','R','e','g','u','l','a','r',0,
+        /* Droid Sans Fallback - Ubuntu's default Simplified Chinese font */
+        'D','r','o','i','d',' ','S','a','n','s',' ','F','a','l','l','b','a','c','k',0,
+        /* Source Han Sans CN - Fedora's default Simplified Chinese font */
+        'S','o','u','r','c','e',' ','H','a','n',' ','S','a','n','s',' ','C','N',' ','R','e','g','u','l','a','r',0,
+        0
+    };
+    static const WCHAR vertical_new_cn_font[] = {
+        /* WenQuanYi Micro Hei - popular open source Simplified Chinese font */
+        '@','W','e','n','Q','u','a','n','Y','i',' ','M','i','c','r','o',' ','H','e','i',0,
+        /* Noto Sans CJK SC Regular - default Simplified Chinese font for Ubuntu 16.04 or later */
+        '@','N','o','t','o',' ','S','a','n','s',' ','C','J','K',' ','S','C',' ','R','e','g','u','l','a','r',0,
+        /* Droid Sans Fallback - Ubuntu's default Simplified Chinese font */
+        '@','D','r','o','i','d',' ','S','a','n','s',' ','F','a','l','l','b','a','c','k',0,
+        /* Source Han Sans CN - Fedora's default Simplified Chinese font */
+        '@','S','o','u','r','c','e',' ','H','a','n',' ','S','a','n','s',' ','C','N',' ','R','e','g','u','l','a','r',0,
+        0
+    };
+#endif
+
     /* @@ Wine registry key: HKCU\Software\Wine\Fonts\Replacements */
     if(RegOpenKeyA(HKEY_CURRENT_USER, "Software\\Wine\\Fonts\\Replacements", &hkey) == ERROR_SUCCESS)
     {
@@ -2399,9 +2479,31 @@
             /* "NewName"="Oldname" */
             if(!find_family_from_any_name(value))
             {
+                const WCHAR *replace = data;
+
+/* CROSSOVER HACK - bug 13095 and 13610 */
+                int j;
+                for (j = 0; j < replacement_count; j++)
+                {
+                    if (!cn_font_seen[j] && !lstrcmpW(value, cn_font_replacement[j]))
+                    {
+#ifdef __APPLE__
+                        BOOL is_vertical = value[0] == '@';
+                        if (type == REG_SZ && !lstrcmpW(data, is_vertical ? atSTSong : STSong))
+                        {
+                            if (is_vertical)
+                                replace = vertical_new_cn_font;
+                            else
+                                replace = new_cn_font;
+                            type = REG_MULTI_SZ;
+                        }
+#endif
+                        cn_font_seen[j] = TRUE;
+                        break;
+                    }
+                }
                 if (type == REG_MULTI_SZ)
                 {
-                    WCHAR *replace = data;
                     while(*replace)
                     {
                         if (map_font_family(value, replace))
@@ -2419,10 +2521,29 @@
 	    dlen = datalen;
 	    vlen = valuelen;
 	}
+/* CROSSOVER HACK - bug 13095 and 13610 */
+        for (i = 0; i < replacement_count; i++)
+        {
+            if (!cn_font_seen[i] && !find_family_from_any_name(cn_font_replacement[i]))
+            {
+                const WCHAR *replace;
+                if (cn_font_replacement[i][0] == '@')
+                    replace = vertical_new_cn_font;
+                else
+                    replace = new_cn_font;
+                while (*replace)
+                {
+                    if (map_font_family(cn_font_replacement[i], replace))
+                        break;
+                    replace += strlenW(replace) + 1;
+                }
+            }
+        }
 	HeapFree(GetProcessHeap(), 0, data);
 	HeapFree(GetProcessHeap(), 0, value);
 	RegCloseKey(hkey);
     }
+    HeapFree(GetProcessHeap(), 0, cn_font_seen);
 }
 
 static const WCHAR *font_links_list[] =
@@ -2829,8 +2950,12 @@
     int i, len;
     char *file;
     const char *ext;
+    static const WCHAR cx_hack_var[] = {'C','X','_','S','K','I','P','_','F','O','N','T','C','O','N','F','I','G','_',
+                                        'F','O','N','T','S',0};
+    WCHAR env_buf[20];
 
     if (!fontconfig_enabled) return;
+    if(GetEnvironmentVariableW(cx_hack_var, env_buf, sizeof(env_buf)/sizeof(WCHAR))) return;
 
     pat = pFcPatternCreate();
     os = pFcObjectSetCreate();
@@ -4099,7 +4224,16 @@
 
 static BOOL init_freetype(void)
 {
-    ft_handle = wine_dlopen(SONAME_LIBFREETYPE, RTLD_NOW, NULL, 0);
+    const char *ftname = "libcxfreetype.so";
+
+    TRACE("Trying freetype library %s (hard-coded)\n",ftname);
+    ft_handle = wine_dlopen(ftname, RTLD_NOW, NULL, 0);
+
+    if(!ft_handle) {
+        TRACE("Can't find freetype library %s, trying %s instead\n", ftname, SONAME_LIBFREETYPE);
+        ft_handle = wine_dlopen(SONAME_LIBFREETYPE, RTLD_NOW, NULL, 0);
+    }
+
     if(!ft_handle) {
         WINE_MESSAGE(
       "Wine cannot find the FreeType font library.  To enable Wine to\n"
@@ -4352,6 +4486,9 @@
  */
 BOOL WineEngInit(void)
 {
+    static const WCHAR cx_hack_var[] = {'C','X','_','T','U','R','N','_','O','F','F','_','F','O','N','T','_',
+                                        'R','E','P','L','A','C','E','M','E','N','T','S',0};
+    WCHAR env_buf[20];
     HKEY hkey;
     DWORD disposition;
     HANDLE font_mutex;
@@ -4401,7 +4538,9 @@
     DumpFontList();
     LoadSubstList();
     DumpSubstList();
-    LoadReplaceList();
+
+    if(!GetEnvironmentVariableW(cx_hack_var, env_buf, sizeof(env_buf)/sizeof(WCHAR)))
+        LoadReplaceList();
 
     if(disposition == REG_CREATED_NEW_KEY)
         update_reg_entries();
@@ -6110,6 +6249,43 @@
     LOGFONTW lf;
     struct enum_charset_list enum_charsets;
 
+    /* for the photoshop japanese font hack */
+    char name[MAX_PATH], *p;
+    INT blockNum=0;
+    static const CHAR BLOCK_LIST[][MAX_PATH] = {
+"/System/Library/Fonts/\xe3\x83\x92\xe3\x83\xa9\xe3\x82\xad\xe3\x82\x99\xe3\x83\x8e\xe8\xa7\x92\xe3\x82\xb3\xe3\x82\x99 Std W8.otf",
+"/System/Library/Fonts/\xe3\x83\x92\xe3\x83\xa9\xe3\x82\xad\xe3\x82\x99\xe3\x83\x8e\xe6\x98\x8e\xe6\x9c\x9d Pro W3.otf",
+"/System/Library/Fonts/\xe3\x83\x92\xe3\x83\xa9\xe3\x82\xad\xe3\x82\x99\xe3\x83\x8e\xe8\xa7\x92\xe3\x82\xb3\xe3\x82\x99 Pro W3.otf",
+"/System/Library/Fonts/\xe3\x83\x92\xe3\x83\xa9\xe3\x82\xad\xe3\x82\x99\xe3\x83\x8e\xe6\x98\x8e\xe6\x9c\x9d Pro W6.otf",
+"/System/Library/Fonts/\xe3\x83\x92\xe3\x83\xa9\xe3\x82\xad\xe3\x82\x99\xe3\x83\x8e\xe8\xa7\x92\xe3\x82\xb3\xe3\x82\x99 Pro W6.otf",
+"/System/Library/Fonts/\xe3\x83\x92\xe3\x83\xa9\xe3\x82\xad\xe3\x82\x99\xe3\x83\x8e\xe4\xb8\xb8\xe3\x82\xb3\xe3\x82\x99 Pro W4.otf",
+/* for Leopard new fonts and things moved */
+"/System/Library/Fonts/\xe3\x83\x92\xe3\x83\xa9\xe3\x82\xad\xe3\x82\x99\xe3\x83\x8e\xe6\x98\x8e\xe6\x9c\x9d ProN W3.otf",
+"/System/Library/Fonts/\xe3\x83\x92\xe3\x83\xa9\xe3\x82\xad\xe3\x82\x99\xe3\x83\x8e\xe8\xa7\x92\xe3\x82\xb3\xe3\x82\x99 ProN W3.otf",
+"/System/Library/Fonts/\xe3\x83\x92\xe3\x83\xa9\xe3\x82\xad\xe3\x82\x99\xe3\x83\x8e\xe6\x98\x8e\xe6\x9c\x9d ProN W6.otf",
+"/System/Library/Fonts/\xe3\x83\x92\xe3\x83\xa9\xe3\x82\xad\xe3\x82\x99\xe3\x83\x8e\xe8\xa7\x92\xe3\x82\xb3\xe3\x82\x99 ProN W6.otf",
+"/Library/Fonts/\xe3\x83\x92\xe3\x83\xa9\xe3\x82\xad\xe3\x82\x99\xe3\x83\x8e\xe8\xa7\x92\xe3\x82\xb3\xe3\x82\x99 StdN W8.otf",
+"/Library/Fonts/\xe3\x83\x92\xe3\x83\xa9\xe3\x82\xad\xe3\x82\x99\xe3\x83\x8e\xe8\xa7\x92\xe3\x82\xb3\xe3\x82\x99 Std W8.otf",
+"/Library/Fonts/\xe3\x83\x92\xe3\x83\xa9\xe3\x82\xad\xe3\x82\x99\xe3\x83\x8e\xe6\x98\x8e\xe6\x9c\x9d Pro W3.otf",
+"/Library/Fonts/\xe3\x83\x92\xe3\x83\xa9\xe3\x82\xad\xe3\x82\x99\xe3\x83\x8e\xe8\xa7\x92\xe3\x82\xb3\xe3\x82\x99 Pro W3.otf",
+"/Library/Fonts/\xe3\x83\x92\xe3\x83\xa9\xe3\x82\xad\xe3\x82\x99\xe3\x83\x8e\xe6\x98\x8e\xe6\x9c\x9d Pro W6.otf",
+"/Library/Fonts/\xe3\x83\x92\xe3\x83\xa9\xe3\x82\xad\xe3\x82\x99\xe3\x83\x8e\xe8\xa7\x92\xe3\x82\xb3\xe3\x82\x99 Pro W6.otf",
+"/Library/Fonts/\xe3\x83\x92\xe3\x83\xa9\xe3\x82\xad\xe3\x82\x99\xe3\x83\x8e\xe4\xb8\xb8\xe3\x82\xb3\xe3\x82\x99 Pro W4.otf",
+"/Library/Fonts/\xe3\x83\x92\xe3\x83\xa9\xe3\x82\xad\xe3\x82\x99\xe3\x83\x8e\xe4\xb8\xb8\xe3\x82\xb3\xe3\x82\x99 ProN W4.otf"
+    };
+
+    GetModuleFileNameA(GetModuleHandleA(NULL),name,MAX_PATH);
+    p = strrchr(name,'\\');
+    if (p)
+        p++;
+    else
+        p = name;
+    if ((strcasecmp(p,"photoshop.exe")==0) ||
+        (strcasecmp(p,"imageready.exe")==0))
+        blockNum = 18;
+    else
+        blockNum = 0;
+
     if (!plf)
     {
         lf.lfCharSet = DEFAULT_CHARSET;
@@ -6139,6 +6315,24 @@
             face_list = get_face_list_from_family(family);
             LIST_FOR_EACH_ENTRY( face, face_list, Face, entry ) {
                 if (!face_matches(family->FamilyName, face, face_name)) continue;
+                if (blockNum>0)
+                {
+                    int i = 0;
+                    BOOL blocked = FALSE;
+                    char *file = strWtoA( CP_UNIXCP, face->file );
+                    for ( i = 0; i < blockNum; i++)
+                        if (lstrcmpA(file,BLOCK_LIST[i])==0)
+                        {
+                            blocked = TRUE;
+                            break;
+                        }
+                    HeapFree( GetProcessHeap(), 0, file );
+                    if (blocked)
+                    {
+                        TRACE("Blocked for Photoshop\n");
+                        continue;
+                    }
+                }
                 if (!enum_face_charsets(family, face, &enum_charsets, proc, lparam, psub ? psub->from.name : NULL)) return FALSE;
 	    }
 	}
@@ -6146,6 +6340,24 @@
         LIST_FOR_EACH_ENTRY( family, &font_list, Family, entry ) {
             face_list = get_face_list_from_family(family);
             face = LIST_ENTRY(list_head(face_list), Face, entry);
+            if (blockNum>0)
+            {
+                int i = 0;
+                BOOL blocked = FALSE;
+                char *file = strWtoA( CP_UNIXCP, face->file );
+                for ( i = 0; i < blockNum; i++)
+                    if (lstrcmpA(file,BLOCK_LIST[i])==0)
+                    {
+                        blocked = TRUE;
+                        break;
+                    }
+                HeapFree( GetProcessHeap(), 0, file );
+                if (blocked)
+                {
+                    TRACE("Blocked for Photoshop\n");
+                    continue;
+                }
+            }
             if (!enum_face_charsets(family, face, &enum_charsets, proc, lparam, NULL)) return FALSE;
 	}
     }
@@ -7180,6 +7392,33 @@
 	unsigned int max_level, row, col;
 	BYTE *start, *ptr;
 
+        /****************** CodeWeavers hack to fix HL2 crash **************************
+         *
+         * Both glyphs 0x2e and 0x39 of this font get rendered to a larger
+         * size with FreeType than under Windows, and HL2 uses a fixed size
+         * buffer on the stack to copy the data into.  For now we'll clip glyphs
+         * from that font into a rather smaller BBox
+         *
+         ******************************************************************************/
+        if(!strcmp(ft_face->family_name, "HL2MP") ||
+           !strcmp(ft_face->family_name, "csd"))
+        {
+            int i;
+            if(width) width--;
+ 
+            for(i = 0; i < 2; i++)
+            {
+                if(height)
+                {
+                    height--;
+                    lpgm->gmptGlyphOrigin.y--;
+                }
+            }
+            gm.gmBlackBoxX = width  ? width  : 1;
+            gm.gmBlackBoxY = height ? height : 1;
+        }
+        /*********************************** End CW's hack ****************************/
+
 	pitch = (width + 3) / 4 * 4;
 	needed = pitch * height;
 
diff -Naur wine-2.0a/dlls/gdi32/mfdrv/text.c wine-2.0b/dlls/gdi32/mfdrv/text.c
--- wine-2.0a/dlls/gdi32/mfdrv/text.c	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/gdi32/mfdrv/text.c	2017-07-11 20:37:49.000000000 +0100
@@ -78,55 +78,18 @@
     RECT16	rect16;
     LPINT16	lpdx16 = NULL;
     BOOL	ret;
-    unsigned int i, j;
+    unsigned int i;
     LPSTR       ascii;
-    DWORD len;
-    CHARSETINFO csi;
-    int charset = GetTextCharset( dev->hdc );
-    UINT cp = CP_ACP;
 
-    if(TranslateCharsetInfo(ULongToPtr(charset), &csi, TCI_SRCCHARSET))
-        cp = csi.ciACP;
-    else {
-        switch(charset) {
-	case OEM_CHARSET:
-	    cp = GetOEMCP();
-	    break;
-	case DEFAULT_CHARSET:
-	    cp = GetACP();
-	    break;
-
-	case VISCII_CHARSET:
-	case TCVN_CHARSET:
-	case KOI8_CHARSET:
-	case ISO3_CHARSET:
-	case ISO4_CHARSET:
-	case ISO10_CHARSET:
-	case CELTIC_CHARSET:
-	  /* FIXME: These have no place here, but because x11drv
-	     enumerates fonts with these (made up) charsets some apps
-	     might use them and then the FIXME below would become
-	     annoying.  Now we could pick the intended codepage for
-	     each of these, but since it's broken anyway we'll just
-	     use CP_ACP and hope it'll go away...
-	  */
-	    cp = CP_ACP;
-	    break;
-
-
-	default:
-	    FIXME("Can't find codepage for charset %d\n", charset);
-	    break;
-	}
+    ascii = HeapAlloc(GetProcessHeap(), 0, count);
+    for(i = 0; i < count; i++) {
+        if(str[i] > 0xff)
+            ascii[i] = '?';
+        else
+            ascii[i] = (BYTE)(str[i] & 0xff);
     }
 
-
-    TRACE("cp == %d\n", cp);
-    len = WideCharToMultiByte(cp, 0, str, count, NULL, 0, NULL, NULL);
-    ascii = HeapAlloc(GetProcessHeap(), 0, len);
-    WideCharToMultiByte(cp, 0, str, count, ascii, len, NULL, NULL);
-    TRACE("mapped %s -> %s\n", debugstr_wn(str, count), debugstr_an(ascii, len));
-
+    TRACE("mapped %s -> %s\n", debugstr_wn(str, count), debugstr_an(ascii, count));
 
     if (lprect)
     {
@@ -137,16 +100,12 @@
     }
 
     if(lpDx) {
-        lpdx16 = HeapAlloc( GetProcessHeap(), 0, sizeof(INT16)*len );
-	for(i = j = 0; i < len; )
-	    if(IsDBCSLeadByteEx(cp, ascii[i])) {
-	        lpdx16[i++] = lpDx[j++];
-		lpdx16[i++] = 0;
-	    } else
-	        lpdx16[i++] = lpDx[j++];
+        lpdx16 = HeapAlloc( GetProcessHeap(), 0, sizeof(INT16)*count );
+	for(i = 0; i < count; i++)
+            lpdx16[i] = lpDx[i];
     }
 
-    ret = MFDRV_MetaExtTextOut(dev,x,y,flags,lprect?&rect16:NULL,ascii,len,lpdx16);
+    ret = MFDRV_MetaExtTextOut(dev,x,y,flags,lprect?&rect16:NULL,ascii,count,lpdx16);
     HeapFree( GetProcessHeap(), 0, ascii );
     HeapFree( GetProcessHeap(), 0, lpdx16 );
     return ret;
diff -Naur wine-2.0a/dlls/gdiplus/graphics.c wine-2.0b/dlls/gdiplus/graphics.c
--- wine-2.0a/dlls/gdiplus/graphics.c	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/gdiplus/graphics.c	2017-07-11 20:37:49.000000000 +0100
@@ -348,7 +348,18 @@
 static GpStatus get_clip_hrgn(GpGraphics *graphics, HRGN *hrgn)
 {
     /* clipping region is in device coords */
-    return GdipGetRegionHRgn(graphics->clip, NULL, hrgn);
+    GpStatus status = GdipGetRegionHRgn(graphics->clip, NULL, hrgn);
+    if ( status == Ok && graphics->hdc)
+    {
+        POINT pt = {0, 0};
+        LPtoDP(graphics->hdc, &pt, 1);
+        if (pt.x!=0 || pt.y!=0)
+        {
+            OffsetRgn(*hrgn, pt.x, pt.y);
+        }
+    }
+
+    return status;
 }
 
 /* Draw ARGB data to the given graphics object */
@@ -4432,10 +4443,23 @@
                 &gp_bound_rect, gp_bound_rect.Width);
 
             if (stat == Ok)
+            {
+                /*Because the ExtSelectClipRgn in alpha_blend_pixels_hrgn use gdi32 device coordinate
+                 So check if need perform a conversion */
+                if (graphics->hdc)
+                {
+                    POINT pt = {0, 0};
+                    LPtoDP(graphics->hdc, &pt, 1);
+                    if (pt.x!=0 || pt.y!=0)
+                    {
+                        OffsetRgn (hregion, pt.x, pt.y);
+                    }
+                }
                 stat = alpha_blend_pixels_hrgn(graphics, gp_bound_rect.X,
                     gp_bound_rect.Y, (BYTE*)pixel_data, gp_bound_rect.Width,
                     gp_bound_rect.Height, gp_bound_rect.Width * 4, hregion,
                     PixelFormat32bppARGB);
+            }
 
             heap_free(pixel_data);
         }
diff -Naur wine-2.0a/dlls/gdiplus/graphicspath.c wine-2.0b/dlls/gdiplus/graphicspath.c
--- wine-2.0a/dlls/gdiplus/graphicspath.c	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/gdiplus/graphicspath.c	2017-07-11 20:37:49.000000000 +0100
@@ -1964,6 +1964,7 @@
     REAL dash_pos=0.0;
     int dash_index=0;
     const REAL *dash_pattern;
+    REAL *dash_pattern_scaled;
     int dash_count;
     GpPointF *tmp_points;
     REAL segment_dy;
@@ -2002,6 +2003,12 @@
         break;
     }
 
+    dash_pattern_scaled = heap_alloc(dash_count * sizeof(REAL));
+    if (!dash_pattern_scaled) return;
+
+    for (i = 0; i < dash_count; i++)
+        dash_pattern_scaled[i] = pen->width * dash_pattern[i];
+
     tmp_points = heap_alloc_zero((end - start + 2) * sizeof(GpPoint));
     if (!tmp_points) return; /* FIXME */
 
@@ -2050,7 +2057,7 @@
                 }
             }
 
-            if (dash_pattern[dash_index] - dash_pos > segment_length - segment_pos)
+            if (dash_pattern_scaled[dash_index] - dash_pos > segment_length - segment_pos)
             {
                 /* advance to next segment */
                 if ((dash_index % 2) == 0)
@@ -2064,7 +2071,7 @@
             else
             {
                 /* advance to next dash in pattern */
-                segment_pos += dash_pattern[dash_index] - dash_pos;
+                segment_pos += dash_pattern_scaled[dash_index] - dash_pos;
                 dash_pos = 0.0;
                 if (++dash_index == dash_count)
                     dash_index = 0;
@@ -2076,8 +2083,7 @@
     if (dash_index % 2 == 0 && num_tmp_points != 0)
     {
         /* last dash overflows last segment */
-        tmp_points[num_tmp_points] = path->pathdata.Points[end];
-        widen_open_figure(tmp_points, pen, 0, num_tmp_points,
+        widen_open_figure(tmp_points, pen, 0, num_tmp_points-1,
             draw_start_cap ? pen->startcap : LineCapFlat, pen->customstart,
             closed ? LineCapFlat : pen->endcap, pen->customend, last_point);
     }
diff -Naur wine-2.0a/dlls/gdiplus/tests/graphicspath.c wine-2.0b/dlls/gdiplus/tests/graphicspath.c
--- wine-2.0a/dlls/gdiplus/tests/graphicspath.c	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/gdiplus/tests/graphicspath.c	2017-07-11 20:37:49.000000000 +0100
@@ -1065,6 +1065,17 @@
     {5.0, 20.0,  PathPointTypeLine|PathPointTypeCloseSubpath,  0, 0} /*3*/
     };
 
+static path_test_t widenline_dash_path[] = {
+    {5.0, 0.0,   PathPointTypeStart, 0, 0}, /*0*/
+    {35.0, 0.0,  PathPointTypeLine,  0, 0}, /*1*/
+    {35.0, 10.0, PathPointTypeLine,  0, 0}, /*2*/
+    {5.0, 10.0,  PathPointTypeLine|PathPointTypeCloseSubpath,  0, 0}, /*3*/
+    {45.0, 0.0,   PathPointTypeStart, 0, 0}, /*4*/
+    {50.0, 0.0,  PathPointTypeLine,  0, 0}, /*5*/
+    {50.0, 10.0, PathPointTypeLine,  0, 0}, /*6*/
+    {45.0, 10.0,  PathPointTypeLine|PathPointTypeCloseSubpath,  0, 0}, /*7*/
+    };
+
 static void test_widen(void)
 {
     GpStatus status;
@@ -1139,6 +1150,22 @@
     status = GdipScaleMatrix(m, 1.0, 0.5, MatrixOrderAppend);
     expect(Ok, status);
 
+    /* dashed line */
+    status = GdipResetPath(path);
+    expect(Ok, status);
+    status = GdipAddPathLine(path, 5.0, 5.0, 50.0, 5.0);
+    expect(Ok, status);
+
+    status = GdipSetPenDashStyle(pen, DashStyleDash);
+    expect(Ok, status);
+
+    status = GdipWidenPath(path, pen, m, 1.0);
+    expect(Ok, status);
+    ok_path(path, widenline_dash_path, sizeof(widenline_dash_path)/sizeof(path_test_t), FALSE);
+
+    status = GdipSetPenDashStyle(pen, DashStyleSolid);
+    expect(Ok, status);
+
     /* pen width in UnitWorld */
     GdipDeletePen(pen);
     status = GdipCreatePen1(0xffffffff, 10.0, UnitWorld, &pen);
diff -Naur wine-2.0a/dlls/glu32/glu.c wine-2.0b/dlls/glu32/glu.c
--- wine-2.0a/dlls/glu32/glu.c	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/glu32/glu.c	2017-07-11 20:37:49.000000000 +0100
@@ -16,12 +16,18 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  */
 
+#include "config.h"
+
 #include <stdarg.h>
 
 #include "windef.h"
 #include "winbase.h"
+#include "wingdi.h" /* CrossOver Hack 10798 */
 
 #include "wine/debug.h"
+/* CrossOver Hack 10798 */
+#include "wine/wgl.h"
+#include "wine/wgl_driver.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(glu);
 
@@ -63,300 +69,279 @@
 #define GLU_TESS_EDGE_FLAG_DATA 100110
 #define GLU_TESS_COMBINE_DATA   100111
 
+/* CrossOver Hack 10798 */
+static struct opengl_funcs* get_opengl_funcs(void)
+{
+    static struct opengl_funcs *funcs;
+
+    if (!funcs)
+    {
+        static const WCHAR displayW[] = {'D','I','S','P','L','A','Y',0};
+        HDC hdc = CreateDCW(displayW, NULL, NULL, NULL);
+        funcs = __wine_get_wgl_driver(hdc, WINE_WGL_DRIVER_VERSION);
+        DeleteDC(hdc);
+    }
+
+    return funcs;
+}
+
 /***********************************************************************
  *		gluLookAt (GLU32.@)
  */
-extern int gluLookAt(double arg0,double arg1,double arg2,double arg3,double arg4,double arg5,double arg6,double arg7,double arg8);
-int WINAPI wine_gluLookAt(double arg0,double arg1,double arg2,double arg3,double arg4,double arg5,double arg6,double arg7,double arg8) {
-	return gluLookAt(arg0,arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8);
+void WINAPI wine_gluLookAt(double arg0,double arg1,double arg2,double arg3,double arg4,double arg5,double arg6,double arg7,double arg8) {
+    get_opengl_funcs()->glu.p_gluLookAt(arg0,arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8);
 }
 
 /***********************************************************************
  *		gluOrtho2D (GLU32.@)
  */
-extern int gluOrtho2D(double arg0,double arg1,double arg2,double arg3);
-int WINAPI wine_gluOrtho2D(double arg0,double arg1,double arg2,double arg3) {
-	return gluOrtho2D(arg0,arg1,arg2,arg3);
+void WINAPI wine_gluOrtho2D(double arg0,double arg1,double arg2,double arg3) {
+    get_opengl_funcs()->glu.p_gluOrtho2D(arg0,arg1,arg2,arg3);
 }
 
 /***********************************************************************
  *		gluPerspective (GLU32.@)
  */
-extern int gluPerspective(double arg0,double arg1,double arg2,double arg3);
-int WINAPI wine_gluPerspective(double arg0,double arg1,double arg2,double arg3) {
-	return gluPerspective(arg0,arg1,arg2,arg3);
+void WINAPI wine_gluPerspective(double arg0,double arg1,double arg2,double arg3) {
+    get_opengl_funcs()->glu.p_gluPerspective(arg0,arg1,arg2,arg3);
 }
 
 /***********************************************************************
  *		gluPickMatrix (GLU32.@)
  */
-extern int gluPickMatrix(double arg0,double arg1,double arg2,double arg3,void *arg4);
-int WINAPI wine_gluPickMatrix(double arg0,double arg1,double arg2,double arg3,void *arg4) {
-	return gluPickMatrix(arg0,arg1,arg2,arg3,arg4);
+void WINAPI wine_gluPickMatrix(double arg0,double arg1,double arg2,double arg3,void *arg4) {
+    get_opengl_funcs()->glu.p_gluPickMatrix(arg0,arg1,arg2,arg3,arg4);
 }
 
 /***********************************************************************
  *		gluProject (GLU32.@)
  */
-extern int gluProject(double arg0,double arg1,double arg2,void *arg3,void *arg4,void *arg5,void *arg6,void *arg7,void *arg8);
 int WINAPI wine_gluProject(double arg0,double arg1,double arg2,void *arg3,void *arg4,void *arg5,void *arg6,void *arg7,void *arg8) {
-	return gluProject(arg0,arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8);
+    return get_opengl_funcs()->glu.p_gluProject(arg0,arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8);
 }
 
 /***********************************************************************
  *		gluUnProject (GLU32.@)
  */
-extern int gluUnProject(double arg0,double arg1,double arg2,void *arg3,void *arg4,void *arg5,void *arg6,void *arg7,void *arg8);
 int WINAPI wine_gluUnProject(double arg0,double arg1,double arg2,void *arg3,void *arg4,void *arg5,void *arg6,void *arg7,void *arg8) {
-	return gluUnProject(arg0,arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8);
+    return get_opengl_funcs()->glu.p_gluUnProject(arg0,arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8);
 }
 
 /***********************************************************************
  *		gluErrorString (GLU32.@)
  */
-extern int gluErrorString(int arg0);
-int WINAPI wine_gluErrorString(int arg0) {
-	return gluErrorString(arg0);
+const GLubyte * WINAPI wine_gluErrorString(int arg0) {
+    return get_opengl_funcs()->glu.p_gluErrorString(arg0);
 }
 
 /***********************************************************************
  *		gluScaleImage (GLU32.@)
  */
-extern int gluScaleImage(int arg0,int arg1,int arg2,int arg3,void *arg4,int arg5,int arg6,int arg7,void *arg8);
 int WINAPI wine_gluScaleImage(int arg0,int arg1,int arg2,int arg3,void *arg4,int arg5,int arg6,int arg7,void *arg8) {
-	return gluScaleImage(arg0,arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8);
+    return get_opengl_funcs()->glu.p_gluScaleImage(arg0,arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8);
 }
 
 /***********************************************************************
  *		gluBuild1DMipmaps (GLU32.@)
  */
-extern int gluBuild1DMipmaps(int arg0,int arg1,int arg2,int arg3,int arg4,void *arg5);
 int WINAPI wine_gluBuild1DMipmaps(int arg0,int arg1,int arg2,int arg3,int arg4,void *arg5) {
-	return gluBuild1DMipmaps(arg0,arg1,arg2,arg3,arg4,arg5);
+    return get_opengl_funcs()->glu.p_gluBuild1DMipmaps(arg0,arg1,arg2,arg3,arg4,arg5);
 }
 
 /***********************************************************************
  *		gluBuild2DMipmaps (GLU32.@)
  */
-extern int gluBuild2DMipmaps(int arg0,int arg1,int arg2,int arg3,int arg4,int arg5,void *arg6);
 int WINAPI wine_gluBuild2DMipmaps(int arg0,int arg1,int arg2,int arg3,int arg4,int arg5,void *arg6) {
-	return gluBuild2DMipmaps(arg0,arg1,arg2,arg3,arg4,arg5,arg6);
+    return get_opengl_funcs()->glu.p_gluBuild2DMipmaps(arg0,arg1,arg2,arg3,arg4,arg5,arg6);
 }
 
 /***********************************************************************
  *		gluNewQuadric (GLU32.@)
  */
-extern int gluNewQuadric(void);
-int WINAPI wine_gluNewQuadric(void) {
-	return gluNewQuadric();
+void* WINAPI wine_gluNewQuadric(void) {
+    return get_opengl_funcs()->glu.p_gluNewQuadric();
 }
 
 /***********************************************************************
  *		gluDeleteQuadric (GLU32.@)
  */
-extern int gluDeleteQuadric(void *arg0);
-int WINAPI wine_gluDeleteQuadric(void *arg0) {
-	return gluDeleteQuadric(arg0);
+void WINAPI wine_gluDeleteQuadric(void *arg0) {
+    get_opengl_funcs()->glu.p_gluDeleteQuadric(arg0);
 }
 
 /***********************************************************************
  *		gluQuadricDrawStyle (GLU32.@)
  */
-extern int gluQuadricDrawStyle(void *arg0,int arg1);
-int WINAPI wine_gluQuadricDrawStyle(void *arg0,int arg1) {
-	return gluQuadricDrawStyle(arg0,arg1);
+void WINAPI wine_gluQuadricDrawStyle(void *arg0,int arg1) {
+    get_opengl_funcs()->glu.p_gluQuadricDrawStyle(arg0,arg1);
 }
 
 /***********************************************************************
  *		gluQuadricOrientation (GLU32.@)
  */
-extern int gluQuadricOrientation(void *arg0,int arg1);
-int WINAPI wine_gluQuadricOrientation(void *arg0,int arg1) {
-	return gluQuadricOrientation(arg0,arg1);
+void WINAPI wine_gluQuadricOrientation(void *arg0,int arg1) {
+    get_opengl_funcs()->glu.p_gluQuadricOrientation(arg0,arg1);
 }
 
 /***********************************************************************
  *		gluQuadricNormals (GLU32.@)
  */
-extern int gluQuadricNormals(void *arg0,int arg1);
-int WINAPI wine_gluQuadricNormals(void *arg0,int arg1) {
-	return gluQuadricNormals(arg0,arg1);
+void WINAPI wine_gluQuadricNormals(void *arg0,int arg1) {
+    get_opengl_funcs()->glu.p_gluQuadricNormals(arg0,arg1);
 }
 
 /***********************************************************************
  *		gluQuadricTexture (GLU32.@)
  */
-extern int gluQuadricTexture(void *arg0,int arg1);
-int WINAPI wine_gluQuadricTexture(void *arg0,int arg1) {
-	return gluQuadricTexture(arg0,arg1);
+void WINAPI wine_gluQuadricTexture(void *arg0,int arg1) {
+    get_opengl_funcs()->glu.p_gluQuadricTexture(arg0,arg1);
 }
 
 /***********************************************************************
  *		gluQuadricCallback (GLU32.@)
  */
-extern int gluQuadricCallback(void *arg0,int arg1,void *arg2);
-int WINAPI wine_gluQuadricCallback(void *arg0,int arg1,void *arg2) {
-	return gluQuadricCallback(arg0,arg1,arg2);
+void WINAPI wine_gluQuadricCallback(void *arg0,int arg1,void *arg2) {
+    get_opengl_funcs()->glu.p_gluQuadricCallback(arg0,arg1,arg2);
 }
 
 /***********************************************************************
  *		gluCylinder (GLU32.@)
  */
-extern int gluCylinder(void *arg0,double arg1,double arg2,double arg3,int arg4,int arg5);
-int WINAPI wine_gluCylinder(void *arg0,double arg1,double arg2,double arg3,int arg4,int arg5) {
-	return gluCylinder(arg0,arg1,arg2,arg3,arg4,arg5);
+void WINAPI wine_gluCylinder(void *arg0,double arg1,double arg2,double arg3,int arg4,int arg5) {
+    get_opengl_funcs()->glu.p_gluCylinder(arg0,arg1,arg2,arg3,arg4,arg5);
 }
 
 /***********************************************************************
  *		gluSphere (GLU32.@)
  */
-extern int gluSphere(void *arg0,double arg1,int arg2,int arg3);
-int WINAPI wine_gluSphere(void *arg0,double arg1,int arg2,int arg3) {
-	return gluSphere(arg0,arg1,arg2,arg3);
+void WINAPI wine_gluSphere(void *arg0,double arg1,int arg2,int arg3) {
+    get_opengl_funcs()->glu.p_gluSphere(arg0,arg1,arg2,arg3);
 }
 
 /***********************************************************************
  *		gluDisk (GLU32.@)
  */
-extern int gluDisk(void *arg0,double arg1,double arg2,int arg3,int arg4);
-int WINAPI wine_gluDisk(void *arg0,double arg1,double arg2,int arg3,int arg4) {
-	return gluDisk(arg0,arg1,arg2,arg3,arg4);
+void WINAPI wine_gluDisk(void *arg0,double arg1,double arg2,int arg3,int arg4) {
+    get_opengl_funcs()->glu.p_gluDisk(arg0,arg1,arg2,arg3,arg4);
 }
 
 /***********************************************************************
  *		gluPartialDisk (GLU32.@)
  */
-extern int gluPartialDisk(void *arg0,double arg1,double arg2,int arg3,int arg4,double arg5,double arg6);
-int WINAPI wine_gluPartialDisk(void *arg0,double arg1,double arg2,int arg3,int arg4,double arg5,double arg6) {
-	return gluPartialDisk(arg0,arg1,arg2,arg3,arg4,arg5,arg6);
+void WINAPI wine_gluPartialDisk(void *arg0,double arg1,double arg2,int arg3,int arg4,double arg5,double arg6) {
+    get_opengl_funcs()->glu.p_gluPartialDisk(arg0,arg1,arg2,arg3,arg4,arg5,arg6);
 }
 
 /***********************************************************************
  *		gluNewNurbsRenderer (GLU32.@)
  */
-extern int gluNewNurbsRenderer(void);
-int WINAPI wine_gluNewNurbsRenderer(void) {
-	return gluNewNurbsRenderer();
+void* WINAPI wine_gluNewNurbsRenderer(void) {
+    return get_opengl_funcs()->glu.p_gluNewNurbsRenderer();
 }
 
 /***********************************************************************
  *		gluDeleteNurbsRenderer (GLU32.@)
  */
-extern int gluDeleteNurbsRenderer(void *arg0);
-int WINAPI wine_gluDeleteNurbsRenderer(void *arg0) {
-	return gluDeleteNurbsRenderer(arg0);
+void WINAPI wine_gluDeleteNurbsRenderer(void *arg0) {
+    get_opengl_funcs()->glu.p_gluDeleteNurbsRenderer(arg0);
 }
 
 /***********************************************************************
  *		gluLoadSamplingMatrices (GLU32.@)
  */
-extern int gluLoadSamplingMatrices(void *arg0,void *arg1,void *arg2,void *arg3);
-int WINAPI wine_gluLoadSamplingMatrices(void *arg0,void *arg1,void *arg2,void *arg3) {
-	return gluLoadSamplingMatrices(arg0,arg1,arg2,arg3);
+void WINAPI wine_gluLoadSamplingMatrices(void *arg0,void *arg1,void *arg2,void *arg3) {
+    get_opengl_funcs()->glu.p_gluLoadSamplingMatrices(arg0,arg1,arg2,arg3);
 }
 
 /***********************************************************************
  *		gluNurbsProperty (GLU32.@)
  */
-extern int gluNurbsProperty(void *arg0,int arg1,int arg2);
-int WINAPI wine_gluNurbsProperty(void *arg0,int arg1,int arg2) {
-	return gluNurbsProperty(arg0,arg1,arg2);
+void WINAPI wine_gluNurbsProperty(void *arg0,int arg1,int arg2) {
+    get_opengl_funcs()->glu.p_gluNurbsProperty(arg0,arg1,arg2);
 }
 
 /***********************************************************************
  *		gluGetNurbsProperty (GLU32.@)
  */
-extern int gluGetNurbsProperty(void *arg0,int arg1,void *arg2);
-int WINAPI wine_gluGetNurbsProperty(void *arg0,int arg1,void *arg2) {
-	return gluGetNurbsProperty(arg0,arg1,arg2);
+void WINAPI wine_gluGetNurbsProperty(void *arg0,int arg1,void *arg2) {
+    get_opengl_funcs()->glu.p_gluGetNurbsProperty(arg0,arg1,arg2);
 }
 
 /***********************************************************************
  *		gluBeginCurve (GLU32.@)
  */
-extern int gluBeginCurve(void *arg0);
-int WINAPI wine_gluBeginCurve(void *arg0) {
-	return gluBeginCurve(arg0);
+void WINAPI wine_gluBeginCurve(void *arg0) {
+    get_opengl_funcs()->glu.p_gluBeginCurve(arg0);
 }
 
 /***********************************************************************
  *		gluEndCurve (GLU32.@)
  */
-extern int gluEndCurve(void *arg0);
-int WINAPI wine_gluEndCurve(void *arg0) {
-	return gluEndCurve(arg0);
+void WINAPI wine_gluEndCurve(void *arg0) {
+    get_opengl_funcs()->glu.p_gluEndCurve(arg0);
 }
 
 /***********************************************************************
  *		gluNurbsCurve (GLU32.@)
  */
-extern int gluNurbsCurve(void *arg0,int arg1,void *arg2,int arg3,void *arg4,int arg5,int arg6);
-int WINAPI wine_gluNurbsCurve(void *arg0,int arg1,void *arg2,int arg3,void *arg4,int arg5,int arg6) {
-	return gluNurbsCurve(arg0,arg1,arg2,arg3,arg4,arg5,arg6);
+void WINAPI wine_gluNurbsCurve(void *arg0,int arg1,void *arg2,int arg3,void *arg4,int arg5,int arg6) {
+    get_opengl_funcs()->glu.p_gluNurbsCurve(arg0,arg1,arg2,arg3,arg4,arg5,arg6);
 }
 
 /***********************************************************************
  *		gluBeginSurface (GLU32.@)
  */
-extern int gluBeginSurface(void *arg0);
-int WINAPI wine_gluBeginSurface(void *arg0) {
-	return gluBeginSurface(arg0);
+void WINAPI wine_gluBeginSurface(void *arg0) {
+    get_opengl_funcs()->glu.p_gluBeginSurface(arg0);
 }
 
 /***********************************************************************
  *		gluEndSurface (GLU32.@)
  */
-extern int gluEndSurface(void *arg0);
-int WINAPI wine_gluEndSurface(void *arg0) {
-	return gluEndSurface(arg0);
+void WINAPI wine_gluEndSurface(void *arg0) {
+    get_opengl_funcs()->glu.p_gluEndSurface(arg0);
 }
 
 /***********************************************************************
  *		gluNurbsSurface (GLU32.@)
  */
-extern int gluNurbsSurface(void *arg0,int arg1,void *arg2,int arg3,void *arg4,int arg5,int arg6,void *arg7,int arg8,int arg9,int arg10);
-int WINAPI wine_gluNurbsSurface(void *arg0,int arg1,void *arg2,int arg3,void *arg4,int arg5,int arg6,void *arg7,int arg8,int arg9,int arg10) {
-	return gluNurbsSurface(arg0,arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10);
+void WINAPI wine_gluNurbsSurface(void *arg0,int arg1,void *arg2,int arg3,void *arg4,int arg5,int arg6,void *arg7,int arg8,int arg9,int arg10) {
+    get_opengl_funcs()->glu.p_gluNurbsSurface(arg0,arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10);
 }
 
 /***********************************************************************
  *		gluBeginTrim (GLU32.@)
  */
-extern int gluBeginTrim(void *arg0);
-int WINAPI wine_gluBeginTrim(void *arg0) {
-	return gluBeginTrim(arg0);
+void WINAPI wine_gluBeginTrim(void *arg0) {
+    get_opengl_funcs()->glu.p_gluBeginTrim(arg0);
 }
 
 /***********************************************************************
  *		gluEndTrim (GLU32.@)
  */
-extern int gluEndTrim(void *arg0);
-int WINAPI wine_gluEndTrim(void *arg0) {
-	return gluEndTrim(arg0);
+void WINAPI wine_gluEndTrim(void *arg0) {
+    get_opengl_funcs()->glu.p_gluEndTrim(arg0);
 }
 
 /***********************************************************************
  *		gluPwlCurve (GLU32.@)
  */
-extern int gluPwlCurve(void *arg0,int arg1,void *arg2,int arg3,int arg4);
-int WINAPI wine_gluPwlCurve(void *arg0,int arg1,void *arg2,int arg3,int arg4) {
-	return gluPwlCurve(arg0,arg1,arg2,arg3,arg4);
+void WINAPI wine_gluPwlCurve(void *arg0,int arg1,void *arg2,int arg3,int arg4) {
+    get_opengl_funcs()->glu.p_gluPwlCurve(arg0,arg1,arg2,arg3,arg4);
 }
 
 /***********************************************************************
  *		gluNurbsCallback (GLU32.@)
  */
-extern int gluNurbsCallback(void *arg0,int arg1,void *arg2);
-int WINAPI wine_gluNurbsCallback(void *arg0,int arg1,void *arg2) {
-	return gluNurbsCallback(arg0,arg1,arg2);
+void WINAPI wine_gluNurbsCallback(void *arg0,int arg1,void *arg2) {
+    get_opengl_funcs()->glu.p_gluNurbsCallback(arg0,arg1,arg2);
 }
 
 /***********************************************************************
  *		gluGetString (GLU32.@)
  */
-extern int gluGetString(int arg0);
-int WINAPI wine_gluGetString(int arg0) {
-	return gluGetString(arg0);
+const GLubyte * WINAPI wine_gluGetString(int arg0) {
+    return get_opengl_funcs()->glu.p_gluGetString(arg0);
 }
 
 /***********************************************************************
@@ -367,23 +352,22 @@
     return 0;
 }
 
-extern void *gluNewTess(void);
-extern void gluDeleteTess(void *);
 
 /***********************************************************************
  *		gluNewTess (GLU32.@)
  */
 void * WINAPI wine_gluNewTess(void)
 {
+    const struct opengl_funcs *funcs = get_opengl_funcs();
     void *tess;
     wine_tess_t *ret;
 
-    if((tess = gluNewTess()) == NULL)
+    if((tess = funcs->glu.p_gluNewTess()) == NULL)
        return NULL;
 
     ret = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(*ret));
     if(!ret) {
-        gluDeleteTess(tess);
+        funcs->glu.p_gluDeleteTess(tess);
         return NULL;
     }
     ret->tess = tess;
@@ -396,7 +380,7 @@
 void WINAPI wine_gluDeleteTess(void *tess)
 {
     wine_tess_t *wine_tess = tess;
-    gluDeleteTess(wine_tess->tess);
+    get_opengl_funcs()->glu.p_gluDeleteTess(wine_tess->tess);
     HeapFree(GetProcessHeap(), 0, wine_tess);
     return;
 }
@@ -404,23 +388,21 @@
 /***********************************************************************
  *		gluTessBeginPolygon (GLU32.@)
  */
-extern void gluTessBeginPolygon(void *, void *);
 void WINAPI wine_gluTessBeginPolygon(void *tess, void *polygon_data)
 {
     wine_tess_t *wine_tess = tess;
     wine_tess->polygon_data = polygon_data;
 
-    gluTessBeginPolygon(wine_tess->tess, wine_tess);
+    get_opengl_funcs()->glu.p_gluTessBeginPolygon(wine_tess->tess, wine_tess);
 }
 
 /***********************************************************************
  *		gluTessEndPolygon (GLU32.@)
  */
-extern void gluTessEndPolygon(void *);
 void WINAPI wine_gluTessEndPolygon(void *tess)
 {
     wine_tess_t *wine_tess = tess;
-    gluTessEndPolygon(wine_tess->tess);
+    get_opengl_funcs()->glu.p_gluTessEndPolygon(wine_tess->tess);
 }
 
 
@@ -477,7 +459,6 @@
 /***********************************************************************
  *		gluTessCallback (GLU32.@)
  */
-extern void gluTessCallback(void *,int,void *);
 void WINAPI wine_gluTessCallback(void *tess,int which,void *fn)
 {
     wine_tess_t *wine_tess = tess;
@@ -540,58 +521,53 @@
         ERR("Unknown callback %d\n", which);
         break;
     }
-    gluTessCallback(wine_tess->tess, which, fn);
+    get_opengl_funcs()->glu.p_gluTessCallback(wine_tess->tess, which, fn);
 }
 
 /***********************************************************************
  *		gluTessBeginContour (GLU32.@)
  */
-extern void gluTessBeginContour(void *);
 void WINAPI wine_gluTessBeginContour(void *tess)
 {
     wine_tess_t *wine_tess = tess;
-    gluTessBeginContour(wine_tess->tess);
+    get_opengl_funcs()->glu.p_gluTessBeginContour(wine_tess->tess);
 }
 
 /***********************************************************************
  *		gluTessEndContour (GLU32.@)
  */
-extern void gluTessEndContour(void *);
 void WINAPI wine_gluTessEndContour(void *tess)
 {
     wine_tess_t *wine_tess = tess;
-    gluTessEndContour(wine_tess->tess);
+    get_opengl_funcs()->glu.p_gluTessEndContour(wine_tess->tess);
 }
 
 /***********************************************************************
  *		gluTessVertex (GLU32.@)
  */
-extern void gluTessVertex(void *, void *, void *);
 void WINAPI wine_gluTessVertex(void *tess,void *arg1,void *arg2)
 {
     wine_tess_t *wine_tess = tess;
-    gluTessVertex(wine_tess->tess, arg1, arg2);
+    get_opengl_funcs()->glu.p_gluTessVertex(wine_tess->tess, arg1, arg2);
 }
 
 
 /***********************************************************************
  *		gluTessProperty (GLU32.@)
  */
-extern void gluTessProperty(void *, int, double);
 void WINAPI wine_gluTessProperty(void *tess, int arg1, double arg2)
 {
     wine_tess_t *wine_tess = tess;
-    gluTessProperty(wine_tess->tess, arg1, arg2);
+    get_opengl_funcs()->glu.p_gluTessProperty(wine_tess->tess, arg1, arg2);
 }
 
 /***********************************************************************
  *		gluTessNormal (GLU32.@)
  */
-extern void gluTessNormal(void *, double, double, double);
 void WINAPI wine_gluTessNormal(void *tess, double arg1, double arg2, double arg3)
 {
     wine_tess_t *wine_tess = tess;
-    gluTessNormal(wine_tess->tess, arg1, arg2, arg3);
+    get_opengl_funcs()->glu.p_gluTessNormal(wine_tess->tess, arg1, arg2, arg3);
 }
 
 /***********************************************************************
@@ -601,8 +577,8 @@
 {
     wine_tess_t *wine_tess = tess;
     wine_tess->polygon_data = NULL;
-    gluTessBeginPolygon(wine_tess->tess, wine_tess);
-    gluTessBeginContour(wine_tess->tess);
+    get_opengl_funcs()->glu.p_gluTessBeginPolygon(wine_tess->tess, wine_tess);
+    get_opengl_funcs()->glu.p_gluTessBeginContour(wine_tess->tess);
 }
 
 /***********************************************************************
@@ -611,8 +587,8 @@
 void WINAPI wine_gluEndPolygon(void *tess)
 {
     wine_tess_t *wine_tess = tess;
-    gluTessEndContour(wine_tess->tess);
-    gluTessEndPolygon(wine_tess->tess);
+    get_opengl_funcs()->glu.p_gluTessEndContour(wine_tess->tess);
+    get_opengl_funcs()->glu.p_gluTessEndPolygon(wine_tess->tess);
 }
 
 /***********************************************************************
@@ -621,6 +597,6 @@
 void WINAPI wine_gluNextContour(void *tess, int arg1)
 {
     wine_tess_t *wine_tess = tess;
-    gluTessEndContour(wine_tess->tess);
-    gluTessBeginContour(wine_tess->tess);
+    get_opengl_funcs()->glu.p_gluTessEndContour(wine_tess->tess);
+    get_opengl_funcs()->glu.p_gluTessBeginContour(wine_tess->tess);
 }
diff -Naur wine-2.0a/dlls/glu32/Makefile.in wine-2.0b/dlls/glu32/Makefile.in
--- wine-2.0a/dlls/glu32/Makefile.in	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/glu32/Makefile.in	2017-07-11 20:37:49.000000000 +0100
@@ -1,7 +1,8 @@
 MODULE    = glu32.dll
 IMPORTLIB = glu32
+# CrossOver Hack 10798: Get GLU functions from the gdi32 driver rather than linking against libGLU
+IMPORTS = gdi32
 EXTRAINCL = $(X_CFLAGS)
-EXTRALIBS = -lGLU $(OPENGL_LIBS) $(X_LIBS) $(X_EXTRA_LIBS)
 
 C_SRCS = \
 	glu.c
diff -Naur wine-2.0a/dlls/ieframe/ieframe.h wine-2.0b/dlls/ieframe/ieframe.h
--- wine-2.0a/dlls/ieframe/ieframe.h	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/ieframe/ieframe.h	2017-07-11 20:37:49.000000000 +0100
@@ -188,6 +188,7 @@
     LONG ref;
 
     INT version;
+    DWORD tid;
 
     IOleClientSite *client;
     IOleClientSite *client_closed;
@@ -285,6 +286,7 @@
 void update_navigation_commands(DocHost *dochost) DECLSPEC_HIDDEN;
 
 #define WM_DOCHOSTTASK (WM_USER+0x300)
+#define WM_GETMARSHALEDDOC (WM_USER+0x400)
 void push_dochost_task(DocHost*,task_header_t*,task_proc_t,task_destr_t,BOOL) DECLSPEC_HIDDEN;
 void abort_dochost_tasks(DocHost*,task_proc_t) DECLSPEC_HIDDEN;
 LRESULT process_dochost_tasks(DocHost*) DECLSPEC_HIDDEN;
diff -Naur wine-2.0a/dlls/ieframe/iexplore.c wine-2.0b/dlls/ieframe/iexplore.c
--- wine-2.0a/dlls/ieframe/iexplore.c	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/ieframe/iexplore.c	2017-07-11 20:37:49.000000000 +0100
@@ -51,8 +51,9 @@
 static const WCHAR szIEWinFrame[] = { 'I','E','F','r','a','m','e',0 };
 
 /* Windows uses "Microsoft Internet Explorer" */
+/* CrossOver: We use "CrossOver Web Browser" */
 static const WCHAR wszWineInternetExplorer[] =
-        {'W','i','n','e',' ','I','n','t','e','r','n','e','t',' ','E','x','p','l','o','r','e','r',0};
+    {'C','r','o','s','s','O','v','e','r',' ','W','e','b',' ','B','r','o','w','s','e','r',0};
 
 static LONG obj_cnt;
 static DWORD dde_inst;
diff -Naur wine-2.0a/dlls/ieframe/intshcut.c wine-2.0b/dlls/ieframe/intshcut.c
--- wine-2.0a/dlls/ieframe/intshcut.c	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/ieframe/intshcut.c	2017-07-11 20:37:49.000000000 +0100
@@ -93,6 +93,9 @@
     WCHAR app[MAX_PATH];
     void *redir;
 
+    if (getenv("CX_NO_WINESHELLLINK"))
+        return TRUE;
+
     GetSystemDirectoryW( app, MAX_PATH - sizeof(menubuilder)/sizeof(WCHAR) );
     strcatW( app, menubuilder );
 
diff -Naur wine-2.0a/dlls/ieframe/oleobject.c wine-2.0b/dlls/ieframe/oleobject.c
--- wine-2.0a/dlls/ieframe/oleobject.c	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/ieframe/oleobject.c	2017-07-11 20:37:49.000000000 +0100
@@ -89,6 +89,42 @@
     case WM_KILLFOCUS:
         notify_on_focus(This, FALSE);
         break;
+    /* CX HACK 11688: Return marshaled MSHTML document if requested from wrong thread. */
+    case WM_GETMARSHALEDDOC: {
+        IStream **ret = (IStream**)lParam, *stream;
+        LARGE_INTEGER offset;
+        IDispatch *disp;
+        HRESULT hres;
+
+        TRACE("WM_GETMARSHALEDDOC\n");
+
+        *ret = NULL;
+        if(!This->doc_host.document)
+            return 0;
+
+        hres = IUnknown_QueryInterface(This->doc_host.document, &IID_IDispatch, (void**)&disp);
+        if(FAILED(hres))
+            return hres;
+
+        hres = CreateStreamOnHGlobal(NULL, TRUE, &stream);
+        if(FAILED(hres)) {
+            IDispatch_Release(disp);
+            return 0;
+        }
+
+        hres = CoMarshalInterface(stream, &IID_IDispatch, (IUnknown*)disp, MSHCTX_INPROC, NULL, MSHLFLAGS_NORMAL);
+        IDispatch_Release(disp);
+        if(FAILED(hres)) {
+            IStream_Release(stream);
+            return 0;
+        }
+
+        offset.QuadPart = 0;
+        IStream_Seek(stream, offset, STREAM_SEEK_SET, NULL);
+
+        *ret = stream;
+        return 0;
+    }
     }
 
     return DefWindowProcW(hwnd, msg, wParam, lParam);
diff -Naur wine-2.0a/dlls/ieframe/webbrowser.c wine-2.0b/dlls/ieframe/webbrowser.c
--- wine-2.0a/dlls/ieframe/webbrowser.c	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/ieframe/webbrowser.c	2017-07-11 20:37:49.000000000 +0100
@@ -366,6 +366,28 @@
             if(SUCCEEDED(hres)) {
                 IDispatch_Release(disp);
                 disp = html_doc;
+
+                /* CX HACK 11688: Return marshaled MSHTML document if requested from wrong thread. */
+                if(This->tid != GetCurrentThreadId() && This->shell_embedding_hwnd) {
+                    IStream *stream = NULL;
+
+                    FIXME("HACK! Document interface requested from wrong object.\n");
+
+                    SendMessageW(This->shell_embedding_hwnd, WM_GETMARSHALEDDOC, 0, (LPARAM)&stream);
+                    if(stream) {
+                        IDispatch *mdisp;
+                        HRESULT init_hres;
+
+                        init_hres = CoInitialize(NULL);
+                        hres = CoUnmarshalInterface(stream, &IID_IDispatch, (void**)&mdisp);
+                        if(SUCCEEDED(init_hres))
+                            CoUninitialize();
+                        if(SUCCEEDED(hres)) {
+                            IDispatch_Release(disp);
+                            disp = mdisp;
+                        }
+                    }
+                }
             }
         }
     }
@@ -1237,6 +1259,7 @@
     ret->IServiceProvider_iface.lpVtbl = &ServiceProviderVtbl;
     ret->ref = 1;
     ret->version = version;
+    ret->tid = GetCurrentThreadId();
 
     DocHost_Init(&ret->doc_host, &ret->IWebBrowser2_iface, &DocHostContainerVtbl);
 
diff -Naur wine-2.0a/dlls/ieinfo5.ocx/ieinfo5.ocx.spec wine-2.0b/dlls/ieinfo5.ocx/ieinfo5.ocx.spec
--- wine-2.0a/dlls/ieinfo5.ocx/ieinfo5.ocx.spec	1970-01-01 01:00:00.000000000 +0100
+++ wine-2.0b/dlls/ieinfo5.ocx/ieinfo5.ocx.spec	2017-07-11 20:37:49.000000000 +0100
@@ -0,0 +1,5 @@
+1 stdcall DllCanUnloadNow()
+2 stdcall DllGetClassObject(ptr ptr ptr)
+3 stdcall DllRegisterServer()
+4 stdcall DllUnregisterServer()
+5 stub GetTemplate
diff -Naur wine-2.0a/dlls/ieinfo5.ocx/main.c wine-2.0b/dlls/ieinfo5.ocx/main.c
--- wine-2.0a/dlls/ieinfo5.ocx/main.c	1970-01-01 01:00:00.000000000 +0100
+++ wine-2.0b/dlls/ieinfo5.ocx/main.c	2017-07-11 20:37:49.000000000 +0100
@@ -0,0 +1,82 @@
+/*
+ * Copyright 2003 Mike McCormack for CodeWeavers
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include "config.h"
+
+#include <stdarg.h>
+
+#include "windef.h"
+#include "winbase.h"
+#include "winerror.h"
+#include "winreg.h"
+#include "winuser.h"
+
+#include "ole2.h"
+#include "olectl.h"
+
+#include "shlwapi.h"
+
+#include "wine/debug.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(ieinfo);
+
+HRESULT WINAPI DllGetVersion(DLLVERSIONINFO *pdvi)
+{
+    TRACE("%p\n",pdvi);
+
+    if (pdvi->cbSize != sizeof(DLLVERSIONINFO))
+        return E_INVALIDARG;
+
+    pdvi->dwMajorVersion = 5;
+    pdvi->dwMinorVersion = 0;
+    pdvi->dwBuildNumber = 0;
+    pdvi->dwPlatformID = 1;
+
+    return S_OK;
+}
+
+HRESULT WINAPI DllGetClassObject(REFCLSID rclsid, REFIID iid,LPVOID *ppv)
+{
+    FIXME("stub\n");
+    return CLASS_E_CLASSNOTAVAILABLE;
+}
+
+
+/***********************************************************************
+ *		DllRegisterServer (IEINFO5.@)
+ */
+HRESULT WINAPI DllRegisterServer(void)
+{
+    FIXME("stub\n");
+    return S_OK;
+}
+
+/***********************************************************************
+ *		DllUnregisterServer (IEINFO5.@)
+ */
+HRESULT WINAPI DllUnregisterServer(void)
+{
+    FIXME("stub\n");
+    return S_OK;
+}
+
+HRESULT WINAPI DllCanUnloadNow(void)
+{
+    return S_FALSE;
+}
+
diff -Naur wine-2.0a/dlls/ieinfo5.ocx/Makefile.in wine-2.0b/dlls/ieinfo5.ocx/Makefile.in
--- wine-2.0a/dlls/ieinfo5.ocx/Makefile.in	1970-01-01 01:00:00.000000000 +0100
+++ wine-2.0b/dlls/ieinfo5.ocx/Makefile.in	2017-07-11 20:37:49.000000000 +0100
@@ -0,0 +1,6 @@
+EXTRADEFS = -DCOM_NO_WINDOWS_H
+MODULE    = ieinfo5.ocx
+IMPORTS   = uuid ole32 user32 advapi32
+
+C_SRCS = \
+	main.c
diff -Naur wine-2.0a/dlls/iernonce/iernonce.c wine-2.0b/dlls/iernonce/iernonce.c
--- wine-2.0a/dlls/iernonce/iernonce.c	1970-01-01 01:00:00.000000000 +0100
+++ wine-2.0b/dlls/iernonce/iernonce.c	2017-07-11 20:37:49.000000000 +0100
@@ -0,0 +1,418 @@
+/*
+ * Implementation of the iernonce.dll
+ *
+ * Copyright 2005 Aric Stewart for CodeWeavers
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include "windef.h"
+#include "wine/debug.h"
+#include "winbase.h"
+#include "winnt.h"
+#include "winuser.h"
+#include "winreg.h"
+#include "wine/unicode.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(iernonce);
+
+typedef struct {
+    HKEY key;
+    LPWSTR name;
+    DWORD position;
+} ordered_key;
+
+typedef struct {
+    ordered_key* key;
+    DWORD   count;
+    HKEY    base_key;
+} ordered_sections;
+
+typedef struct {
+    LPWSTR value;
+    LPWSTR name;
+    DWORD position;
+} ordered_value;
+
+typedef struct {
+    ordered_value* value;
+    DWORD   count;
+    HKEY    base_key;
+} ordered_values;
+
+
+BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)
+{
+	TRACE("(0x%p, %d, %p)\n",hinstDLL,fdwReason,lpvReserved);
+
+	if (fdwReason == DLL_PROCESS_ATTACH)
+	{
+		/* FIXME: Initialisation */
+	}
+	else if (fdwReason == DLL_PROCESS_DETACH)
+	{
+		/* FIXME: Cleanup */
+	}
+
+	return TRUE;
+}
+
+static void init_ordered_sections(ordered_sections *sections)
+{
+    sections->count = 0;
+    sections->key= NULL;
+}
+
+static void init_ordered_values(ordered_values *values)
+{
+    values->count = 0;
+    values->value = NULL;
+}
+
+
+static void close_free_ordered_sections(ordered_sections *sections)
+{
+    INT i;
+    for (i = 0; i < sections->count; i++)
+    {
+        RegCloseKey(sections->key[i].key);
+        HeapFree(GetProcessHeap(),0,sections->key[i].name);
+    }
+    HeapFree(GetProcessHeap(),0,sections->key);
+    init_ordered_sections(sections);
+}
+
+static void free_ordered_values(ordered_values *values)
+{
+    INT i;
+    for (i = 0; i < values->count; i++)
+    {
+        HeapFree(GetProcessHeap(),0,values->value[i].value);
+        HeapFree(GetProcessHeap(),0,values->value[i].name);
+    }
+    HeapFree(GetProcessHeap(),0,values->value);
+    init_ordered_values(values);
+}
+
+static void set_ordered_key(HKEY base_key, ordered_key *newkey, DWORD position,
+        LPCWSTR szName)
+{
+    newkey->position = position;
+    RegOpenKeyW(base_key,szName,&(newkey->key));
+    newkey->name = HeapAlloc(GetProcessHeap(),0,
+            (lstrlenW(szName)+1) * sizeof(WCHAR));
+    strcpyW(newkey->name,szName);
+}
+
+static void set_ordered_value(HKEY base_key, ordered_value *newkey,
+        DWORD position, LPCWSTR szName)
+{
+    DWORD sz = 0;
+    newkey->position = position;
+    newkey->name = HeapAlloc(GetProcessHeap(),0,
+            (lstrlenW(szName)+1) * sizeof(WCHAR));
+    strcpyW(newkey->name,szName);
+    RegQueryValueExW(base_key,szName,NULL,NULL,NULL,&sz);
+    sz ++;
+    newkey->value = HeapAlloc(GetProcessHeap(),0,sz);
+    RegQueryValueExW(base_key,szName,NULL,NULL,(LPBYTE)newkey->value,&sz);
+}
+
+
+static void insert_section(ordered_sections *sections, DWORD index, 
+        DWORD position, LPCWSTR szName)
+{
+    int i;
+    ordered_key* newkeys = HeapAlloc(GetProcessHeap(),0,
+           sizeof(ordered_key)*(sections->count + 1));
+    for (i = 0; i < index; i++)
+        memcpy(&newkeys[i],&sections->key[i],sizeof(ordered_key));
+
+    set_ordered_key(sections->base_key, &newkeys[index],position,szName);
+
+    for (i = index+1; i < sections->count + 1; i++)
+        memcpy(&newkeys[i],&sections->key[i-1],sizeof(ordered_key));
+
+    sections->count ++;
+    HeapFree(GetProcessHeap(),0,sections->key);
+    sections->key = newkeys;
+}
+
+static void insert_value(ordered_values *values, DWORD index, 
+        DWORD position, LPCWSTR szName)
+{
+    int i;
+    ordered_value* newvalues= HeapReAlloc(GetProcessHeap(),0, values->value,
+           sizeof(ordered_value)*(values->count + 1));
+
+    for (i = index+1; i < values->count + 1; i++)
+        memcpy(&newvalues[i],&values->value[i-1],sizeof(ordered_value));
+
+    set_ordered_value(values->base_key, &newvalues[index],position,szName);
+
+    values->count ++;
+    values->value= newvalues;
+}
+
+
+
+static void append_section(ordered_sections *sections, DWORD position, 
+        LPCWSTR szName)
+{
+    ordered_key* newkeys;
+    if (sections->count > 0)
+        newkeys = HeapReAlloc(GetProcessHeap(),0, sections->key,
+           sizeof(ordered_key)*(sections->count + 1));
+    else
+        newkeys = HeapAlloc(GetProcessHeap(),0,sizeof(ordered_key));
+
+    set_ordered_key(sections->base_key, &newkeys[sections->count],position,
+            szName);
+
+    sections->count ++;
+    sections->key = newkeys;
+}
+
+static void append_value(ordered_values *values, DWORD position, 
+        LPCWSTR szName)
+{
+    ordered_value* newvalues;
+    if (values->count > 0)
+        newvalues= HeapReAlloc(GetProcessHeap(),0, values->value,
+           sizeof(ordered_value)*(values->count + 1));
+    else
+        newvalues= HeapAlloc(GetProcessHeap(),0,sizeof(ordered_value));
+
+    set_ordered_value(values->base_key, &newvalues[values->count],position,
+            szName);
+
+    values->count ++;
+    values->value= newvalues;
+}
+
+
+static void build_ordered_sections(HKEY hkey, ordered_sections *sections)
+{
+    INT index = 0;
+    DWORD rc;
+    WCHAR szName[10];
+
+    sections->base_key = hkey;
+
+    rc = RegEnumKeyW(hkey,index,szName,10);
+    while (rc == ERROR_SUCCESS)
+    {
+        int i;
+        DWORD position = strtolW(szName,NULL,10);
+        for (i = 0; i < sections->count; i++)
+        {
+            if (sections->key[i].position > position)
+            {
+                insert_section(sections,i,position,szName);
+                break;
+            }
+        }
+        if (i == sections->count)
+            append_section(sections,position,szName);
+
+        index ++;
+        rc = RegEnumKeyW(hkey,index,szName,10);
+    }
+}
+
+static void build_ordered_values(HKEY hkey, ordered_values *values)
+{
+    INT index = 0;
+    DWORD rc;
+    DWORD sz;
+    WCHAR szName[10];
+
+    values->base_key = hkey;
+
+    sz = 10;
+    rc = RegEnumValueW(hkey,index,szName,&sz,NULL,NULL,NULL,NULL);
+    while (rc == ERROR_SUCCESS)
+    {
+        int i;
+        DWORD position;
+        if (!szName[0])
+        {
+            index ++;
+            sz = 10;
+            rc = RegEnumValueW(hkey,index,szName,&sz,NULL,NULL,NULL,NULL);
+        }
+        position = strtolW(szName,NULL,10);
+        for (i = 0; i < values->count; i++)
+        {
+            if (values->value[i].position > position)
+            {
+                insert_value(values,i,position,szName);
+                break;
+            }
+        }
+        if (i == values->count)
+            append_value(values,position,szName);
+
+        index ++;
+        sz = 10;
+        rc = RegEnumValueW(hkey,index,szName,&sz,NULL,NULL,NULL,NULL);
+    }
+}
+
+static BOOL run_process( LPWSTR command)
+{
+    STARTUPINFOW si;
+    PROCESS_INFORMATION info;
+    BOOL rc;
+    static const WCHAR c_collen[] = {'C',':','\\',0};
+
+    memset(&si,0,sizeof(STARTUPINFOW));
+    memset(&info,0,sizeof(PROCESS_INFORMATION));
+
+    rc = CreateProcessW(NULL, command, NULL, NULL, FALSE, 0, NULL, c_collen,
+            &si, &info);
+
+    if ( !rc )
+        return FALSE;
+    WaitForSingleObject(info.hProcess,INFINITE);
+
+    return TRUE;
+}
+
+static void process_command(LPCWSTR command)
+{
+    LPWSTR execution_command = NULL;
+
+    TRACE("Process command %s\n",debugstr_w(command));
+
+    if ((command[0]=='|' && command[1] == '|') || ! strchrW(command,'|'))
+    {
+        /* run a direct command */
+        LPCWSTR ptr = command;
+        while(*ptr == '|')
+            ptr ++;
+        execution_command = HeapAlloc(GetProcessHeap(),0,
+               (lstrlenW(ptr)+1)* sizeof(WCHAR));
+        strcpyW(execution_command,ptr);
+    }
+    else
+    {
+        /* run a function from a dll file */
+        LPWSTR buff;
+
+        LPWSTR dll = NULL;
+        LPWSTR function = NULL;
+        LPWSTR arguments = NULL;
+        DWORD command_len;
+        static const WCHAR rundll[] = {'r','u','n','d','l','l','3','2','.','e','x','e',' ','\"','%','s','\"',',','%','s',' ','%','s',0};
+        static const WCHAR rundll_noArg[] = {'r','u','n','d','l','l','3','2','.','e','x','e',' ','\"','%','s','\"',',','%','s',0};
+
+        command_len = lstrlenW(command);
+        command_len += lstrlenW(rundll);
+
+        buff = HeapAlloc(GetProcessHeap(),0,(lstrlenW(command)+1) * sizeof(WCHAR));
+        strcpyW(buff,command);
+        dll = buff;
+        function = strchrW(dll,'|');
+        if (function)
+        {
+            *function = '\0';
+            function ++;
+
+            arguments = strchrW(function,'|');
+            if (arguments)
+            {
+                *arguments = '\0';
+                arguments ++;
+            }
+        }
+
+        execution_command = HeapAlloc(GetProcessHeap(),0,
+               command_len * sizeof(WCHAR));
+        if (arguments)
+            sprintfW(execution_command, rundll,dll,function,arguments);
+        else
+            sprintfW(execution_command, rundll_noArg,dll,function);
+        HeapFree(GetProcessHeap(),0,buff);
+    }
+
+    TRACE("Execution command is %s\n",debugstr_w(execution_command));
+    run_process(execution_command);
+
+    HeapFree(GetProcessHeap(),0,execution_command);
+}
+
+static void process_runonceex_section(ordered_key *section)
+{
+    int i;
+    ordered_values values;
+
+    init_ordered_values(&values);
+    build_ordered_values(section->key,&values);
+
+    for (i = 0; i < values.count; i++)
+    {
+        process_command(values.value[i].value);
+        RegDeleteValueW(section->key,values.value[i].name);
+    }
+
+    free_ordered_values(&values);
+}
+
+VOID WINAPI RunOnceExProcess( VOID )
+{
+    HKEY hkey;
+    DWORD rc;
+    DWORD index = 0;
+    ordered_sections sections;
+
+    static const WCHAR szRunOnceKey[] = {'S','o','f','t','w','a','r','e','\\','M','i','c','r','o','s','o','f','t','\\','W','i','n','d','o','w','s','\\','C','u','r','r','e','n','t','V','e','r','s','i','o','n','\\','R','u','n','O','n','c','e','E','x',0};
+    
+    FIXME("Really really basic implementation\n");
+
+    rc = RegOpenKeyW(HKEY_LOCAL_MACHINE,szRunOnceKey,&hkey);
+    if (rc != ERROR_SUCCESS)
+    {
+        TRACE("No RunOnceEx key\n");
+        return;
+    }
+
+    init_ordered_sections(&sections);
+    build_ordered_sections(hkey,&sections);
+    
+    for (index = 0; index < sections.count; index ++)
+    {
+        LPWSTR title = NULL;
+        DWORD sz = 0;
+        TRACE("Section %i\n",sections.key[index].position);
+        RegQueryValueExW(sections.key[index].key,NULL,NULL,NULL,NULL,&sz);
+        if (sz > 0)
+        {
+            title = HeapAlloc(GetProcessHeap(),0,sz);
+            RegQueryValueExW(sections.key[index].key,NULL,NULL,NULL,
+                    (LPBYTE)title, &sz);
+        }
+        if (title)
+            TRACE("Processing Section %s\n",debugstr_w(title));
+
+        process_runonceex_section(&sections.key[index]);
+        RegDeleteKeyW(sections.base_key,sections.key[index].name);
+            
+        HeapFree(GetProcessHeap(),0,title);
+    }
+   
+    close_free_ordered_sections(&sections);
+    RegCloseKey(hkey);
+}
diff -Naur wine-2.0a/dlls/iernonce/iernonce.spec wine-2.0b/dlls/iernonce/iernonce.spec
--- wine-2.0a/dlls/iernonce/iernonce.spec	1970-01-01 01:00:00.000000000 +0100
+++ wine-2.0b/dlls/iernonce/iernonce.spec	2017-07-11 20:37:49.000000000 +0100
@@ -0,0 +1,2 @@
+1 stub InitCallback
+2 stdcall RunOnceExProcess()
diff -Naur wine-2.0a/dlls/iernonce/Makefile.in wine-2.0b/dlls/iernonce/Makefile.in
--- wine-2.0a/dlls/iernonce/Makefile.in	1970-01-01 01:00:00.000000000 +0100
+++ wine-2.0b/dlls/iernonce/Makefile.in	2017-07-11 20:37:49.000000000 +0100
@@ -0,0 +1,5 @@
+MODULE    = iernonce.dll
+IMPORTS   = advapi32
+
+C_SRCS = \
+	iernonce.c
diff -Naur wine-2.0a/dlls/iphlpapi/iphlpapi_main.c wine-2.0b/dlls/iphlpapi/iphlpapi_main.c
--- wine-2.0a/dlls/iphlpapi/iphlpapi_main.c	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/iphlpapi/iphlpapi_main.c	2017-07-11 20:37:49.000000000 +0100
@@ -33,6 +33,9 @@
 #ifdef HAVE_ARPA_NAMESER_H
 # include <arpa/nameser.h>
 #endif
+#ifdef HAVE_DLFCN_H
+# include <dlfcn.h>
+#endif
 #ifdef HAVE_RESOLV_H
 # include <resolv.h>
 #endif
@@ -1305,17 +1308,29 @@
 
 static int get_dns_servers( SOCKADDR_STORAGE *servers, int num, BOOL ip4_only )
 {
-    extern struct res_state *__res_get_state( void );
-    extern int __res_getservers( struct res_state *, struct sockaddr_storage *, int );
-    struct res_state *state = __res_get_state();
-    int i, found = 0, total = __res_getservers( state, NULL, 0 );
+    struct res_state * (*p__res_get_state)( void );
+    int (*p__res_getservers)( struct res_state *, struct sockaddr_storage *, int );
+    struct res_state *state;
+    int i, found = 0, total;
     SOCKADDR_STORAGE *addr = servers;
     struct sockaddr_storage *buf;
 
+    p__res_get_state = dlsym( RTLD_DEFAULT, "__res_get_state" );
+    p__res_getservers = dlsym( RTLD_DEFAULT, "__res_getservers" );
+
+    if (!p__res_get_state || !p__res_getservers)
+    {
+        WARN( "__res_get_state or __res_getservers functions are missing\n" );
+        return 0;
+    }
+
+    state = p__res_get_state();
+    total = p__res_getservers( state, NULL, 0 );
+
     if ((!servers || !num) && !ip4_only) return total;
 
     buf = HeapAlloc( GetProcessHeap(), 0, total * sizeof(struct sockaddr_storage) );
-    total = __res_getservers( state, buf, total );
+    total = p__res_getservers( state, buf, total );
 
     for (i = 0; i < total; i++)
     {
diff -Naur wine-2.0a/dlls/kernel32/kernel_main.c wine-2.0b/dlls/kernel32/kernel_main.c
--- wine-2.0a/dlls/kernel32/kernel_main.c	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/kernel32/kernel_main.c	2017-07-11 20:37:49.000000000 +0100
@@ -107,6 +107,8 @@
 
         if (LdrFindEntryForAddress( GetModuleHandleW( 0 ), &ldr ) || !(ldr->Flags & LDR_WINE_INTERNAL))
             LoadLibraryA( "krnl386.exe16" );
+        /* Codeweavers hack: native crypt32 installed by IE6 is buggy (bug 5259) */
+        set_entry_point( module, "RegisterWaitForSingleObjectEx", 0 );
     }
 
     /* finish the process initialisation for console bits, if needed */
diff -Naur wine-2.0a/dlls/kernel32/locale.c wine-2.0b/dlls/kernel32/locale.c
--- wine-2.0a/dlls/kernel32/locale.c	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/kernel32/locale.c	2017-07-11 20:37:49.000000000 +0100
@@ -359,6 +359,18 @@
     return 0;
 }
 
+static WORD get_default_sublang(LCID lang)
+{
+    switch (PRIMARYLANGID(lang))
+    {
+    case LANG_SPANISH:
+        return SUBLANG_SPANISH_MODERN;
+    case LANG_CHINESE:
+        return SUBLANG_CHINESE_SIMPLIFIED;
+    default:
+        return SUBLANG_DEFAULT;
+    }
+}
 
 /***********************************************************************
  *           find_locale_id_callback
@@ -378,7 +390,7 @@
         GetLocaleInfoW( lcid, LOCALE_SNAME | LOCALE_NOUSEROVERRIDE,
                         buffer, sizeof(buffer)/sizeof(WCHAR) ))
     {
-        if (!strcmpW( data->win_name, buffer ))
+        if (!strcmpiW( data->win_name, buffer ))
         {
             matches = 4;  /* everything matches */
             goto done;
@@ -388,7 +400,7 @@
     if (!GetLocaleInfoW( lcid, LOCALE_SISO639LANGNAME | LOCALE_NOUSEROVERRIDE,
                          buffer, sizeof(buffer)/sizeof(WCHAR) ))
         return TRUE;
-    if (strcmpW( buffer, data->lang )) return TRUE;
+    if (strcmpiW( buffer, data->lang )) return TRUE;
     matches++;  /* language name matched */
 
     if (data->country)
@@ -396,13 +408,13 @@
         if (GetLocaleInfoW( lcid, LOCALE_SISO3166CTRYNAME|LOCALE_NOUSEROVERRIDE,
                             buffer, sizeof(buffer)/sizeof(WCHAR) ))
         {
-            if (strcmpW( buffer, data->country )) goto done;
+            if (strcmpiW( buffer, data->country )) goto done;
             matches++;  /* country name matched */
         }
     }
     else  /* match default language */
     {
-        if (SUBLANGID(LangID) == SUBLANG_DEFAULT) matches++;
+        if (SUBLANGID(LangID) == get_default_sublang( LangID )) matches++;
     }
 
     if (data->codepage)
@@ -1671,7 +1683,7 @@
 
     /* replace SUBLANG_NEUTRAL by SUBLANG_DEFAULT */
     if (SUBLANGID(lang_id) == SUBLANG_NEUTRAL)
-        lang_id = MAKELANGID(PRIMARYLANGID(lang_id), SUBLANG_DEFAULT);
+        lang_id = MAKELANGID(PRIMARYLANGID(lang_id), get_default_sublang( lang_id ));
 
     if (!(hrsrc = FindResourceExW( kernel32_handle, (LPWSTR)RT_STRING,
                                    ULongToPtr((lctype >> 4) + 1), lang_id )))
@@ -2634,6 +2646,10 @@
                                     defchar, used ? &used_tmp : NULL );
             break;
         }
+#ifdef __APPLE__
+        /* CodeWeavers HACK */
+        flags |= WC_COMPOSITECHECK;
+#endif
         /* fall through */
     case CP_UTF8:
         if (defchar || used)
@@ -2776,7 +2792,7 @@
         langid = LANGIDFROMLCID(lcid);
         if (SUBLANGID(langid) == SUBLANG_NEUTRAL)
         {
-          langid = MAKELANGID(PRIMARYLANGID(langid), SUBLANG_DEFAULT);
+          langid = MAKELANGID(PRIMARYLANGID(langid), get_default_sublang( langid ));
           lcid = MAKELCID(langid, SORTIDFROMLCID(lcid));
         }
     }
@@ -4212,7 +4228,7 @@
     langId = GetSystemDefaultLangID();
 
     if (SUBLANGID(langId) == SUBLANG_NEUTRAL)
-        langId = MAKELANGID( PRIMARYLANGID(langId), SUBLANG_DEFAULT );
+        langId = MAKELANGID(PRIMARYLANGID(langId), get_default_sublang( langId ));
 
     hResource = FindResourceExW( kernel32_handle, (LPWSTR)RT_STRING, szResourceName, langId );
 
diff -Naur wine-2.0a/dlls/kernel32/module.c wine-2.0b/dlls/kernel32/module.c
--- wine-2.0a/dlls/kernel32/module.c	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/kernel32/module.c	2017-07-11 20:37:49.000000000 +0100
@@ -923,6 +923,16 @@
 
     load_path = MODULE_get_dll_load_path( flags & LOAD_WITH_ALTERED_SEARCH_PATH ? libname->Buffer : NULL );
 
+    /*
+     * CXHACK 14391: Click2Run depends on flags & LOAD_LIBRARY_AS_IMAGE_RESOURCE. We ignore
+     * LOAD_LIBRARY_AS_IMAGE_RESOURCE as using LdrLoadDll works fine in this case.
+     */
+    if (flags & LOAD_LIBRARY_AS_IMAGE_RESOURCE)
+    {
+        FIXME("CXHACK: LOAD_LIBRARY_AS_IMAGE_RESOURCE flag.\n");
+        flags &= ~LOAD_LIBRARY_AS_DATAFILE;
+    }
+
     if (flags & LOAD_LIBRARY_AS_DATAFILE)
     {
         ULONG_PTR magic;
diff -Naur wine-2.0a/dlls/kernel32/nls/esn.nls wine-2.0b/dlls/kernel32/nls/esn.nls
--- wine-2.0a/dlls/kernel32/nls/esn.nls	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/kernel32/nls/esn.nls	2017-07-11 20:37:49.000000000 +0100
@@ -123,7 +123,7 @@
   LOCALE_SMONTHNAME12 "diciembre"
   LOCALE_SMONTHNAME13 ""
   LOCALE_SMONTHOUSANDSEP "."
-  LOCALE_SNAME "es-ES_modern"
+  LOCALE_SNAME "es-ES"
   LOCALE_SNATIVECTRYNAME "EspaÃ±a"
   LOCALE_SNATIVECURRNAME "euro"
   LOCALE_SNATIVEDIGITS "0123456789"
diff -Naur wine-2.0a/dlls/kernel32/nls/esp.nls wine-2.0b/dlls/kernel32/nls/esp.nls
--- wine-2.0a/dlls/kernel32/nls/esp.nls	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/kernel32/nls/esp.nls	2017-07-11 20:37:49.000000000 +0100
@@ -123,7 +123,7 @@
   LOCALE_SMONTHNAME12 "diciembre"
   LOCALE_SMONTHNAME13 ""
   LOCALE_SMONTHOUSANDSEP "."
-  LOCALE_SNAME "es-ES"
+  LOCALE_SNAME "es-ES_tradnl"
   LOCALE_SNATIVECTRYNAME "EspaÃ±a"
   LOCALE_SNATIVECURRNAME "euro"
   LOCALE_SNATIVEDIGITS "0123456789"
diff -Naur wine-2.0a/dlls/kernel32/path.c wine-2.0b/dlls/kernel32/path.c
--- wine-2.0a/dlls/kernel32/path.c	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/kernel32/path.c	2017-07-11 20:37:49.000000000 +0100
@@ -1990,7 +1990,20 @@
  */
 BOOLEAN WINAPI CreateSymbolicLinkW(LPCWSTR link, LPCWSTR target, DWORD flags)
 {
+    char name[MAX_PATH], *p;
+
     FIXME("(%s %s %d): stub\n", debugstr_w(link), debugstr_w(target), flags);
+
+    /* CXHACK 13427 */
+    GetModuleFileNameA(GetModuleHandleA(NULL), name, sizeof(name));
+    p = strrchr(name, '\\');
+    p = p ? p+1 : name;
+    if(!strcasecmp(p, "OfficeClickToRun.exe"))
+    {
+        FIXME("CXHACK 13427: Using CopyFile\n");
+        return CopyFileW(target, link, FALSE);
+    }
+
     return TRUE;
 }
 
diff -Naur wine-2.0a/dlls/kernel32/process.c wine-2.0b/dlls/kernel32/process.c
--- wine-2.0a/dlls/kernel32/process.c	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/kernel32/process.c	2017-07-11 20:37:49.000000000 +0100
@@ -27,6 +27,7 @@
 #include <signal.h>
 #include <stdarg.h>
 #include <stdio.h>
+#include <stdint.h>
 #include <time.h>
 #ifdef HAVE_SYS_TIME_H
 # include <sys/time.h>
@@ -44,6 +45,9 @@
 #ifdef HAVE_SYS_WAIT_H
 # include <sys/wait.h>
 #endif
+#ifdef HAVE_SYS_UN_H
+# include <sys/un.h>
+#endif
 #ifdef HAVE_UNISTD_H
 # include <unistd.h>
 #endif
@@ -1297,6 +1301,25 @@
         ExitProcess( error );
     }
 
+    /*  CodeWeavers hack on top of the wait-children hack */
+    {
+        const char *child_pipe = getenv("WINE_WAIT_CHILD_PIPE");
+        const char *ignore_child = getenv("WINE_WAIT_CHILD_PIPE_IGNORE");
+        if (child_pipe && ignore_child)
+        {
+            WCHAR ignore[MAX_PATH];
+            MultiByteToWideChar( CP_UNIXCP, 0, ignore_child, -1, ignore, MAX_PATH );
+            if ((p = strrchrW( main_exe_name, '\\' ))) p++;
+            else p = main_exe_name;
+            if (!strcmpiW( p, ignore ))
+            {
+                int fd = atoi(child_pipe);
+                if (fd) close( fd );
+                unsetenv("WINE_WAIT_CHILD_PIPE");
+            }
+        }
+    }
+
     if (!params->CurrentDirectory.Handle) chdir("/"); /* avoid locking removable devices */
 
     LdrInitializeThunk( start_process, 0, 0, 0 );
@@ -1841,6 +1864,329 @@
 }
 #endif
 
+
+/* CrossOver Hack 10523: shunt the loading to CrossOver */
+enum { /* must match definitions in Mac app code (WineLoader.m) */
+    REQUEST_LOAD_WINE = 0x52c17355,
+    RESPONSE_SUCCESS,
+    REQUEST_LOAD_WINE_64BIT,
+};
+
+static BOOL write_data(int sock, const void *buffer, size_t length)
+{
+    const char* p = buffer;
+    while (length)
+    {
+        ssize_t rc = write(sock, p, length);
+        if (rc > 0)
+        {
+            p += rc;
+            length -= rc;
+        }
+        else if (errno != EINTR)
+        {
+            WARN("failed to write data; errno %d\n", errno);
+            return FALSE;
+        }
+    }
+
+    return TRUE;
+}
+
+static BOOL write_length_prefixed_buffer(int sock, const void *buffer, uint64_t length)
+{
+    if (!write_data(sock, &length, sizeof(length)))
+        return FALSE;
+
+    if (!write_data(sock, buffer, length))
+        return FALSE;
+
+    return TRUE;
+}
+
+static BOOL read_data(int sock, void *buffer, size_t length)
+{
+    char* p = buffer;
+    while (length > 0)
+    {
+        int rc = read(sock, p, length);
+        if (rc > 0)
+        {
+            p += rc;
+            length -= rc;
+        }
+        else if (rc == 0 || errno != EINTR)
+            return FALSE;
+    }
+
+    return TRUE;
+}
+
+static BOOL send_to_cx_loader(const char *loader, char **argv, unsigned int flags, int wineserversocket,
+                              int stdin_fd, int stdout_fd, const char *unixdir, char *winedebug,
+                              const struct binary_info *binary_info, const char* wineloader)
+{
+    /* HKCU\Software\CrossOver\SuppressAltLoader */
+    static const WCHAR suppress_key[] = {'S','o','f','t','w','a','r','e','\\',
+                                         'C','r','o','s','s','O','v','e','r','\\',
+                                         'S','u','p','p','r','e','s','s','A','l','t','L','o','a','d','e','r',0};
+    BOOL ret = FALSE;
+    const char *socket_path;
+    int sock = -1;
+    struct sockaddr_un sa;
+    ssize_t rc;
+    uint32_t request_type;
+    char **elem;
+    uint64_t length;
+    uint8_t dummy;
+    struct iovec iov;
+    struct msghdr msg;
+    struct {
+        struct cmsghdr hdr;
+        int fds[5]; // standard in, out, and error, wineserver socket, and WINE_WAIT_CHILD_PIPE
+    } cmsg;
+    int nullfd = -1;
+    const char* wait_child_pipe;
+    uint32_t response;
+
+    TRACE("loader %s flags 0x%08x wineserversocket %d stdin_fd %d stdout_fd %d unixdir %s winedebug %s wineloader %s\n",
+          debugstr_a(loader), flags, wineserversocket, stdin_fd, stdout_fd, debugstr_a(unixdir), debugstr_a(winedebug),
+          debugstr_a(wineloader));
+
+    socket_path = getenv("CX_ALT_LOADER_SOCKET");
+    if (!socket_path)
+    {
+        TRACE("CX_ALT_LOADER_SOCKET is not set; nothing to do\n");
+        goto failed;
+    }
+
+    TRACE("socket path %s\n", debugstr_a(socket_path));
+
+    if (argv[1])
+    {
+        OBJECT_ATTRIBUTES attr;
+
+        attr.Length = sizeof(attr);
+        attr.Attributes = 0;
+        attr.SecurityDescriptor = NULL;
+        attr.SecurityQualityOfService = NULL;
+
+        if (RtlOpenCurrentUser(KEY_READ, &attr.RootDirectory) == STATUS_SUCCESS)
+        {
+            UNICODE_STRING name;
+            HANDLE hkey;
+
+            attr.ObjectName = &name;
+            RtlInitUnicodeString(&name, suppress_key);
+
+            if (NtOpenKey(&hkey, KEY_READ, &attr) == STATUS_SUCCESS)
+            {
+                const char *exename, *p;
+                int len;
+                WCHAR *exenameW;
+                BOOL suppress;
+                KEY_VALUE_BASIC_INFORMATION info;
+                DWORD size;
+                NTSTATUS status;
+
+                exename = argv[1];
+                if ((p = strrchr(exename, '/'))) exename = p + 1;
+                if ((p = strrchr(exename, '\\'))) exename = p + 1;
+                if (!(p = strrchr(exename, '.'))) p = exename + strlen(exename);
+
+                len = MultiByteToWideChar(CP_UNIXCP, 0, exename, p - exename, NULL, 0);
+                exenameW = HeapAlloc(GetProcessHeap(), 0, (len + 1) * sizeof(WCHAR));
+                MultiByteToWideChar(CP_UNIXCP, 0, exename, p - exename, exenameW, len);
+                exenameW[len] = 0;
+
+                RtlInitUnicodeString(&name, exenameW);
+                status = NtQueryValueKey(hkey, &name, KeyValueBasicInformation, &info, sizeof(info), &size);
+                suppress = (status == STATUS_SUCCESS || status == STATUS_BUFFER_OVERFLOW);
+
+                NtClose(hkey);
+
+                if (suppress)
+                {
+                    TRACE("alternative loader suppressed for exe name %s (argv[1] %s)\n", debugstr_w(exenameW), debugstr_a(argv[1]));
+                    HeapFree(GetProcessHeap(), 0, exenameW);
+                    goto failed;
+                }
+
+                HeapFree(GetProcessHeap(), 0, exenameW);
+            }
+        }
+    }
+
+    sa.sun_family = AF_UNIX;
+    if (strlen(socket_path) >= sizeof(sa.sun_path))
+    {
+        WARN("socket path %s is too long for sockaddr_un\n", debugstr_a(socket_path));
+        goto failed;
+    }
+    lstrcpynA(sa.sun_path, socket_path, sizeof(sa.sun_path));
+#ifdef HAVE_STRUCT_SOCKADDR_UN_SUN_LEN
+    sa.sun_len = SUN_LEN(&sa) + 1;
+#endif
+
+    unsetenv("CX_ALT_LOADER_SOCKET");
+    socket_path = NULL;
+
+    sock = socket(PF_LOCAL, SOCK_STREAM, 0);
+    if (sock == -1)
+    {
+        WARN("failed to create socket; errno %d\n", errno);
+        goto failed;
+    }
+
+    if (fcntl(sock, F_SETFD, FD_CLOEXEC))
+        WARN("failed to set socket close-on-exec; proceeding anyway\n");
+
+    do
+    {
+        rc = connect(sock, (struct sockaddr*)&sa, sizeof(sa));
+    } while (rc == -1 && errno == EINTR);
+    if (rc)
+    {
+        WARN("failed to connect; errno %d\n", errno);
+        goto failed;
+    }
+
+    if (binary_info->flags & BINARY_FLAG_64BIT)
+        request_type = REQUEST_LOAD_WINE_64BIT;
+    else
+        request_type = REQUEST_LOAD_WINE;
+    if (!write_data(sock, &request_type, sizeof(request_type)))
+    {
+        WARN("failed to write request type\n");
+        goto failed;
+    }
+
+    if (!write_length_prefixed_buffer(sock, unixdir, unixdir ? strlen(unixdir) + 1 : 0))
+    {
+        WARN("failed to write working directory\n");
+        goto failed;
+    }
+
+    length = 0;
+    for (elem = __wine_get_main_environment(); *elem; elem++)
+        length += strlen(*elem) + 1;
+    if (winedebug) length += strlen(winedebug) + 1;
+    if (wineloader) length += strlen(wineloader) + 1;
+
+    if (!write_data(sock, &length, sizeof(length)))
+    {
+        WARN("failed to write environment length\n");
+        goto failed;
+    }
+
+    for (elem = __wine_get_main_environment(); *elem; elem++)
+    {
+        if (!write_data(sock, *elem, strlen(*elem) + 1))
+        {
+            WARN("failed to write environment variable\n");
+            goto failed;
+        }
+    }
+    if (winedebug && !write_data(sock, winedebug, strlen(winedebug) + 1))
+    {
+        WARN("failed to write environment variable\n");
+        goto failed;
+    }
+    if (wineloader && !write_data(sock, wineloader, strlen(wineloader) + 1))
+    {
+        WARN("failed to write environment variable\n");
+        goto failed;
+    }
+
+    length = 0;
+    if (!loader) loader = ""; /* use empty string as placeholder */
+    length += strlen(loader) + 1;
+    for (elem = &argv[1]; *elem; elem++)
+    {
+        TRACE("argv[%d] %s\n", elem - argv, debugstr_a(*elem));
+        length += strlen(*elem) + 1;
+    }
+
+    if (!write_data(sock, &length, sizeof(length)))
+    {
+        WARN("failed to write args length\n");
+        goto failed;
+    }
+
+    if (!write_data(sock, loader, strlen(loader) + 1))
+    {
+        WARN("failed to write argv[0]\n");
+        goto failed;
+    }
+    for (elem = &argv[1]; *elem; elem++)
+    {
+        if (!write_data(sock, *elem, strlen(*elem) + 1))
+        {
+            WARN("failed to write argument\n");
+            goto failed;
+        }
+    }
+
+    if (flags & (CREATE_NEW_PROCESS_GROUP | CREATE_NEW_CONSOLE | DETACHED_PROCESS))
+    {
+        nullfd = open("/dev/null", O_RDWR);
+        stdin_fd = nullfd;
+        stdout_fd = nullfd;
+    }
+
+    iov.iov_base = &dummy;
+    iov.iov_len = sizeof(dummy);
+
+    cmsg.hdr.cmsg_level = SOL_SOCKET;
+    cmsg.hdr.cmsg_type = SCM_RIGHTS;
+    cmsg.fds[0] = stdin_fd == -1 ? 0 : stdin_fd;
+    cmsg.fds[1] = stdout_fd == -1 ? 1 : stdout_fd;
+    cmsg.fds[2] = 2;
+    cmsg.fds[3] = wineserversocket;
+    if ((wait_child_pipe = getenv("WINE_WAIT_CHILD_PIPE")) &&
+        (cmsg.fds[4] = atoi(wait_child_pipe)))
+        cmsg.hdr.cmsg_len = (char*)&cmsg.fds[5] - (char*)&cmsg;
+    else
+        cmsg.hdr.cmsg_len = (char*)&cmsg.fds[4] - (char*)&cmsg;
+
+    msg.msg_name = NULL;
+    msg.msg_namelen = 0;
+    msg.msg_iov = &iov;
+    msg.msg_iovlen = 1;
+    msg.msg_control = &cmsg;
+    msg.msg_controllen = cmsg.hdr.cmsg_len;
+    msg.msg_flags = 0;
+
+    do
+    {
+        rc = sendmsg(sock, &msg, 0);
+    } while (rc == -1 && errno == EINTR);
+    if (rc != 1)
+    {
+        WARN("failed to send file descriptors; errno %d\n", errno);
+        goto failed;
+    }
+
+    if (shutdown(sock, SHUT_WR))
+    {
+        WARN("failed to shutdown socket for writing; errno %d\n", errno);
+        goto failed;
+    }
+
+    if (!read_data(sock, &response, sizeof(response)))
+    {
+        WARN("failed to read response; errno %d\n", errno);
+        goto failed;
+    }
+
+    ret = (response == RESPONSE_SUCCESS);
+
+failed:
+    if (sock != -1) close(sock);
+    if (nullfd != -1) close(nullfd);
+    return ret;
+}
+
 /***********************************************************************
  *           get_process_cpu
  */
@@ -1871,12 +2217,42 @@
     char *wineloader = NULL;
     const char *loader = NULL;
     char **argv;
+    int argc = 1;
+
+#ifdef __arm__
+    char *lib_path = NULL;
+    char *x86_dir = NULL;
+
+    if ((binary_info->arch == IMAGE_FILE_MACHINE_I386) && !(binary_info->flags & BINARY_FLAG_FAKEDLL))
+    {
+        const char *data_dir = wine_get_data_dir();
+
+        x86_dir = HeapAlloc( GetProcessHeap(), 0, strlen( data_dir ) + sizeof("/../../x86" ));
+        strcpy( x86_dir, data_dir );
+        strcat( x86_dir, "/../../x86" );
+
+        TRACE( "trying qemu for %s dir %s\n", debugstr_w(cmd_line), x86_dir );
+        argc = 6;
+        wineloader = HeapAlloc( GetProcessHeap(), 0,
+                                sizeof( "WINELOADER=/bin/wineloader" ) + strlen( x86_dir ));
+        sprintf( wineloader, "WINELOADER=%s/bin/wineloader", x86_dir );
+        lib_path = HeapAlloc( GetProcessHeap(), 0, sizeof( "LD_LIBRARY_PATH=/lib" ) + strlen( x86_dir ));
+        sprintf( lib_path, "LD_LIBRARY_PATH=%s/lib", x86_dir );
+    }
+#endif
 
-    argv = build_argv( cmd_line, 1 );
+    argv = build_argv( cmd_line, argc );
 
     if (!is_win64 ^ !(binary_info->flags & BINARY_FLAG_64BIT))
         loader = get_alternate_loader( &wineloader );
 
+    /* CrossOver Hack 10523: shunt the loading to CrossOver */
+    if (!exec_only && send_to_cx_loader(loader, argv, flags, socketfd, stdin_fd, stdout_fd,
+                                        unixdir, winedebug, binary_info, wineloader))
+    {
+        pid = 0;
+    }
+    else /* end CrossOver hack */
     if (exec_only || !(pid = fork()))  /* child */
     {
         if (exec_only || !(pid = fork()))  /* grandchild */
@@ -1919,6 +2295,21 @@
 
             if (argv)
             {
+#ifdef __arm__
+                if (x86_dir && lib_path)
+                {
+                    int i = 1;
+                    argv[i++] = "-L";
+                    argv[i++] = x86_dir;
+                    argv[i++] = "-E";
+                    argv[i++] = lib_path;
+                    argv[i++] = wineloader + strlen( "WINELOADER=" );
+                    assert( i == argc );
+                    dup2( 2, 1 );
+                    wine_exec_wine_binary( "qemu-i386", argv, NULL );
+                    _exit(1);
+                }
+#endif
                 do
                 {
                     wine_exec_wine_binary( loader, argv, getenv("WINELOADER") );
@@ -1935,7 +2326,7 @@
         _exit(pid == -1);
     }
 
-    if (pid != -1)
+    if (pid && pid != -1)
     {
         /* reap child */
         pid_t wret;
@@ -1944,6 +2335,10 @@
         } while (wret < 0 && errno == EINTR);
     }
 
+#ifdef __arm__
+    HeapFree( GetProcessHeap(), 0, lib_path );
+    HeapFree( GetProcessHeap(), 0, x86_dir );
+#endif
     HeapFree( GetProcessHeap(), 0, wineloader );
     HeapFree( GetProcessHeap(), 0, argv );
     return pid;
@@ -2329,6 +2724,33 @@
         return FALSE;
     if (hFile == INVALID_HANDLE_VALUE) goto done;
 
+    /* CROSSOVER HACK: bug 13322 (winehq bug 39403)
+     * Insert --no-sandbox in command line of Steam's web helper process to
+     * work around problems hooking our ntdll exports. */
+    {
+        static const WCHAR steamwebhelperexeW[] = {'s','t','e','a','m','w','e','b','h','e','l','p','e','r','.','e','x','e',0};
+        static const WCHAR nosandboxW[] = {' ','-','-','n','o','-','s','a','n','d','b','o','x',0};
+
+        if (strstrW(name, steamwebhelperexeW))
+        {
+            LPWSTR new_command_line;
+
+            new_command_line = HeapAlloc(GetProcessHeap(), 0,
+                sizeof(WCHAR) * (strlenW(tidy_cmdline) + strlenW(nosandboxW) + 1));
+
+            if (!new_command_line) return FALSE;
+
+            strcpyW(new_command_line, tidy_cmdline);
+            strcatW(new_command_line, nosandboxW);
+
+            TRACE("CrossOver hack changing command line to %s\n", debugstr_w(new_command_line));
+
+            if (tidy_cmdline != cmd_line) HeapFree( GetProcessHeap(), 0, tidy_cmdline );
+            tidy_cmdline = new_command_line;
+        }
+    }
+    /* end CROSSOVER HACK */
+
     /* Warn if unsupported features are used */
 
     if (flags & (IDLE_PRIORITY_CLASS | HIGH_PRIORITY_CLASS | REALTIME_PRIORITY_CLASS |
diff -Naur wine-2.0a/dlls/kernel32/tests/locale.c wine-2.0b/dlls/kernel32/tests/locale.c
--- wine-2.0a/dlls/kernel32/tests/locale.c	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/kernel32/tests/locale.c	2017-07-11 20:37:50.000000000 +0100
@@ -255,7 +255,7 @@
     { {'e','s',0}, {'e','s','-','E','S',0},
       MAKELCID(MAKELANGID(LANG_SPANISH, SUBLANG_SPANISH_MODERN), SORT_DEFAULT),
       MAKELCID(MAKELANGID(LANG_SPANISH, SUBLANG_SPANISH), SORT_DEFAULT) /* vista */,
-      {'e','s','-','E','S','_','t','r','a','d','n','l',0}, 0x1 },
+      {'e','s','-','E','S','_','t','r','a','d','n','l',0} },
     { {'g','a',0}, {'g','a','-','I','E',0},
       MAKELCID(MAKELANGID(LANG_IRISH, SUBLANG_IRISH_IRELAND), SORT_DEFAULT), 0, {0}, 0x3 },
     { {'i','t',0}, {'i','t','-','I','T',0},
@@ -273,7 +273,7 @@
     { {'u','z',0}, {'u','z','-','L','a','t','n','-','U','Z',0},
       MAKELCID(MAKELANGID(LANG_UZBEK, SUBLANG_UZBEK_LATIN), SORT_DEFAULT) },
     { {'z','h',0}, {'z','h','-','C','N',0},
-      MAKELCID(MAKELANGID(LANG_CHINESE, SUBLANG_CHINESE_SIMPLIFIED), SORT_DEFAULT), 0, {0}, 0x3 },
+      MAKELCID(MAKELANGID(LANG_CHINESE, SUBLANG_CHINESE_SIMPLIFIED), SORT_DEFAULT) },
     { {0} }
 };
 
@@ -2684,7 +2684,7 @@
     { {'a','z',0}, MAKELCID(MAKELANGID(LANG_AZERI,      SUBLANG_AZERI_LATIN), SORT_DEFAULT) },
     { {'d','e',0}, MAKELCID(MAKELANGID(LANG_GERMAN,     SUBLANG_GERMAN), SORT_DEFAULT) },
     { {'e','n',0}, MAKELCID(MAKELANGID(LANG_ENGLISH,    SUBLANG_ENGLISH_US), SORT_DEFAULT) },
-    { {'e','s',0}, MAKELCID(MAKELANGID(LANG_SPANISH,    SUBLANG_SPANISH_MODERN), SORT_DEFAULT), 1 },
+    { {'e','s',0}, MAKELCID(MAKELANGID(LANG_SPANISH,    SUBLANG_SPANISH_MODERN), SORT_DEFAULT) },
     { {'g','a',0}, MAKELCID(MAKELANGID(LANG_IRISH,      SUBLANG_IRISH_IRELAND), SORT_DEFAULT) },
     { {'i','t',0}, MAKELCID(MAKELANGID(LANG_ITALIAN,    SUBLANG_ITALIAN), SORT_DEFAULT) },
     { {'m','s',0}, MAKELCID(MAKELANGID(LANG_MALAY,      SUBLANG_MALAY_MALAYSIA), SORT_DEFAULT) },
@@ -2693,7 +2693,7 @@
     { {'s','r',0}, MAKELCID(MAKELANGID(LANG_SERBIAN,    SUBLANG_SERBIAN_SERBIA_LATIN), SORT_DEFAULT), 1 },
     { {'s','v',0}, MAKELCID(MAKELANGID(LANG_SWEDISH,    SUBLANG_SWEDISH), SORT_DEFAULT) },
     { {'u','z',0}, MAKELCID(MAKELANGID(LANG_UZBEK,      SUBLANG_UZBEK_LATIN), SORT_DEFAULT) },
-    { {'z','h',0}, MAKELCID(MAKELANGID(LANG_CHINESE,    SUBLANG_CHINESE_SIMPLIFIED), SORT_DEFAULT), 1 },
+    { {'z','h',0}, MAKELCID(MAKELANGID(LANG_CHINESE,    SUBLANG_CHINESE_SIMPLIFIED), SORT_DEFAULT) },
     { {0} }
 };
 
@@ -2703,6 +2703,7 @@
     INT ret;
     WCHAR buffer[LOCALE_NAME_MAX_LENGTH];
     static const WCHAR enW[] = {'e','n',0};
+    static const WCHAR esesW[] = {'e','s','-','e','s',0};
 
     if (!pLocaleNameToLCID)
     {
@@ -2743,6 +2744,10 @@
     ok(!lcid && GetLastError() == ERROR_INVALID_PARAMETER,
        "Expected lcid == 0, got %08x, error %d\n", lcid, GetLastError());
 
+    /* lower-case */
+    lcid = pLocaleNameToLCID(esesW, 0);
+    ok(lcid == MAKELCID(MAKELANGID(LANG_SPANISH, SUBLANG_SPANISH_MODERN), SORT_DEFAULT), "Got wrong lcid for es-es: 0x%x\n", lcid);
+
     /* english neutral name */
     lcid = pLocaleNameToLCID(enW, 0);
     ok(lcid == MAKELCID(MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US), SORT_DEFAULT) ||
diff -Naur wine-2.0a/dlls/kernel32/volume.c wine-2.0b/dlls/kernel32/volume.c
--- wine-2.0a/dlls/kernel32/volume.c	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/kernel32/volume.c	2017-07-11 20:37:50.000000000 +0100
@@ -852,9 +852,21 @@
         if (flags) *flags = FILE_CASE_PRESERVED_NAMES;  /* FIXME */
         break;
     default:
-        if (fsname) lstrcpynW( fsname, ntfsW, fsname_len );
-        if (filename_len) *filename_len = 255;
-        if (flags) *flags = FILE_CASE_PRESERVED_NAMES | FILE_PERSISTENT_ACLS;
+        {
+            DWORD ret = GetEnvironmentVariableA("CX_HACK_FILESYSTEM_TYPE",NULL,0);
+            if (ret > 0)
+            {
+                static const WCHAR unixfsW[] = {'U','N','I','X','F','S',0};
+                if (fsname) lstrcpynW( fsname, unixfsW, fsname_len );
+                if (flags) *flags = FILE_CASE_PRESERVED_NAMES;
+            }
+            else
+            {
+                if (fsname) lstrcpynW( fsname, ntfsW, fsname_len );
+                if (flags) *flags = FILE_CASE_PRESERVED_NAMES | FILE_PERSISTENT_ACLS;
+            }
+            if (filename_len) *filename_len = 255;
+        }
         break;
     }
     ret = TRUE;
@@ -1627,6 +1639,21 @@
     }
     else
     {
+        char type_hack[255];
+        DWORD e_ret = GetEnvironmentVariableA("CX_HACK_REMOTE_DRIVES", type_hack, 255);
+        if (e_ret > 0)
+        {
+            char drive;
+            if (root) drive = root[0];
+            else
+            {
+                WCHAR path[MAX_PATH];
+                GetCurrentDirectoryW( MAX_PATH, path );
+                drive = path[0];
+            }
+            if (strchr( type_hack, tolower(drive) )) return DRIVE_REMOTE;
+        }
+
         switch (info.DeviceType)
         {
         case FILE_DEVICE_CD_ROM_FILE_SYSTEM:  ret = DRIVE_CDROM; break;
diff -Naur wine-2.0a/dlls/mapi32/mapi32.spec wine-2.0b/dlls/mapi32/mapi32.spec
--- wine-2.0a/dlls/mapi32/mapi32.spec	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/mapi32/mapi32.spec	2017-07-11 20:37:50.000000000 +0100
@@ -175,7 +175,7 @@
 236 stub cmc_read
 237 stub cmc_send
 238 stub cmc_send_documents
-239 stub HrDispatchNotifications@4
+239 stdcall HrDispatchNotifications@4(long) HrDispatchNotifications
 241 stub HrValidateParameters@8
 244 stub ScCreateConversationIndex@16
 246 stub HrGetOmiProvidersFlags
diff -Naur wine-2.0a/dlls/mapi32/util.c wine-2.0b/dlls/mapi32/util.c
--- wine-2.0a/dlls/mapi32/util.c	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/mapi32/util.c	2017-07-11 20:37:50.000000000 +0100
@@ -239,6 +239,15 @@
 }
 
 /*************************************************************************
+ * HrDispatchNotifications@4 (MAPI32.239)
+ */
+HRESULT WINAPI HrDispatchNotifications(ULONG flags)
+{
+    FIXME("(%08x)\n", flags);
+    return S_OK;
+}
+
+/*************************************************************************
  * HrThisThreadAdviseSink@8 (MAPI32.42)
  *
  * Ensure that an advise sink is only notified in its originating thread.
diff -Naur wine-2.0a/dlls/mmdevapi/main.c wine-2.0b/dlls/mmdevapi/main.c
--- wine-2.0a/dlls/mmdevapi/main.c	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/mmdevapi/main.c	2017-07-11 20:37:50.000000000 +0100
@@ -114,7 +114,7 @@
     static const WCHAR drv_value[] = {'A','u','d','i','o',0};
 
     static WCHAR default_list[] = {'p','u','l','s','e',',','a','l','s','a',',','o','s','s',',',
-        'c','o','r','e','a','u','d','i','o',0};
+        'c','o','r','e','a','u','d','i','o',',','a','n','d','r','o','i','d',0};
 
     DriverFuncs driver;
     HKEY key;
diff -Naur wine-2.0a/dlls/mscoree/mscoree_main.c wine-2.0b/dlls/mscoree/mscoree_main.c
--- wine-2.0a/dlls/mscoree/mscoree_main.c	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/mscoree/mscoree_main.c	2017-07-11 20:37:50.000000000 +0100
@@ -758,6 +758,12 @@
     return ret;
 }
 
+/* CROSSOVER HACK bug 10194 */
+void WINAPI wine_install_mono(HWND hwnd, HINSTANCE hinst, LPSTR cmdline, int cmdshow)
+{
+    install_wine_mono();
+}
+
 HRESULT WINAPI DllRegisterServer(void)
 {
     install_wine_mono();
diff -Naur wine-2.0a/dlls/mscoree/mscoree.spec wine-2.0b/dlls/mscoree/mscoree.spec
--- wine-2.0a/dlls/mscoree/mscoree.spec	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/mscoree/mscoree.spec	2017-07-11 20:37:50.000000000 +0100
@@ -117,3 +117,6 @@
 @ stdcall _CorExeMain()
 @ stdcall _CorImageUnloading(ptr)
 @ stdcall _CorValidateImage(ptr ptr)
+
+@ stdcall wine_install_mono(ptr ptr ptr long)
+
diff -Naur wine-2.0a/dlls/mshtml/htmllocation.c wine-2.0b/dlls/mshtml/htmllocation.c
--- wine-2.0a/dlls/mshtml/htmllocation.c	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/mshtml/htmllocation.c	2017-07-11 20:37:50.000000000 +0100
@@ -466,7 +466,7 @@
     if(FAILED(hres))
         return hres;
 
-    if(url.dwUrlPathLength && url.lpszUrlPath[0] == '/')
+    if(0&&url.dwUrlPathLength && url.lpszUrlPath[0] == '/')
         *p = SysAllocStringLen(url.lpszUrlPath + 1, url.dwUrlPathLength - 1);
     else
         *p = SysAllocStringLen(url.lpszUrlPath, url.dwUrlPathLength);
diff -Naur wine-2.0a/dlls/mshtml/mshtml.inf wine-2.0b/dlls/mshtml/mshtml.inf
--- wine-2.0a/dlls/mshtml/mshtml.inf	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/mshtml/mshtml.inf	2017-07-11 20:37:50.000000000 +0100
@@ -106,7 +106,8 @@
 HKCR,".gif","Content Type",,"image/gif"
 HKCR,"giffile",,,"GIF Image"
 HKCR,"giffile\CLSID",,,"%CLSID_HTMLDocument%"
-HKCR,"giffile\shell\open\command",,,"""%16422%\Internet Explorer\iexplore.exe"" -nohome"
+; CrossOver hack, bug 7778
+HKCR,"giffile\shell\open\command",,,"%11%\winebrowser.exe -nohome"
 HKCR,"giffile\shell\open\ddeexec",,,"""file:%%1"",,-1,,,,,"
 HKCR,"giffile\shell\open\ddeexec\Application",,,"IExplore"
 HKCR,"giffile\shell\open\ddeexec\Topic",,,"WWW_OpenURL"
@@ -126,8 +127,6 @@
 HKCR,"MIME\Database\Content Type\text/html","Extension",,".htm"
 HKCR,"MIME\Database\Content Type\text/html","Encoding",1,08,00,00,00
 HKCR,"MIME\Database\Content Type\image/x-jg","CLSID",,"%CLSID_HTMLDocument%"
-HKCR,"InternetShortcut\shell\print\command",,,"rundll32.exe mshtml.dll,PrintHTML ""%%1"""
-HKCR,"InternetShortcut\shell\printto\command",,,"rundll32.exe mshtml.dll,PrintHTML ""%%1"" ""%%2"" ""%%3"" ""%%4"""
 HKCR,"htmlfile\shell\print\command",,,"rundll32.exe mshtml.dll,PrintHTML ""%%1"""
 HKCR,"htmlfile\shell\printto\command",,,"rundll32.exe mshtml.dll,PrintHTML ""%%1"" ""%%2"" ""%%3"" ""%%4"""
 HKCR,"htmlfile",,,"HTML Document"
@@ -153,7 +152,8 @@
 HKCR,".jpe","Content Type",,"image/jpeg"
 HKCR,"jpegfile",,,"JPEG Image"
 HKCR,"jpegfile\CLSID",,,"%CLSID_HTMLDocument%"
-HKCR,"jpegfile\shell\open\command",,,"""%16422%\Internet Explorer\iexplore.exe"" -nohome"
+; CrossOver hack, bug 7778
+HKCR,"jpegfile\shell\open\command",,,"%11%\winebrowser.exe -nohome"
 HKCR,"jpegfile\shell\open\ddeexec",,,"""file:%%1"",,-1,,,,,"
 HKCR,"jpegfile\shell\open\ddeexec\Application",,,"IExplore"
 HKCR,"jpegfile\shell\open\ddeexec\Topic",,,"WWW_OpenURL"
@@ -168,7 +168,8 @@
 HKCR,".jpeg","Content Type",,"image/jpeg"
 HKCR,"jpegfile",,,"JPEG Image"
 HKCR,"jpegfile\CLSID",,,"%CLSID_HTMLDocument%"
-HKCR,"jpegfile\shell\open\command",,,"""%16422%\Internet Explorer\iexplore.exe"" -nohome"
+; CrossOver hack, bug 7778
+HKCR,"jpegfile\shell\open\command",,,"%11%\winebrowser.exe -nohome"
 HKCR,"jpegfile\shell\open\ddeexec",,,"""file:%%1"",,-1,,,,,"
 HKCR,"jpegfile\shell\open\ddeexec\Application",,,"IExplore"
 HKCR,"jpegfile\shell\open\ddeexec\Topic",,,"WWW_OpenURL"
@@ -179,7 +180,8 @@
 HKCR,".jpg","Content Type",,"image/jpeg"
 HKCR,"jpegfile",,,"JPEG Image"
 HKCR,"jpegfile\CLSID",,,"%CLSID_HTMLDocument%"
-HKCR,"jpegfile\shell\open\command",,,"""%16422%\Internet Explorer\iexplore.exe"" -nohome"
+; CrossOver hack, bug 7778
+HKCR,"jpegfile\shell\open\command",,,"%11%\winebrowser.exe -nohome"
 HKCR,"jpegfile\shell\open\ddeexec",,,"""file:%%1"",,-1,,,,,"
 HKCR,"jpegfile\shell\open\ddeexec\Application",,,"IExplore"
 HKCR,"jpegfile\shell\open\ddeexec\Topic",,,"WWW_OpenURL"
@@ -216,7 +218,8 @@
 HKCR,".jfif","Content Type",,"image/jpeg"
 HKCR,"pjpegfile",,,"JPEG Image"
 HKCR,"pjpegfile\CLSID",,,"%CLSID_HTMLDocument%"
-HKCR,"pjpegfile\shell\open\command",,,"""%16422%\Internet Explorer\iexplore.exe"" -nohome"
+; CrossOver hack, bug 7778
+HKCR,"pjpegfile\shell\open\command",,,"%11%\winebrowser.exe -nohome"
 HKCR,"pjpegfile\shell\open\ddeexec",,,"""file:%%1"",,-1,,,,,"
 HKCR,"pjpegfile\shell\open\ddeexec\Application",,,"IExplore"
 HKCR,"pjpegfile\shell\open\ddeexec\Topic",,,"WWW_OpenURL"
@@ -229,7 +232,8 @@
 HKCR,".png","Content Type",,"image/png"
 HKCR,"pngfile",,,"PNG Image"
 HKCR,"pngfile\CLSID",,,"%CLSID_HTMLDocument%"
-HKCR,"pngfile\shell\open\command",,,"""%16422%\Internet Explorer\iexplore.exe"" -nohome"
+; CrossOver hack, bug 7778
+HKCR,"pngfile\shell\open\command",,,"%11%\winebrowser.exe -nohome"
 HKCR,"pngfile\shell\open\ddeexec",,,"""file:%%1"",,-1,,,,,"
 HKCR,"pngfile\shell\open\ddeexec\Application",,,"IExplore"
 HKCR,"pngfile\shell\open\ddeexec\Topic",,,"WWW_OpenURL"
@@ -261,6 +265,11 @@
 HKCR,".txt",,,"txtfile"
 HKCR,".txt","Content Type",,"text/plain"
 
+;; URL
+HKCR,".url",,,"InternetShortcut"
+HKCR,"InternetShortcut\shell\print\command",,,"rundll32.exe mshtml.dll,PrintHTML ""%%1"""
+HKCR,"InternetShortcut\shell\printto\command",,,"rundll32.exe mshtml.dll,PrintHTML ""%%1"" ""%%2"" ""%%3"" ""%%4"""
+
 ;; WAV
 HKCR,"MIME\Database\Content Type\audio/wav","CLSID",,"{CD3AFA7B-B84F-48F0-9393-7EDC34128127}"
 HKCR,"MIME\Database\Content Type\audio/wav","Extension",,".wav"
@@ -272,7 +281,8 @@
 HKCR,".xbm","Content Type",,"image/x-xbitmap"
 HKCR,"xbmfile",,,"XBM Image"
 HKCR,"xbmfile\CLSID",,,"%CLSID_HTMLDocument%"
-HKCR,"xbmfile\shell\open\command",,,"""%16422%\Internet Explorer\iexplore.exe"" -nohome"
+; CrossOver hack, bug 7778
+HKCR,"xbmfile\shell\open\command",,,"%11%\winebrowser.exe -nohome"
 HKCR,"xbmfile\shell\open\ddeexec",,,"""file:%%1"",,-1,,,,,"
 HKCR,"xbmfile\shell\open\ddeexec\Application",,,"IExplore"
 HKCR,"xbmfile\shell\open\ddeexec\Topic",,,"WWW_OpenURL"
diff -Naur wine-2.0a/dlls/mshtml/nsio.c wine-2.0b/dlls/mshtml/nsio.c
--- wine-2.0a/dlls/mshtml/nsio.c	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/mshtml/nsio.c	2017-07-11 20:37:50.000000000 +0100
@@ -2830,6 +2830,16 @@
 
     MultiByteToWideChar(CP_UTF8, 0, scheme, -1, buf, sizeof(buf)/sizeof(WCHAR));
     *_retval = !strcmpW(scheme_name, buf);
+
+    /* CXHACK: We cheat security check for posting data from secure to insecure location for STO. See bug 7867 */
+    if(!*_retval && !strcmp(scheme, "https")) {
+        static const WCHAR appW[] = {'a','p','p',0};
+        if(!strcmpW(scheme_name, appW)) {
+            FIXME("CXHACK: https -> app post\n");
+            *_retval = TRUE;
+        }
+    }
+
     SysFreeString(scheme_name);
     return NS_OK;
 }
@@ -3975,6 +3985,8 @@
     BOOL ret = FALSE;
     HRESULT hres;
 
+    static const WCHAR appW[] = {'a','p','p',':'};
+
     if(!doc->hostui || !ensure_uri(uri))
         return FALSE;
 
@@ -3982,6 +3994,12 @@
     if(FAILED(hres))
         return FALSE;
 
+    if(!strncmpW(url, appW, sizeof(appW)/sizeof(WCHAR))) {
+        WCHAR *ptr = strchrW(url, '?');
+        if(ptr)
+            *ptr = 0;
+    }
+
     hres = IDocHostUIHandler_TranslateUrl(doc->hostui, 0, url, &new_url);
     if(hres == S_OK && new_url) {
         if(strcmpW(url, new_url)) {
diff -Naur wine-2.0a/dlls/msi/action.c wine-2.0b/dlls/msi/action.c
--- wine-2.0a/dlls/msi/action.c	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/msi/action.c	2017-07-11 20:37:50.000000000 +0100
@@ -7672,6 +7672,7 @@
     const WCHAR *action;
     UINT (*handler)(MSIPACKAGE *);
     const WCHAR *action_rollback;
+    BOOL disable_wow64_redir; /* CROSSOVER HACK bug 13792 */
 }
 StandardActions[] =
 {
@@ -7681,19 +7682,19 @@
     { szCCPSearch, ACTION_CCPSearch, NULL },
     { szCostFinalize, ACTION_CostFinalize, NULL },
     { szCostInitialize, ACTION_CostInitialize, NULL },
-    { szCreateFolders, ACTION_CreateFolders, szRemoveFolders },
+    { szCreateFolders, ACTION_CreateFolders, szRemoveFolders, TRUE },
     { szCreateShortcuts, ACTION_CreateShortcuts, szRemoveShortcuts },
     { szDeleteServices, ACTION_DeleteServices, szInstallServices },
     { szDisableRollback, ACTION_DisableRollback, NULL },
-    { szDuplicateFiles, ACTION_DuplicateFiles, szRemoveDuplicateFiles },
+    { szDuplicateFiles, ACTION_DuplicateFiles, szRemoveDuplicateFiles, TRUE },
     { szExecuteAction, ACTION_ExecuteAction, NULL },
-    { szFileCost, ACTION_FileCost, NULL },
+    { szFileCost, ACTION_FileCost, NULL, TRUE },
     { szFindRelatedProducts, ACTION_FindRelatedProducts, NULL },
     { szForceReboot, ACTION_ForceReboot, NULL },
     { szInstallAdminPackage, ACTION_InstallAdminPackage, NULL },
     { szInstallExecute, ACTION_InstallExecute, NULL },
     { szInstallExecuteAgain, ACTION_InstallExecute, NULL },
-    { szInstallFiles, ACTION_InstallFiles, szRemoveFiles },
+    { szInstallFiles, ACTION_InstallFiles, szRemoveFiles, TRUE },
     { szInstallFinalize, ACTION_InstallFinalize, NULL },
     { szInstallInitialize, ACTION_InstallInitialize, NULL },
     { szInstallODBC, ACTION_InstallODBC, szRemoveODBC },
@@ -7703,7 +7704,7 @@
     { szIsolateComponents, ACTION_IsolateComponents, NULL },
     { szLaunchConditions, ACTION_LaunchConditions, NULL },
     { szMigrateFeatureStates, ACTION_MigrateFeatureStates, NULL },
-    { szMoveFiles, ACTION_MoveFiles, NULL },
+    { szMoveFiles, ACTION_MoveFiles, NULL, TRUE },
     { szMsiPublishAssemblies, ACTION_MsiPublishAssemblies, szMsiUnpublishAssemblies },
     { szMsiUnpublishAssemblies, ACTION_MsiUnpublishAssemblies, szMsiPublishAssemblies },
     { szPatchFiles, ACTION_PatchFiles, NULL },
@@ -7720,12 +7721,12 @@
     { szRegisterProgIdInfo, ACTION_RegisterProgIdInfo, szUnregisterProgIdInfo },
     { szRegisterTypeLibraries, ACTION_RegisterTypeLibraries, szUnregisterTypeLibraries },
     { szRegisterUser, ACTION_RegisterUser, NULL },
-    { szRemoveDuplicateFiles, ACTION_RemoveDuplicateFiles, szDuplicateFiles },
+    { szRemoveDuplicateFiles, ACTION_RemoveDuplicateFiles, szDuplicateFiles, TRUE },
     { szRemoveEnvironmentStrings, ACTION_RemoveEnvironmentStrings, szWriteEnvironmentStrings },
     { szRemoveExistingProducts, ACTION_RemoveExistingProducts, NULL },
-    { szRemoveFiles, ACTION_RemoveFiles, szInstallFiles },
-    { szRemoveFolders, ACTION_RemoveFolders, szCreateFolders },
-    { szRemoveIniValues, ACTION_RemoveIniValues, szWriteIniValues },
+    { szRemoveFiles, ACTION_RemoveFiles, szInstallFiles, TRUE },
+    { szRemoveFolders, ACTION_RemoveFolders, szCreateFolders, TRUE },
+    { szRemoveIniValues, ACTION_RemoveIniValues, szWriteIniValues, TRUE },
     { szRemoveODBC, ACTION_RemoveODBC, szInstallODBC },
     { szRemoveRegistryValues, ACTION_RemoveRegistryValues, szWriteRegistryValues },
     { szRemoveShortcuts, ACTION_RemoveShortcuts, szCreateShortcuts },
@@ -7759,6 +7760,15 @@
     BOOL ret = FALSE;
     UINT i;
 
+/* CROSSOVER HACK bug 13792 - Disable wow64 redirection when working with files
+ * in 64-bit packages and 32-bit processes. */
+#if __i386__
+    BOOL disable_wow64_redir = (package->platform == PLATFORM_X64 || package->platform == PLATFORM_INTEL64);
+#else
+    BOOL disable_wow64_redir = FALSE;
+#endif
+    void *old_redir_value;
+
     i = 0;
     while (StandardActions[i].action != NULL)
     {
@@ -7768,7 +7778,15 @@
             if (StandardActions[i].handler)
             {
                 ui_actioninfo( package, action, TRUE, 0 );
+
+                if (disable_wow64_redir && StandardActions[i].disable_wow64_redir)
+                    Wow64DisableWow64FsRedirection( &old_redir_value );
+
                 *rc = StandardActions[i].handler( package );
+
+                if (disable_wow64_redir && StandardActions[i].disable_wow64_redir)
+                    Wow64RevertWow64FsRedirection( old_redir_value );
+
                 ui_actioninfo( package, action, FALSE, *rc );
 
                 if (StandardActions[i].action_rollback && !package->need_rollback)
@@ -7797,6 +7815,16 @@
 
     TRACE("Performing action (%s)\n", debugstr_w(action));
 
+    /* CrossOver Hack #12413 for Quicken 2015 Premier. Don't install the PDF driver */
+    {
+        static const WCHAR pdf[] = {'I','n','s','t','a','l','l','P','D','F','D','r','i','v','e','r',0};
+        if (!strcmpiW(action, pdf))
+        {
+            FIXME("HACK: Skipping installation of pdf driver\n");
+            return rc;
+        }
+    }
+
     handled = ACTION_HandleStandardAction(package, action, &rc);
 
     if (!handled)
diff -Naur wine-2.0a/dlls/msi/custom.c wine-2.0b/dlls/msi/custom.c
--- wine-2.0a/dlls/msi/custom.c	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/msi/custom.c	2017-07-11 20:37:50.000000000 +0100
@@ -378,6 +378,105 @@
     return rc;
 }
 
+/* CROSSOVER HACK BUG 11581 */
+static int mta_thread_enabled = -1;
+static int mta_thread_refcount = 0;
+static HANDLE mta_thread_started = NULL;
+static HANDLE mta_thread_signal = NULL;
+static CRITICAL_SECTION mta_thread_cs;
+static CRITICAL_SECTION_DEBUG mta_thread_cs_debug =
+{
+    0, 0, &mta_thread_cs,
+    { &mta_thread_cs_debug.ProcessLocksList,
+      &mta_thread_cs_debug.ProcessLocksList },
+      0, 0, { (DWORD_PTR)(__FILE__ ": mta_thread_cs") }
+};
+static CRITICAL_SECTION mta_thread_cs = { &mta_thread_cs_debug, -1, 0, 0, 0, 0 };
+static HMODULE mta_thread_hmsi;
+
+static DWORD WINAPI mta_thread_proc(void *arg)
+{
+    CoInitializeEx(0, COINIT_MULTITHREADED);
+
+    SetEvent(mta_thread_started);
+
+    while (1)
+    {
+        WaitForSingleObject(mta_thread_signal, INFINITE);
+
+        EnterCriticalSection(&mta_thread_cs);
+
+        if (mta_thread_refcount == 0)
+            break;
+
+        LeaveCriticalSection(&mta_thread_cs);
+    }
+
+    CloseHandle(mta_thread_started);
+    CloseHandle(mta_thread_signal);
+
+    mta_thread_started = mta_thread_signal = NULL;
+
+    LeaveCriticalSection(&mta_thread_cs);
+
+    CoUninitialize();
+
+    FreeLibraryAndExitThread(mta_thread_hmsi, 0);
+
+    return 0;
+}
+
+static void mta_thread_ref(void)
+{
+    if (mta_thread_enabled == 0) return;
+
+    EnterCriticalSection(&mta_thread_cs);
+
+    if (mta_thread_enabled == -1)
+    {
+        char buffer[2];
+
+        mta_thread_enabled = (GetEnvironmentVariableA("CX_MSI_MTA", buffer, 2) != 0);
+        
+        if (mta_thread_enabled == 0)
+        {
+            LeaveCriticalSection(&mta_thread_cs);
+            return;
+        }
+    }
+
+    if (!mta_thread_started)
+    {
+        mta_thread_started = CreateEventW(NULL, TRUE, FALSE, NULL);
+        mta_thread_signal = CreateEventW(NULL, FALSE, FALSE, NULL);
+
+        GetModuleHandleExW(GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS, (LPCWSTR)mta_thread_proc, &mta_thread_hmsi);
+
+        CreateThread(NULL, 0, mta_thread_proc, NULL, 0, NULL);
+
+        WaitForSingleObject(mta_thread_started, INFINITE);
+    }
+
+    mta_thread_refcount++;
+
+    LeaveCriticalSection(&mta_thread_cs);
+}
+
+static void mta_thread_unref(void)
+{
+    if (mta_thread_enabled == 0) return;
+
+    EnterCriticalSection(&mta_thread_cs);
+
+    mta_thread_refcount--;
+
+    if (mta_thread_refcount == 0)
+        SetEvent(mta_thread_signal);
+
+    LeaveCriticalSection(&mta_thread_cs);
+}
+/* END CROSSOVER HACK BUG 11581 */
+
 typedef struct _msi_custom_action_info {
     struct list entry;
     LONG refs;
@@ -632,6 +731,9 @@
     TRACE("custom action (%x) returned %i\n", GetCurrentThreadId(), rc );
 
     MsiCloseAllHandles();
+
+    mta_thread_unref();
+
     return rc;
 }
 
@@ -657,6 +759,8 @@
     list_add_tail( &msi_pending_custom_actions, &info->entry );
     LeaveCriticalSection( &msi_custom_action_cs );
 
+    mta_thread_ref();
+
     info->handle = CreateThread( NULL, 0, DllThread, &info->guid, 0, NULL );
     if (!info->handle)
     {
diff -Naur wine-2.0a/dlls/msi/install.c wine-2.0b/dlls/msi/install.c
--- wine-2.0a/dlls/msi/install.c	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/msi/install.c	2017-07-11 20:37:50.000000000 +0100
@@ -1489,6 +1489,14 @@
     if (!comp)
         return ERROR_UNKNOWN_COMPONENT;
 
+    if (1) /* hack for office 2010 sp1 */
+    {
+        static const WCHAR sppW[] =
+            {'s','p','p','_','p','l','u','g','i','n','s','.','x','8','6',0};
+        if (!strcmpW( szComponent, sppW ) && comp->Installed == INSTALLSTATE_LOCAL &&
+            comp->Action == INSTALLSTATE_LOCAL) comp->Action = INSTALLSTATE_UNKNOWN;
+    }
+
     if (piInstalled)
     {
         if (comp->Enabled)
diff -Naur wine-2.0a/dlls/msxml3/node.c wine-2.0b/dlls/msxml3/node.c
--- wine-2.0a/dlls/msxml3/node.c	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/msxml3/node.c	2017-07-11 20:37:50.000000000 +0100
@@ -28,6 +28,13 @@
 # include <libxml/parser.h>
 # include <libxml/xmlerror.h>
 # include <libxml/HTMLtree.h>
+/*
+ * CrossOver HACK
+ * Avoid relying on presence of symbol _xmlBufContent
+ * in libxml2 on the deployment machine.
+ * For bug 12289.
+ */
+#undef LIBXML2_NEW_BUFFER
 # ifdef SONAME_LIBXSLT
 #  ifdef HAVE_LIBXSLT_PATTERN_H
 #   include <libxslt/pattern.h>
diff -Naur wine-2.0a/dlls/ntdll/directory.c wine-2.0b/dlls/ntdll/directory.c
--- wine-2.0a/dlls/ntdll/directory.c	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/ntdll/directory.c	2017-07-11 20:37:50.000000000 +0100
@@ -586,6 +586,152 @@
 #endif
 
 /***********************************************************************
+ *           get_autofs_mount_points
+ *
+ * Return a list of autofs mount points.
+ */
+static struct drive_info *get_autofs_mount_points( unsigned int *ret_count )
+{
+    struct drive_info *ret = NULL;
+
+#ifdef linux
+    unsigned int count, total;
+    struct mntent *entry;
+    struct stat st;
+    FILE *f;
+
+    if (!(f = fopen( "/etc/mtab", "r" ))) return NULL;
+    count = total = 0;
+    while ((entry = getmntent( f )))
+    {
+        if (strcmp( entry->mnt_type, "autofs" )) continue;
+        if (stat( entry->mnt_dir, &st ) == -1) continue;
+        if (count >= total)
+        {
+            total += 16;
+            if (!ret) ret = RtlAllocateHeap( GetProcessHeap(), 0, total * sizeof(*ret) );
+            else
+            {
+                void *new = RtlReAllocateHeap( GetProcessHeap(), 0, ret, total * sizeof(*ret) );
+                if (!new) RtlFreeHeap( GetProcessHeap(), 0, ret );
+                ret = new;
+            }
+            if (!ret) break;
+        }
+        ret[count].dev = st.st_dev;
+        ret[count].ino = st.st_ino;
+        count++;
+    }
+    *ret_count = count;
+    fclose( f );
+#endif
+    return ret;
+}
+
+
+/***********************************************************************
+ *           read_drive_symlink
+ *
+ * Read the symlink for a given drive and return the resulting full path.
+ */
+static char *read_drive_symlink( char *dos_device, unsigned int *prefix )
+{
+    char *buffer, *p;
+    int ret, size = 128;
+
+    if (!(p = strrchr( dos_device, '/' ))) p = dos_device;
+    else p++;
+
+    for (;;)
+    {
+        if (!(buffer = RtlAllocateHeap( GetProcessHeap(), 0, size + (p - dos_device) )))
+        {
+            errno = ENOMEM;
+            return NULL;
+        }
+        ret = readlink( dos_device, buffer, size );
+        if (ret == -1)
+        {
+            RtlFreeHeap( GetProcessHeap(), 0, buffer );
+            return NULL;
+        }
+        if (ret != size)
+        {
+            buffer[ret] = 0;
+            break;
+        }
+        RtlFreeHeap( GetProcessHeap(), 0, buffer );
+        size *= 2;
+    }
+    if (buffer[0] != '/')
+    {
+        memmove( buffer + (p - dos_device), buffer, strlen(buffer) + 1 );
+        memcpy( buffer, dos_device, p - dos_device );
+        *prefix = p - dos_device;
+    }
+    else *prefix = 0;
+    return buffer;
+}
+
+
+/***********************************************************************
+ *           is_drive_automounted
+ *
+ * Check if any element of the specified dosdevice is inside an autofs
+ * mount point and isn't currently mounted.
+ */
+static int is_drive_automounted( char *dos_device, struct drive_info *mount_points, unsigned int count )
+{
+    struct stat st;
+    unsigned int i, start;
+    char *symlink, *next, *p;
+
+    if (!(symlink = read_drive_symlink( dos_device, &start ))) return -1;
+
+    p = symlink + start;
+    while (*p == '/') p++;  /* skip leading slashes */
+    for (;;)
+    {
+        while (*p && *p != '/') p++;
+        next = p;
+        while (*next == '/') next++;
+        if (!*next) break;  /* don't stat the last element */
+        *p = 0;
+        if (stat( symlink, &st ) != -1)
+        {
+            for (i = 0; i < count; i++)
+                if (mount_points[i].dev == st.st_dev && mount_points[i].ino == st.st_ino) break;
+            if (i < count)
+            {
+                /* now check if the next path element exists, without triggering a mount */
+                struct dirent *de;
+                DIR *dir = opendir( symlink );
+                if (!dir) break;
+                while ((de = readdir( dir )))
+                {
+                    unsigned int len = strlen(de->d_name);
+                    if (!strncmp( de->d_name, next, len ) && (!next[len] || next[len] == '/'))
+                        break;
+                }
+                closedir( dir );
+                if (!de)  /* not found in the dir -> automounted */
+                {
+                    TRACE( "%s is automounted under %s\n", dos_device, symlink );
+                    RtlFreeHeap( GetProcessHeap(), 0, symlink );
+                    return 1;
+                }
+                TRACE( "%s found in %s -> already mounted\n", next, symlink );
+            }
+        }
+        *p = '/';
+        p = next;
+    }
+    RtlFreeHeap( GetProcessHeap(), 0, symlink );
+    return 0;
+}
+
+
+/***********************************************************************
  *           DIR_get_drives_info
  *
  * Retrieve device/inode number for all the drives. Helper for find_drive_root.
@@ -605,6 +751,8 @@
         char *buffer, *p;
         struct stat st;
         unsigned int i;
+        unsigned int count = 0;
+        struct drive_info *mount_points;
 
         if ((buffer = RtlAllocateHeap( GetProcessHeap(), 0,
                                        strlen(config_dir) + sizeof("/dosdevices/a:") )))
@@ -613,21 +761,27 @@
             strcat( buffer, "/dosdevices/a:" );
             p = buffer + strlen(buffer) - 2;
 
+            mount_points = get_autofs_mount_points( &count );
+
             for (i = nb_drives = 0; i < MAX_DOS_DRIVES; i++)
             {
+                cache[i].dev = 0;
+                cache[i].ino = 0;
                 *p = 'a' + i;
+                /* skip the stat for automounted drives to avoid triggering a mount */
+                if (mount_points)
+                {
+                    int res = is_drive_automounted( buffer, mount_points, count );
+                    if (res > 0 || (res == -1 && errno == ENOENT)) continue;
+                }
                 if (!stat( buffer, &st ))
                 {
                     cache[i].dev = st.st_dev;
                     cache[i].ino = st.st_ino;
                     nb_drives++;
                 }
-                else
-                {
-                    cache[i].dev = 0;
-                    cache[i].ino = 0;
-                }
             }
+            RtlFreeHeap( GetProcessHeap(), 0, mount_points );
             RtlFreeHeap( GetProcessHeap(), 0, buffer );
         }
         last_update = now;
@@ -1348,30 +1502,50 @@
 {
     static const char hash_chars[32] = "ABCDEFGHIJKLMNOPQRSTUVWXYZ012345";
 
-    LPCWSTR p, ext, end = name->Buffer + name->Length / sizeof(WCHAR);
+    LPCWSTR p, ext, hash_end, end = name->Buffer + name->Length / sizeof(WCHAR);
     LPWSTR dst;
     unsigned short hash;
     int i;
 
+    /* Find last dot for start of the extension */
+    for (p = name->Buffer + 1, ext = NULL; p < end - 1; p++) if (*p == '.') ext = p;
+
+    /* don't include the standard 3 char .ext in the filename hash */
+    hash_end = end;
+    if (ext && ((end - ext) == 4 ))
+    {
+        /*
+         * FIXME: CodeWeavers hack alert
+         * The next five lines are a nasty hack to only activate this
+         * (more correct behaviour) for Quicken files for the moment.
+         * We don't want to break our install base of programs that have
+         * shortfile names stored in the registry or elsewhere.
+         */
+        WCHAR szqdf[]={'.','q','d','f'};
+        WCHAR szqsd[]={'.','q','s','d'};
+        WCHAR szqel[]={'.','q','e','l'};
+        WCHAR szqph[]={'.','q','p','h'};
+        if (!strncmpiW(ext,szqdf,4) || !strncmpiW(ext,szqsd,4) ||
+            !strncmpiW(ext,szqph,4) || !strncmpiW(ext,szqel,4))
+            hash_end = ext;
+    }
+
     /* Compute the hash code of the file name */
     /* If you know something about hash functions, feel free to */
     /* insert a better algorithm here... */
     if (!is_case_sensitive)
     {
-        for (p = name->Buffer, hash = 0xbeef; p < end - 1; p++)
+        for (p = name->Buffer, hash = 0xbeef; p < hash_end - 1; p++)
             hash = (hash<<3) ^ (hash>>5) ^ tolowerW(*p) ^ (tolowerW(p[1]) << 8);
         hash = (hash<<3) ^ (hash>>5) ^ tolowerW(*p); /* Last character */
     }
     else
     {
-        for (p = name->Buffer, hash = 0xbeef; p < end - 1; p++)
+        for (p = name->Buffer, hash = 0xbeef; p < hash_end - 1; p++)
             hash = (hash << 3) ^ (hash >> 5) ^ *p ^ (p[1] << 8);
         hash = (hash << 3) ^ (hash >> 5) ^ *p;  /* Last character */
     }
 
-    /* Find last dot for start of the extension */
-    for (p = name->Buffer + 1, ext = NULL; p < end - 1; p++) if (*p == '.') ext = p;
-
     /* Copy first 4 chars, replacing invalid chars with '_' */
     for (i = 4, p = name->Buffer, dst = buffer; i > 0; i--, p++)
     {
diff -Naur wine-2.0a/dlls/ntdll/file.c wine-2.0b/dlls/ntdll/file.c
--- wine-2.0a/dlls/ntdll/file.c	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/ntdll/file.c	2017-07-11 20:37:50.000000000 +0100
@@ -248,6 +248,26 @@
             *handle = wine_server_ptr_handle( reply->handle );
         }
         SERVER_END_REQ;
+
+        /* BEGIN CODEWEAVERS HACK */
+        if (created)
+        {
+            static const char wininit[] = "WinInit.Ini", sc[] = { ';',';' };
+
+            if (unix_name.Length >= sizeof(wininit)-1 &&
+                !strcmp( unix_name.Buffer + unix_name.Length - (sizeof(wininit)-1), wininit ))
+            {
+                int fd;
+                if (wine_server_handle_to_fd( *handle, FILE_WRITE_DATA, &fd, NULL ) == STATUS_SUCCESS)
+                {
+                    struct stat st;
+                    if (fstat( fd, &st ) != -1 && st.st_size == 0) pwrite( fd, sc, sizeof(sc), 0 );
+                    wine_server_release_fd( *handle, fd );
+                }
+            }
+        }
+        /* END CODEWEAVERS HACK */
+
         RtlFreeHeap( GetProcessHeap(), 0, objattr );
         RtlFreeAnsiString( &unix_name );
     }
@@ -809,6 +829,30 @@
     return status;
 }
 
+static DWORD get_module_filename( WCHAR *buf, DWORD buflen )
+{
+    DWORD len = 0;
+    ULONG_PTR magic;
+    LDR_MODULE *mod;
+
+    LdrLockLoaderLock( 0, NULL, &magic );
+    if (LdrFindEntryForAddress( NtCurrentTeb()->Peb->ImageBaseAddress, &mod ) == STATUS_SUCCESS)
+    {
+        len = min( buflen - 1, mod->FullDllName.Length / sizeof(WCHAR) );
+        memcpy( buf, mod->FullDllName.Buffer, len * sizeof(WCHAR) );
+        buf[len] = 0;
+    }
+    LdrUnlockLoaderLock( 0, magic );
+    return len;
+}
+
+static BOOL is_quickenpatch(void)
+{
+    static const WCHAR qkn[] = {'q','u','i','c','k','e','n','P','a','t','c','h','.','e','x','e',0};
+    WCHAR path[MAX_PATH];
+    DWORD len = sizeof(qkn)/sizeof(qkn[0]) - 1, len2 = get_module_filename( path, MAX_PATH );
+    return (len <= len2 && !strcmpiW( path + len2 - len, qkn ));
+}
 
 /******************************************************************************
  *  NtReadFile					[NTDLL.@]
@@ -832,7 +876,7 @@
  *           The number of bytes read.
  *  Failure: An NTSTATUS error code describing the error.
  */
-NTSTATUS WINAPI NtReadFile(HANDLE hFile, HANDLE hEvent,
+NTSTATUS WINAPI rpc_NtReadFile(HANDLE hFile, HANDLE hEvent,
                            PIO_APC_ROUTINE apc, void* apc_user,
                            PIO_STATUS_BLOCK io_status, void* buffer, ULONG length,
                            PLARGE_INTEGER offset, PULONG key)
@@ -879,6 +923,9 @@
             /* async I/O doesn't make sense on regular files */
             while ((result = pread( unix_handle, buffer, length, offset->QuadPart )) == -1)
             {
+                /* CrossOver hack 14664 */
+                if (errno == EFAULT && is_quickenpatch() && virtual_check_buffer_for_write( buffer, length ))
+                    continue;
                 if (errno != EINTR)
                 {
                     status = FILE_GetNtStatus();
@@ -953,6 +1000,9 @@
         else if (errno != EAGAIN)
         {
             if (errno == EINTR) continue;
+            /* CrossOver hack 14664 */
+            if (errno == EFAULT && is_quickenpatch() && virtual_check_buffer_for_write( buffer, length ))
+                continue;
             if (!total) status = FILE_GetNtStatus();
             goto done;
         }
@@ -1031,6 +1081,13 @@
     return status;
 }
 
+NTSTATUS WINAPI NtReadFile(HANDLE hFile, HANDLE hEvent,
+                           PIO_APC_ROUTINE apc, void* apc_user,
+                           PIO_STATUS_BLOCK io_status, void* buffer, ULONG length,
+                           PLARGE_INTEGER offset, PULONG key)
+{
+    return rpc_NtReadFile(hFile, hEvent, apc, apc_user, io_status, buffer, length, offset, key);
+}
 
 /******************************************************************************
  *  NtReadFileScatter   [NTDLL.@]
diff -Naur wine-2.0a/dlls/ntdll/nt.c wine-2.0b/dlls/ntdll/nt.c
--- wine-2.0a/dlls/ntdll/nt.c	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/ntdll/nt.c	2017-07-11 20:37:50.000000000 +0100
@@ -232,6 +232,18 @@
     return ret;
 }
 
+
+/* Crossover hack tracked by bug 9315 */
+static BOOLEAN is_msmapi32_present(void)
+{
+    HMODULE dummy;
+    static const WCHAR wszMsmapi32[] = {'m','s','m','a','p','i','3','2','.','d','l','l',0};
+    UNICODE_STRING string;
+    RtlInitUnicodeString(&string, wszMsmapi32);
+    return (STATUS_SUCCESS ==
+        LdrGetDllHandle(0, 0, &string, &dummy));
+}
+
 /******************************************************************************
 *  NtQueryInformationToken		[NTDLL.@]
 *  ZwQueryInformationToken		[NTDLL.@]
@@ -354,21 +366,51 @@
                 struct token_groups *tg = buffer;
                 unsigned int *attr = (unsigned int *)(tg + 1);
                 ULONG i;
-                const int non_sid_portion = (sizeof(struct token_groups) + tg->count * sizeof(unsigned int));
-                SID *sids = (SID *)((char *)tokeninfo + FIELD_OFFSET( TOKEN_GROUPS, Groups[tg->count] ));
+                int non_sid_portion;
+                SID *sids;
+                ULONG needed_bytes;
+                static const SID service_sid = { SID_REVISION, 1, { SECURITY_NT_AUTHORITY }, { SECURITY_SERVICE_RID } };
+                BOOLEAN is_msmapi32 = is_msmapi32_present();
 
-                if (retlen) *retlen = reply->user_len;
+                /* Crossover hack tracked by bug 9315 */
+                if (is_msmapi32)
+                {
+                    non_sid_portion = (sizeof(struct token_groups) + (tg->count + 1) * sizeof(unsigned int));
+                    sids = (SID *)((char *)tokeninfo + FIELD_OFFSET( TOKEN_GROUPS, Groups[tg->count + 1] ));
+                    needed_bytes = reply->user_len +
+                        FIELD_OFFSET( TOKEN_GROUPS, Groups[tg->count + 1] ) - FIELD_OFFSET( TOKEN_GROUPS, Groups[tg->count] ) +
+                        sizeof(service_sid);
+                }
+                else
+                {
+                    non_sid_portion = (sizeof(struct token_groups) + tg->count * sizeof(unsigned int));
+                    sids = (SID *)((char *)tokeninfo + FIELD_OFFSET( TOKEN_GROUPS, Groups[tg->count] ));
+                    needed_bytes = reply->user_len;
+                }
 
-                groups->GroupCount = tg->count;
-                memcpy( sids, (char *)buffer + non_sid_portion,
-                        reply->user_len - FIELD_OFFSET( TOKEN_GROUPS, Groups[tg->count] ));
+                if (retlen) *retlen = needed_bytes;
 
-                for (i = 0; i < tg->count; i++)
+                if (needed_bytes <= tokeninfolength)
                 {
-                    groups->Groups[i].Attributes = attr[i];
-                    groups->Groups[i].Sid = sids;
-                    sids = (SID *)((char *)sids + RtlLengthSid(sids));
+                    groups->GroupCount = tg->count;
+                    memcpy( sids, (char *)buffer + non_sid_portion,
+                            reply->user_len - FIELD_OFFSET( TOKEN_GROUPS, Groups[tg->count] ));
+
+                    for (i = 0; i < tg->count; i++)
+                    {
+                        groups->Groups[i].Attributes = attr[i];
+                        groups->Groups[i].Sid = sids;
+                        sids = (SID *)((char *)sids + RtlLengthSid(sids));
+                    }
+                    if (is_msmapi32)
+                    {
+                        groups->Groups[i].Attributes = 0;
+                        groups->Groups[i].Sid = sids;
+                        groups->GroupCount++;
+                        memcpy(sids, &service_sid, sizeof(service_sid));
+                    }
                 }
+                else status = STATUS_BUFFER_TOO_SMALL;
              }
              else if (retlen) *retlen = 0;
         }
diff -Naur wine-2.0a/dlls/ntdll/ntdll.spec wine-2.0b/dlls/ntdll/ntdll.spec
--- wine-2.0a/dlls/ntdll/ntdll.spec	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/ntdll/ntdll.spec	2017-07-11 20:37:50.000000000 +0100
@@ -1491,3 +1491,6 @@
 @ cdecl wine_nt_to_unix_file_name(ptr ptr long long)
 @ cdecl wine_unix_to_nt_file_name(ptr ptr)
 @ cdecl __wine_init_windows_dir(wstr wstr)
+
+# hack
+@ stdcall rpc_NtReadFile(long long ptr ptr ptr ptr long ptr ptr)
diff -Naur wine-2.0a/dlls/ntdll/process.c wine-2.0b/dlls/ntdll/process.c
--- wine-2.0a/dlls/ntdll/process.c	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/ntdll/process.c	2017-07-11 20:37:50.000000000 +0100
@@ -91,6 +91,18 @@
 HANDLE CDECL __wine_make_process_system(void)
 {
     HANDLE ret = 0;
+
+    /*  CodeWeavers-specific hack:  We need to exclude ourselves
+        from the winewrapper's wait-children process.  So we'll
+        close the wait-children pipe if it is defined.  */
+    const char *child_pipe = getenv("WINE_WAIT_CHILD_PIPE");
+    if (child_pipe)
+    {
+        int fd = atoi(child_pipe);
+        if (fd) close( fd );
+        unsetenv("WINE_WAIT_CHILD_PIPE");
+    }
+
     SERVER_START_REQ( make_process_system )
     {
         if (!wine_server_call( req )) ret = wine_server_ptr_handle( reply->event );
@@ -271,6 +283,12 @@
                 else
                 {
                     memset(&pvmi, 0 , sizeof(VM_COUNTERS));
+                    #define ONEGIG (1024 * 1024 * 1024);
+                    pvmi.QuotaPeakPagedPoolUsage = ONEGIG;
+                    pvmi.QuotaPagedPoolUsage = ONEGIG;
+                    pvmi.QuotaPeakNonPagedPoolUsage = ONEGIG;
+                    pvmi.QuotaNonPagedPoolUsage = ONEGIG;
+                    #undef ONEGIG
                     fill_VM_COUNTERS(&pvmi);
 
                     len = ProcessInformationLength;
diff -Naur wine-2.0a/dlls/ntdll/rtlstr.c wine-2.0b/dlls/ntdll/rtlstr.c
--- wine-2.0a/dlls/ntdll/rtlstr.c	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/ntdll/rtlstr.c	2017-07-11 20:37:50.000000000 +0100
@@ -80,6 +80,10 @@
     if (unix_table)
         return wine_cp_wcstombs( unix_table, flags, src, srclen, dst, dstlen, defchar, used );
     if (used) *used = 0;  /* all chars are valid for UTF-8 */
+#ifdef __APPLE__
+    /* CodeWeavers HACK */
+    flags |= WC_COMPOSITECHECK;
+#endif
     return wine_utf8_wcstombs( flags, src, srclen, dst, dstlen );
 }
 
diff -Naur wine-2.0a/dlls/ntdll/thread.c wine-2.0b/dlls/ntdll/thread.c
--- wine-2.0a/dlls/ntdll/thread.c	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/ntdll/thread.c	2017-07-11 20:37:50.000000000 +0100
@@ -297,6 +297,7 @@
     teb->Tib.StackBase = (void *)~0UL;
     teb->StaticUnicodeString.Buffer = teb->StaticUnicodeBuffer;
     teb->StaticUnicodeString.MaximumLength = sizeof(teb->StaticUnicodeBuffer);
+    teb->ThreadLocalStoragePointer = teb->TlsSlots;
 
     thread_data = (struct ntdll_thread_data *)teb->SpareBytes1;
     thread_data->request_fd = -1;
@@ -532,6 +533,7 @@
     teb->ClientId.UniqueThread  = ULongToHandle(tid);
     teb->StaticUnicodeString.Buffer        = teb->StaticUnicodeBuffer;
     teb->StaticUnicodeString.MaximumLength = sizeof(teb->StaticUnicodeBuffer);
+    teb->ThreadLocalStoragePointer = teb->TlsSlots;
 
     /* create default activation context frame for new thread */
     RtlGetActiveActivationContext(&actctx);
@@ -1151,6 +1153,31 @@
             }
         }
         return status;
+    case ThreadIsIoPending:
+    { /* CrossOver hack for bug 14503 */
+        LDR_MODULE *pldr;
+
+        FIXME( "ThreadIsIoPending info class not supported yet\n" );
+
+        status = LdrFindEntryForAddress( NtCurrentTeb()->Peb->ImageBaseAddress, &pldr );
+        if (status == STATUS_SUCCESS)
+        {
+            static const WCHAR qwexe[] = {'q','w','.','e','x','e'};
+            int i, len = pldr->FullDllName.Length/sizeof(WCHAR);
+
+            for (i = 0; i < len; i++)
+                if (pldr->FullDllName.Buffer[len-i-1] == '\\') break;
+            if (i >= sizeof(qwexe)/sizeof(WCHAR) && !memcmp(pldr->FullDllName.Buffer+len-i, qwexe, sizeof(qwexe)))
+            {
+                FIXME("Quicken ThreadIsIoPending hack\n");
+                if (length != sizeof(BOOL)) return STATUS_INFO_LENGTH_MISMATCH;
+                *(BOOL*)data = FALSE;
+                if (ret_len) *ret_len = sizeof(BOOL);
+                return STATUS_SUCCESS;
+            }
+        }
+        return STATUS_NOT_IMPLEMENTED;
+    }
     case ThreadPriority:
     case ThreadBasePriority:
     case ThreadImpersonationToken:
@@ -1161,7 +1188,6 @@
     case ThreadIdealProcessor:
     case ThreadPriorityBoost:
     case ThreadSetTlsArrayAddress:
-    case ThreadIsIoPending:
     default:
         FIXME( "info class %d not supported yet\n", class );
         return STATUS_NOT_IMPLEMENTED;
diff -Naur wine-2.0a/dlls/ntdll/version.c wine-2.0b/dlls/ntdll/version.c
--- wine-2.0a/dlls/ntdll/version.c	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/ntdll/version.c	2017-07-11 20:37:50.000000000 +0100
@@ -429,25 +429,15 @@
 
 
 /**********************************************************************
- *         parse_win_version
- *
- * Parse the contents of the Version key.
+ *         parse_version_string
  */
-static BOOL parse_win_version( HANDLE hkey )
+static BOOL parse_version_string( const WCHAR *str, DWORD length )
 {
-    static const WCHAR VersionW[] = {'V','e','r','s','i','o','n',0};
-
-    UNICODE_STRING valueW;
-    char tmp[64], buffer[50];
-    KEY_VALUE_PARTIAL_INFORMATION *info = (KEY_VALUE_PARTIAL_INFORMATION *)tmp;
-    DWORD count, len;
     int i;
+    DWORD len;
+    char buffer[50];
 
-    RtlInitUnicodeString( &valueW, VersionW );
-    if (NtQueryValueKey( hkey, &valueW, KeyValuePartialInformation, tmp, sizeof(tmp), &count ))
-        return FALSE;
-
-    RtlUnicodeToMultiByteN( buffer, sizeof(buffer)-1, &len, (WCHAR *)info->Data, info->DataLength );
+    RtlUnicodeToMultiByteN( buffer, sizeof(buffer)-1, &len, str, length );
     buffer[len] = 0;
 
     for (i = 0; i < NB_WINDOWS_VERSIONS; i++)
@@ -481,6 +471,27 @@
     return FALSE;
 }
 
+/**********************************************************************
+ *         parse_win_version
+ *
+ * Parse the contents of the Version key.
+ */
+static BOOL parse_win_version( HKEY hkey )
+{
+    static const WCHAR VersionW[] = {'V','e','r','s','i','o','n',0};
+
+    UNICODE_STRING valueW;
+    char tmp[64];
+    KEY_VALUE_PARTIAL_INFORMATION *info = (KEY_VALUE_PARTIAL_INFORMATION *)tmp;
+    DWORD count;
+
+    RtlInitUnicodeString( &valueW, VersionW );
+    if (NtQueryValueKey( hkey, &valueW, KeyValuePartialInformation, tmp, sizeof(tmp), &count ))
+        return FALSE;
+
+    return parse_version_string( (WCHAR *)info->Data, info->DataLength );
+}
+
 
 /**********************************************************************
  *         version_init
@@ -500,6 +511,23 @@
     else
         current_version = &VersionData[WINXP];
 
+    /* awful CrossOver hack^H^H^H^Hproprietary enhancement */
+    {
+        static const WCHAR cxverW[] = {'C','X','_','W','I','N','D','O','W','S','_','V','E','R','S','I','O','N',0};
+        UNICODE_STRING valueW;
+        WCHAR cxversion[32];
+
+        RtlInitUnicodeString( &nameW, cxverW );
+        valueW.MaximumLength = sizeof(cxversion);
+        valueW.Buffer = cxversion;
+        if (RtlQueryEnvironmentVariable_U(NULL, &nameW, &valueW) == STATUS_SUCCESS)
+        {
+            TRACE( "getting version from CX_WINDOWS_VERSION\n" );
+            got_win_ver = parse_version_string( cxversion, strlenW(cxversion) * sizeof(WCHAR) );
+            goto done;
+        }
+    }
+
     RtlOpenCurrentUser( KEY_ALL_ACCESS, &root );
     attr.Length = sizeof(attr);
     attr.RootDirectory = root;
diff -Naur wine-2.0a/dlls/ntdll/virtual.c wine-2.0b/dlls/ntdll/virtual.c
--- wine-2.0a/dlls/ntdll/virtual.c	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/ntdll/virtual.c	2017-07-11 20:37:50.000000000 +0100
@@ -152,6 +152,8 @@
 static BOOL use_locks;
 static BOOL force_exec_prot;  /* whether to force PROT_EXEC on all PROT_READ mmaps */
 
+static struct file_view *hack_view;
+
 
 /***********************************************************************
  *           VIRTUAL_GetProtStr
@@ -438,6 +440,7 @@
  */
 static void delete_view( struct file_view *view ) /* [in] View */
 {
+    if (view == hack_view) return;
     if (!(view->protect & VPROT_SYSTEM)) unmap_area( view->base, view->size );
     list_remove( &view->entry );
     if (view->mapping) close_handle( view->mapping );
@@ -2542,6 +2545,7 @@
     HANDLE dup_mapping, shared_file;
     LARGE_INTEGER offset;
     sigset_t sigset;
+    int hack_val = 0;
 
     offset.QuadPart = offset_ptr ? offset_ptr->QuadPart : 0;
 
@@ -2564,6 +2568,34 @@
     if ((offset.u.LowPart & mask) || (*addr_ptr && ((UINT_PTR)*addr_ptr & mask)))
         return STATUS_MAPPED_ALIGNMENT;
 
+    /******************* CODEWEAVERS HACKS START HERE *******************
+     *
+     *  This happens with the section generated by
+     * msmapi32.dll in Windows 9x.  This hack detects that section by name.
+     *
+     * PROBLEM
+     *
+     * In Windows 9x, two mappings of the same section result in
+     *  the same pointer across threads and processes.
+     *
+     * In Wine this is hard to duplicate across processes, so
+     *  just try and do it in one process for the time being
+     */
+    {
+        static const WCHAR cw_magic[] = { 'M','A','P','I','-','H','P','!' };
+        char buffer[1024];
+        ULONG len;
+        if (!NtQueryObject( handle, ObjectNameInformation, buffer, sizeof(buffer), &len ))
+        {
+            OBJECT_NAME_INFORMATION *info = (OBJECT_NAME_INFORMATION *)buffer;
+            if (info->Name.Length >= sizeof(cw_magic) &&
+                !memcmp( info->Name.Buffer + (info->Name.Length - sizeof(cw_magic)) / sizeof(WCHAR),
+                         cw_magic, sizeof(cw_magic) ))
+                hack_val = 1;
+        }
+    }
+    /******************* CODEWEAVERS HACKS END HERE ********************/
+
     switch(protect)
     {
     case PAGE_NOACCESS:
@@ -2692,6 +2724,18 @@
 
     server_enter_uninterrupted_section( &csVirtual, &sigset );
 
+    /******************* CODEWEAVERS HACKS START HERE *******************/
+    if (hack_val && hack_view)
+    {
+        TRACE("Trying to be compatible with win9x mapping\n");
+        *size_ptr = hack_view->size;
+        *addr_ptr = hack_view->base;
+        res = STATUS_SUCCESS;
+        server_leave_uninterrupted_section( &csVirtual, &sigset );
+        goto done;
+    }
+    /******************* CODEWEAVERS HACKS END HERE ********************/
+
     get_vprot_flags( protect, &vprot, sec_flags & SEC_IMAGE );
     vprot |= (map_vprot & VPROT_COMMITTED);
     res = map_view( &view, *addr_ptr, size, mask, FALSE, vprot );
@@ -2714,6 +2758,7 @@
         view->mapping = dup_mapping;
         view->map_protect = map_vprot;
         dup_mapping = 0;  /* don't close it */
+        if (hack_val) hack_view = view;
     }
     else
     {
diff -Naur wine-2.0a/dlls/ole32/compobj.c wine-2.0b/dlls/ole32/compobj.c
--- wine-2.0a/dlls/ole32/compobj.c	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/ole32/compobj.c	2017-07-11 20:37:50.000000000 +0100
@@ -490,6 +490,24 @@
     return ret;
 }
 
+static BOOL is_olmapi32( const WCHAR *library_name )
+{
+    static const WCHAR olmapi32[] = {'o','l','m','a','p','i','3','2','.','d','l','l',0};
+    DWORD len = sizeof(olmapi32)/sizeof(olmapi32[0]) - 1, len2 = strlenW( library_name );
+    return (len <= len2 && !strcmpiW( library_name + len2 - len, olmapi32 ));
+}
+
+static BOOL is_outlook(void)
+{
+    static const WCHAR ol2010[] =
+        {'o','f','f','i','c','e','1','4','\\','o','u','t','l','o','o','k','.','e','x','e',0};
+    static const WCHAR ol2013[] =
+        {'o','f','f','i','c','e','1','5','\\','o','u','t','l','o','o','k','.','e','x','e',0};
+    WCHAR path[MAX_PATH];
+    DWORD len = sizeof(ol2010)/sizeof(ol2010[0]) - 1, len2 = GetModuleFileNameW( NULL, path, MAX_PATH );
+    return (len <= len2 && (!strcmpiW( path + len2 - len, ol2010 ) || !strcmpiW( path + len2 - len, ol2013 )));
+}
+
 /* caller must ensure that library_name is not already in the open dll list */
 static HRESULT COMPOBJ_DllList_Add(LPCWSTR library_name, OpenDll **ret)
 {
@@ -514,6 +532,12 @@
         /* failure: DLL could not be loaded */
         return E_ACCESSDENIED; /* FIXME: or should this be CO_E_DLLNOTFOUND? */
     }
+    if (is_olmapi32( library_name ) && is_outlook()) /* CrossOver hack bug 14243 */
+    {
+        HRESULT (WINAPI *pMAPIInitialize)(void *) = (void *)GetProcAddress( hLibrary, "MAPIInitialize" );
+        FIXME( "HACK: calling olmapi32.MAPIInitialize\n" );
+        pMAPIInitialize( NULL );
+    }
 
     DllCanUnloadNow = (void *)GetProcAddress(hLibrary, "DllCanUnloadNow");
     /* Note: failing to find DllCanUnloadNow is not a failure */
@@ -3546,7 +3570,10 @@
         return;
     }
 
-    apartment_freeunusedlibraries(apt, dwUnloadDelay);
+    /* CODEWEAVERS HACK for Office 2003: Don't call
+     * apartment_freeunusedlibraries as it appears to do something the app
+     * doesn't expect and free a module that is in-use */
+    if (0) apartment_freeunusedlibraries(apt, dwUnloadDelay);
 }
 
 /***********************************************************************
diff -Naur wine-2.0a/dlls/ole32/defaulthandler.c wine-2.0b/dlls/ole32/defaulthandler.c
--- wine-2.0a/dlls/ole32/defaulthandler.c	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/ole32/defaulthandler.c	2017-07-11 20:37:50.000000000 +0100
@@ -254,7 +254,10 @@
   if (*ppvObject == NULL)
   {
     WARN( "() : asking for unsupported interface %s\n", debugstr_guid(riid));
-    return E_NOINTERFACE;
+    /* native returns CO_E_OBJNOTCONNECTED here instead of E_NOINTERFACE, since
+     * the latter means that an interface will *never* be supported, but it
+     * could be supported later when we connect to the delegate object */
+    return CO_E_OBJNOTCONNECTED;
   }
 
   /*
diff -Naur wine-2.0a/dlls/ole32/ole2.c wine-2.0b/dlls/ole32/ole2.c
--- wine-2.0a/dlls/ole32/ole2.c	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/ole32/ole2.c	2017-07-11 20:37:50.000000000 +0100
@@ -2484,6 +2484,18 @@
 
     hres = CoCreateInstance(rclsid, 0, CLSCTX_INPROC_SERVER|CLSCTX_INPROC_HANDLER, riid, (LPVOID*)&pUnk);
 
+    /*
+     * If that fails, as it will most times, load the default
+     * OLE handler.
+     */
+    if (FAILED(hres))
+    {
+        hres = OleCreateDefaultHandler(rclsid,
+				   NULL,
+				   riid,
+				   (void**)&pUnk);
+    }
+
     if (SUCCEEDED(hres))
         hres = IStorage_SetClass(pStg, rclsid);
 
diff -Naur wine-2.0a/dlls/ole32/usrmarshal.c wine-2.0b/dlls/ole32/usrmarshal.c
--- wine-2.0a/dlls/ole32/usrmarshal.c	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/ole32/usrmarshal.c	2017-07-11 20:37:50.000000000 +0100
@@ -2121,16 +2121,16 @@
     IClassFactory* This,
     BOOL fLock)
 {
-    FIXME(":stub\n");
-    return E_NOTIMPL;
+    TRACE("(%s)\n", fLock ? "TRUE" : "FALSE");
+    return S_OK; /* like native, ignore LockServer requests */
 }
 
 HRESULT __RPC_STUB IClassFactory_LockServer_Stub(
     IClassFactory* This,
     BOOL fLock)
 {
-    FIXME(":stub\n");
-    return E_NOTIMPL;
+    TRACE("(%s)\n", fLock ? "TRUE" : "FALSE");
+    return IClassFactory_LockServer(This, fLock);
 }
 
 /* call_as/local stubs for objidl.idl */
@@ -2870,8 +2870,11 @@
     IOleInPlaceUIWindow *pUIWindow,
     BOOL fFrameWindow)
 {
-    FIXME(":stub\n");
-    return E_NOTIMPL;
+    TRACE("(%p, %p, %d)\n", prcBorder, pUIWindow, fFrameWindow);
+    return IOleInPlaceActiveObject_RemoteResizeBorder_Proxy(
+        This, prcBorder,
+        fFrameWindow ? &IID_IOleInPlaceFrame : &IID_IOleInPlaceUIWindow,
+        pUIWindow, fFrameWindow);
 }
 
 HRESULT __RPC_STUB IOleInPlaceActiveObject_ResizeBorder_Stub(
@@ -2881,8 +2884,8 @@
     IOleInPlaceUIWindow *pUIWindow,
     BOOL fFrameWindow)
 {
-    FIXME(":stub\n");
-    return E_NOTIMPL;
+    TRACE("(%p, %s, %p, %d)\n", prcBorder, debugstr_guid(riid), pUIWindow, fFrameWindow);
+    return IOleInPlaceActiveObject_ResizeBorder(This, prcBorder, pUIWindow, fFrameWindow);
 }
 
 HRESULT CALLBACK IOleCache2_UpdateCache_Proxy(
diff -Naur wine-2.0a/dlls/oleacc/Makefile.in wine-2.0b/dlls/oleacc/Makefile.in
--- wine-2.0a/dlls/oleacc/Makefile.in	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/oleacc/Makefile.in	2017-07-11 20:37:50.000000000 +0100
@@ -13,3 +13,4 @@
 RC_SRCS = oleacc.rc
 
 dlldata_EXTRADEFS = -DENTRY_PREFIX=OLEACC_ -DPROXY_DELEGATION -DWINE_REGISTER_DLL
+propservice_EXTRADEFS = $(FORCE_ALIGN_ARG_BUG_CFLAGS)
diff -Naur wine-2.0a/dlls/oleaut32/typelib.c wine-2.0b/dlls/oleaut32/typelib.c
--- wine-2.0a/dlls/oleaut32/typelib.c	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/oleaut32/typelib.c	2017-07-11 20:37:50.000000000 +0100
@@ -8493,14 +8493,15 @@
     return ITypeInfo2_Release(&This->ITypeInfo2_iface);
 }
 
-static HRESULT WINAPI ITypeComp_fnBind(
+static HRESULT ITypeComp_internalBind(
     ITypeComp * iface,
     OLECHAR * szName,
     ULONG lHash,
     WORD wFlags,
     ITypeInfo ** ppTInfo,
     DESCKIND * pDescKind,
-    BINDPTR * pBindPtr)
+    BINDPTR * pBindPtr,
+    BOOL dispinterface)
 {
     ITypeInfoImpl *This = info_impl_from_ITypeComp(iface);
     const TLBFuncDesc *pFDesc;
@@ -8530,7 +8531,7 @@
         HRESULT hr = TLB_AllocAndInitFuncDesc(
             &pFDesc->funcdesc,
             &pBindPtr->lpfuncdesc,
-            This->typeattr.typekind == TKIND_DISPATCH);
+            dispinterface || This->typeattr.typekind == TKIND_DISPATCH);
         if (FAILED(hr))
             return hr;
         *pDescKind = DESCKIND_FUNCDESC;
@@ -8563,7 +8564,19 @@
         }
         if (SUCCEEDED(hr))
         {
-            hr = ITypeComp_Bind(pTComp, szName, lHash, wFlags, ppTInfo, pDescKind, pBindPtr);
+            /* CROSSOVER HACK: Bug 5536
+
+            Excel includes some dispatch types that "implement" interfaces but
+            really only implement the interface functions as dispatch functions.
+            I believe this is generally true of dispatch types that implement
+            interfaces and are not dual. Windows returns funcdesc's for dispatch
+            functions instead of virtual functions for Excel's types, but due to
+            an unrelated bug I can't write a good test for it. Also, this is a
+            really hacky way to do it. */
+            if (This->typeattr.typekind == TKIND_DISPATCH &&
+                (This->typeattr.wTypeFlags & TYPEFLAG_FDUAL) == 0)
+                dispinterface = 1;
+            hr = ITypeComp_internalBind(pTComp, szName, lHash, wFlags, ppTInfo, pDescKind, pBindPtr, dispinterface);
             ITypeComp_Release(pTComp);
             if (SUCCEEDED(hr) && *pDescKind == DESCKIND_FUNCDESC &&
                     This->typeattr.typekind == TKIND_DISPATCH)
@@ -8582,6 +8595,18 @@
     return hr;
 }
 
+static HRESULT WINAPI ITypeComp_fnBind(
+    ITypeComp * iface,
+    OLECHAR * szName,
+    ULONG lHash,
+    WORD wFlags,
+    ITypeInfo ** ppTInfo,
+    DESCKIND * pDescKind,
+    BINDPTR * pBindPtr)
+{
+    return ITypeComp_internalBind(iface, szName, lHash, wFlags, ppTInfo, pDescKind, pBindPtr, 0);
+}
+
 static HRESULT WINAPI ITypeComp_fnBindType(
     ITypeComp * iface,
     OLECHAR * szName,
diff -Naur wine-2.0a/dlls/opengl32/make_opengl wine-2.0b/dlls/opengl32/make_opengl
--- wine-2.0a/dlls/opengl32/make_opengl	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/opengl32/make_opengl	2017-07-11 20:37:50.000000000 +0100
@@ -611,6 +611,181 @@
     "wglSwapBuffers" => [ "BOOL", [ [ "HDC", "hdc" ] ] ],
    );
 
+# CrossOver Hack 10798
+my %glu_functions =
+   (
+    "gluBeginCurve" => [ "void", [ [ "void*", "nurb" ] ], "GLU" ],
+    "gluBeginPolygon" => [ "void", [ [ "void*", "tess" ] ], "GLU" ],
+    "gluBeginSurface" => [ "void", [ [ "void*", "nurb" ] ], "GLU" ],
+    "gluBeginTrim" => [ "void", [ [ "void*", "nurb" ] ], "GLU" ],
+    "gluBuild1DMipmaps" => [ "GLint", [ [ "GLenum", "target" ],
+                                        [ "GLint", "internalFormat" ],
+                                        [ "GLsizei", "width" ],
+                                        [ "GLenum", "format" ],
+                                        [ "GLenum", "type" ],
+                                        [ "const void *", "data" ] ], "GLU" ],
+    "gluBuild2DMipmaps" => [ "GLint", [ [ "GLenum", "target" ],
+                                        [ "GLint", "internalFormat" ],
+                                        [ "GLsizei", "width" ],
+                                        [ "GLsizei", "height" ],
+                                        [ "GLenum", "format" ],
+                                        [ "GLenum", "type" ],
+                                        [ "const void *", "data" ] ], "GLU" ],
+    "gluCylinder" => [ "void", [ [ "void*", "quad" ],
+                                 [ "GLdouble", "base" ],
+                                 [ "GLdouble", "top" ],
+                                 [ "GLdouble", "height" ],
+                                 [ "GLint", "slices" ],
+                                 [ "GLint", "stacks" ] ], "GLU" ],
+    "gluDeleteNurbsRenderer" => [ "void", [ [ "void*", "nurb" ] ], "GLU" ],
+    "gluDeleteQuadric" => [ "void", [ [ "void*", "quad" ] ], "GLU" ],
+    "gluDeleteTess" => [ "void", [ [ "void*", "tess" ] ], "GLU" ],
+    "gluDisk" => [ "void", [ [ "void*", "quad" ],
+                             [ "GLdouble", "inner" ],
+                             [ "GLdouble", "outer" ],
+                             [ "GLint", "slices" ],
+                             [ "GLint", "loops" ] ], "GLU" ],
+    "gluEndCurve" => [ "void", [ [ "void*", "nurb" ] ], "GLU" ],
+    "gluEndPolygon" => [ "void", [ [ "void*", "tess" ] ], "GLU" ],
+    "gluEndSurface" => [ "void", [ [ "void*", "nurb" ] ], "GLU" ],
+    "gluEndTrim" => [ "void", [ [ "void*", "nurb" ] ], "GLU" ],
+    "gluErrorString" => [ "const GLubyte *", [ [ "GLenum", "error" ] ], "GLU" ],
+    "gluGetNurbsProperty" => [ "void", [ [ "void*", "nurb" ],
+                                         [ "GLenum", "property" ],
+                                         [ "GLfloat*", "data" ] ], "GLU" ],
+    "gluGetString" => [ "const GLubyte *", [ [ "GLenum", "name" ] ], "GLU" ],
+    "gluGetTessProperty" => [ "void", [ [ "void*", "tess" ],
+                                        [ "GLenum", "which" ],
+                                        [ "GLdouble*", "data" ] ], "GLU" ],
+    "gluLoadSamplingMatrices" => [ "void", [ [ "void*", "nurb" ],
+                                             [ "const GLfloat *", "model" ],
+                                             [ "const GLfloat *", "perspective" ],
+                                             [ "const GLint *", "view" ] ], "GLU" ],
+    "gluLookAt" => [ "void", [ [ "GLdouble", "eyeX" ],
+                               [ "GLdouble", "eyeY" ],
+                               [ "GLdouble", "eyeZ" ],
+                               [ "GLdouble", "centerX" ],
+                               [ "GLdouble", "centerY" ],
+                               [ "GLdouble", "centerZ" ],
+                               [ "GLdouble", "upX" ],
+                               [ "GLdouble", "upY" ],
+                               [ "GLdouble", "upZ" ] ], "GLU" ],
+    "gluNewNurbsRenderer" => [ "void*", [ ], "GLU" ],
+    "gluNewQuadric" => [ "void*", [ ], "GLU" ],
+    "gluNewTess" => [ "void*", [ ], "GLU" ],
+    "gluNextContour" => [ "void", [ [ "void*", "tess" ],
+                                    [ "GLenum", "type" ] ], "GLU" ],
+    "gluNurbsCallback" => [ "void", [ [ "void*", "nurb" ],
+                                      [ "GLenum", "which" ],
+                                      [ "void *", "CallBackFunc" ] ], "GLU" ],
+    "gluNurbsCurve" => [ "void", [ [ "void*", "nurb" ],
+                                   [ "GLint", "knotCount" ],
+                                   [ "GLfloat *", "knots" ],
+                                   [ "GLint", "stride" ],
+                                   [ "GLfloat *", "control" ],
+                                   [ "GLint", "order" ],
+                                   [ "GLenum", "type" ] ], "GLU" ],
+    "gluNurbsProperty" => [ "void", [ [ "void*", "nurb" ],
+                                      [ "GLenum", "property" ],
+                                      [ "GLfloat", "value" ] ], "GLU" ],
+    "gluNurbsSurface" => [ "void", [ [ "void*", "nurb" ],
+                                     [ "GLint", "sKnotCount" ],
+                                     [ "GLfloat*", "sKnots" ],
+                                     [ "GLint", "tKnotCount" ],
+                                     [ "GLfloat*", "tKnots" ],
+                                     [ "GLint", "sStride" ],
+                                     [ "GLint", "tStride" ],
+                                     [ "GLfloat*", "control" ],
+                                     [ "GLint", "sOrder" ],
+                                     [ "GLint", "tOrder" ],
+                                     [ "GLenum", "type" ] ], "GLU" ],
+    "gluOrtho2D" => [ "void", [ [ "GLdouble", "left" ],
+                                [ "GLdouble", "right" ],
+                                [ "GLdouble", "bottom" ],
+                                [ "GLdouble", "top" ] ], "GLU" ],
+    "gluPartialDisk" => [ "void", [ [ "void*", "quad" ],
+                                    [ "GLdouble", "inner" ],
+                                    [ "GLdouble", "outer" ],
+                                    [ "GLint", "slices" ],
+                                    [ "GLint", "loops" ],
+                                    [ "GLdouble", "start" ],
+                                    [ "GLdouble", "sweep" ] ], "GLU" ],
+    "gluPerspective" => [ "void", [ [ "GLdouble", "fovy" ],
+                                    [ "GLdouble", "aspect" ],
+                                    [ "GLdouble", "zNear" ],
+                                    [ "GLdouble", "zFar" ] ], "GLU" ],
+    "gluPickMatrix" => [ "void", [ [ "GLdouble", "x" ],
+                                   [ "GLdouble", "y" ],
+                                   [ "GLdouble", "delX" ],
+                                   [ "GLdouble", "delY" ],
+                                   [ "GLint *", "viewport" ] ], "GLU" ],
+    "gluProject" => [ "GLint", [ [ "GLdouble", "objX" ],
+                                 [ "GLdouble", "objY" ],
+                                 [ "GLdouble", "objZ" ],
+                                 [ "const GLdouble *", "model" ],
+                                 [ "const GLdouble *", "proj" ],
+                                 [ "const GLint *", "view" ],
+                                 [ "GLdouble*", "winX" ],
+                                 [ "GLdouble*", "winY" ],
+                                 [ "GLdouble*", "winZ" ] ], "GLU" ],
+    "gluPwlCurve" => [ "void", [ [ "void*", "nurb" ],
+                                 [ "GLint", "count" ],
+                                 [ "GLfloat*", "data" ],
+                                 [ "GLint", "stride" ],
+                                 [ "GLenum", "type" ] ], "GLU" ],
+    "gluQuadricCallback" => [ "void", [ [ "void*", "quad" ],
+                                        [ "GLenum", "which" ],
+                                        [ "void *", "CallBackFunc" ] ], "GLU" ],
+    "gluQuadricDrawStyle" => [ "void", [ [ "void*", "quad" ],
+                                         [ "GLenum", "draw" ] ], "GLU" ],
+    "gluQuadricNormals" => [ "void", [ [ "void*", "quad" ],
+                                       [ "GLenum", "normal" ] ], "GLU" ],
+    "gluQuadricOrientation" => [ "void", [ [ "void*", "quad" ],
+                                           [ "GLenum", "orientation" ] ], "GLU" ],
+    "gluQuadricTexture" => [ "void", [ [ "void*", "quad" ],
+                                       [ "GLboolean", "texture" ] ], "GLU" ],
+    "gluScaleImage" => [ "GLint", [ [ "GLenum", "format" ],
+                                    [ "GLsizei", "wIn" ],
+                                    [ "GLsizei", "hIn" ],
+                                    [ "GLenum", "typeIn" ],
+                                    [ "const void *", "dataIn" ],
+                                    [ "GLsizei", "wOut" ],
+                                    [ "GLsizei", "hOut" ],
+                                    [ "GLenum", "typeOut" ],
+                                    [ "GLvoid*", "dataOut" ] ], "GLU" ],
+    "gluSphere" => [ "void", [ [ "void*", "quad" ],
+                               [ "GLdouble", "radius" ],
+                               [ "GLint", "slices" ],
+                               [ "GLint", "stacks" ] ], "GLU" ],
+    "gluTessBeginContour" => [ "void", [ [ "void*", "tess" ] ], "GLU" ],
+    "gluTessBeginPolygon" => [ "void", [ [ "void*", "tess" ],
+                                         [ "GLvoid*", "data" ] ], "GLU" ],
+    "gluTessCallback" => [ "void", [ [ "void*", "tess" ],
+                                     [ "GLenum", "which" ],
+                                     [ "void *", "CallBackFunc" ] ], "GLU" ],
+    "gluTessEndContour" => [ "void", [ [ "void*", "tess" ] ], "GLU" ],
+    "gluTessEndPolygon" => [ "void", [ [ "void*", "tess" ] ], "GLU" ],
+    "gluTessNormal" => [ "void", [ [ "void*", "tess" ],
+                                   [ "GLdouble", "valueX" ],
+                                   [ "GLdouble", "valueY" ],
+                                   [ "GLdouble", "valueZ" ] ], "GLU" ],
+    "gluTessProperty" => [ "void", [ [ "void*", "tess" ],
+                                     [ "GLenum", "which" ],
+                                     [ "GLdouble", "data" ] ], "GLU" ],
+    "gluTessVertex" => [ "void", [ [ "void*", "tess" ],
+                                   [ "GLdouble *", "location" ],
+                                   [ "GLvoid*", "data" ] ], "GLU" ],
+    "gluUnProject" => [ "GLint", [ [ "GLdouble", "winX" ],
+                                   [ "GLdouble", "winY" ],
+                                   [ "GLdouble", "winZ" ],
+                                   [ "const GLdouble *", "model" ],
+                                   [ "const GLdouble *", "proj" ],
+                                   [ "const GLint *", "view" ],
+                                   [ "GLdouble*", "objX" ],
+                                   [ "GLdouble*", "objY" ],
+                                   [ "GLdouble*", "objZ" ] ], "GLU" ],
+   );
+
 my %supported_wgl_extensions =
    (
     "WGL_ARB_create_context" => 1,
@@ -813,6 +988,14 @@
     printf HEADER "        %s;\n", get_func_proto("(WINE_GLAPI *p_%s)", $_, $ext_functions{$_});
 }
 print HEADER "    } ext;\n";
+
+# CrossOver Hack 10798
+print HEADER "    struct\n    {\n";
+foreach (sort keys %glu_functions)
+{
+    printf HEADER "        %s;\n", get_func_proto("(WINE_GLAPI *p_%s)", $_, $glu_functions{$_});
+}
+print HEADER "    } glu;\n";
 print HEADER "};\n\n";
 
 print HEADER "#define ALL_WGL_FUNCS";
@@ -823,6 +1006,14 @@
 }
 print HEADER "\n\n";
 
+# CrossOver Hack 10798
+print HEADER "#define ALL_GLU_FUNCS";
+foreach (sort keys %glu_functions)
+{
+    printf HEADER " \\\n    USE_GL_FUNC(\%s)", $_;
+}
+print HEADER "\n\n";
+
 print HEADER "extern struct opengl_funcs * CDECL __wine_get_wgl_driver( HDC hdc, UINT version );\n";
 print HEADER "extern BOOL CDECL __wine_set_pixel_format( HWND hwnd, int format );\n\n";
 print HEADER "#endif /* __WINE_WGL_DRIVER_H */\n";
@@ -943,6 +1134,10 @@
 foreach (sort keys %ext_functions) {
     print NORM generate_null_func($_, $ext_functions{$_});
 }
+# CrossOver Hack 10798
+foreach (sort keys %glu_functions) {
+    print NORM generate_null_func($_, $glu_functions{$_});
+}
 
 print NORM "\nstruct opengl_funcs null_opengl_funcs =\n{\n    {\n";
 foreach (sort keys %wgl_functions) { print NORM "        null_$_,\n"; }
@@ -950,6 +1145,9 @@
 foreach (sort keys %norm_functions) { print NORM "        null_$_,\n" unless $_ eq "glDebugEntry"; }
 print NORM "    },\n    {\n";
 foreach (sort keys %ext_functions) { print NORM "        null_$_,\n"; }
+# CrossOver Hack 10798
+print NORM "    },\n    {\n";
+foreach (sort keys %glu_functions) { print NORM "        null_$_,\n"; }
 print NORM "    }\n};\n";
 
 close(NORM);
diff -Naur wine-2.0a/dlls/opengl32/opengl_norm.c wine-2.0b/dlls/opengl32/opengl_norm.c
--- wine-2.0a/dlls/opengl32/opengl_norm.c	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/opengl32/opengl_norm.c	2017-07-11 20:37:50.000000000 +0100
@@ -5942,6 +5942,58 @@
 static BOOL null_wglSetPbufferAttribARB( struct wgl_pbuffer * hPbuffer, const int* piAttribList ) { return 0; }
 static BOOL null_wglSetPixelFormatWINE( HDC hdc, int format ) { return 0; }
 static BOOL null_wglSwapIntervalEXT( int interval ) { return 0; }
+/* CrossOver Hack 10798 */
+static void null_gluBeginCurve( void* nurb ) { }
+static void null_gluBeginPolygon( void* tess ) { }
+static void null_gluBeginSurface( void* nurb ) { }
+static void null_gluBeginTrim( void* nurb ) { }
+static GLint null_gluBuild1DMipmaps( GLenum target, GLint internalFormat, GLsizei width, GLenum format, GLenum type, const void * data ) { return 0; }
+static GLint null_gluBuild2DMipmaps( GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLenum format, GLenum type, const void * data ) { return 0; }
+static void null_gluCylinder( void* quad, GLdouble base, GLdouble top, GLdouble height, GLint slices, GLint stacks ) { }
+static void null_gluDeleteNurbsRenderer( void* nurb ) { }
+static void null_gluDeleteQuadric( void* quad ) { }
+static void null_gluDeleteTess( void* tess ) { }
+static void null_gluDisk( void* quad, GLdouble inner, GLdouble outer, GLint slices, GLint loops ) { }
+static void null_gluEndCurve( void* nurb ) { }
+static void null_gluEndPolygon( void* tess ) { }
+static void null_gluEndSurface( void* nurb ) { }
+static void null_gluEndTrim( void* nurb ) { }
+static const GLubyte * null_gluErrorString( GLenum error ) { return 0; }
+static void null_gluGetNurbsProperty( void* nurb, GLenum property, GLfloat* data ) { }
+static const GLubyte * null_gluGetString( GLenum name ) { return 0; }
+static void null_gluGetTessProperty( void* tess, GLenum which, GLdouble* data ) { }
+static void null_gluLoadSamplingMatrices( void* nurb, const GLfloat * model, const GLfloat * perspective, const GLint * view ) { }
+static void null_gluLookAt( GLdouble eyeX, GLdouble eyeY, GLdouble eyeZ, GLdouble centerX, GLdouble centerY, GLdouble centerZ, GLdouble upX, GLdouble upY, GLdouble upZ ) { }
+static void* null_gluNewNurbsRenderer( void ) { return 0; }
+static void* null_gluNewQuadric( void ) { return 0; }
+static void* null_gluNewTess( void ) { return 0; }
+static void null_gluNextContour( void* tess, GLenum type ) { }
+static void null_gluNurbsCallback( void* nurb, GLenum which, void * CallBackFunc ) { }
+static void null_gluNurbsCurve( void* nurb, GLint knotCount, GLfloat * knots, GLint stride, GLfloat * control, GLint order, GLenum type ) { }
+static void null_gluNurbsProperty( void* nurb, GLenum property, GLfloat value ) { }
+static void null_gluNurbsSurface( void* nurb, GLint sKnotCount, GLfloat* sKnots, GLint tKnotCount, GLfloat* tKnots, GLint sStride, GLint tStride, GLfloat* control, GLint sOrder, GLint tOrder, GLenum type ) { }
+static void null_gluOrtho2D( GLdouble left, GLdouble right, GLdouble bottom, GLdouble top ) { }
+static void null_gluPartialDisk( void* quad, GLdouble inner, GLdouble outer, GLint slices, GLint loops, GLdouble start, GLdouble sweep ) { }
+static void null_gluPerspective( GLdouble fovy, GLdouble aspect, GLdouble zNear, GLdouble zFar ) { }
+static void null_gluPickMatrix( GLdouble x, GLdouble y, GLdouble delX, GLdouble delY, GLint * viewport ) { }
+static GLint null_gluProject( GLdouble objX, GLdouble objY, GLdouble objZ, const GLdouble * model, const GLdouble * proj, const GLint * view, GLdouble* winX, GLdouble* winY, GLdouble* winZ ) { return 0; }
+static void null_gluPwlCurve( void* nurb, GLint count, GLfloat* data, GLint stride, GLenum type ) { }
+static void null_gluQuadricCallback( void* quad, GLenum which, void * CallBackFunc ) { }
+static void null_gluQuadricDrawStyle( void* quad, GLenum draw ) { }
+static void null_gluQuadricNormals( void* quad, GLenum normal ) { }
+static void null_gluQuadricOrientation( void* quad, GLenum orientation ) { }
+static void null_gluQuadricTexture( void* quad, GLboolean texture ) { }
+static GLint null_gluScaleImage( GLenum format, GLsizei wIn, GLsizei hIn, GLenum typeIn, const void * dataIn, GLsizei wOut, GLsizei hOut, GLenum typeOut, GLvoid* dataOut ) { return 0; }
+static void null_gluSphere( void* quad, GLdouble radius, GLint slices, GLint stacks ) { }
+static void null_gluTessBeginContour( void* tess ) { }
+static void null_gluTessBeginPolygon( void* tess, GLvoid* data ) { }
+static void null_gluTessCallback( void* tess, GLenum which, void * CallBackFunc ) { }
+static void null_gluTessEndContour( void* tess ) { }
+static void null_gluTessEndPolygon( void* tess ) { }
+static void null_gluTessNormal( void* tess, GLdouble valueX, GLdouble valueY, GLdouble valueZ ) { }
+static void null_gluTessProperty( void* tess, GLenum which, GLdouble data ) { }
+static void null_gluTessVertex( void* tess, GLdouble * location, GLvoid* data ) { }
+static GLint null_gluUnProject( GLdouble winX, GLdouble winY, GLdouble winZ, const GLdouble * model, const GLdouble * proj, const GLint * view, GLdouble* objX, GLdouble* objY, GLdouble* objZ ) { return 0; }
 
 struct opengl_funcs null_opengl_funcs =
 {
@@ -8876,5 +8928,58 @@
         null_wglSetPbufferAttribARB,
         null_wglSetPixelFormatWINE,
         null_wglSwapIntervalEXT,
+    },
+    {   /* CrossOver Hack 10798 */
+        null_gluBeginCurve,
+        null_gluBeginPolygon,
+        null_gluBeginSurface,
+        null_gluBeginTrim,
+        null_gluBuild1DMipmaps,
+        null_gluBuild2DMipmaps,
+        null_gluCylinder,
+        null_gluDeleteNurbsRenderer,
+        null_gluDeleteQuadric,
+        null_gluDeleteTess,
+        null_gluDisk,
+        null_gluEndCurve,
+        null_gluEndPolygon,
+        null_gluEndSurface,
+        null_gluEndTrim,
+        null_gluErrorString,
+        null_gluGetNurbsProperty,
+        null_gluGetString,
+        null_gluGetTessProperty,
+        null_gluLoadSamplingMatrices,
+        null_gluLookAt,
+        null_gluNewNurbsRenderer,
+        null_gluNewQuadric,
+        null_gluNewTess,
+        null_gluNextContour,
+        null_gluNurbsCallback,
+        null_gluNurbsCurve,
+        null_gluNurbsProperty,
+        null_gluNurbsSurface,
+        null_gluOrtho2D,
+        null_gluPartialDisk,
+        null_gluPerspective,
+        null_gluPickMatrix,
+        null_gluProject,
+        null_gluPwlCurve,
+        null_gluQuadricCallback,
+        null_gluQuadricDrawStyle,
+        null_gluQuadricNormals,
+        null_gluQuadricOrientation,
+        null_gluQuadricTexture,
+        null_gluScaleImage,
+        null_gluSphere,
+        null_gluTessBeginContour,
+        null_gluTessBeginPolygon,
+        null_gluTessCallback,
+        null_gluTessEndContour,
+        null_gluTessEndPolygon,
+        null_gluTessNormal,
+        null_gluTessProperty,
+        null_gluTessVertex,
+        null_gluUnProject,
     }
 };
diff -Naur wine-2.0a/dlls/opengl32/wgl.c wine-2.0b/dlls/opengl32/wgl.c
--- wine-2.0a/dlls/opengl32/wgl.c	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/opengl32/wgl.c	2017-07-11 20:37:50.000000000 +0100
@@ -45,6 +45,18 @@
 
 extern struct opengl_funcs null_opengl_funcs;
 
+/*
+ * Get a config key from either the app-specific or the default config
+ */
+
+inline static DWORD get_config_key( HKEY defkey, HKEY appkey, const char *name,
+                                    char *buffer, DWORD *size )
+{
+    if (appkey && !RegQueryValueExA( appkey, name, 0, NULL, (LPBYTE)buffer, size )) return 0;
+    if (defkey && !RegQueryValueExA( defkey, name, 0, NULL, (LPBYTE)buffer, size )) return 0;
+    return ERROR_FILE_NOT_FOUND;
+}
+
 /* handle management */
 
 #define MAX_WGL_HANDLES 1024
@@ -1932,19 +1944,41 @@
 
     if (!disabled)
     {
-        HKEY hkey;
         DWORD size;
         char *str = NULL;
+        HKEY hkey = 0;
+        HKEY appkey = 0;
+        char buffer[MAX_PATH+10];
+
+        /* @@ Wine registry key: HKLM\Software\Wine\OpenGL */
+        if (RegOpenKeyA( HKEY_CURRENT_USER, "Software\\Wine\\OpenGL", &hkey)) hkey = 0;
+        size = GetModuleFileNameA( 0, buffer, MAX_PATH );
+        if (size && size < MAX_PATH)
+        {
+            HKEY tmpkey;
+            /* @@ Wine registry key: HKCU\Software\Wine\AppDefaults\app.exe\OpenGL */
+            if (!RegOpenKeyA( HKEY_CURRENT_USER, "Software\\Wine\\AppDefaults", &tmpkey ))
+            {
+                char *p, *appname = buffer;
+                if ((p = strrchr( appname, '/' ))) appname = p + 1;
+                if ((p = strrchr( appname, '\\' ))) appname = p + 1;
+                strcat( appname, "\\OpenGL" );
+                TRACE("appname = [%s]\n", appname);
+                if (RegOpenKeyA( tmpkey, appname, &appkey )) appkey = 0;
+                RegCloseKey( tmpkey );
+            }
+        }
 
-        /* @@ Wine registry key: HKCU\Software\Wine\OpenGL */
-        if (!RegOpenKeyA( HKEY_CURRENT_USER, "Software\\Wine\\OpenGL", &hkey ))
+        if (hkey || appkey)
         {
-            if (!RegQueryValueExA( hkey, "DisabledExtensions", 0, NULL, NULL, &size ))
+            if (!get_config_key( hkey, appkey, "DisabledExtensions", NULL, &size))
             {
-                str = HeapAlloc( GetProcessHeap(), 0, size );
-                if (RegQueryValueExA( hkey, "DisabledExtensions", 0, NULL, (BYTE *)str, &size )) *str = 0;
+                str = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, size);
+                get_config_key( hkey, appkey, "DisabledExtensions", str, &size);
+                TRACE("found DisabledExtensions=%s\n", debugstr_a(str));
             }
-            RegCloseKey( hkey );
+            if (appkey) RegCloseKey( appkey );
+            if (hkey) RegCloseKey( hkey );
         }
         if (str)
         {
diff -Naur wine-2.0a/dlls/pstorec/Makefile.in wine-2.0b/dlls/pstorec/Makefile.in
--- wine-2.0a/dlls/pstorec/Makefile.in	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/pstorec/Makefile.in	2017-07-11 20:37:50.000000000 +0100
@@ -1,5 +1,5 @@
 MODULE    = pstorec.dll
-IMPORTS   = uuid
+IMPORTS   = uuid ole32 shlwapi advapi32
 
 C_SRCS = \
 	pstorec.c
diff -Naur wine-2.0a/dlls/pstorec/pstorec.c wine-2.0b/dlls/pstorec/pstorec.c
--- wine-2.0a/dlls/pstorec/pstorec.c	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/pstorec/pstorec.c	2017-07-11 20:37:50.000000000 +0100
@@ -19,14 +19,21 @@
  */
 
 #include <stdarg.h>
+#include <stdio.h>
 
 #define COBJMACROS
 #include "windef.h"
 #include "winbase.h"
+#include "winreg.h"
+#include "winerror.h"
 #include "winuser.h"
+#include "winnls.h"
 #include "ole2.h"
+#include "shlwapi.h"
+
 #include "pstore.h"
 
+#include "wine/unicode.h"
 #include "wine/debug.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(pstores);
@@ -37,6 +44,13 @@
     LONG ref;
 } PStore_impl;
 
+
+static const WCHAR szPStoresKey[] = {
+    'S','o','f','t','w','a','r','e','\\',
+    'W','i','n','e','\\','W','i','n','e','\\',
+    'p','s','t','o','r','e','s',0
+};
+
 static inline PStore_impl *impl_from_IPStore(IPStore *iface)
 {
     return CONTAINING_RECORD(iface, PStore_impl, IPStore_iface);
@@ -57,6 +71,30 @@
     return TRUE;
 }
 
+/* convert a guid to a wide character string */
+static void IPStore_guid2wstr( const GUID *guid, LPWSTR wstr )
+{
+    char str[40];
+
+    sprintf(str, "{%08X-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}",
+           guid->Data1, guid->Data2, guid->Data3,
+           guid->Data4[0], guid->Data4[1], guid->Data4[2], guid->Data4[3],
+           guid->Data4[4], guid->Data4[5], guid->Data4[6], guid->Data4[7] );
+    MultiByteToWideChar( CP_ACP, 0, str, -1, wstr, 40 );
+}
+
+static LONG IPStore_OpenRoot( PST_KEY Key, HKEY *hkey )
+{
+    switch( Key )
+    {
+    case PST_KEY_CURRENT_USER:
+        return RegCreateKeyW( HKEY_CURRENT_USER, szPStoresKey, hkey );
+    case PST_KEY_LOCAL_MACHINE:
+        return RegCreateKeyW( HKEY_LOCAL_MACHINE, szPStoresKey, hkey );
+    }
+    return ERROR_INVALID_PARAMETER;
+}
+
 /**************************************************************************
  *  IPStore->QueryInterface
  */
@@ -67,7 +105,7 @@
 {
     PStore_impl *This = impl_from_IPStore(iface);
 
-    TRACE("%p %s\n",This,debugstr_guid(riid));
+    TRACE("(%p)->(\n\tIID:\t%s)\n",This,debugstr_guid(riid));
 
     *ppvObj = NULL;
 
@@ -120,7 +158,7 @@
 static HRESULT WINAPI PStore_fnGetInfo( IPStore* iface, PPST_PROVIDERINFO* ppProperties)
 {
     FIXME("\n");
-    return E_NOTIMPL;
+    return E_FAIL;
 }
 
 /******************************************************************************
@@ -130,7 +168,7 @@
     DWORD dwParam, DWORD* pcbData, BYTE** ppbData, DWORD dwFlags)
 {
     FIXME("\n");
-    return E_NOTIMPL;
+    return E_FAIL;
 }
 
 /******************************************************************************
@@ -140,7 +178,7 @@
     DWORD dwParam, DWORD cbData, BYTE* pbData, DWORD* dwFlags)
 {
     FIXME("\n");
-    return E_NOTIMPL;
+    return E_FAIL;
 }
 
 /******************************************************************************
@@ -149,10 +187,38 @@
 static HRESULT WINAPI PStore_fnCreateType( IPStore* This,
     PST_KEY Key, const GUID* pType, PPST_TYPEINFO pInfo, DWORD dwFlags)
 {
-    FIXME("%p %08x %s %p(%d,%s) %08x\n", This, Key, debugstr_guid(pType),
+    LONG r;
+    HKEY hkey, hkeytype;
+    WCHAR szGuid[40];
+    HRESULT hres = E_FAIL;
+    DWORD dwCreated = 0;
+
+    TRACE("%p %08x %s %p(%d,%s) %08x\n", This, Key, debugstr_guid(pType),
           pInfo, pInfo->cbSize, debugstr_w(pInfo->szDisplayName), dwFlags);
 
-    return E_NOTIMPL;
+    r = IPStore_OpenRoot( Key, &hkey );
+    if( r )
+        return hres;
+
+    IPStore_guid2wstr( pType, szGuid );
+    r = RegCreateKeyExW( hkey, szGuid, 0, NULL, REG_OPTION_NON_VOLATILE,
+                         KEY_ALL_ACCESS, NULL, &hkeytype, &dwCreated );
+    if( r == ERROR_SUCCESS )
+    {
+        if( dwCreated == REG_CREATED_NEW_KEY )
+        {
+            r = RegSetValueW( hkeytype, NULL, REG_SZ, 
+                   pInfo->szDisplayName, strlenW( pInfo->szDisplayName ) );
+            if( r == ERROR_SUCCESS )
+                hres = PST_E_OK;
+            RegCloseKey( hkeytype );
+        }
+        else
+            hres = PST_E_TYPE_EXISTS;
+    }
+    RegCloseKey( hkey );
+
+    return hres;
 }
 
 /******************************************************************************
@@ -162,7 +228,7 @@
     PST_KEY Key, const GUID* pType, PPST_TYPEINFO** ppInfo, DWORD dwFlags)
 {
     FIXME("\n");
-    return E_NOTIMPL;
+    return E_FAIL;
 }
 
 /******************************************************************************
@@ -171,8 +237,24 @@
 static HRESULT WINAPI PStore_fnDeleteType( IPStore* This,
     PST_KEY Key, const GUID* pType, DWORD dwFlags)
 {
-    FIXME("%p %d %s %08x\n", This, Key, debugstr_guid(pType), dwFlags);
-    return E_NOTIMPL;
+    LONG r;
+    HKEY hkey;
+    WCHAR szGuid[40];
+    HRESULT hres = E_FAIL;
+
+    TRACE("%p %d %s %08x\n", This, Key, debugstr_guid(pType), dwFlags);
+
+    r = IPStore_OpenRoot( Key, &hkey );
+    if( r )
+        return hres;
+    
+    IPStore_guid2wstr( pType, szGuid );
+    r = SHDeleteKeyW( hkey, szGuid );
+    if( r == ERROR_SUCCESS )
+        hres = PST_E_OK;
+    RegCloseKey( hkey );
+    
+    return hres;
 }
 
 /******************************************************************************
@@ -182,9 +264,40 @@
     PST_KEY Key, const GUID* pType, const GUID* pSubtype,
     PPST_TYPEINFO pInfo, PPST_ACCESSRULESET pRules, DWORD dwFlags)
 {
-    FIXME("%p %08x %s %s %p %p %08x\n", This, Key, debugstr_guid(pType),
+    LONG r;
+    HKEY hkey, hkeysubtype;
+    WCHAR szGuid[80];
+    HRESULT hres = E_FAIL;
+    DWORD dwCreated = 0;
+
+    TRACE("%p %08x %s %s %p %p %08x\n", This, Key, debugstr_guid(pType),
            debugstr_guid(pSubtype), pInfo, pRules, dwFlags);
-    return E_NOTIMPL;
+
+    r = IPStore_OpenRoot( Key, &hkey );
+    if( r )
+        return E_FAIL;
+    
+    IPStore_guid2wstr( pType, szGuid );
+    szGuid[38] = '\\';
+    IPStore_guid2wstr( pSubtype, &szGuid[39] );
+    r = RegCreateKeyExW( hkey, szGuid, 0, NULL, REG_OPTION_NON_VOLATILE,
+                         KEY_ALL_ACCESS, NULL, &hkeysubtype, &dwCreated );
+    if( r == ERROR_SUCCESS )
+    {
+        if( dwCreated == REG_CREATED_NEW_KEY )
+        {
+            r = RegSetValueW( hkeysubtype, NULL, REG_SZ, 
+                       pInfo->szDisplayName, strlenW( pInfo->szDisplayName ) );
+            if( r == ERROR_SUCCESS )
+                hres = S_OK;
+            RegCloseKey( hkeysubtype );
+        }
+        else
+            hres = PST_E_TYPE_EXISTS;
+    }
+    RegCloseKey( hkey );
+
+    return hres;
 }
 
 /******************************************************************************
@@ -195,7 +308,7 @@
     PPST_TYPEINFO** ppInfo, DWORD dwFlags)
 {
     FIXME("\n");
-    return E_NOTIMPL;
+    return E_FAIL;
 }
 
 /******************************************************************************
@@ -204,9 +317,31 @@
 static HRESULT WINAPI PStore_fnDeleteSubtype( IPStore* This,
     PST_KEY Key, const GUID* pType, const GUID* pSubtype, DWORD dwFlags)
 {
-    FIXME("%p %u %s %s %08x\n", This, Key,
+    LONG r;
+    HKEY hkey, hkeytype;
+    WCHAR szGuid[40];
+    HRESULT hres = E_FAIL;
+
+    TRACE("%p %u %s %s %08x\n", This, Key,
           debugstr_guid(pType), debugstr_guid(pSubtype), dwFlags);
-    return E_NOTIMPL;
+
+    r = IPStore_OpenRoot( Key, &hkey );
+    if( r )
+        return hres;
+    
+    IPStore_guid2wstr( pType, szGuid );
+    r = RegOpenKeyW( hkey, szGuid, &hkeytype );
+    if( r == ERROR_SUCCESS )
+    {
+        IPStore_guid2wstr( pSubtype, szGuid );
+        r = SHDeleteKeyW( hkeytype, szGuid );
+        if( r == ERROR_SUCCESS )
+            hres = PST_E_OK;
+        RegCloseKey( hkeytype );
+    }
+    RegCloseKey( hkey );
+
+    return hres;
 }
 
 /******************************************************************************
@@ -217,7 +352,7 @@
     PPST_ACCESSRULESET** ppRules, DWORD dwFlags)
 {
     FIXME("\n");
-    return E_NOTIMPL;
+    return E_FAIL;
 }
 
 /******************************************************************************
@@ -228,7 +363,7 @@
     PPST_TYPEINFO pInfo, PPST_ACCESSRULESET pRules, DWORD dwFlags)
 {
     FIXME("\n");
-    return E_NOTIMPL;
+    return E_FAIL;
 }
 
 /******************************************************************************
@@ -238,7 +373,7 @@
     DWORD dwFlags, IEnumPStoreTypes** ppenum)
 {
     FIXME("\n");
-    return E_NOTIMPL;
+    return E_FAIL;
 }
 
 /******************************************************************************
@@ -248,7 +383,7 @@
     const GUID* pType, DWORD dwFlags, IEnumPStoreTypes** ppenum)
 {
     FIXME("\n");
-    return E_NOTIMPL;
+    return E_FAIL;
 }
 
 /******************************************************************************
@@ -259,7 +394,7 @@
     PPST_PROMPTINFO pPromptInfo, DWORD dwFlags)
 {
     FIXME("\n");
-    return E_NOTIMPL;
+    return E_FAIL;
 }
 
 /******************************************************************************
@@ -269,10 +404,43 @@
     const GUID* pItemType, const GUID* pItemSubtype, LPCWSTR szItemName,
     DWORD *cbData, BYTE** pbData, PPST_PROMPTINFO pPromptInfo, DWORD dwFlags)
 {
-    FIXME("%p %08x %s %s %s %p %p %p %08x\n", This, Key,
-          debugstr_guid(pItemType), debugstr_guid(pItemSubtype),
-          debugstr_w(szItemName), cbData, pbData, pPromptInfo, dwFlags);
-    return E_NOTIMPL;
+    LONG r;
+    HKEY hkey, hkeysubtype;
+    WCHAR szGuid[80];
+    DWORD type;
+
+    TRACE("%p %08x %s %s %s %p %p %p %08x\n", This, Key,
+        debugstr_guid(pItemType), debugstr_guid(pItemSubtype), 
+        debugstr_w(szItemName), cbData, pbData, pPromptInfo, dwFlags);
+
+    *pbData = NULL;
+    *cbData = 0;
+
+    r = IPStore_OpenRoot( Key, &hkey );
+    if( r )
+        return E_FAIL;
+
+    IPStore_guid2wstr( pItemType, szGuid );
+    szGuid[38] = '\\';
+    IPStore_guid2wstr( pItemSubtype, &szGuid[39] );
+    r = RegOpenKeyW( hkey, szGuid, &hkeysubtype );
+    if( r == ERROR_SUCCESS )
+    {
+        type = 0;
+        r = RegQueryValueExW( hkeysubtype, szItemName, NULL, &type,
+                              NULL, cbData );
+        if( ( r == ERROR_SUCCESS ) && ( type == REG_BINARY ) )
+        {
+            *pbData = CoTaskMemAlloc( *cbData );
+            r = RegQueryValueExW( hkeysubtype, szItemName, NULL, &type,
+                                  *pbData, cbData );
+        }
+        RegCloseKey( hkeysubtype );
+    }
+    
+    RegCloseKey( hkey );
+
+    return ( r == ERROR_SUCCESS ) ? S_OK : E_FAIL;
 }
 
 /******************************************************************************
@@ -283,10 +451,32 @@
     DWORD cbData, BYTE* ppbData, PPST_PROMPTINFO pPromptInfo,
     DWORD dwDefaultConfirmationStyle, DWORD dwFlags)
 {
-    FIXME("%p %08x %s %s %s %d %p %p %08x\n", This, Key,
-          debugstr_guid(pItemType), debugstr_guid(pItemSubtype),
-          debugstr_w(szItemName), cbData, ppbData, pPromptInfo, dwFlags);
-    return E_NOTIMPL;
+    LONG r;
+    HKEY hkey, hkeysubtype;
+    WCHAR szGuid[80];
+
+    TRACE("%p %08x %s %s %s %d %p %p %08x\n", This, Key,
+        debugstr_guid(pItemType), debugstr_guid(pItemSubtype), 
+        debugstr_w(szItemName), cbData, ppbData, pPromptInfo, dwFlags);
+
+    r = IPStore_OpenRoot( Key, &hkey );
+    if( r )
+        return E_FAIL;
+
+    IPStore_guid2wstr( pItemType, szGuid );
+    szGuid[38] = '\\';
+    IPStore_guid2wstr( pItemSubtype, &szGuid[39] );
+    r = RegOpenKeyW( hkey, szGuid, &hkeysubtype );
+    if( r == ERROR_SUCCESS )
+    {
+        r = RegSetValueExW( hkeysubtype, szItemName, 0, REG_BINARY, 
+                            ppbData, cbData );
+        RegCloseKey( hkeysubtype );
+    }
+    
+    RegCloseKey( hkey );
+
+    return ( r == ERROR_SUCCESS ) ? S_OK : E_FAIL;
 }
 
 /******************************************************************************
@@ -296,9 +486,37 @@
     const GUID* pItemType, const GUID* pItemSubtype, LPCWSTR szItemName,
     PST_ACCESSMODE ModeFlags, PPST_PROMPTINFO pPromptInfo, DWORD dwFlags )
 {
-    FIXME("(%p,%08x,%s,%s,%s,%08x,%p,%08x) stub\n", This, Key, debugstr_guid(pItemType),
-           debugstr_guid(pItemSubtype), debugstr_w(szItemName), ModeFlags, pPromptInfo, dwFlags);
-    return E_NOTIMPL;
+    LONG r;
+    HKEY hkey, hkeysubtype;
+    WCHAR szGuid[80];
+
+    TRACE("%p %08x %s %s %p %08x %p %08x\n", This, Key,
+           debugstr_guid(pItemType), debugstr_guid(pItemSubtype),
+           debugstr_w(szItemName), ModeFlags, pPromptInfo, dwFlags);
+
+    r = IPStore_OpenRoot( Key, &hkey );
+    if( r )
+        return E_FAIL;
+
+    IPStore_guid2wstr( pItemType, szGuid );
+    szGuid[38] = '\\';
+    IPStore_guid2wstr( pItemSubtype, &szGuid[39] );
+    r = RegOpenKeyW( hkey, szGuid, &hkeysubtype );
+    if( r == ERROR_SUCCESS )
+    {
+        DWORD type;
+
+        r = RegQueryValueExW( hkeysubtype, szItemName, NULL, &type, 
+                              NULL, NULL );
+        if( ( r == ERROR_SUCCESS ) && ( type != REG_BINARY ) )
+            r = ERROR_INVALID_DATA;
+
+        RegCloseKey( hkeysubtype );
+    }
+    
+    RegCloseKey( hkey );
+
+    return ( r == ERROR_SUCCESS ) ? S_OK : E_FAIL;
 }
 
 /******************************************************************************
@@ -308,8 +526,8 @@
     const GUID* pItemType, const GUID* pItemSubtype, LPCWSTR* szItemName,
     DWORD dwFlags)
 {
-    FIXME("\n");
-    return E_NOTIMPL;
+    TRACE("\n");
+    return S_OK;
 }
 
 /******************************************************************************
@@ -320,7 +538,7 @@
     IEnumPStoreItems** ppenum)
 {
     FIXME("\n");
-    return E_NOTIMPL;
+    return E_FAIL;
 }
 
 
@@ -371,13 +589,13 @@
 
 HRESULT WINAPI DllRegisterServer(void)
 {
-    FIXME("\n");
+    FIXME("stub\n");
     return S_OK;
 }
 
 HRESULT WINAPI DllUnregisterServer(void)
 {
-    FIXME("\n");
+    FIXME("stub\n");
     return S_OK;
 }
 
@@ -386,7 +604,7 @@
  */
 HRESULT WINAPI DllGetClassObject(REFCLSID rclsid, REFIID iid, LPVOID *ppv)
 {
-    FIXME("%s %s %p\n", debugstr_guid(rclsid), debugstr_guid(iid), ppv);
+    FIXME("(%s,%s,%p) stub\n", debugstr_guid(rclsid), debugstr_guid(iid), ppv);
     return CLASS_E_CLASSNOTAVAILABLE;
 }
 
diff -Naur wine-2.0a/dlls/riched20/tests/editor.c wine-2.0b/dlls/riched20/tests/editor.c
--- wine-2.0a/dlls/riched20/tests/editor.c	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/riched20/tests/editor.c	2017-07-11 20:37:50.000000000 +0100
@@ -3936,6 +3936,25 @@
   DestroyWindow(hwndRichEdit);
 }
 
+static void test_EM_STREAMOUT_empty_para(void)
+{
+    HWND hwnd = new_richedit(NULL);
+    char buf[1024], *p = buf;
+    EDITSTREAM es;
+
+    SendMessageA(hwnd, WM_SETTEXT, 0, (LPARAM)"");
+
+    memset(buf, 0, sizeof(buf));
+    es.dwCookie    = (DWORD_PTR)&p;
+    es.dwError     = 0;
+    es.pfnCallback = test_WM_SETTEXT_esCallback;
+
+    SendMessageA(hwnd, EM_STREAMOUT, SF_RTF, (LPARAM)&es);
+    ok((p = strstr(buf, "\\pard")) != NULL, "missing \\pard\n");
+    ok(((p = strstr(p, "\\fs")) && isdigit(p[3])), "missing \\fs\n");
+
+    DestroyWindow(hwnd);
+}
 
 static void test_EM_SETTEXTEX(void)
 {
@@ -8720,6 +8739,7 @@
   test_EM_STREAMIN();
   test_EM_STREAMOUT();
   test_EM_STREAMOUT_FONTTBL();
+  test_EM_STREAMOUT_empty_para();
   test_EM_StreamIn_Undo();
   test_EM_FORMATRANGE();
   test_unicode_conversions();
diff -Naur wine-2.0a/dlls/riched20/writer.c wine-2.0b/dlls/riched20/writer.c
--- wine-2.0a/dlls/riched20/writer.c	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/riched20/writer.c	2017-07-11 20:37:50.000000000 +0100
@@ -1074,6 +1074,9 @@
       }
       nChars--;
     } else if (cursor.pRun->member.run.nFlags & MERF_ENDPARA) {
+      if (!ME_StreamOutRTFCharProps(pStream, &cursor.pRun->member.run.style->fmt))
+        return FALSE;
+
       if (cursor.pPara->member.para.fmt.dwMask & PFM_TABLE &&
           cursor.pPara->member.para.fmt.wEffects & PFE_TABLE &&
           !(cursor.pPara->member.para.nFlags & (MEPF_ROWSTART|MEPF_ROWEND|MEPF_CELL)))
diff -Naur wine-2.0a/dlls/rpcrt4/rpc_transport.c wine-2.0b/dlls/rpcrt4/rpc_transport.c
--- wine-2.0a/dlls/rpcrt4/rpc_transport.c	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/rpcrt4/rpc_transport.c	2017-07-11 20:37:50.000000000 +0100
@@ -463,6 +463,19 @@
   return status;
 }
 
+/*
+ * CXHACK 14391:
+ * ClickToRun hooks NtReadFile and many other APIs. Some of hooked functions
+ * do RPC calls. When we call NtReadFile in such RPC call, it locks a critical
+ * section inside its NtReadFile hook, which causes dead locks.
+ * It most likely works on Windows because RPC calls use LPC ports, so they
+ * don't call NtReadFile.
+ */
+NTSTATUS WINAPI rpc_NtReadFile(HANDLE hFile, HANDLE hEvent,
+                           PIO_APC_ROUTINE apc, void* apc_user,
+                           PIO_STATUS_BLOCK io_status, void* buffer, ULONG length,
+                                PLARGE_INTEGER offset, PULONG key);
+
 static int rpcrt4_conn_np_read(RpcConnection *Connection,
                         void *buffer, unsigned int count)
 {
@@ -474,7 +487,7 @@
 
   while (bytes_left)
   {
-    status = NtReadFile(npc->pipe, NULL, NULL, NULL, &io_status, buf, bytes_left, NULL, NULL);
+    status = rpc_NtReadFile(npc->pipe, NULL, NULL, NULL, &io_status, buf, bytes_left, NULL, NULL);
     if (status && status != STATUS_BUFFER_OVERFLOW)
       return -1;
     bytes_left -= io_status.Information;
diff -Naur wine-2.0a/dlls/rpcrt4/tests/ndr_marshall.c wine-2.0b/dlls/rpcrt4/tests/ndr_marshall.c
--- wine-2.0a/dlls/rpcrt4/tests/ndr_marshall.c	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/rpcrt4/tests/ndr_marshall.c	2017-07-11 20:37:50.000000000 +0100
@@ -35,6 +35,7 @@
 #include "rpcdce.h"
 #include "rpcproxy.h"
 #include "midles.h"
+#include "oaidl.h"
 
 static int my_alloc_called;
 static int my_free_called;
@@ -1015,6 +1016,283 @@
     test_pointer_marshal(fmtstr_pointer_struct, &ps1, 17, wiredata, 21, ps1_cmp, 2, "pointer_struct");
 }
 
+static void test_complex_struct(void)
+{
+    RPC_MESSAGE RpcMessage;
+    MIDL_STUB_MESSAGE StubMsg;
+    MIDL_STUB_DESC StubDesc;
+    void *memsrc, *ptr;
+    FUNCDESC fd;
+    ELEMDESC params[2];
+    TYPEDESC td[4];
+    FUNCDESC *dst;
+
+    static const unsigned char fmtstr_funcdesc[] =
+    {
+/* 0 */     0x11, 0x14,	/* FC_RP [alloced_on_stack] */
+/* 2 */     NdrFcShort( 0x2 ),	/* Offset= 2 (4) */
+/* 4 */     0x13, 0x0,	/* FC_OP */
+/* 6 */     NdrFcShort( 0xaa ),	/* Offset= 170 (176) */
+
+/** TYPEDESC union **/
+/* 8 */     0x2b,		/* FC_NON_ENCAPSULATED_UNION */
+            0x7,		/* FC_USHORT */
+/* 10 */    0x7,		/* Corr desc: FC_USHORT */
+            0x0,		/*  */
+/* 12 */    NdrFcShort( 0x4 ),	/* 4 */
+/* 14 */    NdrFcShort( 0x2 ),	/* Offset= 2 (16) */
+/* 16 */    NdrFcShort( 0x4 ),	/* 4 */
+/* 18 */    NdrFcShort( 0x4 ),	/* 4 */
+/* 20 */    NdrFcLong( 0x1a ),	/* 26 */
+/* 24 */    NdrFcShort( 0x16 ),	/* Offset= 22 (46) */
+/* 26 */    NdrFcLong( 0x1b ),	/* 27 */
+/* 30 */    NdrFcShort( 0x10 ),	/* Offset= 16 (46) */
+/* 32 */    NdrFcLong( 0x1c ),	/* 28 */
+/* 36 */    NdrFcShort( 0xe ),	/* Offset= 14 (50) */
+/* 38 */    NdrFcLong( 0x1d ),	/* 29 */
+/* 42 */    NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
+/* 44 */    NdrFcShort( 0x0 ),	/* Offset= 0 */
+/* 46 */    0x13, 0x0,	/* FC_OP */
+/* 48 */    NdrFcShort( 0x24 ),	/* Offset= 36 (84) */
+/* 50 */    0x13, 0x0,	/* FC_OP */
+/* 52 */    NdrFcShort( 0x10 ),	/* Offset= 16 (68) */
+
+/** ARRAYDESC carray **/
+/* 54 */    0x1b,		/* FC_CARRAY */
+            0x3,		/* 3 */
+/* 56 */    NdrFcShort( 0x8 ),	/* 8 */
+/* 58 */    0x7,		/* Corr desc: FC_USHORT */
+            0x0,		/*  */
+/* 60 */    NdrFcShort( 0xfffc ),	/* -4 */
+/* 62 */    0x4c,		/* FC_EMBEDDED_COMPLEX */
+            0x0,		/* 0 */
+/* 64 */    NdrFcShort( 0x92 ),	/* Offset= 146 (210) */
+/* 66 */    0x5c,		/* FC_PAD */
+            0x5b,		/* FC_END */
+
+/** ARRADESC **/
+/* 68 */    0x1a,		/* FC_BOGUS_STRUCT */
+            0x3,		/* 3 */
+/* 70 */    NdrFcShort( 0x4 ),	/* 4 */
+/* 72 */    NdrFcShort( 0xffffffee ),	/* Offset= -18 (54) */
+/* 74 */    NdrFcShort( 0x0 ),	/* Offset= 0 */
+/* 76 */    0x4c,		/* FC_EMBEDDED_COMPLEX */
+            0x0,		/* 0 */
+/* 78 */    NdrFcShort( 0x6 ),	/* Offset= 6 (84) */
+/* 80 */    0x6,		/* FC_SHORT */
+            0x3e,		/* FC_STRUCTPAD2 */
+/* 82 */    0x5c,		/* FC_PAD */
+            0x5b,		/* FC_END */
+
+/** TYPEDESC **/
+/* 84 */    0x1a,		/* FC_BOGUS_STRUCT */
+	    0x3,		/* 3 */
+/* 86 */    NdrFcShort( 0x8 ),	/* 8 */
+/* 88 */    NdrFcShort( 0x0 ),	/* 0 */
+/* 90 */    NdrFcShort( 0x0 ),	/* Offset= 0 */
+/* 92 */    0x4c,		/* FC_EMBEDDED_COMPLEX */
+            0x0,		/* 0 */
+/* 94 */    NdrFcShort( 0xffffffaa ),	/* Offset= -86 (8) */
+/* 96 */    0x6,		/* FC_SHORT */
+            0x3e,		/* FC_STRUCTPAD2 */
+/* 98 */    0x5c,		/* FC_PAD */
+            0x5b,		/* FC_END */
+
+/** PARAMDESCEX **/
+
+/* 100 */   0x1a,		/* FC_BOGUS_STRUCT */
+            0x3,		/* 3 */
+/* 102 */   NdrFcShort( 0x18 ),	/* 24 */
+/* 104 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 106 */	NdrFcShort( 0x0 ),	/* Offset= 0 */
+/* 108 */	0x8,		/* FC_LONG */
+			0x4c,		/* FC_EMBEDDED_COMPLEX */
+/* 110 */	0x4,		/* 4 */
+                NdrFcShort( 0xffffff01 ),	/* Offset= -255 (1110) */ /* FIXME!! */
+		0x5b,		/* FC_END */
+
+
+/** PARAMDESC **/
+/* 114 */	0x1a,		/* FC_BOGUS_STRUCT */
+	        0x3,		/* 3 */
+/* 116 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 118 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 120 */	NdrFcShort( 0x6 ),	/* Offset= 6 (126) */
+/* 122 */	0x36,		/* FC_POINTER */
+			0x6,		/* FC_SHORT */
+/* 124 */	0x3e,		/* FC_STRUCTPAD2 */
+			0x5b,		/* FC_END */
+/* 126 */
+			0x13, 0x0,	/* FC_OP */
+/* 128 */	NdrFcShort( 0xffffffe4 ),	/* Offset= -28 (100) */
+
+/** ELEMDESC **/
+/* 130 */
+			0x1a,		/* FC_BOGUS_STRUCT */
+			0x3,		/* 3 */
+/* 132 */	NdrFcShort( 0x10 ),	/* 16 */
+/* 134 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 136 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 138 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
+			0x0,		/* 0 */
+/* 140 */	NdrFcShort( 0xffffffc8 ),	/* Offset= -56 (84) */
+/* 142 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
+			0x0,		/* 0 */
+/* 144 */	NdrFcShort( 0xffffffe2 ),	/* Offset= -30 (114) */
+/* 146 */	0x5c,		/* FC_PAD */
+			0x5b,		/* FC_END */
+
+
+/* 148 */
+			0x1b,		/* FC_CARRAY */
+			0x3,		/* 3 */
+/* 150 */	NdrFcShort( 0x4 ),	/* 4 */
+/* 152 */	0x16,		/* Corr desc:  field pointer, FC_SHORT */
+			0x0,		/*  */
+/* 154 */	NdrFcShort( 0x1e ),	/* 30 */
+/* 156 */	0x8,		/* FC_LONG */
+			0x5b,		/* FC_END */
+
+/* 158 */
+			0x21,		/* FC_BOGUS_ARRAY */
+			0x3,		/* 3 */
+/* 160 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 162 */	0x16,		/* Corr desc:  field pointer, FC_SHORT */
+			0x0,		/*  */
+/* 164 */	NdrFcShort( 0x18 ),	/* 24 */
+/* 166 */	NdrFcLong( 0xffffffff ),	/* -1 */
+/* 170 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
+			0x0,		/* 0 */
+/* 172 */	NdrFcShort( 0xffffffd6 ),	/* Offset= -42 (130) */
+/* 174 */	0x5c,		/* FC_PAD */
+			0x5b,		/* FC_END */
+/** FUNCDESC **/
+/* 176 */	0x1a,		/* FC_BOGUS_STRUCT */
+			0x3,		/* 3 */
+/* 178 */	NdrFcShort( 0x34 ),	/* 52 */
+/* 180 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 182 */	NdrFcShort( 0x14 ),	/* Offset= 20 (202) */
+/* 184 */	0x8,		/* FC_LONG */
+			0x36,		/* FC_POINTER */
+/* 186 */	0x36,		/* FC_POINTER */
+			0xe,		/* FC_ENUM32 */
+/* 188 */	0xe,		/* FC_ENUM32 */
+			0xe,		/* FC_ENUM32 */
+/* 190 */	0x6,		/* FC_SHORT */
+			0x6,		/* FC_SHORT */
+/* 192 */	0x6,		/* FC_SHORT */
+			0x6,		/* FC_SHORT */
+/* 194 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
+			0x0,		/* 0 */
+/* 196 */	NdrFcShort( 0xffffffbe ),	/* Offset= -66 (130) */
+/* 198 */	0x6,		/* FC_SHORT */
+			0x3e,		/* FC_STRUCTPAD2 */
+/* 200 */	0x5c,		/* FC_PAD */
+			0x5b,		/* FC_END */
+/* 202 */
+			0x13, 0x0,	/* FC_OP */
+/* 204 */	NdrFcShort( 0xffffffc8 ),	/* Offset= -56 (148) */
+/* 206 */	
+			0x13, 0x0,	/* FC_OP */
+/* 208 */	NdrFcShort( 0xffffffce ),	/* Offset= -50 (158) */
+
+/** SAFEARRAYBOUND **/
+/* 210 */
+			0x15,		/* FC_STRUCT */
+			0x3,		/* 3 */
+/* 212 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 214 */	0x8,		/* FC_LONG */
+			0x8,		/* FC_LONG */
+/* 216 */	0x5c,		/* FC_PAD */
+			0x5b,		/* FC_END */
+    };
+
+    StubDesc = Object_StubDesc;
+    StubDesc.pFormatTypes = fmtstr_funcdesc;
+
+    memsrc = &fd;
+    memset(&fd, 0, sizeof(fd));
+
+    fd.memid = 0xcafebabe;
+    fd.lprgscode = NULL;
+    fd.lprgelemdescParam = params;
+    params[0].tdesc.vt = VT_PTR;
+    U(params[0].tdesc).lptdesc = &td[0];
+    U(params[0].tdesc).lptdesc->vt = VT_SAFEARRAY;
+    U(*U(params[0].tdesc).lptdesc).lptdesc = &td[1];
+    U(*U(params[0].tdesc).lptdesc).lptdesc->vt = VT_R8;
+    U(params[0]).paramdesc.pparamdescex = NULL;
+    U(params[0]).paramdesc.wParamFlags = 0xbeef;
+
+    params[1].tdesc.vt = VT_I4;
+    /*    U(params[1].tdesc).vt = VT_PTR;
+    U(params[1].tdesc).lptdesc = &td[2];
+    U(params[1].tdesc).lptdesc->vt = VT_SAFEARRAY;
+    U(*U(params[1].tdesc).lptdesc).lptdesc = &td[3];
+    U(*U(params[1].tdesc).lptdesc).lptdesc->vt = VT_R8;*/
+    U(params[1]).paramdesc.pparamdescex = NULL;
+    U(params[1]).paramdesc.wParamFlags = 0xdead;
+    fd.funckind = 0;
+    fd.invkind = 1;
+    fd.callconv = 4;
+    fd.cParams = 2;
+    fd.cParamsOpt = 0;
+    fd.oVft = 8;
+    fd.cScodes = 0;
+    fd.elemdescFunc.tdesc.vt = VT_R8;
+    U(fd.elemdescFunc).paramdesc.pparamdescex = NULL;
+    U(fd.elemdescFunc).paramdesc.wParamFlags = 0xcafe;
+    fd.wFuncFlags = 0;
+
+    NdrClientInitializeNew(&RpcMessage, &StubMsg, &StubDesc, 0);
+
+    StubMsg.BufferLength = 0;
+    StubMsg.PointerLength = 0;
+
+    NdrComplexStructBufferSize( &StubMsg, (unsigned char *)memsrc, fmtstr_funcdesc + 176 );
+    ok(StubMsg.BufferLength >= 96, "buffer size %d\n", StubMsg.BufferLength);
+
+    StubMsg.RpcMsg->Buffer = StubMsg.BufferStart = StubMsg.Buffer = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, StubMsg.BufferLength);
+    StubMsg.BufferEnd = StubMsg.BufferStart + StubMsg.BufferLength;
+
+    ptr = NdrComplexStructMarshall( &StubMsg,  memsrc, fmtstr_funcdesc + 176 );
+   
+    ok(StubMsg.Buffer - StubMsg.BufferStart == 96, "marshaled length %d\n", StubMsg.Buffer - StubMsg.BufferStart);
+
+    /* Compare upto the first embedded union (elemdescFunc) */
+    ok(!memcmp(StubMsg.BufferStart, &fd, 32), "top level differ\n");
+    /* discriminant */
+    ok(!memcmp(StubMsg.BufferStart + 32, &fd.elemdescFunc.tdesc.vt, sizeof(short)), "discrimants differ\n");
+    /* now the vt itself */
+    ok(!memcmp(StubMsg.BufferStart + 34, &fd.elemdescFunc.tdesc.vt, sizeof(short)), "vts differ\n");
+    /* paramdesc */
+    ok(!memcmp(StubMsg.BufferStart + 36, &U(fd.elemdescFunc).paramdesc, sizeof(PARAMDESC)), "paramdesc differ\n");
+    /* param array discrim */
+    ok(!memcmp(StubMsg.BufferStart + 44, &fd.cParams, sizeof(short)), "param array discrim differs\n");
+
+    ok(!memcmp(StubMsg.BufferStart + 48, &params[0].tdesc.vt, sizeof(short)), "param[0] first vt differ\n");
+    ok(!memcmp(StubMsg.BufferStart + 52, &params[0].tdesc, 6), "param[0] first tdesc differ\n");
+    ok(!memcmp(StubMsg.BufferStart + 60, &U(params[0]).paramdesc, 6), "param[0] paramdesc differ\n");
+
+    ok(!memcmp(StubMsg.BufferStart + 68, &params[1].tdesc.vt, sizeof(short)), "param[1] first vt differ\n");
+    ok(!memcmp(StubMsg.BufferStart + 70, &params[1].tdesc.vt, sizeof(short)), "param[1] first tdesc differ\n");
+    ok(!memcmp(StubMsg.BufferStart + 72, &U(params[1]).paramdesc, 6), "param[1] paramdesc differ\n");
+
+    ok(!memcmp(StubMsg.BufferStart + 80, &U(params[0].tdesc).lptdesc->vt, sizeof(short)), "param[0] 2nd vt differ\n");
+    ok(!memcmp(StubMsg.BufferStart + 84, U(params[0].tdesc).lptdesc, 6), "param[0] 2nd tdesc differ\n");
+
+    ok(!memcmp(StubMsg.BufferStart + 92, &U(*U(params[0].tdesc).lptdesc).lptdesc->vt, sizeof(short)), "param[0] 3rd vt differ\n");
+    ok(!memcmp(StubMsg.BufferStart + 94, &U(*U(params[0].tdesc).lptdesc).lptdesc->vt, 2), "param[0] 3rd tdesc differ\n");
+
+    StubMsg.Buffer = StubMsg.BufferStart;
+    StubMsg.MemorySize = 0;
+
+    dst = HeapAlloc(GetProcessHeap(), 0, 1000);
+    NdrComplexStructUnmarshall( &StubMsg, (void*)&dst, fmtstr_funcdesc + 176, 1);
+    ok(dst->cParams == fd.cParams, "params not right\n");
+    ok(U(*U(dst->lprgelemdescParam[0].tdesc).lptdesc).lptdesc->vt == U(*U(params[0].tdesc).lptdesc).lptdesc->vt, "param[0] tdesc differ\n");
+}
+
 static void test_fullpointer_xlat(void)
 {
     PFULL_PTR_XLAT_TABLES pXlatTables;
@@ -2497,6 +2775,7 @@
     test_simple_types();
     test_nontrivial_pointer_types();
     test_simple_struct();
+    test_complex_struct();
     test_fullpointer_xlat();
     test_client_init();
     test_server_init();
diff -Naur wine-2.0a/dlls/secur32/ntlm.c wine-2.0b/dlls/secur32/ntlm.c
--- wine-2.0a/dlls/secur32/ntlm.c	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/secur32/ntlm.c	2017-07-11 20:37:50.000000000 +0100
@@ -21,6 +21,7 @@
 #include <assert.h>
 #include <stdarg.h>
 #include <stdio.h>
+#include <stdlib.h>
 #include "windef.h"
 #include "winbase.h"
 #include "winnls.h"
@@ -30,6 +31,7 @@
 #include "lm.h"
 #include "secur32_priv.h"
 #include "hmac_md5.h"
+#include "wine/library.h"
 #include "wine/unicode.h"
 #include "wine/debug.h"
 
@@ -41,7 +43,8 @@
 #define MIN_NTLM_AUTH_MINOR_VERSION 0
 #define MIN_NTLM_AUTH_MICRO_VERSION 25
 
-static CHAR ntlm_auth[] = "ntlm_auth";
+static CHAR ntlm_auth[256];
+static char *config_file_option;
 
 /***********************************************************************
  *              QueryCredentialsAttributesA
@@ -528,8 +531,8 @@
     {
         static char helper_protocol[] = "--helper-protocol=ntlmssp-client-1";
         static CHAR credentials_argv[] = "--use-cached-creds";
-        SEC_CHAR *client_argv[5];
-        int pwlen = 0;
+        SEC_CHAR *client_argv[6];
+        int pwlen = 0, arg = 0;
 
         TRACE("First time in ISC()\n");
 
@@ -550,8 +553,9 @@
             goto isc_end;
         }
 
-        client_argv[0] = ntlm_auth;
-        client_argv[1] = helper_protocol;
+        client_argv[arg++] = ntlm_auth;
+        client_argv[arg++] = helper_protocol;
+        if (config_file_option) client_argv[arg++] = config_file_option;
         if (!ntlm_cred->username_arg && !ntlm_cred->domain_arg)
         {
             LPWKSTA_USER_INFO_1 ui = NULL;
@@ -592,9 +596,8 @@
 
                 CredFree(cred);
 
-                client_argv[2] = username;
-                client_argv[3] = domain;
-                client_argv[4] = NULL;
+                client_argv[arg++] = username;
+                client_argv[arg++] = domain;
             }
             else
             {
@@ -609,17 +612,16 @@
 
                 TRACE("using cached credentials\n");
 
-                client_argv[2] = username;
-                client_argv[3] = credentials_argv;
-                client_argv[4] = NULL;
+                client_argv[arg++] = username;
+                client_argv[arg++] = credentials_argv;
             }
         }
         else
         {
-            client_argv[2] = ntlm_cred->username_arg;
-            client_argv[3] = ntlm_cred->domain_arg;
-            client_argv[4] = NULL;
+            client_argv[arg++] = ntlm_cred->username_arg;
+            client_argv[arg++] = ntlm_cred->domain_arg;
         }
+        client_argv[arg] = NULL;
 
         if((ret = fork_helper(&helper, ntlm_auth, client_argv)) != SEC_E_OK)
             goto isc_end;
@@ -1055,6 +1057,7 @@
         static CHAR server_helper_protocol[] = "--helper-protocol=squid-2.5-ntlmssp";
         SEC_CHAR *server_argv[] = { ntlm_auth,
             server_helper_protocol,
+            config_file_option,
             NULL };
 
         if (!phCredential)
@@ -2033,11 +2036,56 @@
         version,
         NULL };
 
+    strcpy(ntlm_auth, "ntlm_auth");
+
     if(fork_helper(&helper, ntlm_auth, args) != SEC_E_OK)
         helper = NULL;
     else
         check_version(helper);
 
+    /* CodeWeavers feature: fall back to our shipped ntlm_auth if a suitable
+     * system version isn't found */
+    if( (!helper ||
+        ((helper->major <  MIN_NTLM_AUTH_MAJOR_VERSION) ||
+        (helper->major == MIN_NTLM_AUTH_MAJOR_VERSION  &&
+         helper->minor < MIN_NTLM_AUTH_MINOR_VERSION) ||
+        (helper->major == MIN_NTLM_AUTH_MAJOR_VERSION  &&
+         helper->minor == MIN_NTLM_AUTH_MINOR_VERSION  &&
+         helper->micro < MIN_NTLM_AUTH_MICRO_VERSION))) &&
+         getenv("CX_ROOT") )
+    {
+        static const char config_file_format[] = "--configfile=%s/smb.conf";
+        const char *datadir = wine_get_data_dir();
+
+        cleanup_helper(helper);
+
+        TRACE("falling back to CrossOver version of ntlm_auth\n");
+
+        strcpy(ntlm_auth, getenv("CX_ROOT"));
+        strcat(ntlm_auth, "/bin/cxntlm_auth");
+
+#ifdef __ANDROID__  /* the bin dir is different on Android */
+        if (getenv( "WINELOADER" ))
+        {
+            char *p;
+            strcpy(ntlm_auth, getenv("WINELOADER"));
+            if (!(p = strrchr( ntlm_auth, '/' ))) p = ntlm_auth;
+            strcpy( p, "/cxntlm_auth");
+        }
+#endif
+
+        if(fork_helper(&helper, ntlm_auth, args) != SEC_E_OK)
+            helper = NULL;
+        else
+            check_version(helper);
+
+        if (datadir)
+        {
+            config_file_option = HeapAlloc( GetProcessHeap(), 0, sizeof(config_file_format) + strlen(datadir) );
+            sprintf( config_file_option, config_file_format, datadir );
+        }
+    }
+
     if( helper &&
         ((helper->major >  MIN_NTLM_AUTH_MAJOR_VERSION) ||
          (helper->major == MIN_NTLM_AUTH_MAJOR_VERSION  &&
diff -Naur wine-2.0a/dlls/secur32/schannel_gnutls.c wine-2.0b/dlls/secur32/schannel_gnutls.c
--- wine-2.0a/dlls/secur32/schannel_gnutls.c	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/secur32/schannel_gnutls.c	2017-07-11 20:37:50.000000000 +0100
@@ -174,6 +174,9 @@
         return FALSE;
     }
 
+    /* HACK for CrossOver bug 12357 */
+    if (pgnutls_cipher_get_block_size == compat_cipher_get_block_size) strcpy(priority, "NORMAL");
+
     p = priority + strlen(priority);
     for(i=0; i < sizeof(protocol_priority_flags)/sizeof(*protocol_priority_flags); i++) {
         *p++ = ':';
@@ -494,6 +497,18 @@
 {
     int ret;
 
+if (1) { /* CROSSOVER HACK - bug 10151 */
+    const char *libgnutls_name_candidates[] = {SONAME_LIBGNUTLS,
+                                               "libgnutls.so.30",
+                                               "libgnutls.so.28",
+                                               "libgnutls-deb0.so.28",
+                                               "libgnutls.so.26",
+                                               NULL};
+    int i;
+    for (i=0; libgnutls_name_candidates[i] && !libgnutls_handle; i++)
+        libgnutls_handle = wine_dlopen(libgnutls_name_candidates[i], RTLD_NOW, NULL, 0);
+}
+else
     libgnutls_handle = wine_dlopen(SONAME_LIBGNUTLS, RTLD_NOW, NULL, 0);
     if (!libgnutls_handle)
     {
diff -Naur wine-2.0a/dlls/secur32/secur32.spec wine-2.0b/dlls/secur32/secur32.spec
--- wine-2.0a/dlls/secur32/secur32.spec	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/secur32/secur32.spec	2017-07-11 20:37:50.000000000 +0100
@@ -73,6 +73,7 @@
 @ stdcall SspiEncodeStringsAsAuthIdentity(wstr wstr wstr ptr) sspicli.SspiEncodeStringsAsAuthIdentity
 @ stdcall SspiFreeAuthIdentity(ptr) sspicli.SspiFreeAuthIdentity
 @ stdcall SspiLocalFree(ptr) sspicli.SspiLocalFree
+@ stdcall SspiPrepareForCredWrite(ptr wstr ptr ptr ptr ptr ptr) sspicli.SspiPrepareForCredWrite
 @ stdcall SspiZeroAuthIdentity(ptr) sspicli.SspiZeroAuthIdentity
 @ stdcall TranslateNameA(str long long ptr ptr)
 @ stdcall TranslateNameW(wstr long long ptr ptr)
diff -Naur wine-2.0a/dlls/secur32/tests/secur32.c wine-2.0b/dlls/secur32/tests/secur32.c
--- wine-2.0a/dlls/secur32/tests/secur32.c	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/secur32/tests/secur32.c	2017-07-11 20:37:50.000000000 +0100
@@ -27,6 +27,7 @@
 #define SECURITY_WIN32
 #include <security.h>
 #include <schannel.h>
+#include <wincred.h>
 
 #include "wine/test.h"
 
@@ -40,6 +41,8 @@
     (PSEC_WINNT_AUTH_IDENTITY_OPAQUE);
 static void (SEC_ENTRY *pSspiLocalFree)
     (void *);
+static SECURITY_STATUS (SEC_ENTRY *pSspiPrepareForCredWrite)
+    (PSEC_WINNT_AUTH_IDENTITY_OPAQUE, PCWSTR, PULONG, PCWSTR *, PCWSTR *, PUCHAR *, PULONG);
 static void (SEC_ENTRY *pSspiZeroAuthIdentity)
     (PSEC_WINNT_AUTH_IDENTITY_OPAQUE);
 
@@ -317,6 +320,60 @@
     pSspiFreeAuthIdentity( id );
 }
 
+static void test_SspiPrepareForCredWrite(void)
+{
+    static const WCHAR usernameW[] =
+        {'u','s','e','r','n','a','m','e',0};
+    static const WCHAR domainnameW[] =
+        {'d','o','m','a','i','n','n','a','m','e',0};
+    static const WCHAR passwordW[] =
+        {'p','a','s','s','w','o','r','d',0};
+    static const WCHAR targetW[] =
+        {'d','o','m','a','i','n','n','a','m','e','\\','u','s','e','r','n','a','m','e',0};
+    static const WCHAR target2W[] =
+        {'d','o','m','a','i','n','n','a','m','e','2','\\','u','s','e','r','n','a','m','e','2',0};
+    const WCHAR *target, *username;
+    PSEC_WINNT_AUTH_IDENTITY_OPAQUE id;
+    SECURITY_STATUS status;
+    ULONG type, size;
+    UCHAR *blob;
+
+    if (!pSspiPrepareForCredWrite)
+    {
+        win_skip( "SspiPrepareForCredWrite not exported by secur32.dll\n" );
+        return;
+    }
+
+    status = pSspiEncodeStringsAsAuthIdentity( usernameW, domainnameW, passwordW, &id );
+    ok( status == SEC_E_OK, "got %08x\n", status );
+
+    type = size = 0;
+    status = pSspiPrepareForCredWrite( id, NULL, &type, &target, &username, &blob, &size );
+    ok( status == SEC_E_OK, "got %08x\n", status );
+    ok( type == CRED_TYPE_DOMAIN_PASSWORD, "got %u\n", type );
+    ok( !lstrcmpW( target, targetW ), "got %s\n", wine_dbgstr_w(target) );
+    ok( !lstrcmpW( username, targetW ), "got %s\n", wine_dbgstr_w(username) );
+    ok( !memcmp( blob, passwordW, sizeof(passwordW) - sizeof(WCHAR) ), "wrong data\n" );
+    ok( size == sizeof(passwordW) - sizeof(WCHAR), "got %u\n", size );
+    pSspiLocalFree( (void *)target );
+    pSspiLocalFree( (void *)username );
+    pSspiLocalFree( blob );
+
+    type = size = 0;
+    status = pSspiPrepareForCredWrite( id, target2W, &type, &target, &username, &blob, &size );
+    ok( status == SEC_E_OK, "got %08x\n", status );
+    ok( type == CRED_TYPE_DOMAIN_PASSWORD, "got %u\n", type );
+    ok( !lstrcmpW( target, target2W ), "got %s\n", wine_dbgstr_w(target) );
+    ok( !lstrcmpW( username, targetW ), "got %s\n", wine_dbgstr_w(username) );
+    ok( !memcmp( blob, passwordW, sizeof(passwordW) - sizeof(WCHAR) ), "wrong data\n" );
+    ok( size == sizeof(passwordW) - sizeof(WCHAR), "got %u\n", size );
+    pSspiLocalFree( (void *)target );
+    pSspiLocalFree( (void *)username );
+    pSspiLocalFree( blob );
+
+    pSspiFreeAuthIdentity( id );
+}
+
 static void test_kerberos(void)
 {
     SecPkgInfoA *info;
@@ -379,6 +436,7 @@
         pSspiEncodeStringsAsAuthIdentity = (void *)GetProcAddress(secdll, "SspiEncodeStringsAsAuthIdentity");
         pSspiFreeAuthIdentity = (void *)GetProcAddress(secdll, "SspiFreeAuthIdentity");
         pSspiLocalFree = (void *)GetProcAddress(secdll, "SspiLocalFree");
+        pSspiPrepareForCredWrite = (void *)GetProcAddress(secdll, "SspiPrepareForCredWrite");
         pSspiZeroAuthIdentity = (void *)GetProcAddress(secdll, "SspiZeroAuthIdentity");
         pGetComputerObjectNameA = (PVOID)GetProcAddress(secdll, "GetComputerObjectNameA");
         pGetComputerObjectNameW = (PVOID)GetProcAddress(secdll, "GetComputerObjectNameW");
@@ -386,7 +444,7 @@
         pGetUserNameExW = (PVOID)GetProcAddress(secdll, "GetUserNameExW");
         pInitSecurityInterfaceA = (PVOID)GetProcAddress(secdll, "InitSecurityInterfaceA");
         pInitSecurityInterfaceW = (PVOID)GetProcAddress(secdll, "InitSecurityInterfaceW");
- 
+
         if (pGetComputerObjectNameA)
             testGetComputerObjectNameA();
         else
@@ -409,6 +467,7 @@
 
         test_InitSecurityInterface();
         test_SspiEncodeStringsAsAuthIdentity();
+        test_SspiPrepareForCredWrite();
 
         FreeLibrary(secdll);
     }
diff -Naur wine-2.0a/dlls/setupapi/dirid.c wine-2.0b/dlls/setupapi/dirid.c
--- wine-2.0a/dlls/setupapi/dirid.c	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/setupapi/dirid.c	2017-07-11 20:37:50.000000000 +0100
@@ -96,6 +96,7 @@
     case DIRID_WINDOWS:
         GetWindowsDirectoryW( buffer, MAX_PATH );
         break;
+    case 13: /* DIRID_SYSTEM32 ? - used by IE6 install */
     case DIRID_SYSTEM:
         GetSystemDirectoryW( buffer, MAX_PATH );
         break;
diff -Naur wine-2.0a/dlls/setupapi/queue.c wine-2.0b/dlls/setupapi/queue.c
--- wine-2.0a/dlls/setupapi/queue.c	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/setupapi/queue.c	2017-07-11 20:37:50.000000000 +0100
@@ -70,6 +70,7 @@
 
 struct file_queue
 {
+    DWORD                dummy;
     struct file_op_queue copy_queue;
     struct file_op_queue delete_queue;
     struct file_op_queue rename_queue;
diff -Naur wine-2.0a/dlls/shell32/ebrowser.c wine-2.0b/dlls/shell32/ebrowser.c
--- wine-2.0a/dlls/shell32/ebrowser.c	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/shell32/ebrowser.c	2017-07-11 20:37:50.000000000 +0100
@@ -578,7 +578,9 @@
         if(SUCCEEDED(hr))
         {
             INameSpaceTreeControlEvents *pnstce;
+#ifndef __ANDROID__
             IShellFolder *psfdesktop;
+#endif
             IShellItem *psi;
             IOleWindow *pow;
             LPITEMIDLIST pidl;
@@ -613,12 +615,17 @@
                 hr = SHCreateShellItem(NULL, NULL, pidl, &psi);
                 if(SUCCEEDED(hr))
                 {
+#ifndef __ANDROID__
                     hr = INameSpaceTreeControl2_AppendRoot(pnstc2, psi, SHCONTF_NONFOLDERS, NSTCRS_VISIBLE, NULL);
+#else
+                    hr = INameSpaceTreeControl2_AppendRoot(pnstc2, psi, SHCONTF_NONFOLDERS, NSTCRS_EXPANDED, NULL);
+#endif
                     IShellItem_Release(psi);
                 }
                 ILFree(pidl);
             }
 
+#ifndef __ANDROID__
             SHGetDesktopFolder(&psfdesktop);
             hr = SHGetItemFromObject((IUnknown*)psfdesktop, &IID_IShellItem, (void**)&psi);
             IShellFolder_Release(psfdesktop);
@@ -627,7 +634,7 @@
                 hr = INameSpaceTreeControl2_AppendRoot(pnstc2, psi, SHCONTF_FOLDERS, NSTCRS_EXPANDED, NULL);
                 IShellItem_Release(psi);
             }
-
+#endif
             /* TODO:
              * We should advertise IID_INameSpaceTreeControl to the site of the
              * host through its IProfferService interface, if any.
diff -Naur wine-2.0a/dlls/shell32/pidl.c wine-2.0b/dlls/shell32/pidl.c
--- wine-2.0a/dlls/shell32/pidl.c	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/shell32/pidl.c	2017-07-11 20:37:50.000000000 +0100
@@ -1245,16 +1245,27 @@
  */
 BOOL WINAPI SHGetPathFromIDListW(LPCITEMIDLIST pidl, LPWSTR pszPath)
 {
+    return SHGetPathFromIDListEx(pidl, pszPath, MAX_PATH, 0);
+}
+
+/*************************************************************************
+ * SHGetPathFromIDListEx             [SHELL32.@]
+ */
+BOOL WINAPI SHGetPathFromIDListEx(LPCITEMIDLIST pidl, WCHAR *path, DWORD path_size, GPFIDL_FLAGS flags)
+{
     HRESULT hr;
     LPCITEMIDLIST pidlLast;
     LPSHELLFOLDER psfFolder;
     DWORD dwAttributes;
     STRRET strret;
 
-    TRACE_(shell)("(pidl=%p,%p)\n", pidl, pszPath);
+    TRACE_(shell)("(pidl=%p,%p,%u,%x)\n", pidl, path, path_size, flags);
     pdump(pidl);
 
-    *pszPath = '\0';
+    if (flags != GPFIDL_DEFAULT)
+        FIXME("Unsupported flags %x\n", flags);
+
+    *path = '\0';
     if (!pidl)
         return FALSE;
 
@@ -1272,9 +1283,9 @@
     IShellFolder_Release(psfFolder);
     if (FAILED(hr)) return FALSE;
 
-    hr = StrRetToBufW(&strret, pidlLast, pszPath, MAX_PATH);
+    hr = StrRetToBufW(&strret, pidlLast, path, path_size);
 
-    TRACE_(shell)("-- %s, 0x%08x\n",debugstr_w(pszPath), hr);
+    TRACE_(shell)("-- %s, 0x%08x\n",debugstr_w(path), hr);
     return SUCCEEDED(hr);
 }
 
diff -Naur wine-2.0a/dlls/shell32/shell32.spec wine-2.0b/dlls/shell32/shell32.spec
--- wine-2.0a/dlls/shell32/shell32.spec	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/shell32/shell32.spec	2017-07-11 20:37:50.000000000 +0100
@@ -390,6 +390,7 @@
 @ stdcall SHGetNewLinkInfo(str str ptr long long) SHGetNewLinkInfoA
 @ stdcall SHGetPathFromIDList(ptr ptr) SHGetPathFromIDListA
 @ stdcall SHGetPathFromIDListA(ptr ptr)
+@ stdcall SHGetPathFromIDListEx(ptr ptr long long)
 @ stdcall SHGetPathFromIDListW(ptr ptr)
 @ stdcall SHGetPropertyStoreForWindow(long ptr ptr)
 @ stdcall SHGetPropertyStoreFromParsingName(wstr ptr long ptr ptr)
@@ -477,3 +478,5 @@
 @ stdcall StrStrIW(wstr wstr) shlwapi.StrStrIW
 @ stdcall StrStrW(wstr wstr) shlwapi.StrStrW
 @ stdcall WOWShellExecute(long str str str str long ptr)
+
+@ stdcall wine_update_symbolic_links()
diff -Naur wine-2.0a/dlls/shell32/shelllink.c wine-2.0b/dlls/shell32/shelllink.c
--- wine-2.0a/dlls/shell32/shelllink.c	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/shell32/shelllink.c	2017-07-11 20:37:50.000000000 +0100
@@ -317,6 +317,9 @@
     WCHAR app[MAX_PATH];
     void *redir;
 
+    if (getenv("CX_NO_WINESHELLLINK"))
+        return TRUE;
+
     GetSystemDirectoryW( app, MAX_PATH - sizeof(menubuilder)/sizeof(WCHAR) );
     strcatW( app, menubuilder );
 
@@ -372,12 +375,33 @@
     IPersistStream *StreamThis = &This->IPersistStream_iface;
     HRESULT r;
     IStream *stm;
+    static const WCHAR wszIEStartMenuHardCoded[] = {'C',':','\\','W','i','n','d','o','w','s','\\','S','t','a','r','t',' ','M','e','n','u','\\','P','r','o','g','r','a','m','s','\\','I','n','t','e','r','n','e','t',' ','E','x','p','l','o','r','e','r','.','l','n','k',0};
+    static const WCHAR wszIEDesktopHardCoded[] = {'C',':','\\','W','i','n','d','o','w','s','\\','D','e','s','k','t','o','p','\\','I','n','t','e','r','n','e','t',' ','E','x','p','l','o','r','e','r','.','l','n','k',0};
+    WCHAR buffer[MAX_PATH];
 
     TRACE("(%p)->(%s)\n",This,debugstr_w(pszFileName));
 
     if (!pszFileName)
         return E_FAIL;
 
+    /* CrossOver HACK! The IE 6 installer hardcodes these paths (which work on
+     * Win9x), but don't in Windows 2000+ and Wine. So fix them up to use the
+     * proper functions to get the directory to save the link into */
+    if (!strcmpW(pszFileName, wszIEStartMenuHardCoded))
+    {
+        r = SHGetFolderPathW(NULL, CSIDL_STARTMENU, NULL, SHGFP_TYPE_CURRENT, buffer);
+        strcatW(buffer, strchrW(strchrW(strchrW(wszIEStartMenuHardCoded, '\\') + 1, '\\') + 1, '\\'));
+        TRACE("changing %s to %s\n", debugstr_w(pszFileName), debugstr_w(buffer));
+        pszFileName = buffer;
+    }
+    else if (!strcmpW(pszFileName, wszIEDesktopHardCoded))
+    {
+        r = SHGetFolderPathW(NULL, CSIDL_DESKTOP, NULL, SHGFP_TYPE_CURRENT, buffer);
+        strcatW(buffer, strchrW(strchrW(strchrW(wszIEDesktopHardCoded, '\\') + 1, '\\') + 1, '\\'));
+        TRACE("changing %s to %s\n", debugstr_w(pszFileName), debugstr_w(buffer));
+        pszFileName = buffer;
+    }
+
     r = SHCreateStreamOnFileW( pszFileName, STGM_READWRITE | STGM_CREATE | STGM_SHARE_EXCLUSIVE, &stm );
     if( SUCCEEDED( r ) )
     {
diff -Naur wine-2.0a/dlls/shell32/shellpath.c wine-2.0b/dlls/shell32/shellpath.c
--- wine-2.0a/dlls/shell32/shellpath.c	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/shell32/shellpath.c	2017-07-11 20:37:50.000000000 +0100
@@ -3273,6 +3273,21 @@
     return hr;
 }
 
+/* CrossOver HACK: Load an English string to work around restoring bottles
+ * with non-US-ASCII characters, which doesn't work when the locale has
+ * changed */
+static inline INT LoadStringW_English( HINSTANCE instance, UINT resource_id,
+                            LPWSTR buffer, INT buflen )
+{
+	INT ret;
+	LCID lcid = GetThreadLocale();
+	SetThreadLocale(MAKELCID(MAKELANGID(LANG_ENGLISH,SUBLANG_DEFAULT),SORT_DEFAULT));
+	ret = LoadStringW(instance, resource_id, buffer, buflen);
+	SetThreadLocale(lcid);
+	return ret;
+}
+
+
 /* Gets a 'semi-expanded' default value of the CSIDL with index folder into
  * pszPath, based on the entries in CSIDL_Data.  By semi-expanded, I mean:
  * - The entry's szDefaultPath may be either a string value or an integer
@@ -3322,7 +3337,7 @@
     if (CSIDL_Data[folder].szDefaultPath &&
      IS_INTRESOURCE(CSIDL_Data[folder].szDefaultPath))
     {
-        if (LoadStringW(shell32_hInstance,
+        if (LoadStringW_English(shell32_hInstance,
          LOWORD(CSIDL_Data[folder].szDefaultPath), resourcePath, MAX_PATH))
         {
             hr = S_OK;
@@ -3685,11 +3700,10 @@
         }
         else if (!strncmpiW(szTemp, UserProfileW, strlenW(UserProfileW)))
         {
-            WCHAR userName[MAX_PATH];
-            DWORD userLen = MAX_PATH;
+            /* CrossOver Hack 12735 */
+            static const WCHAR userName[] = {'c','r','o','s','s','o','v','e','r',0};
 
             strcpyW(szDest, szProfilesPrefix);
-            GetUserNameW(userName, &userLen);
             PathAppendW(szDest, userName);
             PathAppendW(szDest, szTemp + strlenW(UserProfileW));
         }
@@ -4248,6 +4262,10 @@
  */
 static void _SHCreateSymbolicLinks(void)
 {
+#ifdef __ANDROID__
+    static const WCHAR DownloadW[] = {'D','o','w','n','l','o','a','d','\0'};
+    char target[FILENAME_MAX], link[FILENAME_MAX], *favorites;
+#endif
     UINT aidsMyStuff[] = { IDS_MYPICTURES, IDS_MYVIDEOS, IDS_MYMUSIC }, i;
     const WCHAR* MyOSXStuffW[] = { PicturesW, MoviesW, MusicW };
     int acsidlMyStuff[] = { CSIDL_MYPICTURES, CSIDL_MYVIDEO, CSIDL_MYMUSIC };
@@ -4273,7 +4291,11 @@
     hr = XDG_UserDirLookup(xdg_dirs, num, &xdg_results);
     if (FAILED(hr)) xdg_results = NULL;
 
+#ifndef __ANDROID__
     pszHome = getenv("HOME");
+#else
+    pszHome = "/sdcard";
+#endif
     if (pszHome && !stat(pszHome, &statFolder) && S_ISDIR(statFolder.st_mode))
     {
         while (1)
@@ -4305,7 +4327,7 @@
                 break;
             }
 
-            /* Or the hardcoded / OS X Documents folder */
+            /* Or the hardcoded / OS X / RemixOS Documents folder */
             strcpy(szPersonalTarget, pszHome);
             if (_SHAppendToUnixPath(szPersonalTarget, DocumentsW) &&
                !stat(szPersonalTarget, &statFolder) &&
@@ -4380,6 +4402,14 @@
     }
 
     /* Last but not least, the Desktop folder */
+    if (getenv("CX_DIRECT_DESKTOP"))
+    {
+    /* Link the Desktop folder to the native one like in vanilla Wine.
+     * Note that this means .lnk files will be created on the user's native
+     * desktop, next to the corresponding .desktop file on Linux. They will
+     * also not be part of the bottle and will thus not be deleted, archived
+     * or packaged with it.
+     */
     if (pszHome)
         strcpy(szDesktopTarget, pszHome);
     else
@@ -4393,7 +4423,7 @@
     {
         hr = SHGetFolderPathW(NULL, CSIDL_DESKTOPDIRECTORY|CSIDL_FLAG_CREATE, NULL,
                               SHGFP_TYPE_DEFAULT, wszTempPath);
-        if (SUCCEEDED(hr) && (pszDesktop = wine_get_unix_file_name(wszTempPath))) 
+        if (SUCCEEDED(hr) && (pszDesktop = wine_get_unix_file_name(wszTempPath)))
         {
             remove(pszDesktop);
             if (xdg_desktop_dir)
@@ -4403,6 +4433,96 @@
             HeapFree(GetProcessHeap(), 0, pszDesktop);
         }
     }
+    }
+    else
+    {
+        /* CrossOver Hack 12791:
+         * Create the Desktop folder and put a link to the native one inside.
+         */
+        xdg_desktop_dir = xdg_results ? xdg_results[num - 1] : NULL;
+        hr = SHGetFolderPathW(NULL, CSIDL_DESKTOPDIRECTORY|CSIDL_FLAG_CREATE, NULL,
+                              SHGFP_TYPE_DEFAULT, wszTempPath);
+        if (pszHome && SUCCEEDED(hr) &&
+            (pszDesktop = wine_get_unix_file_name(wszTempPath)))
+        {
+#           define szLinuxDesktop  "/My Linux Desktop"
+#           define szMacDesktop    "/My Mac Desktop"
+#           define szRemixDesktop "/My Remix Desktop"
+#           define szNativeDesktop "/My Native Desktop"
+            static const char* szDesktops[] = {szRemixDesktop, szLinuxDesktop, szMacDesktop,
+                                               szNativeDesktop, NULL};
+            const char* pszNativeDesktop;
+#ifdef __ANDROID__
+            pszNativeDesktop = szRemixDesktop;
+#elif defined(linux)
+            pszNativeDesktop = szLinuxDesktop;
+#elif defined(__APPLE__)
+            pszNativeDesktop = szMacDesktop;
+#else
+            pszNativeDesktop = szNativeDesktop;
+#endif
+            for (i=0; szDesktops[i]; i++)
+            {
+                char * pszDesktopLink = HeapAlloc(GetProcessHeap(), 0, strlen(pszDesktop) + strlen(szDesktops[i])+1);
+                strcpy(pszDesktopLink, pszDesktop);
+                strcat(pszDesktopLink, szDesktops[i]);
+                rmdir(pszDesktopLink);
+                if (stat(pszDesktopLink, &statFolder) ||
+                    !S_ISDIR(statFolder.st_mode) ||
+                    statFolder.st_uid != geteuid())
+                {
+#ifdef __ANDROID__
+                    int needSameUid = 0;
+#else
+                    int needSameUid = 0;
+#endif
+                    /* Delete the other platforms' links */
+                    unlink(pszDesktopLink);
+                    if (strcmp(szDesktops[i], pszNativeDesktop) != 0)
+                        continue;
+
+                    /* And create one for the current platform */
+                    if (xdg_desktop_dir)
+                        symlink(xdg_desktop_dir, pszDesktopLink);
+                    else
+                    {
+                        strcpy(szDesktopTarget, pszHome);
+                        if (_SHAppendToUnixPath(szDesktopTarget, DesktopW) &&
+                            !stat(szDesktopTarget, &statFolder) &&
+                            S_ISDIR(statFolder.st_mode) &&
+                            needSameUid ? statFolder.st_uid == geteuid() : 1)
+                            symlink(szDesktopTarget, pszDesktopLink);
+                    }
+                }
+                HeapFree(GetProcessHeap(), 0, pszDesktopLink);
+            }
+            HeapFree(GetProcessHeap(), 0, pszDesktop);
+        }
+    }
+
+#ifdef __ANDROID__
+    hr = SHGetFolderPathW(NULL, CSIDL_FAVORITES|CSIDL_FLAG_CREATE, NULL,
+                          SHGFP_TYPE_DEFAULT, wszTempPath);
+    if (SUCCEEDED(hr) && (favorites = wine_get_unix_file_name(wszTempPath)))
+    {
+#define CREATE_SYMLINK(name) \
+        strcpy(target, pszHome); \
+        strcpy(link, favorites); \
+        if (_SHAppendToUnixPath(target, name) && _SHAppendToUnixPath(link, name)) \
+        { \
+            FIXME( "%s -> %s\n", debugstr_a(link), debugstr_a(target) ); \
+            symlink(target, link); \
+        }
+
+        CREATE_SYMLINK(DocumentsW)
+        CREATE_SYMLINK(PicturesW)
+        CREATE_SYMLINK(MusicW)
+        CREATE_SYMLINK(MoviesW)
+        CREATE_SYMLINK(DownloadW)
+        CREATE_SYMLINK(DesktopW)
+#undef CREATE_SYMLINK
+    }
+#endif
 
     /* Free resources allocated by XDG_UserDirLookup() */
     if (xdg_results)
@@ -4413,6 +4533,12 @@
     }
 }
 
+void WINAPI wine_update_symbolic_links(HWND hwnd, HINSTANCE handle, LPCWSTR cmdline, INT show)
+{
+    TRACE("\n");
+    _SHCreateSymbolicLinks();
+}
+
 /******************************************************************************
  * create_extra_folders  [Internal]
  *
diff -Naur wine-2.0a/dlls/shell32/shfldr_mycomp.c wine-2.0b/dlls/shell32/shfldr_mycomp.c
--- wine-2.0a/dlls/shell32/shfldr_mycomp.c	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/shell32/shfldr_mycomp.c	2017-07-11 20:37:50.000000000 +0100
@@ -26,6 +26,7 @@
 #include <string.h>
 #include <stdarg.h>
 #include <stdio.h>
+#include <limits.h>
 
 #define COBJMACROS
 #define NONAMELESSUNION
@@ -701,6 +702,24 @@
 
                 GetVolumeInformationW (pszPath, wszDrive, sizeof(wszDrive)/sizeof(wszDrive[0]) - 5,
                         NULL, NULL, NULL, NULL, 0);
+
+                /* Display unix path if volume has no label */
+                if (!wszDrive[0])
+                {
+                    char *unix_path = wine_get_unix_file_name(pszPath);
+                    if (unix_path)
+                    {
+                        char real_unix_path[PATH_MAX];
+                        int len;
+
+                        realpath(unix_path, real_unix_path);
+                        HeapFree( GetProcessHeap(), 0, unix_path );
+                        len = MultiByteToWideChar(CP_UNIXCP, 0, real_unix_path, -1,
+                                            wszDrive, sizeof(wszDrive)/sizeof(wszDrive[0]) - 6);
+                        wszDrive[len] = '\0';
+                    }
+                }
+
                 strcatW (wszDrive, wszOpenBracket);
                 lstrcpynW (wszDrive + strlenW(wszDrive), pszPath, 3);
                 strcatW (wszDrive, wszCloseBracket);
diff -Naur wine-2.0a/dlls/shell32/shlexec.c wine-2.0b/dlls/shell32/shlexec.c
--- wine-2.0a/dlls/shell32/shlexec.c	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/shell32/shlexec.c	2017-07-11 20:37:50.000000000 +0100
@@ -340,6 +340,74 @@
     dwCreationFlags = CREATE_UNICODE_ENVIRONMENT;
     if (!(psei->fMask & SEE_MASK_NO_CONSOLE))
         dwCreationFlags |= CREATE_NEW_CONSOLE;
+
+#ifdef __ANDROID__
+    {   /* CX HACK: start the installer if explorer.exe tries to start
+         * an executable. the installer will launch the program like normal if
+         * it isn't a recognized installer executable. */
+        char name[MAX_PATH], *p;
+
+        GetModuleFileNameA(GetModuleHandleA(NULL),name,MAX_PATH);
+        p = strrchr(name,'\\');
+        if (p)
+            p++;
+        else
+            p = name;
+
+        if ((strcasecmp(p,"explorer.exe")==0)){
+            WCHAR **argv;
+            int argc = 0;
+
+            argv = CommandLineToArgvW(lpCmd, &argc);
+
+            /* don't hijack commands with arguments */
+            if(argv && argc == 1){
+                size_t len;
+                char *unix_path;
+
+                /* the installer can currently only start binary files, not MSIs for example */
+                len = strlenW(argv[0]);
+                if((argv[0][len - 3] == 'e' || argv[0][len - 3] == 'E') &&
+                        (argv[0][len - 2] == 'x' || argv[0][len - 2] == 'X') &&
+                        (argv[0][len - 1] == 'e' || argv[0][len - 1] == 'E')){
+
+                    unix_path = wine_get_unix_file_name(argv[0]);
+                    if(unix_path){
+                        static const WCHAR cxlaunchinstallerW[] = {'c','x','l','a','u','n','c','h','i','n','s','t','a','l','l','e','r','.','e','x','e',' ',0};
+                        WCHAR cmdline[MAX_PATH];
+                        size_t end;
+
+                        TRACE("going to override this command line with cxlaunchinstaller: %s\n", wine_dbgstr_w(lpCmd));
+
+                        lstrcpyW(cmdline, cxlaunchinstallerW);
+                        end = sizeof(cxlaunchinstallerW)/sizeof(WCHAR) - 1;
+                        cmdline[end++] = '"';
+
+                        end += MultiByteToWideChar(CP_UNIXCP, 0,
+                                unix_path, -1,
+                                &cmdline[end],
+                                sizeof(cmdline) - sizeof(cxlaunchinstallerW)/sizeof(WCHAR) - 1) - 1;
+                        cmdline[end++] = '"';
+                        cmdline[end++] = 0;
+
+                        ZeroMemory(&startup,sizeof(STARTUPINFOW));
+                        startup.cb = sizeof(STARTUPINFOW);
+                        CreateProcessW(NULL, cmdline, NULL, NULL, FALSE,
+                                0, NULL, lpDirectory, &startup, &info);
+                        CloseHandle(info.hProcess);
+
+                        LocalFree(argv);
+
+                        return 33;
+                    }
+                }
+            }
+
+            LocalFree(argv);
+        }
+    }
+#endif
+
     if (CreateProcessW(NULL, (LPWSTR)lpCmd, NULL, NULL, FALSE, dwCreationFlags, env,
                        lpDirectory, &startup, &info))
     {
@@ -371,6 +439,62 @@
     return retval;
 }
 
+/*
+ * Helper function for ShellExecuteExA
+ * In order to prevent opening of particular extension types
+ */
+static BOOL verify_extension_permission(const WCHAR* ext)
+{
+    static const WCHAR AppDefaultsW[] = {'S','o','f','t','w','a','r','e','\\','W','i','n','e','\\',
+                                         'A','p','p','D','e','f','a','u','l','t','s',0};
+    static const WCHAR DenyShellExecuteW[] = {'D','e','n','y','S','h','e','l','l','E','x','e','c','u','t','e',0};
+    WCHAR buffer[MAX_PATH];
+    WCHAR *filename;
+    HKEY hkey,appkey;
+    int RC;
+    DWORD type,count;
+
+    if(!GetModuleFileNameW(0,buffer,MAX_PATH))
+        return TRUE;
+
+    filename = PathFindFileNameW(buffer);
+    /* @@ Wine registry key: HKCU\Software\Wine\AppDefaults\app.exe */
+    if (RegOpenKeyW( HKEY_CURRENT_USER, AppDefaultsW, &hkey ))
+        return TRUE;
+
+    if (RegOpenKeyW( hkey, filename, &appkey )) appkey = 0;
+    RegCloseKey( hkey );
+
+    if (!appkey)
+        return TRUE;
+
+    RC = TRUE;
+    count = sizeof(buffer);
+    if (!RegQueryValueExW(appkey,DenyShellExecuteW,NULL,&type,(LPBYTE)buffer,&count))
+    {
+        WCHAR *s,*e;
+        int lext;
+
+        buffer[count / sizeof(WCHAR)] = 0;
+        ext++; /* Skip the '.' */
+        lext=strlenW(ext);
+        s=buffer;
+        while (*s) {
+            e=strchrW(s,';');
+            if (!e)
+                e=s+strlenW(s);
+            if ((e-s==lext) && (strncmpiW(ext,s,lext)==0))
+            {
+                RC=FALSE;
+                break;
+            }
+            s=(*e?e+1:e);
+        }
+    }
+    RegCloseKey(appkey);
+    return RC;
+}
+
 
 /***********************************************************************
  *           SHELL_BuildEnvW	[Internal]
@@ -637,6 +761,8 @@
             return SE_ERR_NOASSOC;
         }
 
+        if (!verify_extension_permission(extension)) return 31;  /* no association */
+
         /* Three places to check: */
         /* 1. win.ini, [windows], programs (NB no leading '.') */
         /* 2. Registry, HKEY_CLASS_ROOT\<classname>\shell\open\command */
@@ -1058,6 +1184,37 @@
     return retval;
 }
 
+static UINT_PTR SHELL_CrossOverFallback(const WCHAR* lpFile, const WCHAR* lpVerb, WCHAR* cmdFormat, int cmdFormatSize)
+{
+    /* See if there is a native association for this file.
+     * This is a CodeWeavers only hack.
+     *
+     * But before that, check that this is not the file we just opened
+     * in order to avoid native -> wine -> native association loops.
+     */
+    UINT_PTR retval = SE_ERR_NOASSOC;
+    static const WCHAR NoCrossOverFallbackW[] = {'N','O','C','R','O','S','S','O','V','E','R','F','A','L','L','B','A','C','K',0};
+    WCHAR* nofallback=NULL;
+    int size=GetEnvironmentVariableW(NoCrossOverFallbackW, NULL, 0);
+    if (size)
+    {
+        nofallback=HeapAlloc(GetProcessHeap(), 0, size*sizeof(*nofallback));
+        GetEnvironmentVariableW(NoCrossOverFallbackW, nofallback, size);
+        TRACE("NoCrossOverFallback=%s\n", debugstr_w(nofallback));
+    }
+    if (!nofallback || strcmpW(nofallback, lpFile) != 0)
+    {
+        WCHAR szFallback[MAX_PATH] = {'C','r','o','s','s','O','v','e','r','F','a','l','l','b','a','c','k',0};
+
+        TRACE("Trying CrossOverFallback, verb=%s\n", debugstr_w(lpVerb));
+        retval=SHELL_FindExecutableByVerb(lpVerb, NULL, szFallback, cmdFormat, cmdFormatSize);
+    }
+    if (nofallback)
+        HeapFree(GetProcessHeap(), 0, nofallback);
+    TRACE("CrossOverFallback returning %ld\n", retval);
+    return retval;
+}
+
 /*************************************************************************
  * FindExecutableW			[SHELL32.@]
  *
@@ -1106,6 +1263,35 @@
     if (retval > 32)
         strcpyW(lpResult, res);
 
+    if (retval <= 32)
+    {
+        retval=SHELL_CrossOverFallback(lpFile, wszOpen, lpResult, MAX_PATH*sizeof(*lpResult));
+        if (retval > 32)
+        {
+            /* Remove double quotation marks and command line arguments */
+            if (*lpResult == '"')
+            {
+                WCHAR *p = lpResult;
+                while (*(p + 1) != '"')
+                {
+                    *p = *(p + 1);
+                    p++;
+                }
+                *p = '\0';
+            }
+            else
+            {
+                /* Truncate on first space, like Windows:
+                 * http://support.microsoft.com/?scid=kb%3Ben-us%3B140724
+                 */
+                WCHAR *p = lpResult;
+                while (*p != ' ' && *p != '\0')
+                    p++;
+                *p='\0';
+            }
+        }
+    }
+
     TRACE("returning %s\n", debugstr_w(lpResult));
     if (lpDirectory)
         SetCurrentDirectoryW(old_dir);
@@ -1843,6 +2029,32 @@
         strcatW(lpstrTmpFile, lpFile);
         retval = (UINT_PTR)ShellExecuteW(sei_tmp.hwnd, sei_tmp.lpVerb, lpstrTmpFile, NULL, NULL, 0);
     }
+    else
+    {
+        WCHAR wCmdFormat[1024];
+        retval=SHELL_CrossOverFallback(lpFile, sei_tmp.lpVerb, wCmdFormat, sizeof(wCmdFormat));
+        if (retval > 32)
+        {
+
+            WCHAR wCommandLine[1024];
+            DWORD len;
+            TRACE("wCmdFormat=%s\n", debugstr_w(wCmdFormat));
+            SHELL_ArgifyW(wCommandLine, 1024, wCmdFormat, lpFile, sei_tmp.lpIDList, NULL, &len);
+            TRACE("wCommandLine=%s\n", debugstr_w(wCommandLine));
+            sei_tmp.fMask|=SEE_MASK_NOCLOSEPROCESS;
+            retval = execfunc(wCommandLine, env, FALSE, &sei_tmp, sei);
+            if (retval > 32)
+            {
+                DWORD retcode;
+                WaitForSingleObject(sei->hProcess, INFINITE);
+                GetExitCodeProcess(sei->hProcess, &retcode);
+                CloseHandle(sei->hProcess);
+                sei->hProcess=NULL;
+                TRACE("CrossOverFallback returned %d\n", retcode);
+                retval=(retcode == 0 ? 33 : 31);
+            }
+        }
+    }
 
     TRACE("retval %lu\n", retval);
 
diff -Naur wine-2.0a/dlls/shell32/systray.c wine-2.0b/dlls/shell32/systray.c
--- wine-2.0a/dlls/shell32/systray.c	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/shell32/systray.c	2017-07-11 20:37:50.000000000 +0100
@@ -23,6 +23,12 @@
 #define NONAMELESSUNION
 
 #include <stdarg.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <errno.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <sys/un.h>
 
 #include "windef.h"
 #include "winbase.h"
@@ -126,6 +132,7 @@
 {
     HWND tray;
     COPYDATASTRUCT cds;
+    char *socketname;
     struct notify_data data_buffer;
     struct notify_data *data = &data_buffer;
     BOOL ret;
@@ -240,6 +247,35 @@
 
     cds.lpData = data;
     ret = SendMessageW(tray, WM_COPYDATA, (WPARAM)nid->hWnd, (LPARAM)&cds);
+
+    /* If there's a socket available for communicating back to CrossOver,
+        send a message with everything we know. */
+    if ((socketname = getenv("CX_SYSTRAY_SOCKET")))
+    {
+        struct sockaddr_un sa;
+        int sock = socket(AF_UNIX,SOCK_STREAM,0);
+
+        WINE_TRACE("Sending a systray notification to CrossOver.\n");
+
+        sa.sun_family=AF_UNIX;
+        lstrcpynA(sa.sun_path,socketname,sizeof(sa.sun_path));
+        sa.sun_path[sizeof(sa.sun_path) - 1] = 0;
+
+        if (!connect(sock, (struct sockaddr *) &sa, sizeof(sa)))
+        {
+            uint messageid = WM_COPYDATA;
+            write(sock,&messageid,sizeof(messageid));
+            write(sock,&dwMessage,sizeof(dwMessage));
+            write(sock,&cds.cbData,sizeof(cds.cbData));
+            write(sock,cds.lpData,cds.cbData);
+        }
+        else
+        {
+            WINE_WARN("When sending systray icon, failed to connect to launch-notification socket %s.  errno: %d\n",socketname,errno);
+        }
+        close(sock);
+    }
+
     if (data != &data_buffer) HeapFree( GetProcessHeap(), 0, data );
     return ret;
 }
diff -Naur wine-2.0a/dlls/shell32/tests/shlfolder.c wine-2.0b/dlls/shell32/tests/shlfolder.c
--- wine-2.0a/dlls/shell32/tests/shlfolder.c	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/shell32/tests/shlfolder.c	2017-07-11 20:37:50.000000000 +0100
@@ -76,6 +76,7 @@
 static HRESULT (WINAPI *pSHCreateShellFolderView)(const SFV_CREATE *pcsfv, IShellView **ppsv);
 static HRESULT (WINAPI *pSHCreateShellFolderViewEx)(LPCSFV psvcbi, IShellView **ppv);
 static HRESULT (WINAPI *pSHILCreateFromPath)(LPCWSTR, LPITEMIDLIST *,DWORD*);
+static BOOL (WINAPI *pSHGetPathFromIDListEx)(PCIDLIST_ABSOLUTE,WCHAR*,DWORD,GPFIDL_FLAGS);
 
 static WCHAR *make_wstr(const char *str)
 {
@@ -135,6 +136,7 @@
     MAKEFUNC(SHCreateDefaultContextMenu);
     MAKEFUNC(SHCreateShellFolderView);
     MAKEFUNC(SHCreateShellFolderViewEx);
+    MAKEFUNC(SHGetPathFromIDListEx);
 #undef MAKEFUNC
 
 #define MAKEFUNC_ORD(f, ord) (p##f = (void*)GetProcAddress(hmod, (LPSTR)(ord)))
@@ -1347,10 +1349,34 @@
 
     result = pSHGetPathFromIDListW(pidlTestFile, wszPath);
     ok(result, "SHGetPathFromIDListW failed! Last error: %u\n", GetLastError());
-    IMalloc_Free(ppM, pidlTestFile);
-    if (!result) return;
     ok(0 == lstrcmpW(wszFileName, wszPath), "SHGetPathFromIDListW returned incorrect path for file placed on desktop\n");
 
+    if (pSHGetPathFromIDListEx)
+    {
+        result = pSHGetPathFromIDListEx(pidlEmpty, wszPath, MAX_PATH, SFGAO_FILESYSTEM);
+        ok(result, "SHGetPathFromIDListEx failed: %u\n", GetLastError());
+        ok(!lstrcmpiW(wszDesktop, wszPath), "Unexpected SHGetPathFromIDListEx result %s, expected %s\n",
+           wine_dbgstr_w(wszPath), wine_dbgstr_w(wszDesktop));
+
+        result = pSHGetPathFromIDListEx(pidlTestFile, wszPath, MAX_PATH, SFGAO_FILESYSTEM);
+        ok(result, "SHGetPathFromIDListEx failed: %u\n", GetLastError());
+        ok(!lstrcmpiW(wszFileName, wszPath), "Unexpected SHGetPathFromIDListEx result %s, expected %s\n",
+           wine_dbgstr_w(wszPath), wine_dbgstr_w(wszFileName));
+
+        SetLastError(0xdeadbeef);
+        memset(wszPath, 0x55, sizeof(wszPath));
+        result = pSHGetPathFromIDListEx(pidlTestFile, wszPath, 5, SFGAO_FILESYSTEM);
+        ok(!result, "SHGetPathFromIDListEx returned: %x(%u)\n", result, GetLastError());
+
+        SetLastError(0xdeadbeef);
+        memset(wszPath, 0x55, sizeof(wszPath));
+        result = pSHGetPathFromIDListEx(pidlEmpty, wszPath, 5, SFGAO_FILESYSTEM);
+        ok(!result, "SHGetPathFromIDListEx returned: %x(%u)\n", result, GetLastError());
+    }
+    else
+        win_skip("SHGetPathFromIDListEx not available\n");
+
+    IMalloc_Free(ppM, pidlTestFile);
 
     /* Test if we can get the path from the start menu "program files" PIDL. */
     hr = pSHGetSpecialFolderLocation(NULL, CSIDL_PROGRAM_FILES, &pidlPrograms);
@@ -1358,7 +1384,7 @@
 
     SetLastError(0xdeadbeef);
     result = pSHGetPathFromIDListW(pidlPrograms, wszPath);
-	IMalloc_Free(ppM, pidlPrograms);
+    IMalloc_Free(ppM, pidlPrograms);
     ok(result, "SHGetPathFromIDListW failed\n");
 }
 
diff -Naur wine-2.0a/dlls/shlwapi/string.c wine-2.0b/dlls/shlwapi/string.c
--- wine-2.0a/dlls/shlwapi/string.c	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/shlwapi/string.c	2017-07-11 20:37:50.000000000 +0100
@@ -1521,47 +1521,58 @@
  */
 HRESULT WINAPI StrRetToBufW (LPSTRRET src, const ITEMIDLIST *pidl, LPWSTR dest, UINT len)
 {
-        TRACE("dest=%p len=0x%x strret=%p pidl=%p\n", dest, len, src, pidl);
+    TRACE("dest=%p len=0x%x strret=%p pidl=%p\n", dest, len, src, pidl);
 
-	if (!src)
-	{
-	  WARN("Invalid lpStrRet would crash under Win32!\n");
-	  if (dest)
-	    *dest = '\0';
-	  return E_FAIL;
-	}
-
-	if (!dest || !len)
-	  return E_FAIL;
+    if (!dest || !len)
+        return E_FAIL;
 
-	*dest = '\0';
+    if (!src)
+    {
+        WARN("Invalid lpStrRet would crash under Win32!\n");
+        if (dest)
+            *dest = '\0';
+        return E_FAIL;
+    }
+
+    *dest = '\0';
+
+    switch (src->uType) {
+    case STRRET_WSTR: {
+        size_t dst_len;
+        if (!src->u.pOleStr)
+            return E_FAIL;
+        dst_len = strlenW(src->u.pOleStr);
+        memcpy(dest, src->u.pOleStr, min(dst_len, len-1) * sizeof(WCHAR));
+        dest[min(dst_len, len-1)] = 0;
+        CoTaskMemFree(src->u.pOleStr);
+        if (len <= dst_len)
+        {
+            dest[0] = 0;
+            return E_NOT_SUFFICIENT_BUFFER;
+        }
+        break;
+    }
+
+    case STRRET_CSTR:
+        if (!MultiByteToWideChar( CP_ACP, 0, src->u.cStr, -1, dest, len ))
+            dest[len-1] = 0;
+        break;
 
-	switch (src->uType)
+    case STRRET_OFFSET:
+        if (pidl)
 	{
-	  case STRRET_WSTR:
-            lstrcpynW(dest, src->u.pOleStr, len);
-	    CoTaskMemFree(src->u.pOleStr);
-	    break;
-
-	  case STRRET_CSTR:
-              if (!MultiByteToWideChar( CP_ACP, 0, src->u.cStr, -1, dest, len ))
-                  dest[len-1] = 0;
-	    break;
-
-	  case STRRET_OFFSET:
-	    if (pidl)
-	    {
-              if (!MultiByteToWideChar( CP_ACP, 0, ((LPCSTR)&pidl->mkid)+src->u.uOffset, -1,
-                                        dest, len ))
-                  dest[len-1] = 0;
-	    }
-	    break;
-
-	  default:
-	    FIXME("unknown type!\n");
-	    return E_NOTIMPL;
-	}
-	return S_OK;
+            if (!MultiByteToWideChar( CP_ACP, 0, ((LPCSTR)&pidl->mkid)+src->u.uOffset, -1,
+                                      dest, len ))
+                dest[len-1] = 0;
+        }
+        break;
+
+    default:
+        FIXME("unknown type!\n");
+        return E_NOTIMPL;
+    }
+
+    return S_OK;
 }
 
 /*************************************************************************
diff -Naur wine-2.0a/dlls/shlwapi/tests/string.c wine-2.0b/dlls/shlwapi/tests/string.c
--- wine-2.0a/dlls/shlwapi/tests/string.c	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/shlwapi/tests/string.c	2017-07-11 20:37:50.000000000 +0100
@@ -988,6 +988,7 @@
     WCHAR wstr1[2*MAX_PATH+1], wbuf[2*MAX_PATH];
     const WCHAR fmt[] = {'%','s',0};
     STRRET strret;
+    HRESULT hres;
     int ret;
     int i;
 
@@ -1059,9 +1060,27 @@
         memset(wbuf, 0xbf, sizeof(wbuf));
         strret.uType = STRRET_WSTR;
         U(strret).pOleStr = StrDupW(wstr1);
-        expect_eq2(pStrRetToBufW(&strret, NULL, wbuf, 10), S_OK, E_NOT_SUFFICIENT_BUFFER /* Vista */, HRESULT, "%x");
+        hres = pStrRetToBufW(&strret, NULL, wbuf, 10);
+        ok(hres == E_NOT_SUFFICIENT_BUFFER || broken(hres == S_OK) /* winxp */,
+           "StrRetToBufW returned %08x\n", hres);
+        if (hres == E_NOT_SUFFICIENT_BUFFER)
+            expect_eq(wbuf[0], 0, WCHAR, "%x");
         expect_eq(wbuf[9], 0, WCHAR, "%x");
         expect_eq(wbuf[10], (WCHAR)0xbfbf, WCHAR, "%x");
+
+        memset(wbuf, 0xbf, sizeof(wbuf));
+        strret.uType = STRRET_CSTR;
+        StrCpyNA(U(strret).cStr, str1, MAX_PATH);
+        hres = pStrRetToBufW(&strret, NULL, wbuf, 10);
+        ok(hres == S_OK, "StrRetToBufW returned %08x\n", hres);
+        ok(!memcmp(wbuf, wstr1, 9*sizeof(WCHAR)) && !wbuf[9], "StrRetToBuf returned %s\n", wine_dbgstr_w(wbuf));
+
+        memset(wbuf, 0xbf, sizeof(wbuf));
+        strret.uType = STRRET_WSTR;
+        U(strret).pOleStr = NULL;
+        hres = pStrRetToBufW(&strret, NULL, wbuf, 10);
+        ok(hres == E_FAIL, "StrRetToBufW returned %08x\n", hres);
+        ok(!wbuf[0], "StrRetToBuf returned %s\n", wine_dbgstr_w(wbuf));
     }
     else
         win_skip("StrRetToBufW() is not available\n");
diff -Naur wine-2.0a/dlls/sspicli/main.c wine-2.0b/dlls/sspicli/main.c
--- wine-2.0a/dlls/sspicli/main.c	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/sspicli/main.c	2017-07-11 20:37:50.000000000 +0100
@@ -22,6 +22,7 @@
 #include "winbase.h"
 #include "rpc.h"
 #include "sspi.h"
+#include "wincred.h"
 
 #include "wine/debug.h"
 #include "wine/unicode.h"
@@ -140,3 +141,59 @@
     TRACE( "%p\n", ptr );
     HeapFree( GetProcessHeap(), 0, ptr );
 }
+
+/***********************************************************************
+ *		SspiPrepareForCredWrite (SECUR32.0)
+ */
+SECURITY_STATUS SEC_ENTRY SspiPrepareForCredWrite( PSEC_WINNT_AUTH_IDENTITY_OPAQUE opaque_id,
+    PCWSTR target, PULONG type, PCWSTR *targetname, PCWSTR *username, PUCHAR *blob, PULONG size )
+{
+    SEC_WINNT_AUTH_IDENTITY_W *id = (SEC_WINNT_AUTH_IDENTITY_W *)opaque_id;
+    WCHAR *str, *str2;
+    UCHAR *password;
+    ULONG len;
+
+    FIXME( "%p %s %p %p %p %p %p\n", opaque_id, debugstr_w(target), type, targetname, username,
+           blob, size );
+
+    if (id->DomainLength)
+    {
+        len = (id->DomainLength + id->UserLength + 2) * sizeof(WCHAR);
+        if (!(str = HeapAlloc(GetProcessHeap(), 0 , len ))) return SEC_E_INSUFFICIENT_MEMORY;
+        memcpy( str, id->Domain, id->DomainLength * sizeof(WCHAR) );
+        str[id->DomainLength] = '\\';
+        memcpy( str + id->DomainLength + 1, id->User, id->UserLength * sizeof(WCHAR) );
+        str[id->DomainLength + 1 + id->UserLength] = 0;
+    }
+    else
+    {
+        len = (id->UserLength + 1) * sizeof(WCHAR);
+        if (!(str = HeapAlloc(GetProcessHeap(), 0 , len ))) return SEC_E_INSUFFICIENT_MEMORY;
+        memcpy( str, id->User, id->UserLength * sizeof(WCHAR) );
+        str[id->UserLength] = 0;
+    }
+
+    str2 = target ? strdupW( target ) : strdupW( str );
+    if (!str2)
+    {
+        HeapFree( GetProcessHeap(), 0, str );
+        return SEC_E_INSUFFICIENT_MEMORY;
+    }
+
+    len = id->PasswordLength * sizeof(WCHAR);
+    if (!(password = HeapAlloc(GetProcessHeap(), 0 , len )))
+    {
+        HeapFree( GetProcessHeap(), 0, str );
+        HeapFree( GetProcessHeap(), 0, str2 );
+        return SEC_E_INSUFFICIENT_MEMORY;
+    }
+    memcpy( password, id->Password, len );
+
+    *type = CRED_TYPE_DOMAIN_PASSWORD;
+    *username = str;
+    *targetname = str2;
+    *blob = password;
+    *size = len;
+
+    return SEC_E_OK;
+}
diff -Naur wine-2.0a/dlls/sspicli/sspicli.spec wine-2.0b/dlls/sspicli/sspicli.spec
--- wine-2.0a/dlls/sspicli/sspicli.spec	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/sspicli/sspicli.spec	2017-07-11 20:37:50.000000000 +0100
@@ -95,7 +95,7 @@
 @ stdcall SspiLocalFree(ptr)
 @ stub SspiMarshalAuthIdentity
 @ stub SspiPrepareForCredRead
-@ stub SspiPrepareForCredWrite
+@ stdcall SspiPrepareForCredWrite(ptr wstr ptr ptr ptr ptr ptr)
 @ stub SspiUnmarshalAuthIdentity
 @ stub SspiUnmarshalAuthIdentityInternal
 @ stub SspiValidateAuthIdentity
diff -Naur wine-2.0a/dlls/taskschd/Makefile.in wine-2.0b/dlls/taskschd/Makefile.in
--- wine-2.0a/dlls/taskschd/Makefile.in	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/taskschd/Makefile.in	2017-07-11 20:37:50.000000000 +0100
@@ -11,3 +11,5 @@
 IDL_SRCS = \
 	schrpc.idl \
 	taskschd_tlb.idl
+
+folder_EXTRADEFS = $(FORCE_ALIGN_ARG_BUG_CFLAGS)
diff -Naur wine-2.0a/dlls/uiautomationcore/Makefile.in wine-2.0b/dlls/uiautomationcore/Makefile.in
--- wine-2.0a/dlls/uiautomationcore/Makefile.in	1970-01-01 01:00:00.000000000 +0100
+++ wine-2.0b/dlls/uiautomationcore/Makefile.in	2017-07-11 20:37:50.000000000 +0100
@@ -0,0 +1,5 @@
+MODULE = uiautomationcore.dll
+IMPORTS = advapi32
+
+C_SRCS = \
+	uia_main.c
diff -Naur wine-2.0a/dlls/uiautomationcore/uia_main.c wine-2.0b/dlls/uiautomationcore/uia_main.c
--- wine-2.0a/dlls/uiautomationcore/uia_main.c	1970-01-01 01:00:00.000000000 +0100
+++ wine-2.0b/dlls/uiautomationcore/uia_main.c	2017-07-11 20:37:50.000000000 +0100
@@ -0,0 +1,68 @@
+/*
+ * Copyright 2017 Jacek Caban for CodeWeavers
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include "uiautomationcore.h"
+
+#include "wine/debug.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(uiautomation);
+
+static BOOL disable_dll_hack(void)
+{
+    HKEY key;
+    DWORD res;
+    static const WCHAR enable_keyW[] =
+        {'S','o','f','t','w','a','r','e',
+         '\\','W','i','n','e',
+         '\\','E','n','a','b','l','e','U','I','A','u','t','o','m','a','t','i','o','n','C','o','r','e',0};
+
+    res = RegOpenKeyW(HKEY_CURRENT_USER, enable_keyW, &key);
+    if(res == ERROR_SUCCESS) {
+        RegCloseKey(key);
+        return FALSE;
+    }
+
+    FIXME("CXHACK: Disabling uiautomationcore.dll.");
+    return TRUE;
+}
+
+BOOL WINAPI DllMain(HINSTANCE hInstDLL, DWORD fdwReason, void *lpv)
+{
+    TRACE("(%p %d %p)\n", hInstDLL, fdwReason, lpv);
+
+    switch(fdwReason) {
+    case DLL_WINE_PREATTACH:
+        return FALSE;  /* prefer native version */
+    case DLL_PROCESS_ATTACH:
+        if(disable_dll_hack())
+            return FALSE;
+        DisableThreadLibraryCalls(hInstDLL);
+        break;
+    }
+
+    return TRUE;
+}
+
+/***********************************************************************
+ *          UiaClientsAreListening (uiautomationcore.@)
+ */
+BOOL WINAPI UiaClientsAreListening(void)
+{
+    FIXME("()\n");
+    return FALSE;
+}
diff -Naur wine-2.0a/dlls/uiautomationcore/uiautomationcore.spec wine-2.0b/dlls/uiautomationcore/uiautomationcore.spec
--- wine-2.0a/dlls/uiautomationcore/uiautomationcore.spec	1970-01-01 01:00:00.000000000 +0100
+++ wine-2.0b/dlls/uiautomationcore/uiautomationcore.spec	2017-07-11 20:37:50.000000000 +0100
@@ -0,0 +1,93 @@
+@ stub DllCanUnloadNow
+@ stub DllGetClassObject
+@ stub DllRegisterServer
+@ stub DllUnregisterServer
+@ stub DockPattern_SetDockPosition
+@ stub ExpandCollapsePattern_Collapse
+@ stub ExpandCollapsePattern_Expand
+@ stub GridPattern_GetItem
+@ stub InvokePattern_Invoke
+@ stub ItemContainerPattern_FindItemByProperty
+@ stub LegacyIAccessiblePattern_DoDefaultAction
+@ stub LegacyIAccessiblePattern_GetIAccessible
+@ stub LegacyIAccessiblePattern_Select
+@ stub LegacyIAccessiblePattern_SetValue
+@ stub MultipleViewPattern_GetViewName
+@ stub MultipleViewPattern_SetCurrentView
+@ stub RangeValuePattern_SetValue
+@ stub ScrollItemPattern_ScrollIntoView
+@ stub ScrollPattern_Scroll
+@ stub ScrollPattern_SetScrollPercent
+@ stub SelectionItemPattern_AddToSelection
+@ stub SelectionItemPattern_RemoveFromSelection
+@ stub SelectionItemPattern_Select
+@ stub SynchronizedInputPattern_Cancel
+@ stub SynchronizedInputPattern_StartListening
+@ stub TextPattern_GetSelection
+@ stub TextPattern_GetVisibleRanges
+@ stub TextPattern_RangeFromChild
+@ stub TextPattern_RangeFromPoint
+@ stub TextPattern_get_DocumentRange
+@ stub TextPattern_get_SupportedTextSelection
+@ stub TextRange_AddToSelection
+@ stub TextRange_Clone
+@ stub TextRange_Compare
+@ stub TextRange_CompareEndpoints
+@ stub TextRange_ExpandToEnclosingUnit
+@ stub TextRange_FindAttribute
+@ stub TextRange_FindText
+@ stub TextRange_GetAttributeValue
+@ stub TextRange_GetBoundingRectangles
+@ stub TextRange_GetChildren
+@ stub TextRange_GetEnclosingElement
+@ stub TextRange_GetText
+@ stub TextRange_Move
+@ stub TextRange_MoveEndpointByRange
+@ stub TextRange_MoveEndpointByUnit
+@ stub TextRange_RemoveFromSelection
+@ stub TextRange_ScrollIntoView
+@ stub TextRange_Select
+@ stub TogglePattern_Toggle
+@ stub TransformPattern_Move
+@ stub TransformPattern_Resize
+@ stub TransformPattern_Rotate
+@ stub UiaAddEvent
+@ stdcall UiaClientsAreListening()
+@ stub UiaEventAddWindow
+@ stub UiaEventRemoveWindow
+@ stub UiaFind
+@ stub UiaGetErrorDescription
+@ stub UiaGetPatternProvider
+@ stub UiaGetPropertyValue
+@ stub UiaGetReservedMixedAttributeValue
+@ stub UiaGetReservedNotSupportedValue
+@ stub UiaGetRootNode
+@ stub UiaGetRuntimeId
+@ stub UiaGetUpdatedCache
+@ stub UiaHPatternObjectFromVariant
+@ stub UiaHTextRangeFromVariant
+@ stub UiaHUiaNodeFromVariant
+@ stub UiaHasServerSideProvider
+@ stub UiaHostProviderFromHwnd
+@ stub UiaLookupId
+@ stub UiaNavigate
+@ stub UiaNodeFromFocus
+@ stub UiaNodeFromHandle
+@ stub UiaNodeFromPoint
+@ stub UiaNodeFromProvider
+@ stub UiaNodeRelease
+@ stub UiaPatternRelease
+@ stub UiaRaiseAsyncContentLoadedEvent
+@ stub UiaRaiseAutomationEvent
+@ stub UiaRaiseAutomationPropertyChangedEvent
+@ stub UiaRaiseStructureChangedEvent
+@ stub UiaRegisterProviderCallback
+@ stub UiaRemoveEvent
+@ stub UiaReturnRawElementProvider
+@ stub UiaSetFocus
+@ stub UiaTextRangeRelease
+@ stub ValuePattern_SetValue
+@ stub VirtualizedItemPattern_Realize
+@ stub WindowPattern_Close
+@ stub WindowPattern_SetWindowVisualState
+@ stub WindowPattern_WaitForInputIdle
diff -Naur wine-2.0a/dlls/user32/combo.c wine-2.0b/dlls/user32/combo.c
--- wine-2.0a/dlls/user32/combo.c	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/user32/combo.c	2017-07-11 20:37:50.000000000 +0100
@@ -1787,6 +1787,22 @@
     pcbi->hwndCombo = lphc->self;
     pcbi->hwndItem = lphc->hWndEdit;
     pcbi->hwndList = lphc->hWndLBox;
+
+    /* Codeweavers Hack for Project 2010, see bug 9946 */
+    if(!pcbi->hwndItem) {
+        char process_name[MAX_PATH], *p;
+
+        GetModuleFileNameA(GetModuleHandleA(NULL), process_name, MAX_PATH);
+        p = strrchr(process_name, '\\');
+        if(p)
+            p++;
+        else
+            p = process_name;
+
+        if(!strcasecmp(p, "winproj.exe"))
+            pcbi->hwndItem = pcbi->hwndCombo;
+    }
+
     return TRUE;
 }
 
diff -Naur wine-2.0a/dlls/user32/driver.c wine-2.0b/dlls/user32/driver.c
--- wine-2.0a/dlls/user32/driver.c	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/user32/driver.c	2017-07-11 20:37:50.000000000 +0100
@@ -39,6 +39,8 @@
 const USER_DRIVER *USER_Driver = &lazy_load_driver;
 static char driver_load_error[80];
 
+static BOOL CDECL nodrv_CreateWindow( HWND hwnd );
+
 static HMODULE load_desktop_driver( HWND hwnd )
 {
     static const WCHAR display_device_guid_propW[] = {
@@ -152,6 +154,16 @@
         GET_USER_FUNC(ThreadDetach);
 #undef GET_USER_FUNC
     }
+    else
+    {
+        USEROBJECTFLAGS flags;
+        HWINSTA winstation;
+
+        winstation = GetProcessWindowStation();
+        if (!GetUserObjectInformationA(winstation, UOI_FLAGS, &flags, sizeof(flags), NULL)
+            || (flags.dwFlags & WSF_VISIBLE))
+            driver->pCreateWindow = nodrv_CreateWindow;
+    }
 
     prev = InterlockedCompareExchangePointer( (void **)&USER_Driver, driver, &lazy_load_driver );
     if (prev != &lazy_load_driver)
@@ -360,7 +372,7 @@
     return TRUE;
 }
 
-static BOOL CDECL nulldrv_CreateWindow( HWND hwnd )
+static BOOL CDECL nodrv_CreateWindow( HWND hwnd )
 {
     static int warned;
     HWND parent = GetAncestor( hwnd, GA_PARENT );
@@ -374,6 +386,11 @@
     return FALSE;
 }
 
+static BOOL CDECL nulldrv_CreateWindow( HWND hwnd )
+{
+    return TRUE;
+}
+
 static void CDECL nulldrv_DestroyWindow( HWND hwnd )
 {
 }
diff -Naur wine-2.0a/dlls/user32/focus.c wine-2.0b/dlls/user32/focus.c
--- wine-2.0a/dlls/user32/focus.c	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/user32/focus.c	2017-07-11 20:37:50.000000000 +0100
@@ -209,6 +209,11 @@
         else  /* new window belongs to us */
             ret = set_active_window( hwnd, NULL, mouse, TRUE );
     }
+
+#ifdef __APPLE__
+    MENU_send_window_menubar_to_macapp( hwnd );
+#endif
+
     return ret;
 }
 
@@ -309,6 +314,9 @@
         if (HOOK_CallHooks( WH_CBT, HCBT_SETFOCUS, 0, (LPARAM)previous, TRUE )) return 0;
     }
 
+    /* CrossOver HACK for bug 6727 */
+    MENU_send_window_menubar_to_macapp( hwnd );
+
     /* change focus and send messages */
     return set_focus_window( hwnd );
 }
diff -Naur wine-2.0a/dlls/user32/hook.c wine-2.0b/dlls/user32/hook.c
--- wine-2.0a/dlls/user32/hook.c	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/user32/hook.c	2017-07-11 20:37:50.000000000 +0100
@@ -362,11 +362,43 @@
 void *get_hook_proc( void *proc, const WCHAR *module, HMODULE *free_module )
 {
     HMODULE mod;
+    static INT isBlocking = -1;
 
     GetModuleHandleExW( 0, module, &mod );
     *free_module = mod;
     if (!mod)
     {
+        /* Codeweavers Hack for Quicken Update */
+        if (isBlocking == -1)
+        {
+            char processName[MAX_PATH];
+            char *p;
+            GetModuleFileNameA(GetModuleHandleA(NULL),processName,MAX_PATH);
+            p = strrchr(processName,'\\');
+            if (p)
+                p++;
+            else
+                p = processName;
+            if (strcasecmp(p,"explorer.exe")==0 || strcasecmp(p,"qwpatch.exe")==0)
+                isBlocking = 1;
+            else
+                isBlocking = 0;
+        }
+
+        if (isBlocking)
+        {
+            LPCWSTR ptr;
+            static const WCHAR szQwMain[] = {'Q','W','M','A','I','N','.','D','L','L',0};
+            static const WCHAR szQwWin[] = {'Q','W','W','I','N','.','D','L','L',0};
+
+            ptr = strrchrW(module,'\\');
+            if (!ptr) ptr = module; else ptr++;
+            if (lstrcmpiW(ptr,szQwMain)==0 || lstrcmpiW(ptr,szQwWin)==0)
+            {
+                TRACE("Blocking Hook for Quicken Update\n");
+                return NULL;
+            }
+        }
         TRACE( "loading %s\n", debugstr_w(module) );
         /* FIXME: the library will never be freed */
         if (!(mod = LoadLibraryExW(module, NULL, LOAD_WITH_ALTERED_SEARCH_PATH))) return NULL;
diff -Naur wine-2.0a/dlls/user32/menu.c wine-2.0b/dlls/user32/menu.c
--- wine-2.0a/dlls/user32/menu.c	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/user32/menu.c	2017-07-11 20:37:50.000000000 +0100
@@ -44,6 +44,11 @@
 
 #include <stdarg.h>
 #include <string.h>
+#include <errno.h>
+#include <stdio.h>
+#include <poll.h>
+#include <sys/un.h>
+#include <sys/socket.h>
 
 #define OEMRESOURCE
 
@@ -1040,9 +1045,12 @@
          */
         lpitem->rect.right += mis.itemWidth + 2 * menucharsize.cx;
         if (menuBar) {
-            /* under at least win95 you seem to be given a standard
-               height for the menu and the height value is ignored */
-            lpitem->rect.bottom += GetSystemMetrics(SM_CYMENUSIZE);
+            if (!getenv("CX_MENU_SOCKET"))
+            {
+                /* under at least win95 you seem to be given a standard
+                   height for the menu and the height value is ignored */
+                lpitem->rect.bottom += GetSystemMetrics(SM_CYMENUSIZE);
+            }
         } else
             lpitem->rect.bottom += mis.itemHeight;
 
@@ -1136,7 +1144,14 @@
         }
 	if (hfontOld) SelectObject (hdc, hfontOld);
     } else if( menuBar) {
-        itemheight = max( itemheight, GetSystemMetrics(SM_CYMENU)-1);
+        if (getenv("CX_MENU_SOCKET"))
+        {
+            itemheight = 0;
+        }
+        else
+        {
+            itemheight = max( itemheight, GetSystemMetrics(SM_CYMENU)-1);
+        }
     }
     lpitem->rect.bottom += itemheight;
     TRACE("%s\n", wine_dbgstr_rect( &lpitem->rect));
@@ -1302,7 +1317,14 @@
     }
 
     lprect->bottom = maxY;
-    lppop->Height = lprect->bottom - lprect->top;
+    if (getenv("CX_MENU_SOCKET"))
+    {
+        lppop->Height = 0;
+    }
+    else
+    {
+        lppop->Height = lprect->bottom - lprect->top;
+    }
 
     /* Flush right all items between the MF_RIGHTJUSTIFY and */
     /* the last item (if several lines, only move the last line) */
@@ -1791,6 +1813,484 @@
     }
 }
 
+
+#ifdef __APPLE__
+/***********************************************************************
+ *           MENU_get_menu_socket
+ *
+ *  CrossOver HACKs for bug 6727.
+ *
+ *  On OSX, crossover.app can put a socket handle in
+ *   the CX_MENU_SOCKET environemtn variable.  If that
+ *   value is set then we will make an XML structure out
+ *   of the menu bar and pass it upstream so that the mac
+ *   application can display a proper mac-style menubar.
+ *
+ */
+static int MENU_get_menu_socket(void)
+{
+    char *socketname;
+
+    if ((socketname = getenv("CX_MENU_SOCKET")))
+    {
+        struct sockaddr_un sa;
+        int sock = socket(AF_UNIX,SOCK_STREAM,0);
+        TRACE("Found socket %s.\n",socketname);
+
+        sa.sun_family=AF_UNIX;
+        if (strlen(socketname) > (sizeof(sa.sun_path)-1))
+        {
+            TRACE("Socket name %s is too long for us to use!\n", socketname);
+            return -1;
+        }
+
+        lstrcpynA(sa.sun_path,socketname,sizeof(sa.sun_path));
+
+        if (!connect(sock, (struct sockaddr *) &sa, sizeof(sa)))
+        {
+            /* Make the socket nonblocking.  That prevents us from locking up
+               if the Mac App stops listening. */
+            int flags = fcntl(sock, F_GETFL);
+            if (fcntl(sock, F_SETFL, flags | O_NONBLOCK) == -1)
+            {
+                TRACE("Failed to set socket to O_NONBLOCK.\n");
+            }
+
+            return sock;
+        }
+        else
+        {
+            WINE_WARN("Failed to connect to menu socket %s.  errno: %d\n",socketname,errno);
+            return -1;
+        }
+    }
+
+    return -1;
+}
+
+/***********************************************************************
+ *           to_utf8
+ *
+ *  CrossOver HACKs for bug 6727.
+ *
+ *  This function and the next one are used to sanitize internal menu
+ *   titles so they can be embedded in XML as utf8.
+ *
+ */
+static LPSTR to_utf8(LPCWSTR strW)
+{
+    LPSTR str;
+    int len;
+
+    len = WideCharToMultiByte(CP_UTF8, 0, strW, -1, NULL, 0, NULL, NULL);
+    str = HeapAlloc(GetProcessHeap(), 0, len);
+    WideCharToMultiByte(CP_UTF8, 0, strW, -1, str, len, NULL, NULL);
+    return str;
+}
+
+/***********************************************************************
+ *           sanitize_for_xml
+ *
+ *  CrossOver HACKs for bug 6727.
+ *
+ */
+static char* sanitize_for_xml(const WCHAR* srcW)
+{
+    const char* s;
+    char *src, *dst, *d;
+    DWORD len;
+
+    src=to_utf8(srcW);
+
+    /* Start with 1 rather than 0 to make room for null-termination */
+    len=1;
+    for (s=src; *s; s++)
+    {
+        switch (*s)
+        {
+        case '<':
+        case '>':
+            len+=4;
+            break;
+        case '\'':
+            len+=6;
+            break;
+        case '\"':
+            len+=6;
+            break;
+        case '&':
+            len+=5;
+            break;
+        default:
+            if ((unsigned char)*s <= 0x1f)
+                len+=3;
+            else
+                len+=1;
+        }
+    }
+
+    dst=d=HeapAlloc(GetProcessHeap(), 0, len);
+    for (s=src; *s; s++)
+    {
+        switch (*s)
+        {
+        case '<':
+            sprintf(d, "&lt;");
+            d+=4;
+            break;
+        case '>':
+            sprintf(d, "&gt;");
+            d+=4;
+            break;
+        case '\'':
+            sprintf(d, "&apos;");
+            d+=6;
+            break;
+        case '&':
+            sprintf(d, "&amp;");
+            d+=5;
+            break;
+        case '\"':
+            sprintf(d, "&quot;");
+            d+=6;
+            break;
+        default:
+            if ((unsigned char)*s <= 0x1f)
+            {
+                sprintf(d, "^%02X", (unsigned char) *s);
+                d+=3;
+            }
+            else
+            {
+                *d=*s;
+                d++;
+            }
+        }
+    }
+    *d='\0';
+
+    HeapFree(GetProcessHeap(), 0, src);
+    return dst;
+}
+
+
+static BOOL MENU_write_data_to_pipe(int sock, const char *data, int len)
+{
+    int written = 0;
+    short revents = 0;
+
+    while (written < len && !(revents & (POLLERR | POLLHUP)))
+    {
+        struct pollfd pollstruct;
+        int ready;
+
+        pollstruct.fd = sock;
+        pollstruct.events = POLLOUT;
+        pollstruct.revents = revents;
+
+        ready = poll(&pollstruct, 1, 1000);
+        if (ready && (ready != -1))
+        {
+            int thisChunkSize;
+            thisChunkSize = write(sock,data+written,len-written);
+            if (thisChunkSize == -1)
+            {
+                TRACE("Failed to write menu info.  errno: %d\n", errno);
+                break;
+            }
+            written += thisChunkSize;
+        }
+        else
+        {
+            /*  Timed out.  If the Mac app isn't listening, we
+                can just error out... there will be plenty more
+                menus where this one came from.  */
+            return FALSE;
+        }
+    }
+
+    if (written < len)
+    {
+        WINE_WARN("Failed to write to menu socket.  errno: %d\n",errno);
+        return FALSE;
+    }
+
+    return TRUE;
+}
+
+/***********************************************************************
+ *           MENU_put_escaped_string_on_pipe
+ *
+ *  CrossOver HACKs for bug 6727.
+ *
+ *  Sanitize a string and then write it to the CX_MENU_SOCKET.
+ *
+ */
+static BOOL MENU_put_escaped_string_on_pipe(int sock,  const WCHAR *string)
+{
+    BOOL rval;
+    if (sock)
+    {
+        LPSTR escapedstring = sanitize_for_xml(string);
+        int size = strlen(escapedstring);
+        rval = MENU_write_data_to_pipe(sock, escapedstring, size);
+        HeapFree(GetProcessHeap(), 0, escapedstring);
+    }
+    else
+    {
+        rval = FALSE;
+        TRACE("no socket.\n");
+    }
+
+    return rval;
+}
+
+/***********************************************************************
+ *           MENU_put_string_on_pipe
+ *
+ *  CrossOver HACKs for bug 6727.
+ *
+ *  Convert a string to utf8 and Write it to the CX_MENU_SOCKET.
+ *
+ */
+static BOOL MENU_put_string_on_pipe(int sock, const WCHAR *string)
+{
+    BOOL rval;
+    if (sock)
+    {
+        LPSTR utf8copy = to_utf8(string);
+        int size = strlen(utf8copy);
+        rval = MENU_write_data_to_pipe(sock, utf8copy, size);
+        HeapFree(GetProcessHeap(), 0, utf8copy);
+    }
+    else
+    {
+        rval = FALSE;
+        TRACE("no socket.\n");
+    }
+
+    return rval;
+}
+
+static BOOL MENU_put_astring_on_pipe(int sock, const char *string)
+{
+    BOOL rval;
+
+    if (sock)
+    {
+        int size = strlen(string);
+        rval = MENU_write_data_to_pipe(sock, string, size);
+    }
+    else
+    {
+        rval = FALSE;
+        TRACE("no socket.\n");
+    }
+
+    return rval;
+}
+
+
+/* We'll be composing our own XML structures using these tags. */
+static const WCHAR mainmenutitle[] =  {'m','a','i','n','m','e','n','u','\0'};
+
+static const WCHAR menuitemtag[] =  {'<','m','e','n','u','i','t','e','m','>','\0'};
+static const WCHAR menuitemendtag[] = {'<','/','m','e','n','u','i','t','e','m','>','\n','\0'};
+
+static const WCHAR menutag[] =  {'<','m','e','n','u','>','\0'};
+static const WCHAR menuendtag[] = {'<','/','m','e','n','u','>','\n','\0'};
+static const WCHAR titletag[] =  {'<','t','i','t','l','e','>','\0'};
+static const WCHAR titleendtag[] =  {'<','/','t','i','t','l','e','>','\0'};
+static const WCHAR statetag[] =  {'<','s','t','a','t','e','>','\0'};
+static const WCHAR stateendtag[] =  {'<','/','s','t','a','t','e','>','\0'};
+static const WCHAR hwndtag[] =  {'<','h','w','n','d','>','\0'};
+static const WCHAR hwndendtag[] =  {'<','/','h','w','n','d','>','\0'};
+static const WCHAR menuidtag[] =  {'<','m','e','n','u','i','d','>','\0'};
+static const WCHAR menuidendtag[] =  {'<','/','m','e','n','u','i','d','>','\0'};
+static const WCHAR empty[] = {'\0'};
+
+static BOOL MENU_put_menu_on_pipe(int sock,  HMENU hMenu, const WCHAR *title, HWND hwnd);
+
+/***********************************************************************
+ *           MENU_put_item_on_pipe
+ *
+ *  CrossOver HACKs for bug 6727.
+ *
+ *  Compose an XML element for a single menu item, and
+ *   write it to the CX_MENU_SOCKET.
+ *
+ *  If the menu item has a submenu, call MENY_put_menu_on_pipe
+ *   recursively.
+ *
+ */
+static BOOL MENU_put_item_on_pipe(int sock,  MENUITEM *item)
+{
+    char idstring[16];
+    sprintf(idstring, "%d", (UINT) item->wID);
+    if (item->fType & MF_SEPARATOR)
+    {
+        if (!MENU_put_string_on_pipe(sock, menuitemtag))
+            return FALSE;
+        if (!MENU_put_string_on_pipe(sock, menuitemendtag))
+            return FALSE;
+    }
+    else if (item->hSubMenu)
+    {
+        if(!MENU_put_menu_on_pipe(sock, item->hSubMenu, item->text, (HWND) -1))
+            return FALSE;
+    }
+    else
+    {
+        char statestring[16];
+        sprintf(statestring, "%d", item->fState);
+        if (!MENU_put_string_on_pipe(sock, menuitemtag))
+            return FALSE;
+        if (!MENU_put_string_on_pipe(sock, menuidtag))
+            return FALSE;
+        if (!MENU_put_astring_on_pipe(sock, idstring))
+            return FALSE;
+        if (!MENU_put_string_on_pipe(sock, menuidendtag))
+            return FALSE;
+        if (!MENU_put_string_on_pipe(sock, titletag))
+            return FALSE;
+        if (!MENU_put_escaped_string_on_pipe(sock, item->text))
+            return FALSE;
+        if (!MENU_put_string_on_pipe(sock, titleendtag))
+            return FALSE;
+        if (!MENU_put_string_on_pipe(sock, statetag))
+            return FALSE;
+        if (!MENU_put_astring_on_pipe(sock, statestring))
+            return FALSE;
+        if (!MENU_put_string_on_pipe(sock, stateendtag))
+            return FALSE;
+        if (!MENU_put_string_on_pipe(sock, menuitemendtag))
+            return FALSE;
+    }
+
+    return TRUE;
+}
+
+/***********************************************************************
+ *           MENU_put_menu_on_pipe
+ *
+ *  CrossOver HACKs for bug 6727.
+ *
+ *  Compose an XML element for a complete menu.  This
+ *   may get called recursively via MENU_put_menu_item_on_pipe.
+ *
+ */
+static BOOL MENU_put_menu_on_pipe(int sock,  HMENU hMenu, const WCHAR *title, HWND hwnd)
+{
+    int i;
+    POPUPMENU *menu = MENU_GetMenu(hMenu);
+    char idstring[16];
+
+    if (!menu)
+    {
+        return TRUE;
+    }
+    sprintf(idstring, "%d", (UINT) hMenu);
+
+    if (!MENU_put_string_on_pipe(sock, menutag))
+        return FALSE;
+    if (!MENU_put_string_on_pipe(sock, menuidtag))
+        return FALSE;
+    if (!MENU_put_astring_on_pipe(sock, idstring))
+        return FALSE;
+    if (!MENU_put_string_on_pipe(sock, menuidendtag))
+        return FALSE;
+    if (!MENU_put_string_on_pipe(sock, titletag))
+        return FALSE;
+    if (!MENU_put_escaped_string_on_pipe(sock, title))
+        return FALSE;
+    if (!MENU_put_string_on_pipe(sock, titleendtag))
+        return FALSE;
+    if (hwnd != (HWND) -1)
+    {
+        char hwndstring[16];
+        sprintf(hwndstring, "%d", (int) hwnd);
+        if (!MENU_put_string_on_pipe(sock, hwndtag))
+            return FALSE;
+        if (!MENU_put_astring_on_pipe(sock, hwndstring))
+            return FALSE;
+        if (!MENU_put_string_on_pipe(sock, hwndendtag))
+            return FALSE;
+    }
+
+    for (i = 0; i < menu->nItems; i++)
+    {
+        MENUITEM *item;
+        item = &menu->items[i];
+        if (item && item->text)
+        {
+            if (!MENU_put_item_on_pipe(sock, item))
+                return FALSE;
+        }
+        if (item->fType & MF_SEPARATOR)
+        {
+            if (!MENU_put_item_on_pipe(sock, item))
+                return FALSE;
+        }
+    }
+    if (!MENU_put_string_on_pipe(sock, menuendtag))
+        return FALSE;
+
+    return TRUE;
+}
+
+#endif /* __APPLE__ */
+
+
+/***********************************************************************
+ *           MENU_send_window_menubar_to_macapp
+ *
+ *  CrossOver HACKs for bug 6727.
+ *
+ *  If we are able to open the CX_MENU_SOCKET, then
+ *   write the menu bar for hwnd to the socket.
+ *
+ *  Returns TRUE on success, False if the socket cannot
+ *   be opened.
+ */
+BOOL MENU_send_window_menubar_to_macapp( HWND ahwnd )
+{
+#ifdef __APPLE__
+
+    int sock;
+    HWND hwnd = ahwnd;
+    HMENU hMenu = NULL;
+
+    while (!hMenu && hwnd)
+    {
+        hMenu = GetMenu(hwnd);
+        if (!hMenu)
+            hwnd = GetParent(hwnd);
+    }
+
+    if (!hMenu)
+    {
+        return FALSE;
+    }
+
+    sock = MENU_get_menu_socket();
+    if (sock != -1)
+    {
+        if (!MENU_put_menu_on_pipe(sock, hMenu, mainmenutitle, hwnd))
+        {
+            close(sock);
+            return FALSE;
+            TRACE("Failed due to timeout.\n");
+        }
+        close(sock);
+        return TRUE;
+    }
+
+#endif /* __APPLE__ */
+
+    return FALSE;
+}
+
+
 /***********************************************************************
  *           MENU_DrawMenuBar
  *
@@ -1802,6 +2302,12 @@
     LPPOPUPMENU lppop;
     HMENU hMenu = GetMenu(hwnd);
 
+    if (getenv("CX_MENU_SOCKET"))
+    {
+        MENU_send_window_menubar_to_macapp( GetForegroundWindow() );
+        return 0;
+    }
+
     lppop = MENU_GetMenu( hMenu );
     if (lppop == NULL || lprect == NULL)
     {
@@ -3658,6 +4164,7 @@
     ret = item->fState & MF_CHECKED;
     if (flags & MF_CHECKED) item->fState |= MF_CHECKED;
     else item->fState &= ~MF_CHECKED;
+    MENU_send_window_menubar_to_macapp( GetForegroundWindow() );
     return ret;
 }
 
@@ -3973,6 +4480,9 @@
         menu->items = HeapReAlloc( GetProcessHeap(), 0, menu->items,
                                    menu->nItems * sizeof(MENUITEM) );
     }
+
+    MENU_send_window_menubar_to_macapp( GetForegroundWindow() );
+
     return TRUE;
 }
 
diff -Naur wine-2.0a/dlls/user32/misc.c wine-2.0b/dlls/user32/misc.c
--- wine-2.0a/dlls/user32/misc.c	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/user32/misc.c	2017-07-11 20:37:50.000000000 +0100
@@ -243,11 +243,75 @@
     return 1;
 }
 
-static const WCHAR primary_device_name[] = {'\\','\\','.','\\','D','I','S','P','L','A','Y','1',0};
-static const WCHAR primary_device_string[] = {'X','1','1',' ','W','i','n','d','o','w','i','n','g',' ',
-                                              'S','y','s','t','e','m',0};
-static const WCHAR primary_device_deviceid[] = {'P','C','I','\\','V','E','N','_','0','0','0','0','&',
+/* CrossOver Hack 13441 */
+static const WCHAR adapter_device_string[] = {'W','i','n','e',' ','D','i','s','p','l','a','y',' ',
+                                              'A','d','a','p','t','e','r',0};
+static const WCHAR adapter_device_deviceid[] = {'P','C','I','\\','V','E','N','_','0','0','0','0','&',
                                                 'D','E','V','_','0','0','0','0',0};
+static const WCHAR display_device_name[] = {'%','s','\\','M','o','n','i','t','o','r','0',0};
+static const WCHAR display_device_string[] = {'W','i','n','e',' ','D','i','s','p','l','a','y',0};
+static const WCHAR display_device_deviceid[] = {'M','O','N','I','T','O','R','\\','W','I','N','E','%','0','4','d',0};
+
+struct display_devices_enum_info
+{
+    LPCWSTR adapter;
+    DWORD target;
+    DWORD non_primary_seen;
+    LPDISPLAY_DEVICEW device;
+};
+
+/***********************************************************************
+ *		display_devices_enum
+ *
+ * Helper callback for EnumDisplayDevicesW()
+ */
+static BOOL CALLBACK display_devices_enum( HMONITOR monitor, HDC hdc, LPRECT rect, LPARAM lp )
+{
+    struct display_devices_enum_info *info = (struct display_devices_enum_info *)lp;
+    MONITORINFOEXW mon_info;
+    BOOL match;
+
+    mon_info.cbSize = sizeof(mon_info);
+    GetMonitorInfoW( monitor, (MONITORINFO*)&mon_info );
+
+    if (!(mon_info.dwFlags & MONITORINFOF_PRIMARY))
+        info->non_primary_seen++;
+
+    if (info->adapter)
+    {
+        match = !strcmpiW( info->adapter, mon_info.szDevice );
+        if (match)
+        {
+            snprintfW( info->device->DeviceName, sizeof(info->device->DeviceName) / sizeof(WCHAR),
+                       display_device_name, mon_info.szDevice );
+            lstrcpynW( info->device->DeviceString, display_device_string, sizeof(info->device->DeviceString) / sizeof(WCHAR) );
+
+            if (info->device->cb >= offsetof(DISPLAY_DEVICEW, DeviceID) + sizeof(info->device->DeviceID))
+            {
+                snprintfW( info->device->DeviceID, sizeof(info->device->DeviceID) / sizeof(WCHAR),
+                           display_device_deviceid, (mon_info.dwFlags & MONITORINFOF_PRIMARY) ? 0 : info->non_primary_seen );
+            }
+        }
+    }
+    else
+    {
+        if (mon_info.dwFlags & MONITORINFOF_PRIMARY)
+            match = (info->target == 0);
+        else
+            match = (info->target == info->non_primary_seen);
+
+        if (match)
+        {
+            lstrcpynW( info->device->DeviceName, mon_info.szDevice, sizeof(info->device->DeviceName) / sizeof(WCHAR) );
+            lstrcpynW( info->device->DeviceString, adapter_device_string, sizeof(info->device->DeviceString) / sizeof(WCHAR) );
+
+            if (info->device->cb >= offsetof(DISPLAY_DEVICEW, DeviceID) + sizeof(info->device->DeviceID))
+                lstrcpynW( info->device->DeviceID, adapter_device_deviceid, sizeof(info->device->DeviceID) / sizeof(WCHAR) );
+        }
+    }
+
+    return !match;
+}
 
 /***********************************************************************
  *		EnumDisplayDevicesA (USER32.@)
@@ -288,24 +352,34 @@
 BOOL WINAPI EnumDisplayDevicesW( LPCWSTR lpDevice, DWORD i, LPDISPLAY_DEVICEW lpDisplayDevice,
                                  DWORD dwFlags )
 {
-    FIXME("(%s,%d,%p,0x%08x), stub!\n",debugstr_w(lpDevice),i,lpDisplayDevice,dwFlags);
+    /* CrossOver Hack 13441 */
+    struct display_devices_enum_info info;
 
-    if (i)
+    TRACE("(%s,%d,%p,0x%08x)\n",debugstr_w(lpDevice),i,lpDisplayDevice,dwFlags);
+
+    if (lpDevice && i)
         return FALSE;
 
-    memcpy(lpDisplayDevice->DeviceName, primary_device_name, sizeof(primary_device_name));
-    memcpy(lpDisplayDevice->DeviceString, primary_device_string, sizeof(primary_device_string));
-  
     lpDisplayDevice->StateFlags =
         DISPLAY_DEVICE_ATTACHED_TO_DESKTOP |
-        DISPLAY_DEVICE_PRIMARY_DEVICE |
         DISPLAY_DEVICE_VGA_COMPATIBLE;
 
-    if(lpDisplayDevice->cb >= offsetof(DISPLAY_DEVICEW, DeviceID) + sizeof(lpDisplayDevice->DeviceID))
-        memcpy(lpDisplayDevice->DeviceID, primary_device_deviceid, sizeof(primary_device_deviceid));
+    if (!lpDevice && i == 0)
+        lpDisplayDevice->StateFlags |= DISPLAY_DEVICE_PRIMARY_DEVICE;
+
+    info.adapter = lpDevice;
+    info.target = i;
+    info.non_primary_seen = 0;
+    info.device = lpDisplayDevice;
+    if (EnumDisplayMonitors( 0, NULL, display_devices_enum, (LPARAM)&info ))
+        return FALSE;
+
     if(lpDisplayDevice->cb >= offsetof(DISPLAY_DEVICEW, DeviceKey) + sizeof(lpDisplayDevice->DeviceKey))
         lpDisplayDevice->DeviceKey[0] = 0;
 
+    TRACE("DeviceName %s DeviceString %s DeviceID %s DeviceKey %s\n", debugstr_w(lpDisplayDevice->DeviceName),
+          debugstr_w(lpDisplayDevice->DeviceString), debugstr_w(lpDisplayDevice->DeviceID), debugstr_w(lpDisplayDevice->DeviceKey));
+
     return TRUE;
 }
 
diff -Naur wine-2.0a/dlls/user32/nonclient.c wine-2.0b/dlls/user32/nonclient.c
--- wine-2.0a/dlls/user32/nonclient.c	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/user32/nonclient.c	2017-07-11 20:37:50.000000000 +0100
@@ -21,6 +21,7 @@
 #include "config.h"
 
 #include <stdarg.h>
+#include <stdlib.h>
 
 #include "windef.h"
 #include "winbase.h"
@@ -1623,6 +1624,7 @@
         break;
 
     case SC_KEYMENU:
+        if (getenv("CX_MENU_SOCKET")) break;
         MENU_TrackKbdMenuBar( hwnd, wParam, (WCHAR)lParam );
         break;
 
diff -Naur wine-2.0a/dlls/user32/scroll.c wine-2.0b/dlls/user32/scroll.c
--- wine-2.0a/dlls/user32/scroll.c	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/user32/scroll.c	2017-07-11 20:37:50.000000000 +0100
@@ -928,6 +928,9 @@
     case SCROLL_TOP_ARROW:
         SCROLL_DrawArrows( hdc, infoPtr, &rect, arrowSize, vertical,
                            (hittest == SCROLL_trackHitTest), FALSE );
+        SCROLL_DrawInterior( hwnd, hdc, nBar, &rect, arrowSize, thumbSize,
+                             thumbPos, infoPtr->flags, vertical,
+                             (hittest == SCROLL_trackHitTest), FALSE );
         if (hittest == SCROLL_trackHitTest)
         {
             if ((msg == WM_LBUTTONDOWN) || (msg == WM_SYSTIMER))
@@ -1030,6 +1033,9 @@
     case SCROLL_BOTTOM_ARROW:
         SCROLL_DrawArrows( hdc, infoPtr, &rect, arrowSize, vertical,
                            FALSE, (hittest == SCROLL_trackHitTest) );
+        SCROLL_DrawInterior( hwnd, hdc, nBar, &rect, arrowSize, thumbSize,
+                             thumbPos, infoPtr->flags, vertical,
+                             FALSE, (hittest == SCROLL_trackHitTest) );
         if (hittest == SCROLL_trackHitTest)
         {
             if ((msg == WM_LBUTTONDOWN) || (msg == WM_SYSTIMER))
diff -Naur wine-2.0a/dlls/user32/user_private.h wine-2.0b/dlls/user32/user_private.h
--- wine-2.0a/dlls/user32/user_private.h	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/user32/user_private.h	2017-07-11 20:37:50.000000000 +0100
@@ -340,6 +340,8 @@
 extern int bitmap_info_size( const BITMAPINFO * info, WORD coloruse ) DECLSPEC_HIDDEN;
 extern BOOL get_icon_size( HICON handle, SIZE *size ) DECLSPEC_HIDDEN;
 
+extern BOOL MENU_send_window_menubar_to_macapp( HWND hwnd );
+
 /* Mingw's assert() imports MessageBoxA and gets confused by user32 exporting it */
 #ifdef __MINGW32__
 #undef assert
diff -Naur wine-2.0a/dlls/user32/win.c wine-2.0b/dlls/user32/win.c
--- wine-2.0a/dlls/user32/win.c	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/user32/win.c	2017-07-11 20:37:50.000000000 +0100
@@ -2706,6 +2706,33 @@
     INT offset, /* [in] offset, in bytes, of location to alter */
     LONG newval /* [in] new value of location */
 ) {
+    if (GetVersion()&0x80000000 && offset == GWLP_WNDPROC)
+    {
+         /* CodeWeavers Only Hack... Needed for the Delegates tab 
+          * in Outlook XP running in win98 mode
+          */
+         char class[80];
+         GetClassNameA(hwnd, class, sizeof(class));
+         if (strcmp(class,"REListBox20W")==0)
+         {
+            char name[MAX_PATH], *p;
+            
+            GetModuleFileNameA(GetModuleHandleA(NULL),name,MAX_PATH);
+            p = strrchr(name, '\\');
+
+            if (p)
+                p++;
+            else
+                p = name;
+
+            if (!strcasecmp(p,"OUTLOOK.EXE"))
+            {
+                ERR("Outlook in WIN98 calling supposedly unimplemented function, triggering bandaid for class %s\n",debugstr_a(class));
+                SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
+                return 0;
+            }
+         }
+    }
     return WIN_SetWindowLong( hwnd, offset, sizeof(LONG), newval, TRUE );
 }
 
@@ -3818,6 +3845,25 @@
     if (!USER_Driver->pUpdateLayeredWindow( hwnd, info, &window_rect )) return FALSE;
 
     set_window_pos( hwnd, 0, flags, &window_rect, &client_rect, NULL );
+
+    /*
+     * CrossOver hack:
+     * Hide non-working, semi-transparent window in Quicken 2012.
+     * for bug 8982.
+     */
+    if(1) {
+        static const WCHAR QWinLightbox[] = {'Q','W','i','n','L','i','g','h','t','b','o','x',0};
+        WCHAR window_class[sizeof(QWinLightbox)/sizeof(WCHAR)];
+
+        if(GetClassNameW(hwnd, window_class, sizeof(QWinLightbox)/sizeof(WCHAR))
+                && !memcmp(QWinLightbox, window_class, sizeof(QWinLightbox))) {
+            FIXME("Hide semi-transparent window that is created over application window.\n");
+            SetWindowPos(hwnd, HWND_BOTTOM, 0, 0, 0, 0,
+                    SWP_NOZORDER | SWP_NOACTIVATE | SWP_NOREDRAW | SWP_NOSENDCHANGING);
+        }
+    }
+
+
     return TRUE;
 }
 
diff -Naur wine-2.0a/dlls/user32/winpos.c wine-2.0b/dlls/user32/winpos.c
--- wine-2.0a/dlls/user32/winpos.c	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/user32/winpos.c	2017-07-11 20:37:50.000000000 +0100
@@ -2661,7 +2661,7 @@
     HDC hdc;
     HWND parent;
     LONG hittest = (LONG)(wParam & 0x0f);
-    WPARAM syscommand = wParam & 0xfff0;
+    WPARAM syscommand = wParam & 0xfff0,mmstate;
     HCURSOR hDragCursor = 0, hOldCursor = 0;
     POINT minTrack, maxTrack;
     POINT capturePoint, pt;
@@ -2934,4 +2934,15 @@
         }
         else WINPOS_ShowIconTitle( hwnd, TRUE );
     }
+
+    /* windows finishes this off with a WM_MOUSEMOVE with the current position
+       and buttons state. This message is relied on by some games. */
+    mmstate = 0;
+    if (GetAsyncKeyState(VK_LBUTTON)&0x1) mmstate &= MK_LBUTTON;
+    if (GetAsyncKeyState(VK_RBUTTON)&0x1) mmstate &= MK_RBUTTON;
+    if (GetAsyncKeyState(VK_MBUTTON)&0x1) mmstate &= MK_MBUTTON;
+    if (GetAsyncKeyState(VK_CONTROL)&0x1) mmstate &= MK_CONTROL;
+    if (GetAsyncKeyState(VK_SHIFT)&0x1) mmstate &= MK_SHIFT;
+
+    PostMessageW( hwnd, WM_MOUSEMOVE, mmstate, MAKELONG(pt.x,pt.y) );
 }
diff -Naur wine-2.0a/dlls/user32/winproc.c wine-2.0b/dlls/user32/winproc.c
--- wine-2.0a/dlls/user32/winproc.c	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/user32/winproc.c	2017-07-11 20:37:50.000000000 +0100
@@ -491,7 +491,7 @@
     case LB_DIR:
     case LB_ADDFILE:
     case EM_REPLACESEL:
-        if (!lParam) ret = callback( hwnd, msg, wParam, lParam, result, arg );
+        if (!HIWORD(lParam)) ret = callback( hwnd, msg, wParam, lParam, result, arg );
         else
         {
             WCHAR *ptr, buffer[512];
diff -Naur wine-2.0a/dlls/vmm.vxd/vmm.c wine-2.0b/dlls/vmm.vxd/vmm.c
--- wine-2.0a/dlls/vmm.vxd/vmm.c	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/vmm.vxd/vmm.c	2017-07-11 20:37:51.000000000 +0100
@@ -159,7 +159,13 @@
         if ( page == PR_PRIVATE || page == PR_SHARED ) page = 0;
         /* FIXME: Handle flags in some way */
         address = (LPVOID )(page * page_size);
-        ret = VirtualAlloc ( address, npages * page_size, MEM_RESERVE, PAGE_EXECUTE_READWRITE );
+       if (flags & PR_STATIC)
+           /* FIXME: this isn't right, it's just a workaround for the stupid native wininet which
+            * thinks it's a good idea to allocate its own stack without committing it
+            */
+           ret = VirtualAlloc ( address, npages * page_size, MEM_COMMIT, PAGE_EXECUTE_READWRITE );
+       else
+           ret = VirtualAlloc ( address, npages * page_size, MEM_RESERVE, PAGE_EXECUTE_READWRITE );
         TRACE("PageReserve: returning: %p\n", ret );
         if ( ret == NULL )
           return -1;
diff -Naur wine-2.0a/dlls/windowscodecs/pngformat.c wine-2.0b/dlls/windowscodecs/pngformat.c
--- wine-2.0a/dlls/windowscodecs/pngformat.c	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/windowscodecs/pngformat.c	2017-07-11 20:37:51.000000000 +0100
@@ -319,11 +319,6 @@
 MAKE_FUNCPTR(png_set_bgr);
 MAKE_FUNCPTR(png_set_crc_action);
 MAKE_FUNCPTR(png_set_error_fn);
-#ifdef HAVE_PNG_SET_EXPAND_GRAY_1_2_4_TO_8
-MAKE_FUNCPTR(png_set_expand_gray_1_2_4_to_8);
-#else
-MAKE_FUNCPTR(png_set_gray_1_2_4_to_8);
-#endif
 MAKE_FUNCPTR(png_set_filler);
 MAKE_FUNCPTR(png_set_filter);
 MAKE_FUNCPTR(png_set_gray_to_rgb);
@@ -342,6 +337,33 @@
 MAKE_FUNCPTR(png_write_rows);
 #undef MAKE_FUNCPTR
 
+void (*ppng_set_expand_gray_1_2_4_to_8)(png_structp);
+
+/* CX Hack 9660:
+ * Search for more soname names than the one
+ * that we happened to build Wine against. */
+static struct {
+    const char *soname;
+    const char *verstring;
+} libpng_candidates[] = {
+    { SONAME_LIBPNG, PNG_LIBPNG_VER_STRING },
+    { "libpng16.so", "1.6.0" },
+    { "libpng16.so.0", "1.6.0" },
+    { "libpng16.so.16", "1.6.0" },
+    { "libpng15.so", "1.5.0" },
+    { "libpng15.so.0", "1.5.0" },
+    { "libpng15.so.15", "1.5.0" },
+    { "libpng14.so", "1.4.0" },
+    { "libpng14.so.0", "1.4.0" },
+    { "libpng14.so.14", "1.4.0" },
+    { "libpng12.so", "1.2.0" },
+    { "libpng12.so.0", "1.2.0" },
+    { "libpng12.so.12", "1.2.0" },
+};
+
+static const char *soname_libpng;
+static const char *libpng_ver_string;
+
 static CRITICAL_SECTION init_png_cs;
 static CRITICAL_SECTION_DEBUG init_png_cs_debug =
 {
@@ -357,11 +379,19 @@
 
 static void *load_libpng(void)
 {
+    int i;
     void *result;
 
     EnterCriticalSection(&init_png_cs);
+    for(i = 0; i < sizeof(libpng_candidates) / sizeof(*libpng_candidates); ++i){
+        soname_libpng = libpng_candidates[i].soname;
+        libpng_ver_string = libpng_candidates[i].verstring;
+        libpng_handle = wine_dlopen(soname_libpng, RTLD_NOW, NULL, 0);
+        if(libpng_handle)
+            break;
+    }
 
-    if(!libpng_handle && (libpng_handle = wine_dlopen(SONAME_LIBPNG, RTLD_NOW, NULL, 0)) != NULL) {
+    if(libpng_handle){
 
 #define LOAD_FUNCPTR(f) \
     if((p##f = wine_dlsym(libpng_handle, #f, NULL, 0)) == NULL) { \
@@ -388,11 +418,6 @@
         LOAD_FUNCPTR(png_set_bgr);
         LOAD_FUNCPTR(png_set_crc_action);
         LOAD_FUNCPTR(png_set_error_fn);
-#ifdef HAVE_PNG_SET_EXPAND_GRAY_1_2_4_TO_8
-        LOAD_FUNCPTR(png_set_expand_gray_1_2_4_to_8);
-#else
-        LOAD_FUNCPTR(png_set_gray_1_2_4_to_8);
-#endif
         LOAD_FUNCPTR(png_set_filler);
         LOAD_FUNCPTR(png_set_filter);
         LOAD_FUNCPTR(png_set_gray_to_rgb);
@@ -409,8 +434,16 @@
         LOAD_FUNCPTR(png_write_end);
         LOAD_FUNCPTR(png_write_info);
         LOAD_FUNCPTR(png_write_rows);
-
 #undef LOAD_FUNCPTR
+
+        ppng_set_expand_gray_1_2_4_to_8 = wine_dlsym(libpng_handle, "png_set_expand_gray_1_2_4_to_8", NULL, 0);
+        if(!ppng_set_expand_gray_1_2_4_to_8){
+            ppng_set_expand_gray_1_2_4_to_8 = wine_dlsym(libpng_handle, "png_set_gray_1_2_4_to_8", NULL, 0);
+            if(!ppng_set_expand_gray_1_2_4_to_8){
+                libpng_handle = NULL;
+                return NULL;
+            }
+        }
     }
 
     result = libpng_handle;
@@ -596,7 +629,7 @@
     EnterCriticalSection(&This->lock);
 
     /* initialize libpng */
-    This->png_ptr = ppng_create_read_struct(PNG_LIBPNG_VER_STRING, NULL, NULL, NULL);
+    This->png_ptr = ppng_create_read_struct(libpng_ver_string, NULL, NULL, NULL);
     if (!This->png_ptr)
     {
         hr = E_FAIL;
@@ -658,11 +691,7 @@
         {
             if (bit_depth < 8)
             {
-#ifdef HAVE_PNG_SET_EXPAND_GRAY_1_2_4_TO_8
                 ppng_set_expand_gray_1_2_4_to_8(This->png_ptr);
-#else
-                ppng_set_gray_1_2_4_to_8(This->png_ptr);
-#endif
                 bit_depth = 8;
             }
             ppng_set_gray_to_rgb(This->png_ptr);
@@ -1290,7 +1319,7 @@
 
     if (!load_libpng())
     {
-        ERR("Failed reading PNG because unable to find %s\n",SONAME_LIBPNG);
+        ERR("Failed reading PNG because unable to find libpng 1.2-1.5\n");
         return E_FAIL;
     }
 
@@ -1877,7 +1906,7 @@
     }
 
     /* initialize libpng */
-    This->png_ptr = ppng_create_write_struct(PNG_LIBPNG_VER_STRING, NULL, NULL, NULL);
+    This->png_ptr = ppng_create_write_struct(libpng_ver_string, NULL, NULL, NULL);
     if (!This->png_ptr)
     {
         LeaveCriticalSection(&This->lock);
@@ -2056,7 +2085,7 @@
 
     if (!load_libpng())
     {
-        ERR("Failed writing PNG because unable to find %s\n",SONAME_LIBPNG);
+        ERR("Failed writing PNG because unable to find libpng 1.2-1.5\n");
         return E_FAIL;
     }
 
diff -Naur wine-2.0a/dlls/wineandroid.drv/android.h wine-2.0b/dlls/wineandroid.drv/android.h
--- wine-2.0a/dlls/wineandroid.drv/android.h	1970-01-01 01:00:00.000000000 +0100
+++ wine-2.0b/dlls/wineandroid.drv/android.h	2017-07-11 20:37:51.000000000 +0100
@@ -0,0 +1,353 @@
+/*
+ * Android driver definitions
+ *
+ * Copyright 2013 Alexandre Julliard
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#ifndef __WINE_ANDROID_H
+#define __WINE_ANDROID_H
+
+#include <limits.h>
+#include <stdarg.h>
+#include <stdlib.h>
+#include <android/log.h>
+#include <android/configuration.h>
+#include <android/input.h>
+#include <android/native_window_jni.h>
+
+#undef SendMessage /* conflicts with SLMIDIMessageItf_::SendMessage */
+#include <SLES/OpenSLES.h>
+#include <SLES/OpenSLES_Android.h>
+
+#include "windef.h"
+#include "winbase.h"
+#include "wingdi.h"
+#include "winuser.h"
+#include "wine/gdi_driver.h"
+#include "android_native.h"
+#include "wine/list.h"
+
+
+/**************************************************************************
+ * Android interface
+ */
+#define DECL_FUNCPTR(f) extern typeof(f) * p##f DECLSPEC_HIDDEN
+DECL_FUNCPTR( __android_log_print );
+DECL_FUNCPTR( ANativeWindow_fromSurface );
+DECL_FUNCPTR( ANativeWindow_release );
+DECL_FUNCPTR( slCreateEngine );
+DECL_FUNCPTR( SL_IID_ANDROIDSIMPLEBUFFERQUEUE );
+DECL_FUNCPTR( SL_IID_ENGINE );
+DECL_FUNCPTR( SL_IID_PLAY );
+DECL_FUNCPTR( SL_IID_PLAYBACKRATE );
+DECL_FUNCPTR( SL_IID_RECORD );
+#undef DECL_FUNCPTR
+
+/**************************************************************************
+ * GDI driver
+ */
+
+typedef struct
+{
+    struct gdi_physdev dev;
+} ANDROID_PDEVICE;
+
+static inline ANDROID_PDEVICE *get_android_dev( PHYSDEV dev )
+{
+    return (ANDROID_PDEVICE *)dev;
+}
+
+static inline void reset_bounds( RECT *bounds )
+{
+    bounds->left = bounds->top = INT_MAX;
+    bounds->right = bounds->bottom = INT_MIN;
+}
+
+static inline void add_bounds_rect( RECT *bounds, const RECT *rect )
+{
+    if (rect->left >= rect->right || rect->top >= rect->bottom) return;
+    bounds->left   = min( bounds->left, rect->left );
+    bounds->top    = min( bounds->top, rect->top );
+    bounds->right  = max( bounds->right, rect->right );
+    bounds->bottom = max( bounds->bottom, rect->bottom );
+}
+
+enum android_pixel_format
+{
+    PF_RGBA_8888 = 1,
+    PF_RGBX_8888 = 2,
+    PF_RGB_888   = 3,
+    PF_RGB_565   = 4,
+    PF_BGRA_8888 = 5,
+    PF_RGBA_5551 = 6,
+    PF_RGBA_4444 = 7
+};
+
+extern void destroy_gl_drawable( HWND hwnd ) DECLSPEC_HIDDEN;
+extern struct opengl_funcs *get_wgl_driver( UINT version ) DECLSPEC_HIDDEN;
+
+
+/**************************************************************************
+ * Android pseudo-device
+ */
+
+extern void start_android_device(void) DECLSPEC_HIDDEN;
+extern void register_native_window( HWND hwnd, struct ANativeWindow *win ) DECLSPEC_HIDDEN;
+extern int ioctl_window_pos_changed( HWND hwnd, const RECT *rect, UINT style, UINT flags,
+                                     HWND after, HWND owner ) DECLSPEC_HIDDEN;
+extern int ioctl_set_window_focus( HWND hwnd ) DECLSPEC_HIDDEN;
+extern int ioctl_set_window_text( HWND hwnd, const WCHAR *text ) DECLSPEC_HIDDEN;
+extern int ioctl_set_window_icon( HWND hwnd, int width, int height,
+                                  const unsigned int *bits ) DECLSPEC_HIDDEN;
+extern int ioctl_set_window_rgn( HWND hwnd, HRGN rgn ) DECLSPEC_HIDDEN;
+extern int ioctl_set_window_layered( HWND hwnd, COLORREF key, BYTE alpha ) DECLSPEC_HIDDEN;
+extern int ioctl_set_surface_alpha( HWND hwnd, BOOL has_alpha ) DECLSPEC_HIDDEN;
+extern int ioctl_set_capture( HWND hwnd ) DECLSPEC_HIDDEN;
+extern struct ANativeWindow *create_ioctl_window( HWND hwnd ) DECLSPEC_HIDDEN;
+extern void destroy_ioctl_window( HWND hwnd ) DECLSPEC_HIDDEN;
+extern void grab_ioctl_window( struct ANativeWindow *window ) DECLSPEC_HIDDEN;
+extern void release_ioctl_window( struct ANativeWindow *window ) DECLSPEC_HIDDEN;
+extern int ioctl_gamepad_query( int index, int device, void* data) DECLSPEC_HIDDEN;
+extern int ioctl_imeText( int target, int *cursor, int *length, WCHAR* string ) DECLSPEC_HIDDEN;
+extern int ioctl_imeFinish( int target ) DECLSPEC_HIDDEN;
+extern int ioctl_get_clipboard_formats( DWORD* seqno, UINT** formats, DWORD* num_formats ) DECLSPEC_HIDDEN;
+extern int ioctl_get_clipboard_data( UINT format, HGLOBAL* result, BOOL* pending ) DECLSPEC_HIDDEN;
+extern int ioctl_render_clipboard_data( int android_format ) DECLSPEC_HIDDEN;
+extern int ioctl_empty_clipboard( void ) DECLSPEC_HIDDEN;
+extern int ioctl_set_clipboard_data( UINT format, BOOL format_present, BYTE* buffer, DWORD size ) DECLSPEC_HIDDEN;
+extern int ioctl_end_clipboard_update( void ) DECLSPEC_HIDDEN;
+extern int ioctl_acquire_clipboard( void ) DECLSPEC_HIDDEN;
+extern int ioctl_export_clipboard_data( int android_format, BYTE* data, DWORD size ) DECLSPEC_HIDDEN;
+
+
+/**************************************************************************
+ * USER driver
+ */
+
+extern unsigned int screen_width DECLSPEC_HIDDEN;
+extern unsigned int screen_height DECLSPEC_HIDDEN;
+extern unsigned int screen_bpp DECLSPEC_HIDDEN;
+extern unsigned int screen_dpi DECLSPEC_HIDDEN;
+extern RECT virtual_screen_rect DECLSPEC_HIDDEN;
+extern MONITORINFOEXW default_monitor DECLSPEC_HIDDEN;
+
+enum android_window_messages
+{
+    WM_ANDROID_REFRESH = 0x80001000,
+    WM_ANDROID_IME_CONTROL,
+    WM_ANDROID_RENDERFORMAT,
+    WM_ANDROID_CLIPBOARD_REQUEST,
+};
+
+/* private window data */
+struct android_win_data
+{
+    HWND           hwnd;           /* hwnd that this private data belongs to */
+    RECT           window_rect;    /* USER window rectangle relative to parent */
+    RECT           whole_rect;     /* X window rectangle for the whole window relative to parent */
+    RECT           client_rect;    /* client area relative to parent */
+    ANativeWindow *window;
+    struct window_surface *surface;
+};
+
+extern struct android_win_data *get_win_data( HWND hwnd ) DECLSPEC_HIDDEN;
+extern void release_win_data( struct android_win_data *data ) DECLSPEC_HIDDEN;
+extern struct ANativeWindow *get_ioctl_window( HWND hwnd ) DECLSPEC_HIDDEN;
+extern HWND get_capture_window(void) DECLSPEC_HIDDEN;
+extern void set_screen_dpi( DWORD dpi, BOOL force ) DECLSPEC_HIDDEN;
+extern void init_monitors( int width, int height ) DECLSPEC_HIDDEN;
+extern void handle_run_cmdline( LPWSTR cmdline, LPWSTR* wineEnv ) DECLSPEC_HIDDEN;
+extern void handle_clear_meta_key_states( int states ) DECLSPEC_HIDDEN;
+extern void handle_clipboard_changed( void ) DECLSPEC_HIDDEN;
+extern void handle_import_clipboard_data( INT android_format, BYTE* data, DWORD len ) DECLSPEC_HIDDEN;
+extern int get_clipboard_formats( DWORD* seqno, UINT* formats, UINT* num_formats ) DECLSPEC_HIDDEN;
+extern void get_exported_formats( BOOL* formats, int num_formats ) DECLSPEC_HIDDEN;
+extern BOOL handle_ioctl_get_clipboard_data( UINT format, BOOL* format_present, BOOL* pending, BYTE* data, DWORD* size ) DECLSPEC_HIDDEN;
+extern void handle_ioctl_empty_clipboard( void ) DECLSPEC_HIDDEN;
+extern void handle_ioctl_set_clipboard_data( UINT format, BOOL format_present, BYTE* data, DWORD size ) DECLSPEC_HIDDEN;
+extern void handle_ioctl_end_clipboard_update( void ) DECLSPEC_HIDDEN;
+extern void handle_clipboard_request( int android_format ) DECLSPEC_HIDDEN;
+extern void update_keyboard_lock_state( WORD vkey, UINT state ) DECLSPEC_HIDDEN;
+
+/* JNI entry points */
+extern jboolean keyboard_event( JNIEnv *env, jobject obj, jint win, jint action, jint keycode, jint scancode, jint state ) DECLSPEC_HIDDEN;
+extern jboolean clear_meta_key_states( JNIEnv *env, jobject obj, jint states ) DECLSPEC_HIDDEN;
+extern jboolean motion_event( JNIEnv *env, jobject obj, jint win, jint action, jint x, jint y, jint state, jint vscroll ) DECLSPEC_HIDDEN;
+extern void surface_changed( JNIEnv *env, jobject obj, jint win, jobject surface ) DECLSPEC_HIDDEN;
+extern void desktop_changed( JNIEnv *env, jobject obj, jint width, jint height ) DECLSPEC_HIDDEN;
+extern void config_changed( JNIEnv *env, jobject obj, jint dpi, jboolean force ) DECLSPEC_HIDDEN;
+extern void clipboard_changed( JNIEnv *env, jobject obj, jbooleanArray formats_present ) DECLSPEC_HIDDEN;
+extern void import_clipboard_data( JNIEnv *env, jobject obj, jint android_format, jbyteArray data ) DECLSPEC_HIDDEN;
+extern void clipboard_request( JNIEnv *env, jobject obj, jint android_format ) DECLSPEC_HIDDEN;
+extern void run_commandline( JNIEnv *env, jobject obj, jobject _cmdline, jobjectArray _wineEnv ) DECLSPEC_HIDDEN;;
+
+/* IME entry points */
+extern void IME_UpdateAssociation(HWND focus) DECLSPEC_HIDDEN;
+extern void ime_text( JNIEnv *env, jobject obj, jstring text, jint length, jint cursor) DECLSPEC_HIDDEN;
+extern void ime_finish( JNIEnv *env, jobject obj) DECLSPEC_HIDDEN;
+extern void ime_cancel( JNIEnv *env, jobject obj) DECLSPEC_HIDDEN;
+extern void ime_start( JNIEnv *env, jobject obj) DECLSPEC_HIDDEN;
+extern void handle_IME_TEXT(int target, int length) DECLSPEC_HIDDEN;
+extern void handle_IME_FINISH(int target, int length) DECLSPEC_HIDDEN;
+extern void handle_IME_CANCEL(void) DECLSPEC_HIDDEN;
+extern void handle_IME_START(void) DECLSPEC_HIDDEN;
+extern LRESULT Ime_Control(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp) DECLSPEC_HIDDEN;
+
+/* GAMEPAD entry points and DATA*/
+extern void gamepad_count(JNIEnv *env, jobject obj, jint count) DECLSPEC_HIDDEN;
+extern void gamepad_data(JNIEnv *env, jobject obj, jint index, jint id, jstring name) DECLSPEC_HIDDEN;
+extern void gamepad_sendaxis(JNIEnv *env, jobject obj, jint device, jfloatArray axis) DECLSPEC_HIDDEN;
+extern void gamepad_sendbutton(JNIEnv *env, jobject obj, jint device, jint element, jint value) DECLSPEC_HIDDEN;
+
+#define DI_AXIS_COUNT 8
+#define DI_POV_COUNT 1  /* POVs take 2 axis  */
+#define DI_AXIS_DATA_COUNT (DI_AXIS_COUNT + DI_POV_COUNT*2)
+#define DI_BUTTON_COUNT 30
+#define DI_DATASIZE  (DI_AXIS_DATA_COUNT + DI_BUTTON_COUNT)
+#define DI_BUTTON_DATA_OFFSET DI_AXIS_DATA_COUNT
+#define DI_NAME_LENGTH 255
+
+typedef int di_value_set[DI_DATASIZE];
+typedef WCHAR di_name[DI_NAME_LENGTH];
+
+extern di_value_set *di_value;
+extern di_name      *di_names;
+extern int          di_controllers;
+
+enum event_type
+{
+    HARDWARE_INPUT,
+    SURFACE_CHANGED,
+    DESKTOP_CHANGED,
+    CONFIG_CHANGED,
+    CLIPBOARD_CHANGED,
+    IMPORT_CLIPBOARD_DATA,
+    CLIPBOARD_REQUEST,
+    IME_TEXT,
+    IME_FINISH,
+    IME_CANCEL,
+    IME_START,
+    RUN_CMDLINE,
+    CLEAR_META
+};
+
+union event_data
+{
+    enum event_type type;
+    struct
+    {
+        enum event_type type;
+        HWND            hwnd;
+        INPUT           input;
+    } hw;
+    struct
+    {
+        enum event_type type;
+        HWND            hwnd;
+        ANativeWindow *window;
+        unsigned int width;
+        unsigned int height;
+    } surface;
+    struct
+    {
+        enum event_type type;
+        HWND            hwnd;
+        RECT            rect;
+    } flush;
+    struct
+    {
+        enum event_type type;
+        unsigned int    width;
+        unsigned int    height;
+    } desktop;
+    struct
+    {
+        enum event_type type;
+        unsigned int    dpi;
+        BOOL            force;
+    } cfg;
+    struct
+    {
+        enum event_type type;
+        INT             android_format;
+        DWORD           len;
+        BYTE*           data;
+    } clipdata;
+    struct
+    {
+        enum event_type type;
+        WORD            target;
+        WORD            length;
+    } ime_text;
+    struct
+    {
+        enum event_type type;
+        WORD            target;
+        WORD            length;
+    } ime_finish;
+    struct
+    {
+        enum event_type type;
+        LPWSTR          cmdline;
+        LPWSTR*         env;
+    } runcmd;
+    struct
+    {
+        enum event_type type;
+        int             states;
+    } clearmeta;
+};
+
+struct android_thread_data
+{
+    union event_data *current_event;
+    int               event_pipe[2];
+    struct list       event_queue;
+};
+
+extern struct android_thread_data *android_init_thread_data(void) DECLSPEC_HIDDEN;
+extern DWORD thread_data_tls_index DECLSPEC_HIDDEN;
+
+int send_event( struct android_thread_data *thread, const union event_data *data );
+extern struct android_thread_data *desktop_thread;
+
+static inline struct android_thread_data *android_thread_data(void)
+{
+    return TlsGetValue( thread_data_tls_index );
+}
+
+extern JavaVM *wine_get_java_vm(void);
+extern jobject wine_get_java_object(void);
+
+extern struct gralloc_module_t *gralloc_module;
+
+extern ANativeWindow *main_window DECLSPEC_HIDDEN;
+
+extern HANDLE g_timer_q;
+
+typedef struct _s_ime_text {
+    WCHAR *text;
+    INT    length;
+    INT    cursor_pos;
+} s_ime_text;
+
+extern s_ime_text **java_ime_text;
+extern INT java_ime_active_target;
+extern INT java_ime_count;
+
+
+#endif  /* __WINE_ANDROID_H */
diff -Naur wine-2.0a/dlls/wineandroid.drv/AndroidManifest.xml wine-2.0b/dlls/wineandroid.drv/AndroidManifest.xml
--- wine-2.0a/dlls/wineandroid.drv/AndroidManifest.xml	1970-01-01 01:00:00.000000000 +0100
+++ wine-2.0b/dlls/wineandroid.drv/AndroidManifest.xml	2017-07-11 20:37:51.000000000 +0100
@@ -0,0 +1,9 @@
+<?xml version="1.0" encoding="utf-8"?>
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+      package="org.winehq.wine"
+      android:versionCode="1"
+      android:versionName="1.0">
+    <uses-feature android:glEsVersion="0x00020000" android:required="true" />
+    <uses-permission android:name="android.permission.INTERNET" />
+    <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" />
+</manifest>
diff -Naur wine-2.0a/dlls/wineandroid.drv/android_native.h wine-2.0b/dlls/wineandroid.drv/android_native.h
--- wine-2.0a/dlls/wineandroid.drv/android_native.h	1970-01-01 01:00:00.000000000 +0100
+++ wine-2.0b/dlls/wineandroid.drv/android_native.h	2017-07-11 20:37:51.000000000 +0100
@@ -0,0 +1,209 @@
+/*
+ * Android native system definitions
+ *
+ * Copyright 2013 Alexandre Julliard
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+/* Copy of some Android native structures to avoid depending on the Android source */
+/* Hopefully these won't change too frequently... */
+
+/* Native window definitions */
+
+typedef struct native_handle
+{
+    int version;
+    int numFds;
+    int numInts;
+    int data[0];
+} native_handle_t;
+
+typedef const native_handle_t *buffer_handle_t;
+
+struct android_native_base_t
+{
+    int magic;
+    int version;
+    void *reserved[4];
+    void (*incRef)(struct android_native_base_t *base);
+    void (*decRef)(struct android_native_base_t *base);
+};
+
+typedef struct android_native_rect_t
+{
+    int32_t left;
+    int32_t top;
+    int32_t right;
+    int32_t bottom;
+} android_native_rect_t;
+
+struct ANativeWindowBuffer
+{
+    struct android_native_base_t common;
+    int width;
+    int height;
+    int stride;
+    int format;
+    int usage;
+    void *reserved[2];
+    buffer_handle_t handle;
+    void *reserved_proc[8];
+};
+
+struct ANativeWindow
+{
+    struct android_native_base_t common;
+    uint32_t flags;
+    int      minSwapInterval;
+    int      maxSwapInterval;
+    float    xdpi;
+    float    ydpi;
+    intptr_t oem[4];
+    int (*setSwapInterval)(struct ANativeWindow *window, int interval);
+    int (*dequeueBuffer_DEPRECATED)(struct ANativeWindow *window, struct ANativeWindowBuffer **buffer);
+    int (*lockBuffer_DEPRECATED)(struct ANativeWindow *window, struct ANativeWindowBuffer *buffer);
+    int (*queueBuffer_DEPRECATED)(struct ANativeWindow *window, struct ANativeWindowBuffer *buffer);
+    int (*query)(const struct ANativeWindow *window, int what, int *value);
+    int (*perform)(struct ANativeWindow *window, int operation, ... );
+    int (*cancelBuffer_DEPRECATED)(struct ANativeWindow *window, struct ANativeWindowBuffer *buffer);
+    int (*dequeueBuffer)(struct ANativeWindow *window, struct ANativeWindowBuffer **buffer, int *fenceFd);
+    int (*queueBuffer)(struct ANativeWindow *window, struct ANativeWindowBuffer *buffer, int fenceFd);
+    int (*cancelBuffer)(struct ANativeWindow *window, struct ANativeWindowBuffer *buffer, int fenceFd);
+};
+
+enum native_window_query
+{
+    NATIVE_WINDOW_WIDTH                     = 0,
+    NATIVE_WINDOW_HEIGHT                    = 1,
+    NATIVE_WINDOW_FORMAT                    = 2,
+    NATIVE_WINDOW_MIN_UNDEQUEUED_BUFFERS    = 3,
+    NATIVE_WINDOW_QUEUES_TO_WINDOW_COMPOSER = 4,
+    NATIVE_WINDOW_CONCRETE_TYPE             = 5,
+    NATIVE_WINDOW_DEFAULT_WIDTH             = 6,
+    NATIVE_WINDOW_DEFAULT_HEIGHT            = 7,
+    NATIVE_WINDOW_TRANSFORM_HINT            = 8,
+    NATIVE_WINDOW_CONSUMER_RUNNING_BEHIND   = 9
+};
+
+enum native_window_perform
+{
+    NATIVE_WINDOW_SET_USAGE                   = 0,
+    NATIVE_WINDOW_CONNECT                     = 1,
+    NATIVE_WINDOW_DISCONNECT                  = 2,
+    NATIVE_WINDOW_SET_CROP                    = 3,
+    NATIVE_WINDOW_SET_BUFFER_COUNT            = 4,
+    NATIVE_WINDOW_SET_BUFFERS_GEOMETRY        = 5,
+    NATIVE_WINDOW_SET_BUFFERS_TRANSFORM       = 6,
+    NATIVE_WINDOW_SET_BUFFERS_TIMESTAMP       = 7,
+    NATIVE_WINDOW_SET_BUFFERS_DIMENSIONS      = 8,
+    NATIVE_WINDOW_SET_BUFFERS_FORMAT          = 9,
+    NATIVE_WINDOW_SET_SCALING_MODE            = 10,
+    NATIVE_WINDOW_LOCK                        = 11,
+    NATIVE_WINDOW_UNLOCK_AND_POST             = 12,
+    NATIVE_WINDOW_API_CONNECT                 = 13,
+    NATIVE_WINDOW_API_DISCONNECT              = 14,
+    NATIVE_WINDOW_SET_BUFFERS_USER_DIMENSIONS = 15,
+    NATIVE_WINDOW_SET_POST_TRANSFORM_CROP     = 16
+};
+
+
+/* Hardware module definitions */
+
+struct hw_module_methods_t;
+struct hw_device_t;
+struct android_ycbcr;
+
+struct hw_module_t
+{
+    uint32_t tag;
+    uint16_t module_api_version;
+    uint16_t hal_api_version;
+    const char *id;
+    const char *name;
+    const char *author;
+    struct hw_module_methods_t *methods;
+    void *dso;
+    uint32_t reserved[32-7];
+};
+
+struct hw_module_methods_t
+{
+    int (*open)(const struct hw_module_t *module, const char *id, struct hw_device_t **device);
+};
+
+struct hw_device_t
+{
+    uint32_t tag;
+    uint32_t version;
+    struct hw_module_t *module;
+    uint32_t reserved[12];
+    int (*close)(struct hw_device_t *device);
+};
+
+struct gralloc_module_t
+{
+    struct hw_module_t common;
+    int (*registerBuffer)(struct gralloc_module_t const *module, buffer_handle_t handle);
+    int (*unregisterBuffer)(struct gralloc_module_t const *module, buffer_handle_t handle);
+    int (*lock)(struct gralloc_module_t const *module, buffer_handle_t handle, int usage, int l, int t, int w, int h, void **vaddr);
+    int (*unlock)(struct gralloc_module_t const *module, buffer_handle_t handle);
+    int (*perform)(struct gralloc_module_t const *module, int operation, ... );
+    int (*lock_ycbcr)(struct gralloc_module_t const *module, buffer_handle_t handle, int usage, int l, int t, int w, int h, struct android_ycbcr *ycbcr);
+    void *reserved_proc[6];
+};
+
+#define ANDROID_NATIVE_MAKE_CONSTANT(a,b,c,d) \
+    (((unsigned)(a)<<24)|((unsigned)(b)<<16)|((unsigned)(c)<<8)|(unsigned)(d))
+
+#define ANDROID_NATIVE_WINDOW_MAGIC \
+    ANDROID_NATIVE_MAKE_CONSTANT('_','w','n','d')
+
+#define ANDROID_NATIVE_BUFFER_MAGIC \
+    ANDROID_NATIVE_MAKE_CONSTANT('_','b','f','r')
+
+enum gralloc_usage
+{
+    GRALLOC_USAGE_SW_READ_NEVER         = 0x00000000,
+    GRALLOC_USAGE_SW_READ_RARELY        = 0x00000002,
+    GRALLOC_USAGE_SW_READ_OFTEN         = 0x00000003,
+    GRALLOC_USAGE_SW_READ_MASK          = 0x0000000F,
+    GRALLOC_USAGE_SW_WRITE_NEVER        = 0x00000000,
+    GRALLOC_USAGE_SW_WRITE_RARELY       = 0x00000020,
+    GRALLOC_USAGE_SW_WRITE_OFTEN        = 0x00000030,
+    GRALLOC_USAGE_SW_WRITE_MASK         = 0x000000F0,
+    GRALLOC_USAGE_HW_TEXTURE            = 0x00000100,
+    GRALLOC_USAGE_HW_RENDER             = 0x00000200,
+    GRALLOC_USAGE_HW_2D                 = 0x00000400,
+    GRALLOC_USAGE_HW_COMPOSER           = 0x00000800,
+    GRALLOC_USAGE_HW_FB                 = 0x00001000,
+    GRALLOC_USAGE_HW_VIDEO_ENCODER      = 0x00010000,
+    GRALLOC_USAGE_HW_CAMERA_WRITE       = 0x00020000,
+    GRALLOC_USAGE_HW_CAMERA_READ        = 0x00040000,
+    GRALLOC_USAGE_HW_CAMERA_ZSL         = 0x00060000,
+    GRALLOC_USAGE_HW_CAMERA_MASK        = 0x00060000,
+    GRALLOC_USAGE_HW_MASK               = 0x00071F00,
+    GRALLOC_USAGE_EXTERNAL_DISP         = 0x00002000,
+    GRALLOC_USAGE_PROTECTED             = 0x00004000,
+    GRALLOC_USAGE_PRIVATE_0             = 0x10000000,
+    GRALLOC_USAGE_PRIVATE_1             = 0x20000000,
+    GRALLOC_USAGE_PRIVATE_2             = 0x40000000,
+    GRALLOC_USAGE_PRIVATE_3             = 0x80000000,
+    GRALLOC_USAGE_PRIVATE_MASK          = 0xF0000000,
+};
+
+#define GRALLOC_HARDWARE_MODULE_ID "gralloc"
+
+extern int hw_get_module(const char *id, const struct hw_module_t **module);
diff -Naur wine-2.0a/dlls/wineandroid.drv/build.gradle wine-2.0b/dlls/wineandroid.drv/build.gradle
--- wine-2.0a/dlls/wineandroid.drv/build.gradle	1970-01-01 01:00:00.000000000 +0100
+++ wine-2.0b/dlls/wineandroid.drv/build.gradle	2017-07-11 20:37:51.000000000 +0100
@@ -0,0 +1,29 @@
+apply plugin: 'com.android.library'
+
+buildscript
+{
+    repositories
+    {
+        jcenter()
+    }
+
+    dependencies
+    {
+        classpath 'com.android.tools.build:gradle:1.1.3'
+    }
+}
+
+android
+{
+    compileSdkVersion 17
+    buildToolsVersion "21.1.2"
+
+    defaultConfig
+    {
+        minSdkVersion 17
+    }
+}
+
+task wrapper(type: Wrapper) {
+    gradleVersion = '2.5'
+}
diff -Naur wine-2.0a/dlls/wineandroid.drv/clipboard.c wine-2.0b/dlls/wineandroid.drv/clipboard.c
--- wine-2.0a/dlls/wineandroid.drv/clipboard.c	1970-01-01 01:00:00.000000000 +0100
+++ wine-2.0b/dlls/wineandroid.drv/clipboard.c	2017-07-11 20:37:51.000000000 +0100
@@ -0,0 +1,1202 @@
+/*
+ * Clipboard related functions
+ *
+ * Copyright 1994 Martin Ayotte
+ *	     1996 Alex Korobka
+ *	     1999 Noel Borthwick
+ *           2003 Ulrich Czekalla for CodeWeavers
+ *           2014 Damjan Jovanovic
+ *           2016 Vincent Povirk for CodeWeavers
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#define NONAMELESSUNION
+#define NONAMELESSSTRUCT
+
+#include "config.h"
+#include "wine/port.h"
+
+#include <fcntl.h>
+#include <math.h>
+#include <poll.h>
+#include <errno.h>
+#include <stdarg.h>
+#include <stdlib.h>
+#include <stdio.h>
+#ifdef HAVE_UNISTD_H
+# include <unistd.h>
+#endif
+
+#include "ntstatus.h"
+#define WIN32_NO_STATUS
+#include "windef.h"
+#include "winbase.h"
+#include "wingdi.h"
+#include "winuser.h"
+#include "wine/unicode.h"
+
+#include "android.h"
+#include "wine/debug.h"
+#include "wine/server.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(clipboard);
+
+typedef HANDLE (*AndroidImportFunction)(BYTE* data, DWORD len);
+typedef DWORD (*AndroidExportFunction)(HANDLE input, BYTE* output, DWORD len);
+
+typedef struct android_clipformat {
+    UINT uFormat;
+    AndroidImportFunction import;
+    AndroidExportFunction export;
+    BOOL present;
+    BOOL requested;
+} android_clipformat;
+
+static HANDLE ANDROID_CLIPBOARD_ImportText(BYTE* data, DWORD len);
+static DWORD ANDROID_CLIPBOARD_ExportText(HANDLE input, BYTE* output, DWORD len);
+
+/* Keep synced with TopView.clip_mimetypes */
+static android_clipformat android_clipformats[] = {
+    { CF_UNICODETEXT, ANDROID_CLIPBOARD_ImportText, ANDROID_CLIPBOARD_ExportText }, /* text/plain */
+};
+
+enum HANDLE_TYPE {
+    HANDLE_TYPE_GLOBAL,
+    HANDLE_TYPE_GDI,
+    HANDLE_TYPE_EMF,
+    HANDLE_TYPE_METAFILEPICT,
+    HANDLE_TYPE_PRIVATE,
+};
+
+DWORD clipdata_seqno = 0;
+DWORD clipdata_count = 0;
+
+typedef struct clipdata {
+    struct list entry;
+    UINT format;
+    HANDLE data;
+    enum data_source {
+        DATA_SOURCE_INPROCESS,
+        DATA_SOURCE_SYNTHESIZE,
+        DATA_SOURCE_RENDERFORMAT,
+        DATA_SOURCE_DESKTOP,
+        DATA_SOURCE_JAVA,
+    } data_source;
+    int android_format;
+    BOOL waiting; /* TRUE if someone is waiting for this format's data */
+} clipdata;
+
+struct list clipdata_list = LIST_INIT(clipdata_list);
+
+static CRITICAL_SECTION clipdata_section;
+static CRITICAL_SECTION_DEBUG critsect_debug =
+{
+    0, 0, &clipdata_section,
+    { &critsect_debug.ProcessLocksList, &critsect_debug.ProcessLocksList },
+      0, 0, { (DWORD_PTR)(__FILE__ ": clipdata_section") }
+};
+static CRITICAL_SECTION clipdata_section = { &critsect_debug, -1, 0, 0, 0, 0 };
+
+static BOOL handling_clipboard_changed;
+
+HANDLE data_update_event; /* Signaled if any format where waiting==TRUE has changed. */
+
+static clipdata* ANDROID_CLIPBOARD_LookupData( UINT format )
+{
+    clipdata* entry;
+
+    EnterCriticalSection( &clipdata_section );
+
+    LIST_FOR_EACH_ENTRY(entry, &clipdata_list, clipdata, entry) {
+        if (entry->format == format)
+        {
+            LeaveCriticalSection( &clipdata_section );
+            return entry;
+        }
+    }
+
+    LeaveCriticalSection( &clipdata_section );
+
+    return NULL;
+}
+
+static enum HANDLE_TYPE format_handle_type( UINT format )
+{
+    if ((format >= CF_GDIOBJFIRST && format <= CF_GDIOBJLAST) ||
+        format == CF_BITMAP ||
+        format == CF_DIB ||
+        format == CF_PALETTE)
+        return HANDLE_TYPE_GDI;
+    else if (format == CF_METAFILEPICT)
+        return HANDLE_TYPE_METAFILEPICT;
+    else if (format == CF_ENHMETAFILE)
+        return HANDLE_TYPE_EMF;
+    else if (format >= CF_PRIVATEFIRST && format <= CF_PRIVATELAST)
+        return HANDLE_TYPE_PRIVATE;
+    else
+        return HANDLE_TYPE_GLOBAL;
+}
+
+static void ANDROID_CLIPBOARD_FreeData( clipdata *data )
+{
+    TRACE("%04X %p\n", data->format, data->data);
+
+    switch (format_handle_type( data->format ))
+    {
+    case HANDLE_TYPE_GLOBAL:
+        GlobalFree( data->data );
+        break;
+    case HANDLE_TYPE_GDI:
+        DeleteObject( data->data );
+        break;
+    case HANDLE_TYPE_EMF:
+        if (data->data)
+            GlobalFree( data->data );
+        break;
+    case HANDLE_TYPE_METAFILEPICT:
+        if (data->data)
+        {
+            DeleteMetaFile(((METAFILEPICT *)GlobalLock( data->data ))->hMF );
+            GlobalFree(data->data);
+        }
+        break;
+    case HANDLE_TYPE_PRIVATE:
+        break;
+    }
+
+    data->data = 0;
+}
+
+static HANDLE get_data_update_event(void)
+{
+    if (!data_update_event)
+    {
+        HANDLE result = CreateEventA( NULL, TRUE, TRUE, "Global\\WineAndroidClipboardUpdate" );
+        if (InterlockedCompareExchangePointer( (void*)&data_update_event, result, NULL ))
+            CloseHandle( result );
+    }
+    return data_update_event;
+}
+
+static void ANDROID_CLIPBOARD_HandleJavaRequests(void);
+
+static clipdata* ANDROID_CLIPBOARD_InsertData( UINT format, HANDLE data, enum data_source data_source )
+{
+    clipdata* result;
+    BOOL was_waiting=FALSE;
+
+    TRACE("%04X, %p, %u\n", format, data, data_source);
+
+    EnterCriticalSection( &clipdata_section );
+
+    if ((result = ANDROID_CLIPBOARD_LookupData( format )))
+    {
+        ANDROID_CLIPBOARD_FreeData( result );
+        result->data = data;
+        result->data_source = data_source;
+        if (result->waiting)
+        {
+            was_waiting = TRUE;
+            result->waiting = FALSE;
+        }
+    }
+    else if ((result = HeapAlloc( GetProcessHeap(), 0, sizeof(*result) )))
+    {
+        result->format = format;
+        result->data = data;
+        result->data_source = data_source;
+        result->waiting = FALSE;
+
+        list_add_tail( &clipdata_list, &result->entry );
+        clipdata_count++;
+    }
+
+    if (was_waiting)
+    {
+        SetEvent( get_data_update_event() );
+        ANDROID_CLIPBOARD_HandleJavaRequests();
+    }
+
+    LeaveCriticalSection( &clipdata_section );
+
+    return result;
+}
+
+static void ANDROID_CLIPBOARD_SynthesizeFormats( void )
+{
+    clipdata *entry;
+    BOOL cf_text=FALSE, cf_oemtext=FALSE, cf_unicodetext=FALSE;
+
+    EnterCriticalSection( &clipdata_section );
+
+    LIST_FOR_EACH_ENTRY(entry, &clipdata_list, clipdata, entry) {
+        switch (entry->format) {
+        case CF_TEXT:
+            cf_text = TRUE;
+            break;
+        case CF_OEMTEXT:
+            cf_oemtext = TRUE;
+            break;
+        case CF_UNICODETEXT:
+            cf_unicodetext = TRUE;
+            break;
+        }
+    }
+
+    if (cf_text || cf_oemtext || cf_unicodetext) {
+        if (!cf_text) ANDROID_CLIPBOARD_InsertData( CF_TEXT, 0, DATA_SOURCE_SYNTHESIZE );
+        if (!cf_oemtext) ANDROID_CLIPBOARD_InsertData( CF_OEMTEXT, 0, DATA_SOURCE_SYNTHESIZE );
+        if (!cf_unicodetext) ANDROID_CLIPBOARD_InsertData( CF_UNICODETEXT, 0, DATA_SOURCE_SYNTHESIZE );
+    }
+
+    LeaveCriticalSection( &clipdata_section );
+}
+
+static BOOL is_desktop_process( void )
+{
+    /* FIXME: There must be a better way. */
+    DWORD pid;
+    GetWindowThreadProcessId( GetDesktopWindow(), &pid );
+    return pid == GetCurrentProcessId();
+}
+
+void clipboard_changed( JNIEnv *env, jobject obj, jbooleanArray formats_present )
+{
+    union event_data data;
+    jboolean* values;
+    int i;
+
+    values = (*env)->GetBooleanArrayElements( env, formats_present, NULL );
+    for (i=0; i < sizeof(android_clipformats)/sizeof(android_clipformats[0]); i++)
+    {
+        android_clipformats[i].present = (values[i] != JNI_FALSE);
+    }
+    (*env)->ReleaseBooleanArrayElements( env, formats_present, values, JNI_ABORT );
+
+    memset( &data, 0, sizeof(data) );
+    data.type = CLIPBOARD_CHANGED;
+    p__android_log_print( ANDROID_LOG_INFO, "wine", "clipboard_changed\n" );
+    send_event( desktop_thread, &data );
+}
+
+void handle_clipboard_changed(void)
+{
+    int i;
+
+    TRACE("\n");
+
+    if (OpenClipboard( GetDesktopWindow() ))
+    {
+        handling_clipboard_changed = TRUE;
+
+        EmptyClipboard();
+
+        for (i=0; i < sizeof(android_clipformats)/sizeof(android_clipformats[0]); i++)
+        {
+            if (android_clipformats[i].import && android_clipformats[i].present)
+            {
+                clipdata *data = ANDROID_CLIPBOARD_InsertData( android_clipformats[i].uFormat, NULL, DATA_SOURCE_JAVA );
+                if (data)
+                    data->android_format = i;
+            }
+        }
+
+        CloseClipboard();
+    }
+}
+
+BOOL get_clipboard_data( UINT wFormat, HANDLE* data, BOOL may_block );
+
+void clipboard_request( JNIEnv *env, jobject obj, jint format )
+{
+    union event_data data;
+
+    memset( &data, 0, sizeof(data) );
+    data.type = CLIPBOARD_REQUEST;
+    data.clipdata.android_format = format;
+    p__android_log_print( ANDROID_LOG_INFO, "wine", "clipboard_requested\n" );
+    send_event( desktop_thread, &data );
+}
+
+void handle_clipboard_request( int format )
+{
+    HANDLE data;
+    android_clipformat *clipformat = &android_clipformats[format];
+
+    TRACE("%i\n", format);
+
+    if (get_clipboard_data( clipformat->uFormat, &data, FALSE ))
+    {
+        BYTE* exported=NULL;
+        DWORD exported_len=0;
+
+        if (data)
+        {
+            exported_len = clipformat->export( data, NULL, 0 );
+            if (exported_len)
+            {
+                exported = HeapAlloc( GetProcessHeap(), 0, exported_len );
+                if (exported)
+                    clipformat->export( data, exported, exported_len );
+                else
+                    exported_len = 0;
+            }
+        }
+
+        clipformat->requested = FALSE;
+
+        ioctl_export_clipboard_data( format, exported, exported_len );
+
+        HeapFree( GetProcessHeap(), 0, exported );
+    }
+    else
+        clipformat->requested = TRUE;
+}
+
+static void ANDROID_CLIPBOARD_HandleJavaRequests(void)
+{
+    int i;
+
+    for (i=0; i<sizeof(android_clipformats)/sizeof(android_clipformats[0]); i++)
+    {
+        if (android_clipformats[i].requested)
+        {
+            /* This may be called from the device thread, in which case we'll
+             * hang if we try an ioctl, so send it to the desktop thread */
+            SendNotifyMessageW( GetDesktopWindow(), WM_ANDROID_CLIPBOARD_REQUEST, (WPARAM)i, 0 );
+        }
+    }
+}
+
+void get_exported_formats( BOOL* formats, int num_formats )
+{
+    int i;
+
+    if (num_formats != sizeof(android_clipformats)/sizeof(android_clipformats[0]))
+    {
+        ERR( "get_exported_formats called with wrong size\n" );
+        return;
+    }
+
+    EnterCriticalSection( &clipdata_section );
+
+    for (i=0; i<num_formats; i++)
+    {
+        android_clipformat *clipformat = &android_clipformats[i];
+
+        formats[i] = (clipformat->export != NULL &&
+            ANDROID_CLIPBOARD_LookupData( clipformat->uFormat ) != NULL);
+    }
+
+    LeaveCriticalSection( &clipdata_section );
+}
+
+static void ANDROID_CLIPBOARD_EmptyClipData(void)
+{
+    clipdata *data, *next;
+    BOOL any_waiting=FALSE;
+
+    EnterCriticalSection( &clipdata_section );
+
+    LIST_FOR_EACH_ENTRY_SAFE( data, next, &clipdata_list, clipdata, entry )
+    {
+        list_remove( &data->entry );
+        ANDROID_CLIPBOARD_FreeData( data );
+        if (data->waiting)
+            any_waiting = TRUE;
+        HeapFree( GetProcessHeap(), 0, data );
+        clipdata_count--;
+    }
+
+    if (any_waiting)
+    {
+        SetEvent( get_data_update_event() );
+        ANDROID_CLIPBOARD_HandleJavaRequests();
+    }
+
+    LeaveCriticalSection( &clipdata_section );
+}
+
+void CDECL ANDROID_EmptyClipboard(void)
+{
+    TRACE("\n");
+
+    ANDROID_CLIPBOARD_EmptyClipData();
+
+    if (!is_desktop_process())
+        ioctl_empty_clipboard();
+}
+
+void CDECL ANDROID_EndClipboardUpdate(void)
+{
+    TRACE("\n");
+
+    clipdata_seqno = GetClipboardSequenceNumber();
+
+    if (!is_desktop_process())
+        ioctl_end_clipboard_update();
+    else if (handling_clipboard_changed)
+        handling_clipboard_changed = FALSE;
+    else
+        ioctl_acquire_clipboard();
+
+    ANDROID_CLIPBOARD_SynthesizeFormats();
+}
+
+static BOOL ANDROID_CLIPBOARD_IsClipDataCurrent(void)
+{
+    BOOL is_process_owner = FALSE;
+    DWORD current_seqno = 0;
+
+    if (is_desktop_process())
+        return TRUE;
+
+    SERVER_START_REQ( set_clipboard_info )
+    {
+        req->flags = 0;
+        if (!wine_server_call_err( req ))
+        {
+            is_process_owner = (reply->flags & CB_PROCESS);
+            current_seqno = reply->seqno;
+        }
+    }
+    SERVER_END_REQ;
+
+    return is_process_owner || current_seqno == clipdata_seqno;
+}
+
+static void ANDROID_CLIPBOARD_UpdateCache(void)
+{
+    if (!ANDROID_CLIPBOARD_IsClipDataCurrent())
+    {
+        DWORD current_seqno, current_count, i;
+        UINT *current_formats;
+
+        TRACE("updating\n");
+
+        if (ioctl_get_clipboard_formats( &current_seqno, &current_formats, &current_count ))
+            return;
+
+        EnterCriticalSection( &clipdata_section );
+
+        ANDROID_CLIPBOARD_EmptyClipData();
+        /* FIXME: wineserver spontaneously updates seqno so the one we get from the desktop process may be outdated */
+        clipdata_seqno = GetClipboardSequenceNumber();
+        for (i=0; i<current_count; i++)
+        {
+            ANDROID_CLIPBOARD_InsertData( current_formats[i], NULL, DATA_SOURCE_DESKTOP );
+        }
+
+        ANDROID_CLIPBOARD_SynthesizeFormats();
+
+        LeaveCriticalSection( &clipdata_section );
+    }
+}
+
+UINT CDECL ANDROID_EnumClipboardFormats( UINT wFormat )
+{
+    struct list *ptr = NULL;
+    UINT ret;
+
+    TRACE("(%04X)\n", wFormat);
+
+    ANDROID_CLIPBOARD_UpdateCache();
+
+    EnterCriticalSection( &clipdata_section );
+
+    if (!wFormat)
+    {
+        ptr = list_head( &clipdata_list );
+    }
+    else
+    {
+        clipdata *lpData = ANDROID_CLIPBOARD_LookupData( wFormat );
+        if (lpData) ptr = list_next( &clipdata_list, &lpData->entry );
+    }
+
+    if (!ptr) ret = 0;
+    else ret = LIST_ENTRY( ptr, clipdata, entry )->format;
+
+    LeaveCriticalSection( &clipdata_section );
+
+    return ret;
+}
+
+BOOL CDECL ANDROID_IsClipboardFormatAvailable( UINT wFormat )
+{
+    TRACE("(%04X)\n", wFormat);
+
+    ANDROID_CLIPBOARD_UpdateCache();
+
+    return (ANDROID_CLIPBOARD_LookupData( wFormat ) != NULL);
+}
+
+INT CDECL ANDROID_CountClipboardFormats(void)
+{
+    ANDROID_CLIPBOARD_UpdateCache();
+
+    TRACE("count=%d\n", clipdata_count);
+
+    return clipdata_count;
+}
+
+/* Import UTF-16 text, adding NULL terminator if necessary. */
+static HANDLE ANDROID_CLIPBOARD_ImportText( BYTE* data, DWORD len )
+{
+    HANDLE result;
+    BYTE* lock;
+    DWORD alloc_len = len;
+
+    if (len < 2 || data[len-2] != 0 || data[len-1] != 0)
+        alloc_len += 2;
+
+    result = GlobalAlloc( GMEM_MOVEABLE, alloc_len );
+    if (result)
+    {
+        lock = GlobalLock( result );
+        memcpy( lock, data, len );
+        lock[alloc_len-2] = 0;
+        lock[alloc_len-1] = 0;
+        GlobalUnlock( result );
+    }
+
+    return result;
+}
+
+/* Export CF_UNICODE to utf8 with no NULL terminator */
+static DWORD ANDROID_CLIPBOARD_ExportText(HANDLE input, BYTE* output, DWORD len)
+{
+    DWORD input_size, input_len, output_len;
+    WCHAR *input_data, *input_end;
+
+    input_size = GlobalSize( input );
+
+    input_data = GlobalLock( input );
+
+    input_end = memchrW( input_data, 0, input_size/sizeof(WCHAR) );
+    if (input_end) input_len = input_end - input_data;
+    else input_len = input_size/sizeof(WCHAR);
+
+    output_len = WideCharToMultiByte( CP_UTF8, 0, input_data, input_len, NULL, 0, NULL, NULL );
+
+    if (output != NULL && output_len <= len)
+    {
+        WideCharToMultiByte( CP_UTF8, 0, input_data, input_len, (LPSTR)output, output_len, NULL, NULL );
+    }
+
+    GlobalUnlock( input );
+
+    return output_len;
+}
+
+static HANDLE ANDROID_CLIPBOARD_DeserializeHGlobal( UINT format, HGLOBAL data )
+{
+    HANDLE result = NULL;
+
+    TRACE("%04X %p\n", format, data);
+
+    switch (format_handle_type( format ))
+    {
+    case HANDLE_TYPE_GDI:
+    case HANDLE_TYPE_EMF:
+    case HANDLE_TYPE_METAFILEPICT:
+        FIXME("%04X\n", format);
+        GlobalFree( data );
+        break;
+    case HANDLE_TYPE_GLOBAL:
+        return data;
+        break;
+    case HANDLE_TYPE_PRIVATE:
+        ERR("shouldn't happen\n");
+        break;
+    }
+
+    return result;
+}
+
+static DWORD ANDROID_CLIPBOARD_GetSerializedSize( UINT format, HANDLE handle )
+{
+    switch (format_handle_type( format ))
+    {
+    case HANDLE_TYPE_GDI:
+    case HANDLE_TYPE_EMF:
+    case HANDLE_TYPE_METAFILEPICT:
+        FIXME("%04X\n", format);
+        return 0;
+    case HANDLE_TYPE_GLOBAL:
+        return GlobalSize( handle );
+    case HANDLE_TYPE_PRIVATE:
+        ERR("shouldn't happen\n");
+        return 0;
+    }
+
+    return 0;
+}
+
+static void ANDROID_CLIPBOARD_SerializeHandle( UINT format, HANDLE handle, BYTE* buffer, DWORD size )
+{
+    switch (format_handle_type( format ))
+    {
+    case HANDLE_TYPE_GDI:
+    case HANDLE_TYPE_EMF:
+    case HANDLE_TYPE_METAFILEPICT:
+        FIXME("%04X\n", format);
+        break;
+    case HANDLE_TYPE_GLOBAL:
+    {
+        DWORD actual_size = GlobalSize( handle );
+        if (actual_size <= size)
+        {
+            void* lock = GlobalLock( handle );
+            if (lock)
+            {
+                memcpy( buffer, lock, actual_size );
+                GlobalUnlock( handle );
+            }
+        }
+        break;
+    }
+    case HANDLE_TYPE_PRIVATE:
+        ERR("shouldn't happen\n");
+        break;
+    }
+}
+
+static BOOL ANDROID_CLIPBOARD_ShouldExportData( clipdata* clipdata )
+{
+    if (clipdata->data_source == DATA_SOURCE_SYNTHESIZE) {
+        /* We have no way for the desktop process to ask a client to
+         * render synthesized data on another client's behalf, so the
+         * easiest thing is for every process to synthesize its own data. */
+        return FALSE;
+    }
+
+    switch (format_handle_type( clipdata->format ))
+    {
+    case HANDLE_TYPE_GDI:
+    case HANDLE_TYPE_EMF:
+    case HANDLE_TYPE_METAFILEPICT:
+    case HANDLE_TYPE_GLOBAL:
+        return TRUE;
+    case HANDLE_TYPE_PRIVATE:
+    default:
+        return FALSE;
+    }
+}
+
+extern NTSTATUS get_clipboard_formats( DWORD* seqno, UINT* formats, UINT* num_formats )
+{
+    UINT buffer_length = *num_formats;
+    clipdata* entry;
+    int i;
+
+    *seqno = clipdata_seqno;
+
+    EnterCriticalSection( &clipdata_section );
+
+    i = 0;
+    LIST_FOR_EACH_ENTRY(entry, &clipdata_list, clipdata, entry) {
+        if (ANDROID_CLIPBOARD_ShouldExportData( entry ))
+        {
+            if (formats && i < buffer_length)
+                formats[i] = entry->format;
+            i++;
+        }
+    }
+
+    LeaveCriticalSection( &clipdata_section );
+
+    *num_formats = i;
+
+    return i <= buffer_length ? STATUS_SUCCESS : STATUS_BUFFER_OVERFLOW;
+}
+
+void import_clipboard_data( JNIEnv *env, jobject obj, jint android_format, jbyteArray data )
+{
+    union event_data event;
+    jsize array_length;
+    jbyte* array_values;
+    BYTE* buffer = NULL;
+
+    array_length = (*env)->GetArrayLength( env, (jarray)data );
+
+    if (array_length)
+    {
+        buffer = malloc( array_length );
+
+        if (!buffer) return;
+
+        array_values = (*env)->GetByteArrayElements( env, data, NULL );
+        memcpy( buffer, array_values, array_length );
+        (*env)->ReleaseByteArrayElements( env, data, array_values, JNI_ABORT );
+    }
+    else
+        buffer = NULL;
+
+    memset( &event, 0, sizeof(event) );
+    event.type = IMPORT_CLIPBOARD_DATA;
+    event.clipdata.android_format = android_format;
+    event.clipdata.len = array_length;
+    event.clipdata.data = buffer;
+    p__android_log_print( ANDROID_LOG_INFO, "wine", "import_clipboard_data\n" );
+    send_event( desktop_thread, &event );
+}
+
+void handle_import_clipboard_data( INT android_format, BYTE* data, DWORD len )
+{
+    android_clipformat* clipformat = &android_clipformats[android_format];
+    clipdata* clipdata;
+
+    TRACE("%i\n", android_format);
+
+    EnterCriticalSection( &clipdata_section );
+
+    clipdata = ANDROID_CLIPBOARD_LookupData( clipformat->uFormat );
+
+    if (clipdata && !clipdata->data && clipdata->data_source == DATA_SOURCE_JAVA)
+    {
+        ANDROID_CLIPBOARD_InsertData( clipformat->uFormat, clipformat->import( data, len ), DATA_SOURCE_INPROCESS );
+    }
+
+    LeaveCriticalSection( &clipdata_section );
+}
+
+enum RENDERFORMAT_RESULT {
+    COMPLETE, /* clipboard format is rendered (handle may be NULL on failure) */
+    BLOCK, /* caller should block on get_data_update_event() and retry */
+    RETRY, /* caller should retry immediately */
+};
+
+static enum RENDERFORMAT_RESULT ANDROID_CLIPBOARD_SynthesizeAnsiText( clipdata* clip, HANDLE* data, BOOL block )
+{
+    clipdata *unicode_clipdata;
+    HANDLE hsrc, hdst;
+    WCHAR *psrc;
+    char *pdst;
+    UINT cp;
+    INT src_len, dst_len;
+    WCHAR *src_end;
+
+    TRACE("\n");
+
+    unicode_clipdata = ANDROID_CLIPBOARD_LookupData( CF_UNICODETEXT );
+
+    if (!unicode_clipdata)
+    {
+        ERR("missing CF_UNICODETEXT\n");
+        LeaveCriticalSection( &clipdata_section );
+        *data = NULL;
+        return COMPLETE;
+    }
+
+    if (!unicode_clipdata->data)
+    {
+        enum RENDERFORMAT_RESULT ret;
+        HANDLE dummy;
+        LeaveCriticalSection( &clipdata_section );
+        ret = get_clipboard_data( CF_UNICODETEXT, &dummy, block );
+        if (ret == BLOCK) return BLOCK;
+        else return RETRY;
+    }
+
+    if (clip->format == CF_OEMTEXT)
+        cp = CP_OEMCP;
+    else
+        cp = CP_ACP;
+
+    hsrc = unicode_clipdata->data;
+    src_len = GlobalSize( hsrc ) / sizeof(WCHAR);
+    psrc = GlobalLock( hsrc );
+
+    src_end = memchrW( psrc, 0, src_len );
+    if (src_end) src_len = src_end - psrc;
+
+    dst_len = WideCharToMultiByte( cp, 0, psrc, src_len, 0, 0, 0, 0 );
+
+    hdst = GlobalAlloc( GMEM_MOVEABLE, dst_len + 1 );
+    if (!hdst)
+    {
+        GlobalUnlock( hsrc );
+        LeaveCriticalSection( &clipdata_section );
+        *data = NULL;
+        return COMPLETE;
+    }
+
+    pdst = GlobalLock( hdst );
+    WideCharToMultiByte( cp, 0, psrc, src_len, pdst, dst_len, 0, 0 );
+    pdst[dst_len] = 0;
+    GlobalUnlock( hdst );
+    GlobalUnlock( hsrc );
+
+    clip->data = hdst;
+
+    LeaveCriticalSection( &clipdata_section );
+
+    *data = hdst;
+    return COMPLETE;
+}
+
+static enum RENDERFORMAT_RESULT ANDROID_CLIPBOARD_SynthesizeUnicodeText( clipdata* clip, HANDLE* data, BOOL block )
+{
+    clipdata *ansi_clipdata;
+    UINT src_format;
+    HANDLE hsrc, hdst;
+    char *psrc;
+    WCHAR *pdst;
+    UINT cp;
+    INT src_len, dst_len;
+    char *src_end;
+
+    TRACE("\n");
+
+    ansi_clipdata = ANDROID_CLIPBOARD_LookupData( CF_TEXT );
+
+    if (ansi_clipdata && ansi_clipdata->data_source == DATA_SOURCE_SYNTHESIZE)
+        ansi_clipdata = ANDROID_CLIPBOARD_LookupData( CF_OEMTEXT );
+
+    if (!ansi_clipdata)
+    {
+        ERR("missing CF_TEXT\n");
+        LeaveCriticalSection( &clipdata_section );
+        *data = NULL;
+        return COMPLETE;
+    }
+
+    src_format = ansi_clipdata->format;
+
+    if (!ansi_clipdata->data)
+    {
+        enum RENDERFORMAT_RESULT ret;
+        HANDLE dummy;
+        LeaveCriticalSection( &clipdata_section );
+        ret = get_clipboard_data( src_format, &dummy, block );
+        if (ret == BLOCK) return BLOCK;
+        else return RETRY;
+    }
+
+    if (ansi_clipdata->format == CF_OEMTEXT)
+        cp = CP_OEMCP;
+    else
+        cp = CP_ACP;
+
+    hsrc = ansi_clipdata->data;
+    src_len = GlobalSize( hsrc );
+    psrc = GlobalLock( hsrc );
+
+    src_end = memchr( psrc, 0, src_len );
+    if (src_end) src_len = src_end - psrc;
+
+    dst_len = MultiByteToWideChar( cp, 0, psrc, src_len, 0, 0 );
+
+    hdst = GlobalAlloc( GMEM_MOVEABLE, (dst_len + 1) * sizeof(WCHAR) );
+    if (!hdst)
+    {
+        GlobalUnlock( hsrc );
+        LeaveCriticalSection( &clipdata_section );
+        *data = NULL;
+        return COMPLETE;
+    }
+
+    pdst = GlobalLock( hdst );
+    MultiByteToWideChar( cp, 0, psrc, src_len, pdst, dst_len );
+    pdst[dst_len] = 0;
+    GlobalUnlock( hdst );
+    GlobalUnlock( hsrc );
+
+    clip->data = hdst;
+
+    LeaveCriticalSection( &clipdata_section );
+
+    *data = hdst;
+    return COMPLETE;
+}
+
+/* Caller must hold clipdata_section. clipdata_section is released by this function. */
+static enum RENDERFORMAT_RESULT ANDROID_CLIPBOARD_RenderFormat( clipdata* clipdata, HANDLE* data, BOOL block )
+{
+    switch (clipdata->data_source)
+    {
+    case DATA_SOURCE_INPROCESS:
+        *data = clipdata->data;
+        LeaveCriticalSection( &clipdata_section );
+        return COMPLETE;
+    case DATA_SOURCE_SYNTHESIZE:
+        TRACE("%04X synthesize\n", clipdata->format);
+
+        if (clipdata->data)
+        {
+            *data = clipdata->data;
+            LeaveCriticalSection( &clipdata_section );
+            return COMPLETE;
+        }
+
+        switch (clipdata->format)
+        {
+        case CF_TEXT:
+        case CF_OEMTEXT:
+            return ANDROID_CLIPBOARD_SynthesizeAnsiText( clipdata, data, block );
+        case CF_UNICODETEXT:
+            return ANDROID_CLIPBOARD_SynthesizeUnicodeText( clipdata, data, block );
+        }
+
+        FIXME("can't synthesize format %04X", clipdata->format);
+        *data = NULL;
+        LeaveCriticalSection( &clipdata_section );
+        return COMPLETE;
+    case DATA_SOURCE_RENDERFORMAT:
+    {
+        TRACE("%04X renderformat\n", clipdata->format);
+        if (block)
+        {
+            DWORD format = clipdata->format;
+            LeaveCriticalSection( &clipdata_section );
+            SendMessageW( GetClipboardOwner(), WM_RENDERFORMAT, format, 0 );
+            return RETRY;
+        }
+        else
+        {
+            clipdata->waiting = TRUE;
+            ResetEvent( get_data_update_event() );
+            SendNotifyMessageW( GetClipboardOwner(), WM_RENDERFORMAT, clipdata->format, 0 );
+            LeaveCriticalSection( &clipdata_section );
+            return BLOCK;
+        }
+    }
+    case DATA_SOURCE_DESKTOP:
+    {
+        HGLOBAL global_data=NULL, handle;
+        BOOL pending=FALSE;
+
+        TRACE("%04X desktop\n", clipdata->format);
+
+        if (ioctl_get_clipboard_data( clipdata->format, &global_data, &pending ))
+        {
+            *data = NULL;
+            LeaveCriticalSection( &clipdata_section );
+            return COMPLETE;
+        }
+        if (pending) {
+            LeaveCriticalSection( &clipdata_section );
+            return BLOCK;
+        }
+        if (global_data)
+        {
+            handle = ANDROID_CLIPBOARD_DeserializeHGlobal( clipdata->format, global_data );
+
+            ANDROID_CLIPBOARD_InsertData( clipdata->format, handle, DATA_SOURCE_INPROCESS );
+        }
+        *data = clipdata->data;
+        LeaveCriticalSection( &clipdata_section );
+        return COMPLETE;
+    }
+    case DATA_SOURCE_JAVA:
+        TRACE("%04X java\n", clipdata->format);
+        /* Can't call ioctl_render_clipboard_data here because we may be in an ioctl handler */
+        SendNotifyMessageW( GetDesktopWindow(), WM_ANDROID_RENDERFORMAT, clipdata->android_format, 0 );
+        clipdata->waiting = TRUE;
+        ResetEvent( get_data_update_event() );
+        LeaveCriticalSection( &clipdata_section );
+        return BLOCK;
+    }
+
+    *data = NULL;
+    LeaveCriticalSection( &clipdata_section );
+    return COMPLETE;
+}
+
+/* Get clipboard data. Returns FALSE if blocking is required.
+ * If may_block is TRUE, this function will eventually return TRUE.
+ * clipdata_section should not be held when may_block is TRUE. */
+BOOL get_clipboard_data( UINT wFormat, HANDLE* data, BOOL may_block )
+{
+    clipdata *clipdata;
+
+    TRACE("(%04X)\n", wFormat);
+
+retry:
+
+    ANDROID_CLIPBOARD_UpdateCache();
+
+    EnterCriticalSection( &clipdata_section );
+
+    if ((clipdata = ANDROID_CLIPBOARD_LookupData( wFormat )))
+    {
+        enum RENDERFORMAT_RESULT res = ANDROID_CLIPBOARD_RenderFormat( clipdata, data, may_block );
+        /* ANDROID_CLIPBOARD_RenderFormat leaves critical section. */
+
+        switch (res)
+        {
+        case COMPLETE:
+            TRACE("returning %p (type %04X)\n", *data, wFormat);
+            return TRUE;
+        case BLOCK:
+            TRACE("pending (type %04X) %i\n", wFormat, may_block);
+            if (may_block)
+            {
+                WaitForSingleObject( get_data_update_event(), INFINITE );
+                goto retry;
+            }
+            return FALSE;
+        case RETRY:
+            TRACE("retry (type %04X)\n", wFormat);
+            goto retry;
+        }
+    }
+    else
+        LeaveCriticalSection( &clipdata_section );
+
+    TRACE("returning NULL (type %04x)\n", wFormat);
+    *data = NULL;
+    return TRUE;
+}
+
+NTSTATUS handle_ioctl_get_clipboard_data( UINT format, BOOL* format_present, BOOL* pending, BYTE* data, DWORD* size )
+{
+    HANDLE handle;
+    DWORD out_size = *size;
+
+    if (!get_clipboard_data( format, &handle, FALSE ))
+    {
+        *format_present = TRUE;
+        *size = 0;
+        *pending = TRUE;
+        return STATUS_SUCCESS;
+    }
+
+    if (!handle)
+    {
+        *format_present = FALSE;
+        *size = 0;
+        *pending = FALSE;
+        return STATUS_SUCCESS;
+    }
+
+    *format_present = TRUE;
+    *size = ANDROID_CLIPBOARD_GetSerializedSize( format, handle );
+    *pending = FALSE;
+
+    if (out_size >= *size)
+    {
+        ANDROID_CLIPBOARD_SerializeHandle( format, handle, data, out_size );
+        return STATUS_SUCCESS;
+    }
+    else if (out_size == 0)
+        return STATUS_SUCCESS;
+    else
+        return STATUS_BUFFER_OVERFLOW;
+}
+
+void handle_ioctl_empty_clipboard( void )
+{
+    TRACE("\n");
+
+    ANDROID_CLIPBOARD_EmptyClipData();
+}
+
+void handle_ioctl_set_clipboard_data( UINT format, BOOL format_present, BYTE* data, DWORD size )
+{
+    HANDLE hglobal, handle;
+    void* lock;
+
+    TRACE("%04X, %i\n", format, format_present);
+
+    if (!format_present)
+    {
+        ANDROID_CLIPBOARD_InsertData( format, NULL, DATA_SOURCE_RENDERFORMAT );
+        return;
+    }
+
+    hglobal = GlobalAlloc( GMEM_MOVEABLE, size );
+
+    if (!hglobal)
+        return;
+
+    lock = GlobalLock( hglobal );
+    memcpy( lock, data, size );
+    GlobalUnlock( hglobal );
+
+    handle = ANDROID_CLIPBOARD_DeserializeHGlobal( format, hglobal );
+
+    ANDROID_CLIPBOARD_InsertData( format, handle, DATA_SOURCE_INPROCESS );
+}
+
+void handle_ioctl_end_clipboard_update( void )
+{
+    TRACE("\n");
+
+    clipdata_seqno = GetClipboardSequenceNumber();
+
+    ANDROID_CLIPBOARD_SynthesizeFormats();
+}
+
+HANDLE CDECL ANDROID_GetClipboardData( UINT wFormat )
+{
+    HANDLE data;
+
+    get_clipboard_data( wFormat, &data, TRUE );
+
+    return data;
+}
+
+BOOL CDECL ANDROID_SetClipboardData( UINT wFormat, HANDLE hData, BOOL owner )
+{
+    clipdata* clipdata=NULL;
+    BOOL res=TRUE;
+
+    TRACE("%04X, %p\n", wFormat, hData);
+
+    ANDROID_CLIPBOARD_UpdateCache();
+
+    EnterCriticalSection( &clipdata_section );
+
+    /* FIXME: Should fail if !owner and non-NULL data was previously set by the owner. */
+
+    if (res)
+    {
+        clipdata = ANDROID_CLIPBOARD_InsertData( wFormat, hData,
+            hData ? DATA_SOURCE_INPROCESS : DATA_SOURCE_RENDERFORMAT );
+        res = (clipdata != NULL);
+    }
+
+    LeaveCriticalSection( &clipdata_section );
+
+    if (res && ANDROID_CLIPBOARD_ShouldExportData( clipdata ) && !is_desktop_process())
+    {
+        BYTE* buffer=NULL;
+        DWORD size=0;
+
+        if (hData)
+        {
+            size = ANDROID_CLIPBOARD_GetSerializedSize( wFormat, hData );
+
+            if (size)
+            {
+                buffer = HeapAlloc( GetProcessHeap(), 0, size );
+                if (buffer)
+                    ANDROID_CLIPBOARD_SerializeHandle( wFormat, hData, buffer, size );
+                else
+                    res = FALSE;
+            }
+        }
+
+        if (res)
+            ioctl_set_clipboard_data( wFormat, hData != NULL, buffer, size );
+
+        HeapFree( GetProcessHeap(), 0, buffer );
+    }
+
+    return res;
+}
diff -Naur wine-2.0a/dlls/wineandroid.drv/device.c wine-2.0b/dlls/wineandroid.drv/device.c
--- wine-2.0a/dlls/wineandroid.drv/device.c	1970-01-01 01:00:00.000000000 +0100
+++ wine-2.0b/dlls/wineandroid.drv/device.c	2017-07-11 20:37:51.000000000 +0100
@@ -0,0 +1,2270 @@
+/*
+ * Android pseudo-device handling
+ *
+ * Copyright 2014 Alexandre Julliard
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include "config.h"
+#include "wine/port.h"
+
+#include <assert.h>
+#include <errno.h>
+#include <stdio.h>
+#include <stdarg.h>
+#include <sys/ioctl.h>
+
+#define NONAMELESSUNION
+#define NONAMELESSSTRUCT
+
+#include "ntstatus.h"
+#define WIN32_NO_STATUS
+#include "windef.h"
+#include "winbase.h"
+#include "winternl.h"
+#include "winioctl.h"
+#include "psapi.h"
+#include "ddk/wdm.h"
+#include "android.h"
+#include "wine/server.h"
+#include "wine/unicode.h"
+#include "wine/library.h"
+#include "wine/debug.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(android);
+
+#ifndef SYNC_IOC_WAIT
+#define SYNC_IOC_WAIT _IOW('>', 0, __s32)
+#endif
+
+extern NTSTATUS CDECL wine_ntoskrnl_main_loop( HANDLE stop_event );
+static DEVICE_OBJECT *ioctl_device;
+static HANDLE stop_event;
+static HANDLE thread;
+static JNIEnv *jni_env;
+
+static DRIVER_OBJECT *driver_obj;
+
+static const WCHAR driver_nameW[] = {'\\','D','r','i','v','e','r','\\','W','i','n','e','A','n','d','r','o','i','d',0 };
+static const WCHAR device_nameW[] = {'\\','D','e','v','i','c','e','\\','W','i','n','e','A','n','d','r','o','i','d',0 };
+static const WCHAR device_linkW[] = {'\\','?','?','\\','W','i','n','e','A','n','d','r','o','i','d',0 };
+
+#define ANDROIDCONTROLTYPE  ((ULONG)'A')
+#define ANDROID_IOCTL(n) CTL_CODE(ANDROIDCONTROLTYPE, n, METHOD_BUFFERED, FILE_READ_ACCESS)
+
+#define IOCTL_ANDROID_DEQUEUE_BUFFER          ANDROID_IOCTL(0)
+#define IOCTL_ANDROID_QUEUE_BUFFER            ANDROID_IOCTL(1)
+#define IOCTL_ANDROID_CANCEL_BUFFER           ANDROID_IOCTL(2)
+#define IOCTL_ANDROID_QUERY                   ANDROID_IOCTL(3)
+#define IOCTL_ANDROID_PERFORM                 ANDROID_IOCTL(4)
+#define IOCTL_ANDROID_SET_SWAP_INT            ANDROID_IOCTL(5)
+#define IOCTL_ANDROID_CREATE_WINDOW           ANDROID_IOCTL(6)
+#define IOCTL_ANDROID_DESTROY_WINDOW          ANDROID_IOCTL(7)
+#define IOCTL_ANDROID_WINDOW_POS_CHANGED      ANDROID_IOCTL(8)
+#define IOCTL_ANDROID_SET_WINDOW_FOCUS        ANDROID_IOCTL(9)
+#define IOCTL_ANDROID_SET_WINDOW_TEXT         ANDROID_IOCTL(10)
+#define IOCTL_ANDROID_SET_WINDOW_ICON         ANDROID_IOCTL(11)
+#define IOCTL_ANDROID_SET_WINDOW_RGN          ANDROID_IOCTL(12)
+#define IOCTL_ANDROID_SET_WINDOW_LAYERED      ANDROID_IOCTL(13)
+#define IOCTL_ANDROID_SET_SURFACE_ALPHA       ANDROID_IOCTL(14)
+#define IOCTL_ANDROID_SET_CAPTURE             ANDROID_IOCTL(15)
+#define IOCTL_ANDROID_GAMEPAD_QUERY           ANDROID_IOCTL(16)
+#define IOCTL_ANDROID_IMETEXT                 ANDROID_IOCTL(17)
+#define IOCTL_ANDROID_GET_CLIPBOARD_FORMATS   ANDROID_IOCTL(18)
+#define IOCTL_ANDROID_GET_CLIPBOARD_DATA      ANDROID_IOCTL(19)
+#define IOCTL_ANDROID_RENDER_CLIPBOARD_DATA   ANDROID_IOCTL(20)
+#define IOCTL_ANDROID_EMPTY_CLIPBOARD         ANDROID_IOCTL(21)
+#define IOCTL_ANDROID_SET_CLIPBOARD_DATA      ANDROID_IOCTL(22)
+#define IOCTL_ANDROID_END_CLIPBOARD_UPDATE    ANDROID_IOCTL(23)
+#define IOCTL_ANDROID_ACQUIRE_CLIPBOARD       ANDROID_IOCTL(24)
+#define IOCTL_ANDROID_EXPORT_CLIPBOARD_DATA   ANDROID_IOCTL(25)
+#define IOCTL_ANDROID_IMEFINISH               ANDROID_IOCTL(26)
+
+#define IOCTL_ANDROID_FIRST IOCTL_ANDROID_DEQUEUE_BUFFER
+#define IOCTL_ANDROID_LAST  IOCTL_ANDROID_IMEFINISH
+
+#define NB_CACHED_BUFFERS 4
+
+struct native_buffer_wrapper;
+
+/* buffer for storing a variable-size native handle inside an ioctl structure */
+union native_handle_buffer
+{
+    native_handle_t handle;
+    int space[256];
+};
+
+/* data about the native window in the context of the Java process */
+struct native_win_data
+{
+    struct ANativeWindow       *parent;
+    struct ANativeWindowBuffer *buffers[NB_CACHED_BUFFERS];
+    void                       *mappings[NB_CACHED_BUFFERS];
+    HWND                        hwnd;
+    int                         buffer_format;
+    int                         buffer_lru[NB_CACHED_BUFFERS];
+};
+
+/* wrapper for a native window in the context of the client (non-Java) process */
+struct native_win_wrapper
+{
+    struct ANativeWindow          win;
+    struct native_buffer_wrapper *buffers[NB_CACHED_BUFFERS];
+    struct ANativeWindowBuffer   *locked_buffer;
+    LONG                          ref;
+    HWND                          hwnd;
+};
+
+/* wrapper for a native buffer in the context of the client (non-Java) process */
+struct native_buffer_wrapper
+{
+    struct ANativeWindowBuffer buffer;
+    LONG                       ref;
+    HWND                       hwnd;
+    void                      *bits;
+    int                        buffer_id;
+    union native_handle_buffer native_handle;
+};
+
+struct ioctl_header
+{
+    int hwnd;
+};
+
+struct ioctl_android_dequeueBuffer
+{
+    struct ioctl_header hdr;
+    int                 win32;
+    int                 width;
+    int                 height;
+    int                 stride;
+    int                 format;
+    int                 usage;
+    int                 buffer_id;
+    union native_handle_buffer native_handle;
+};
+
+struct ioctl_android_queueBuffer
+{
+    struct ioctl_header hdr;
+    int                 buffer_id;
+};
+
+struct ioctl_android_cancelBuffer
+{
+    struct ioctl_header hdr;
+    int                 buffer_id;
+};
+
+struct ioctl_android_query
+{
+    struct ioctl_header hdr;
+    int                 what;
+    int                 value;
+};
+
+struct ioctl_android_perform
+{
+    struct ioctl_header hdr;
+    int                 operation;
+    int                 args[4];
+};
+
+struct ioctl_android_set_swap_interval
+{
+    struct ioctl_header hdr;
+    int                 interval;
+};
+
+struct ioctl_android_create_window
+{
+    struct ioctl_header hdr;
+};
+
+struct ioctl_android_destroy_window
+{
+    struct ioctl_header hdr;
+};
+
+struct ioctl_android_window_pos_changed
+{
+    struct ioctl_header hdr;
+    int                 left;
+    int                 top;
+    int                 right;
+    int                 bottom;
+    int                 style;
+    int                 flags;
+    int                 after;
+    int                 owner;
+};
+
+struct ioctl_android_set_window_focus
+{
+    struct ioctl_header hdr;
+};
+
+struct ioctl_android_set_window_text
+{
+    struct ioctl_header hdr;
+    WCHAR               text[1];
+};
+
+struct ioctl_android_set_window_icon
+{
+    struct ioctl_header hdr;
+    int                 width;
+    int                 height;
+    int                 bits[1];
+};
+
+struct ioctl_android_set_window_rgn
+{
+    struct ioctl_header hdr;
+    int                 has_region;
+};
+
+struct ioctl_android_set_window_layered
+{
+    struct ioctl_header hdr;
+    int                 key;
+    int                 alpha;
+};
+
+struct ioctl_android_set_surface_alpha
+{
+    struct ioctl_header hdr;
+    int                 has_alpha;
+};
+
+struct ioctl_android_set_capture
+{
+    struct ioctl_header hdr;
+};
+
+struct ioctl_android_gamepad_value
+{
+    struct ioctl_header hdr;
+    int                 index;
+    int                 device;
+    union
+    {
+            int          count;
+            di_name      name;
+            di_value_set value;
+    } data;
+};
+
+struct ioctl_android_ime_text
+{
+    struct ioctl_header hdr;
+    INT                 target;
+    INT                 length;
+    INT                 cursor;
+    WCHAR               text[1];
+};
+
+struct ioctl_android_ime_finish
+{
+    struct ioctl_header hdr;
+    INT                 target;
+};
+
+struct ioctl_android_clipboard_formats
+{
+    struct ioctl_header hdr;
+    DWORD               seqno;
+    DWORD               count;
+    UINT                formats[1];
+};
+
+struct ioctl_android_clipboard_data
+{
+    struct ioctl_header hdr;
+    UINT                format;
+    BOOL                pending;
+    BOOL                format_present;
+    UINT                size;
+    BYTE                data[1];
+};
+
+struct ioctl_android_render_clipboard_data
+{
+    struct ioctl_header hdr;
+    INT                 android_format;
+};
+
+struct ioctl_android_empty_clipboard
+{
+    struct ioctl_header hdr;
+};
+
+struct ioctl_android_end_clipboard_update
+{
+    struct ioctl_header hdr;
+};
+
+struct ioctl_android_acquire_clipboard
+{
+    struct ioctl_header hdr;
+};
+
+struct irp_entry
+{
+    struct list entry;
+    HWND        hwnd;
+    IRP        *irp;
+    DWORD       client;
+};
+
+static struct list irp_queue = LIST_INIT( irp_queue );
+
+static HWND capture_window;
+static DWORD current_client;
+
+static inline BOOL is_in_desktop_process(void)
+{
+    return thread != NULL;
+}
+
+static inline DWORD current_client_id(void)
+{
+    return current_client ? current_client : HandleToUlong( PsGetCurrentProcessId() );
+}
+
+static inline BOOL is_client_in_process(void)
+{
+    return current_client_id() == GetCurrentProcessId();
+}
+
+/* queue an IRP for later processing once the window becomes ready */
+static NTSTATUS queue_irp( HWND hwnd, IRP *irp )
+{
+    struct irp_entry *entry = HeapAlloc( GetProcessHeap(), 0, sizeof(*entry) );
+
+    if (!entry) return STATUS_NO_MEMORY;
+    TRACE( "hwnd %p irp %p\n", hwnd, irp );
+    entry->hwnd = hwnd;
+    entry->irp = irp;
+    entry->client = current_client_id();
+    list_add_tail( &irp_queue, &entry->entry );
+    return STATUS_PENDING;
+}
+
+/* process IRPs pending for a given window */
+static void process_pending_irp( HWND hwnd )
+{
+    PDRIVER_DISPATCH dispatch = ioctl_device->DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL];
+    struct irp_entry *entry, *next;
+
+    LIST_FOR_EACH_ENTRY_SAFE( entry, next, &irp_queue, struct irp_entry, entry )
+    {
+        if (entry->hwnd != hwnd) continue;
+        list_remove( &entry->entry );
+        TRACE( "hwnd %p irp %p\n", hwnd, entry->irp );
+        current_client = entry->client;
+        dispatch( ioctl_device, entry->irp );
+        current_client = 0;
+        HeapFree( GetProcessHeap(), 0, entry );
+    }
+}
+
+#ifdef __i386__  /* the Java VM uses %fs for its own purposes, so we need to wrap the calls */
+
+static WORD orig_fs, java_fs;
+static inline void wrap_java_call(void)   { wine_set_fs( java_fs ); }
+static inline void unwrap_java_call(void) { wine_set_fs( orig_fs ); }
+
+#else
+
+static inline void wrap_java_call(void) { }
+static inline void unwrap_java_call(void) { }
+
+#endif  /* __i386__ */
+
+/* FIXME: quick & dirty window handle context management */
+static struct native_win_data *data_map[65536];
+
+static struct native_win_data *get_native_win_data( HWND hwnd )
+{
+    struct native_win_data *data = data_map[LOWORD(hwnd)];
+
+    if (data && data->hwnd == hwnd) return data;
+    WARN( "unknown win %p\n", hwnd );
+    return NULL;
+}
+
+static void wait_fence_and_close( int fence )
+{
+    __s32 timeout = 1000;  /* FIXME: should be -1 for infinite timeout */
+
+    if (fence == -1) return;
+    ioctl( fence, SYNC_IOC_WAIT, &timeout );
+    close( fence );
+}
+
+static int duplicate_fd( HANDLE client, int fd )
+{
+    HANDLE handle, ret = 0;
+
+    if (!wine_server_fd_to_handle( dup(fd), GENERIC_READ | SYNCHRONIZE, 0, &handle ))
+        DuplicateHandle( GetCurrentProcess(), handle, client, &ret,
+                         DUPLICATE_SAME_ACCESS, FALSE, DUP_HANDLE_CLOSE_SOURCE );
+
+    if (!ret) return -1;
+    return HandleToLong( ret );
+}
+
+static int map_native_handle( union native_handle_buffer *dest, const native_handle_t *src,
+                              HANDLE mapping, HANDLE client )
+{
+    const size_t size = offsetof( native_handle_t, data[src->numFds + src->numInts] );
+    int i;
+
+    if (mapping)  /* only duplicate the mapping handle */
+    {
+        HANDLE ret = 0;
+        if (!DuplicateHandle( GetCurrentProcess(), mapping, client, &ret,
+                              DUPLICATE_SAME_ACCESS, FALSE, DUP_HANDLE_CLOSE_SOURCE ))
+            return -ENOSPC;
+        dest->handle.numFds = 0;
+        dest->handle.numInts = 1;
+        dest->handle.data[0] = HandleToLong( ret );
+        return 0;
+    }
+    if (is_client_in_process())  /* transfer the actual handle pointer */
+    {
+        dest->handle.numFds = 0;
+        dest->handle.numInts = sizeof(src) / sizeof(int);
+        memcpy( dest->handle.data, &src, sizeof(src) );
+        return 0;
+    }
+    if (size > sizeof(*dest)) return -ENOSPC;
+    memcpy( dest, src, size );
+    /* transfer file descriptors to the client process */
+    for (i = 0; i < dest->handle.numFds; i++)
+        dest->handle.data[i] = duplicate_fd( client, src->data[i] );
+    return 0;
+}
+
+static native_handle_t *unmap_native_handle( const native_handle_t *src )
+{
+    const size_t size = offsetof( native_handle_t, data[src->numFds + src->numInts] );
+    native_handle_t *dest;
+    int i;
+
+    if (!is_in_desktop_process())
+    {
+        dest = HeapAlloc( GetProcessHeap(), 0, size );
+        memcpy( dest, src, size );
+        /* fetch file descriptors passed from the server process */
+        for (i = 0; i < dest->numFds; i++)
+            wine_server_handle_to_fd( LongToHandle(src->data[i]), GENERIC_READ | SYNCHRONIZE,
+                                      &dest->data[i], NULL );
+    }
+    else memcpy( &dest, src->data, sizeof(dest) );
+    return dest;
+}
+
+static void close_native_handle( native_handle_t *handle )
+{
+    int i;
+
+    for (i = 0; i < handle->numFds; i++) close( handle->data[i] );
+    HeapFree( GetProcessHeap(), 0, handle );
+}
+
+HWND get_capture_window(void)
+{
+    return capture_window;
+}
+
+/* insert a buffer index at the head of the LRU list */
+static void insert_buffer_lru( struct native_win_data *win, int index )
+{
+    unsigned int i;
+
+    for (i = 0; i < NB_CACHED_BUFFERS; i++)
+    {
+        if (win->buffer_lru[i] == index) break;
+        if (win->buffer_lru[i] == -1) break;
+    }
+
+    assert( i < NB_CACHED_BUFFERS );
+    memmove( win->buffer_lru + 1, win->buffer_lru, i * sizeof(win->buffer_lru[0]) );
+    win->buffer_lru[0] = index;
+}
+
+static int register_buffer( struct native_win_data *win, struct ANativeWindowBuffer *buffer,
+                            HANDLE *mapping, int *is_new )
+{
+    unsigned int i;
+
+    *is_new = 0;
+    for (i = 0; i < NB_CACHED_BUFFERS; i++)
+    {
+        if (win->buffers[i] == buffer) goto done;
+        if (!win->buffers[i]) break;
+    }
+
+    if (i == NB_CACHED_BUFFERS)
+    {
+        /* reuse the least recently used buffer */
+        i = win->buffer_lru[NB_CACHED_BUFFERS - 1];
+        assert( i < NB_CACHED_BUFFERS );
+
+        TRACE( "%p %p evicting buffer %p id %d from cache\n",
+               win->hwnd, win->parent, win->buffers[i], i );
+        win->buffers[i]->common.decRef( &win->buffers[i]->common );
+        if (win->mappings[i]) UnmapViewOfFile( win->mappings[i] );
+    }
+
+    win->buffers[i] = buffer;
+    win->mappings[i] = NULL;
+
+    if (mapping)
+    {
+        *mapping = CreateFileMappingW( INVALID_HANDLE_VALUE, NULL, PAGE_READWRITE, 0,
+                                       buffer->stride * buffer->height * 4, NULL );
+        win->mappings[i] = MapViewOfFile( *mapping, FILE_MAP_READ, 0, 0, 0 );
+    }
+    buffer->common.incRef( &buffer->common );
+    *is_new = 1;
+    TRACE( "%p %p %p -> %d\n", win->hwnd, win->parent, buffer, i );
+
+done:
+    insert_buffer_lru( win, i );
+    return i;
+}
+
+static struct ANativeWindowBuffer *get_registered_buffer( struct native_win_data *win, int id )
+{
+    if (id < 0 || id >= NB_CACHED_BUFFERS || !win->buffers[id])
+    {
+        ERR( "unknown buffer %d for %p %p\n", id, win->hwnd, win->parent );
+        return NULL;
+    }
+    return win->buffers[id];
+}
+
+static void release_native_window( struct native_win_data *data )
+{
+    unsigned int i;
+
+    if (data->parent) pANativeWindow_release( data->parent );
+    for (i = 0; i < NB_CACHED_BUFFERS; i++)
+    {
+        if (data->buffers[i]) data->buffers[i]->common.decRef( &data->buffers[i]->common );
+        if (data->mappings[i]) UnmapViewOfFile( data->mappings[i] );
+        data->buffer_lru[i] = -1;
+    }
+    memset( data->buffers, 0, sizeof(data->buffers) );
+    memset( data->mappings, 0, sizeof(data->mappings) );
+}
+
+static void free_native_win_data( struct native_win_data *data )
+{
+    unsigned int idx = LOWORD( data->hwnd );
+
+    InterlockedCompareExchangePointer( (void **)&capture_window, 0, data->hwnd );
+    release_native_window( data );
+    HeapFree( GetProcessHeap(), 0, data );
+    data_map[idx] = NULL;
+}
+
+static struct native_win_data *create_native_win_data( HWND hwnd )
+{
+    unsigned int i, idx = LOWORD( hwnd );
+    struct native_win_data *data = data_map[idx];
+
+    if (data)
+    {
+        WARN( "data for %p not freed correctly\n", data->hwnd );
+        free_native_win_data( data );
+    }
+    if (!(data = HeapAlloc( GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(*data) ))) return NULL;
+    data->hwnd = hwnd;
+    data->buffer_format = PF_BGRA_8888;
+    data_map[idx] = data;
+    for (i = 0; i < NB_CACHED_BUFFERS; i++) data->buffer_lru[i] = -1;
+    return data;
+}
+
+static void CALLBACK register_native_window_callback( ULONG_PTR arg1, ULONG_PTR arg2, ULONG_PTR arg3 )
+{
+    HWND hwnd = (HWND)arg1;
+    struct ANativeWindow *win = (struct ANativeWindow *)arg2;
+    struct native_win_data *data = get_native_win_data( hwnd );
+
+    if (!data || data->parent == win)
+    {
+        if (win) pANativeWindow_release( win );
+        return;
+    }
+
+    release_native_window( data );
+    data->parent = win;
+    if (win)
+    {
+        wrap_java_call();
+        win->perform( win, NATIVE_WINDOW_SET_BUFFERS_FORMAT, data->buffer_format );
+        /* switch to asynchronous mode to avoid buffer queue deadlocks */
+        win->setSwapInterval( win, 0 );
+        unwrap_java_call();
+        PostMessageW( hwnd, WM_ANDROID_REFRESH, 0, 0 );
+    }
+    TRACE( "%p -> %p win %p\n", hwnd, data, win );
+    process_pending_irp( hwnd );
+}
+
+/* register a native window received from the Java side for use in ioctls */
+void register_native_window( HWND hwnd, struct ANativeWindow *win )
+{
+    NtQueueApcThread( thread, register_native_window_callback, (ULONG_PTR)hwnd, (ULONG_PTR)win, 0 );
+}
+
+static NTSTATUS android_error_to_status( int err )
+{
+    switch (err)
+    {
+    case 0:            return STATUS_SUCCESS;
+    case -ENOMEM:      return STATUS_NO_MEMORY;
+    case -ENOSYS:      return STATUS_NOT_SUPPORTED;
+    case -EINVAL:      return STATUS_INVALID_PARAMETER;
+    case -ENOENT:      return STATUS_INVALID_HANDLE;
+    case -EPERM:       return STATUS_ACCESS_DENIED;
+    case -ENODEV:      return STATUS_NO_SUCH_DEVICE;
+    case -EEXIST:      return STATUS_DUPLICATE_NAME;
+    case -EPIPE:       return STATUS_PIPE_DISCONNECTED;
+    case -ENODATA:     return STATUS_NO_MORE_FILES;
+    case -ETIMEDOUT:   return STATUS_IO_TIMEOUT;
+    case -EBADMSG:     return STATUS_INVALID_DEVICE_REQUEST;
+    case -EWOULDBLOCK: return STATUS_DEVICE_NOT_READY;
+    default:
+        FIXME( "unmapped error %d\n", err );
+        return STATUS_UNSUCCESSFUL;
+    }
+}
+
+static int status_to_android_error( NTSTATUS status )
+{
+    switch (status)
+    {
+    case STATUS_SUCCESS:                return 0;
+    case STATUS_NO_MEMORY:              return -ENOMEM;
+    case STATUS_NOT_SUPPORTED:          return -ENOSYS;
+    case STATUS_INVALID_PARAMETER:      return -EINVAL;
+    case STATUS_BUFFER_OVERFLOW:        return -EINVAL;
+    case STATUS_INVALID_HANDLE:         return -ENOENT;
+    case STATUS_ACCESS_DENIED:          return -EPERM;
+    case STATUS_NO_SUCH_DEVICE:         return -ENODEV;
+    case STATUS_DUPLICATE_NAME:         return -EEXIST;
+    case STATUS_PIPE_DISCONNECTED:      return -EPIPE;
+    case STATUS_NO_MORE_FILES:          return -ENODATA;
+    case STATUS_IO_TIMEOUT:             return -ETIMEDOUT;
+    case STATUS_INVALID_DEVICE_REQUEST: return -EBADMSG;
+    case STATUS_DEVICE_NOT_READY:       return -EWOULDBLOCK;
+    default:
+        FIXME( "unmapped status %08x\n", status );
+        return -EINVAL;
+    }
+}
+
+static jobject load_java_method( jmethodID *method, const char *name, const char *args )
+{
+    jobject object = wine_get_java_object();
+
+    if (!*method)
+    {
+        jclass class;
+
+        wrap_java_call();
+        class = (*jni_env)->GetObjectClass( jni_env, object );
+        *method = (*jni_env)->GetMethodID( jni_env, class, name, args );
+        unwrap_java_call();
+        if (!*method)
+        {
+            FIXME( "method %s not found\n", name );
+            return NULL;
+        }
+    }
+    return object;
+}
+
+static NTSTATUS dequeueBuffer_ioctl( void *data, DWORD in_size, DWORD out_size, ULONG_PTR *ret_size )
+{
+    struct ANativeWindow *parent;
+    struct ioctl_android_dequeueBuffer *res = data;
+    struct native_win_data *win_data;
+    struct ANativeWindowBuffer *buffer;
+    int fence, ret, is_new;
+
+    if (out_size < sizeof( *res )) return STATUS_BUFFER_OVERFLOW;
+
+    if (in_size < offsetof( struct ioctl_android_dequeueBuffer, native_handle ))
+        return STATUS_INVALID_PARAMETER;
+
+    if (!(win_data = get_native_win_data( LongToHandle(res->hdr.hwnd) ))) return STATUS_INVALID_HANDLE;
+    if (!(parent = win_data->parent)) return STATUS_PENDING;
+
+    *ret_size = offsetof( struct ioctl_android_dequeueBuffer, native_handle );
+    wrap_java_call();
+    ret = parent->dequeueBuffer( parent, &buffer, &fence );
+    unwrap_java_call();
+    if (!ret)
+    {
+        HANDLE mapping = 0;
+
+        TRACE( "%08x got buffer %p fence %d\n", res->hdr.hwnd, buffer, fence );
+        res->width  = buffer->width;
+        res->height = buffer->height;
+        res->stride = buffer->stride;
+        res->format = buffer->format;
+        res->usage  = buffer->usage;
+        res->buffer_id = register_buffer( win_data, buffer, res->win32 ? &mapping : NULL, &is_new );
+        if (is_new)
+        {
+            HANDLE process = OpenProcess( PROCESS_DUP_HANDLE, FALSE, current_client_id() );
+            map_native_handle( &res->native_handle, buffer->handle, mapping, process );
+            CloseHandle( process );
+            *ret_size = sizeof( *res );
+        }
+        wait_fence_and_close( fence );
+        return STATUS_SUCCESS;
+    }
+    ERR( "%08x failed %d\n", res->hdr.hwnd, ret );
+    return android_error_to_status( ret );
+}
+
+static NTSTATUS cancelBuffer_ioctl( void *data, DWORD in_size, DWORD out_size, ULONG_PTR *ret_size )
+{
+    struct ioctl_android_cancelBuffer *res = data;
+    struct ANativeWindow *parent;
+    struct ANativeWindowBuffer *buffer;
+    struct native_win_data *win_data;
+    int ret;
+
+    if (in_size < sizeof(*res)) return STATUS_INVALID_PARAMETER;
+
+    if (!(win_data = get_native_win_data( LongToHandle(res->hdr.hwnd) ))) return STATUS_INVALID_HANDLE;
+    if (!(parent = win_data->parent)) return STATUS_PENDING;
+
+    if (!(buffer = get_registered_buffer( win_data, res->buffer_id ))) return STATUS_INVALID_HANDLE;
+
+    TRACE( "%08x buffer %p\n", res->hdr.hwnd, buffer );
+    wrap_java_call();
+    ret = parent->cancelBuffer( parent, buffer, -1 );
+    unwrap_java_call();
+    return android_error_to_status( ret );
+}
+
+static NTSTATUS queueBuffer_ioctl( void *data, DWORD in_size, DWORD out_size, ULONG_PTR *ret_size )
+{
+    struct ioctl_android_queueBuffer *res = data;
+    struct ANativeWindow *parent;
+    struct ANativeWindowBuffer *buffer;
+    struct native_win_data *win_data;
+    int ret;
+
+    if (in_size < sizeof(*res)) return STATUS_INVALID_PARAMETER;
+
+    if (!(win_data = get_native_win_data( LongToHandle(res->hdr.hwnd) ))) return STATUS_INVALID_HANDLE;
+    if (!(parent = win_data->parent)) return STATUS_PENDING;
+
+    if (!(buffer = get_registered_buffer( win_data, res->buffer_id ))) return STATUS_INVALID_HANDLE;
+
+    TRACE( "%08x buffer %p mapping %p\n", res->hdr.hwnd, buffer, win_data->mappings[res->buffer_id] );
+    if (win_data->mappings[res->buffer_id])
+    {
+        void *bits;
+        int ret = gralloc_module->lock( gralloc_module, buffer->handle,
+                                        GRALLOC_USAGE_SW_READ_OFTEN | GRALLOC_USAGE_SW_WRITE_OFTEN,
+                                        0, 0, buffer->width, buffer->height, &bits );
+        if (ret) return android_error_to_status( ret );
+        memcpy( bits, win_data->mappings[res->buffer_id], buffer->stride * buffer->height * 4 );
+        gralloc_module->unlock( gralloc_module, buffer->handle );
+    }
+    wrap_java_call();
+    ret = parent->queueBuffer( parent, buffer, -1 );
+    unwrap_java_call();
+    return android_error_to_status( ret );
+}
+
+static NTSTATUS setSwapInterval_ioctl( void *data, DWORD in_size, DWORD out_size, ULONG_PTR *ret_size )
+{
+    struct ioctl_android_set_swap_interval *res = data;
+    struct ANativeWindow *parent;
+    struct native_win_data *win_data;
+    int ret;
+
+    if (in_size < sizeof(*res)) return STATUS_INVALID_PARAMETER;
+
+    if (!(win_data = get_native_win_data( LongToHandle(res->hdr.hwnd) ))) return STATUS_INVALID_HANDLE;
+    if (!(parent = win_data->parent)) return STATUS_PENDING;
+
+    wrap_java_call();
+    ret = parent->setSwapInterval( parent, res->interval );
+    unwrap_java_call();
+    return ret;
+}
+
+static NTSTATUS query_ioctl( void *data, DWORD in_size, DWORD out_size, ULONG_PTR *ret_size )
+{
+    struct ioctl_android_query *res = data;
+    struct ANativeWindow *parent;
+    struct native_win_data *win_data;
+    int ret;
+
+    if (in_size < sizeof(*res)) return STATUS_INVALID_PARAMETER;
+    if (out_size < sizeof(*res)) return STATUS_BUFFER_OVERFLOW;
+
+    if (!(win_data = get_native_win_data( LongToHandle(res->hdr.hwnd) ))) return STATUS_INVALID_HANDLE;
+    if (!(parent = win_data->parent)) return STATUS_PENDING;
+
+    *ret_size = sizeof( *res );
+    wrap_java_call();
+    ret = parent->query( parent, res->what, &res->value );
+    unwrap_java_call();
+    return android_error_to_status( ret );
+}
+
+static NTSTATUS start_opengl( int hwnd )
+{
+    static jmethodID method;
+    jobject object;
+    struct native_win_data *win_data;
+
+    if (!(win_data = get_native_win_data( LongToHandle(hwnd) ))) return STATUS_INVALID_HANDLE;
+
+    TRACE( "hwnd %08x\n", hwnd );
+
+    if (!(object = load_java_method( &method, "startOpenGL", "(I)V" ))) return STATUS_NOT_SUPPORTED;
+
+    wrap_java_call();
+    (*jni_env)->CallVoidMethod( jni_env, object, method, hwnd );
+    unwrap_java_call();
+    return STATUS_SUCCESS;
+}
+
+static NTSTATUS perform_ioctl( void *data, DWORD in_size, DWORD out_size, ULONG_PTR *ret_size )
+{
+    struct ioctl_android_perform *res = data;
+    struct ANativeWindow *parent;
+    struct native_win_data *win_data;
+    int ret = -ENOENT;
+
+    if (in_size < sizeof(*res)) return STATUS_INVALID_PARAMETER;
+
+    if (!(win_data = get_native_win_data( LongToHandle(res->hdr.hwnd) ))) return STATUS_INVALID_HANDLE;
+    if (res->operation == NATIVE_WINDOW_API_CONNECT) start_opengl( res->hdr.hwnd );
+    if (!(parent = win_data->parent)) return STATUS_PENDING;
+
+    switch (res->operation)
+    {
+    case NATIVE_WINDOW_SET_BUFFERS_FORMAT:
+        wrap_java_call();
+        ret = parent->perform( parent, res->operation, res->args[0] );
+        unwrap_java_call();
+        if (!ret) win_data->buffer_format = res->args[0];
+        break;
+    case NATIVE_WINDOW_SET_USAGE:
+    case NATIVE_WINDOW_SET_BUFFERS_TRANSFORM:
+    case NATIVE_WINDOW_SET_SCALING_MODE:
+    case NATIVE_WINDOW_API_CONNECT:
+    case NATIVE_WINDOW_API_DISCONNECT:
+        wrap_java_call();
+        ret = parent->perform( parent, res->operation, res->args[0] );
+        unwrap_java_call();
+        break;
+    case NATIVE_WINDOW_SET_BUFFER_COUNT:
+        wrap_java_call();
+        ret = parent->perform( parent, res->operation, (size_t)res->args[0] );
+        unwrap_java_call();
+        break;
+    case NATIVE_WINDOW_SET_BUFFERS_DIMENSIONS:
+    case NATIVE_WINDOW_SET_BUFFERS_USER_DIMENSIONS:
+        wrap_java_call();
+        ret = parent->perform( parent, res->operation, res->args[0], res->args[1] );
+        unwrap_java_call();
+        break;
+    case NATIVE_WINDOW_SET_BUFFERS_GEOMETRY:
+        wrap_java_call();
+        ret = parent->perform( parent, res->operation, res->args[0], res->args[1], res->args[2] );
+        unwrap_java_call();
+        break;
+    case NATIVE_WINDOW_SET_BUFFERS_TIMESTAMP:
+        wrap_java_call();
+        ret = parent->perform( parent, res->operation, res->args[0] | ((int64_t)res->args[1] << 32) );
+        unwrap_java_call();
+        break;
+    case NATIVE_WINDOW_CONNECT:
+    case NATIVE_WINDOW_DISCONNECT:
+    case NATIVE_WINDOW_UNLOCK_AND_POST:
+        wrap_java_call();
+        ret = parent->perform( parent, res->operation );
+        unwrap_java_call();
+        break;
+    case NATIVE_WINDOW_SET_CROP:
+    {
+        android_native_rect_t rect;
+        rect.left   = res->args[0];
+        rect.top    = res->args[1];
+        rect.right  = res->args[2];
+        rect.bottom = res->args[3];
+        wrap_java_call();
+        ret = parent->perform( parent, res->operation, &rect );
+        unwrap_java_call();
+        break;
+    }
+    case NATIVE_WINDOW_LOCK:
+    default:
+        FIXME( "unsupported perform op %d\n", res->operation );
+        break;
+    }
+    return android_error_to_status( ret );
+}
+
+static void create_desktop_window( HWND hwnd )
+{
+    static jmethodID method;
+    jobject object;
+
+    if (!(object = load_java_method( &method, "createDesktopWindow", "(I)V" ))) return;
+
+    wrap_java_call();
+    (*jni_env)->CallVoidMethod( jni_env, object, method, HandleToLong( hwnd ));
+    unwrap_java_call();
+}
+
+static NTSTATUS createWindow_ioctl( void *data, DWORD in_size, DWORD out_size, ULONG_PTR *ret_size )
+{
+    static jmethodID method;
+    jobject object;
+    struct ioctl_android_create_window *res = data;
+    struct native_win_data *win_data;
+    jstring str;
+    char modpath[MAX_PATH], *modname;
+    HANDLE process = OpenProcess( PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, FALSE, current_client_id() );
+    DWORD rc;
+
+    if (in_size < sizeof(*res)) return STATUS_INVALID_PARAMETER;
+
+    if (!(win_data = create_native_win_data( LongToHandle(res->hdr.hwnd) ))) return STATUS_NO_MEMORY;
+
+    if ((rc = GetModuleFileNameExA( process, NULL, modpath, MAX_PATH )))
+    {
+        modname = strrchr( modpath, '\\' );
+        modname = modname ? modname + 1 : modpath;
+    }
+    else
+    {
+        ERR( "Failed to get client executable name: %d\n", GetLastError() );
+        modname = "none";
+    }
+
+    TRACE( "hwnd %08x modname %s\n", res->hdr.hwnd, modname );
+
+    if (!(object = load_java_method( &method, "createWindow", "(ILjava/lang/String;)V" ))) return STATUS_NOT_SUPPORTED;
+
+    wrap_java_call();
+    str = (*jni_env)->NewStringUTF( jni_env, modname );
+    (*jni_env)->CallVoidMethod( jni_env, object, method, res->hdr.hwnd, str );
+    (*jni_env)->DeleteLocalRef( jni_env, str );
+    unwrap_java_call();
+    CloseHandle( process );
+    return STATUS_SUCCESS;
+}
+
+static NTSTATUS destroyWindow_ioctl( void *data, DWORD in_size, DWORD out_size, ULONG_PTR *ret_size )
+{
+    static jmethodID method;
+    jobject object;
+    struct ioctl_android_destroy_window *res = data;
+    struct native_win_data *win_data;
+
+    if (in_size < sizeof(*res)) return STATUS_INVALID_PARAMETER;
+
+    if (!(win_data = get_native_win_data( LongToHandle(res->hdr.hwnd) ))) return STATUS_INVALID_HANDLE;
+
+    TRACE( "hwnd %08x\n", res->hdr.hwnd );
+
+    if (!(object = load_java_method( &method, "destroyWindow", "(I)V" ))) return STATUS_NOT_SUPPORTED;
+
+    wrap_java_call();
+    (*jni_env)->CallVoidMethod( jni_env, object, method, res->hdr.hwnd );
+    unwrap_java_call();
+    free_native_win_data( win_data );
+    process_pending_irp( LongToHandle(res->hdr.hwnd) );
+    return STATUS_SUCCESS;
+}
+
+static NTSTATUS windowPosChanged_ioctl( void *data, DWORD in_size, DWORD out_size, ULONG_PTR *ret_size )
+{
+    static jmethodID method;
+    jobject object;
+    struct ioctl_android_window_pos_changed *res = data;
+    struct native_win_data *win_data;
+
+    if (in_size < sizeof(*res)) return STATUS_INVALID_PARAMETER;
+
+    if (!(win_data = get_native_win_data( LongToHandle(res->hdr.hwnd) ))) return STATUS_INVALID_HANDLE;
+
+    TRACE( "hwnd %08x pos %d,%d-%d,%d style %08x flags %08x after %08x owner %08x\n",
+           res->hdr.hwnd, res->left, res->top, res->right, res->bottom,
+           res->style, res->flags, res->after, res->owner );
+
+    if (!(object = load_java_method( &method, "windowPosChanged", "(IIIIIIIII)V" )))
+        return STATUS_NOT_SUPPORTED;
+
+    wrap_java_call();
+    (*jni_env)->CallVoidMethod( jni_env, object, method, res->hdr.hwnd, res->flags, res->after, res->owner,
+                                res->style, res->left, res->top, res->right, res->bottom );
+    unwrap_java_call();
+    return STATUS_SUCCESS;
+}
+
+static NTSTATUS setWindowFocus_ioctl( void *data, DWORD in_size, DWORD out_size, ULONG_PTR *ret_size )
+{
+    static jmethodID method;
+    jobject object;
+    struct ioctl_android_set_window_focus *res = data;
+    struct native_win_data *win_data;
+
+    if (in_size < sizeof(*res)) return STATUS_INVALID_PARAMETER;
+
+    if (!(win_data = get_native_win_data( LongToHandle(res->hdr.hwnd) ))) return STATUS_INVALID_HANDLE;
+
+    TRACE( "hwnd %08x\n", res->hdr.hwnd );
+
+    if (!(object = load_java_method( &method, "setFocus", "(I)V" ))) return STATUS_NOT_SUPPORTED;
+
+    wrap_java_call();
+    (*jni_env)->CallVoidMethod( jni_env, object, method, res->hdr.hwnd );
+    unwrap_java_call();
+    return STATUS_SUCCESS;
+}
+
+static NTSTATUS setWindowText_ioctl( void *data, DWORD in_size, DWORD out_size, ULONG_PTR *ret_size )
+{
+    static jmethodID method;
+    jobject object;
+    jstring str;
+    int len;
+    struct ioctl_android_set_window_text *res = data;
+    struct native_win_data *win_data;
+
+    len = in_size - offsetof( struct ioctl_android_set_window_text, text );
+    if (len < 0 || (len % sizeof(WCHAR))) return STATUS_INVALID_PARAMETER;
+    len /= sizeof(WCHAR);
+
+    if (!(win_data = get_native_win_data( LongToHandle(res->hdr.hwnd) ))) return STATUS_INVALID_HANDLE;
+
+    TRACE( "hwnd %08x text %s\n", res->hdr.hwnd, wine_dbgstr_wn( res->text, len ));
+
+    if (!(object = load_java_method( &method, "setWindowText", "(ILjava/lang/String;)V" )))
+        return STATUS_NOT_SUPPORTED;
+
+    wrap_java_call();
+    str = (*jni_env)->NewString( jni_env, res->text, len );
+    (*jni_env)->CallVoidMethod( jni_env, object, method, res->hdr.hwnd, str );
+    (*jni_env)->DeleteLocalRef( jni_env, str );
+    unwrap_java_call();
+    return STATUS_SUCCESS;
+}
+
+static NTSTATUS setWindowIcon_ioctl( void *data, DWORD in_size, DWORD out_size, ULONG_PTR *ret_size )
+{
+    static jmethodID method;
+    jobject object;
+    int size;
+    struct ioctl_android_set_window_icon *res = data;
+    struct native_win_data *win_data;
+
+    if (in_size < offsetof( struct ioctl_android_set_window_icon, bits )) return STATUS_INVALID_PARAMETER;
+
+    if (!(win_data = get_native_win_data( LongToHandle(res->hdr.hwnd) ))) return STATUS_INVALID_HANDLE;
+
+    if (res->width < 0 || res->height < 0 || res->width > 256 || res->height > 256)
+        return STATUS_INVALID_PARAMETER;
+
+    size = res->width * res->height;
+    if (in_size != offsetof( struct ioctl_android_set_window_icon, bits[size] ))
+        return STATUS_INVALID_PARAMETER;
+
+    TRACE( "hwnd %08x size %d\n", res->hdr.hwnd, size );
+
+    if (!(object = load_java_method( &method, "setWindowIcon", "(III[I)V" )))
+        return STATUS_NOT_SUPPORTED;
+
+    wrap_java_call();
+
+    if (size)
+    {
+        jintArray array = (*jni_env)->NewIntArray( jni_env, size );
+        (*jni_env)->SetIntArrayRegion( jni_env, array, 0, size, (jint *)res->bits );
+        (*jni_env)->CallVoidMethod( jni_env, object, method, res->hdr.hwnd, res->width, res->height, array );
+        (*jni_env)->DeleteLocalRef( jni_env, array );
+    }
+    else (*jni_env)->CallVoidMethod( jni_env, object, method, res->hdr.hwnd, 0, 0, 0 );
+
+    unwrap_java_call();
+
+    return STATUS_SUCCESS;
+}
+
+static NTSTATUS setWindowRgn_ioctl( void *data, DWORD in_size, DWORD out_size, ULONG_PTR *ret_size )
+{
+    static jmethodID method;
+    jobject object;
+    struct ioctl_android_set_window_rgn *res = data;
+    struct native_win_data *win_data;
+
+    if (in_size < sizeof(*res)) return STATUS_INVALID_PARAMETER;
+
+    if (!(win_data = get_native_win_data( LongToHandle(res->hdr.hwnd) ))) return STATUS_INVALID_HANDLE;
+
+    TRACE( "hwnd %08x region %d\n", res->hdr.hwnd, res->has_region );
+
+    if (!(object = load_java_method( &method, "setWindowRgn", "(II)V" ))) return STATUS_NOT_SUPPORTED;
+
+    wrap_java_call();
+    (*jni_env)->CallVoidMethod( jni_env, object, method, res->hdr.hwnd, res->has_region );
+    unwrap_java_call();
+    return STATUS_SUCCESS;
+}
+
+static NTSTATUS setWindowLayered_ioctl( void *data, DWORD in_size, DWORD out_size, ULONG_PTR *ret_size )
+{
+    static jmethodID method;
+    jobject object;
+    struct ioctl_android_set_window_layered *res = data;
+    struct native_win_data *win_data;
+
+    if (in_size < sizeof(*res)) return STATUS_INVALID_PARAMETER;
+
+    if (!(win_data = get_native_win_data( LongToHandle(res->hdr.hwnd) ))) return STATUS_INVALID_HANDLE;
+
+    TRACE( "hwnd %08x key %08x alpha %d\n", res->hdr.hwnd, res->key, res->alpha );
+
+    if (!(object = load_java_method( &method, "setWindowLayered", "(III)V" ))) return STATUS_NOT_SUPPORTED;
+
+    wrap_java_call();
+    (*jni_env)->CallVoidMethod( jni_env, object, method, res->hdr.hwnd, res->key, res->alpha );
+    unwrap_java_call();
+    return STATUS_SUCCESS;
+}
+
+static NTSTATUS setSurfaceAlpha_ioctl( void *data, DWORD in_size, DWORD out_size, ULONG_PTR *ret_size )
+{
+    static jmethodID method;
+    jobject object;
+    struct ioctl_android_set_surface_alpha *res = data;
+    struct native_win_data *win_data;
+
+    if (in_size < sizeof(*res)) return STATUS_INVALID_PARAMETER;
+
+    if (!(win_data = get_native_win_data( LongToHandle(res->hdr.hwnd) ))) return STATUS_INVALID_HANDLE;
+
+    TRACE( "hwnd %08x has alpha %d\n", res->hdr.hwnd, res->has_alpha );
+
+    if (!(object = load_java_method( &method, "setWindowSurface", "(IZ)V" ))) return STATUS_NOT_SUPPORTED;
+
+    wrap_java_call();
+    (*jni_env)->CallVoidMethod( jni_env, object, method, res->hdr.hwnd, res->has_alpha );
+    unwrap_java_call();
+    return STATUS_SUCCESS;
+}
+
+static NTSTATUS setCapture_ioctl( void *data, DWORD in_size, DWORD out_size, ULONG_PTR *ret_size )
+{
+    struct ioctl_android_set_capture *res = data;
+
+    if (in_size < sizeof(*res)) return STATUS_INVALID_PARAMETER;
+
+    if (res->hdr.hwnd && !get_native_win_data( LongToHandle(res->hdr.hwnd) )) return STATUS_INVALID_HANDLE;
+
+    TRACE( "hwnd %08x\n", res->hdr.hwnd );
+
+    InterlockedExchangePointer( (void **)&capture_window, LongToHandle( res->hdr.hwnd ));
+    return STATUS_SUCCESS;
+}
+
+
+static NTSTATUS gamepad_query( void *data, DWORD in_size, DWORD out_size, ULONG_PTR *ret_size )
+{
+    struct ioctl_android_gamepad_value *res = data;
+
+    if (res->device > di_controllers) return STATUS_INVALID_PARAMETER;
+    if (in_size < sizeof(*res)) return STATUS_INVALID_PARAMETER;
+    if (out_size < sizeof(*res)) return STATUS_BUFFER_OVERFLOW;
+
+    switch (res->index) {
+    case 0:  /* Count */
+        res->data.count =  di_controllers;
+        break;
+    case 1: /* name */
+        lstrcpynW(res->data.name, di_names[res->device], DI_NAME_LENGTH);
+        break;
+    case 2: /* values*/
+        memcpy(res->data.value, di_value[res->device], sizeof(res->data.value));
+        break;
+    }
+    *ret_size = sizeof(*res);
+    return STATUS_SUCCESS;
+}
+
+static NTSTATUS imeText_ioctl( void *data, DWORD in_size, DWORD out_size, ULONG_PTR *ret_size )
+{
+    WORD length;
+    struct ioctl_android_ime_text *res = data;
+
+    if (in_size < sizeof(*res)) return STATUS_INVALID_PARAMETER;
+    if (out_size < sizeof(*res) + ((res->length-1) * sizeof(WCHAR))) return STATUS_BUFFER_OVERFLOW;
+    if (res->target < 0 || res->target > java_ime_count) return STATUS_INVALID_PARAMETER;
+    if (!java_ime_text[res->target]) return STATUS_INVALID_PARAMETER;
+
+    length = min(java_ime_text[res->target]->length, res->length);
+    res->length = java_ime_text[res->target]->length;
+    lstrcpynW(res->text, java_ime_text[res->target]->text, length);
+    res->cursor = java_ime_text[res->target]->cursor_pos;
+
+    *ret_size = sizeof(*res) + (length * sizeof(WCHAR));
+    return STATUS_SUCCESS;
+}
+
+static NTSTATUS imeFinish_ioctl( void *data, DWORD in_size, DWORD out_size, ULONG_PTR *ret_size )
+{
+    struct ioctl_android_ime_finish *res = data;
+
+    if (in_size < sizeof(*res)) return STATUS_INVALID_PARAMETER;
+    if (res->target < 0 || res->target > java_ime_count) return STATUS_INVALID_PARAMETER;
+
+    if (java_ime_text[res->target])
+    {
+        if (java_ime_text[res->target]->text)
+            free(java_ime_text[res->target]->text);
+        free(java_ime_text[res->target]);
+        java_ime_text[res->target] = NULL;
+    }
+    *ret_size = 0;
+    return STATUS_SUCCESS;
+}
+
+static NTSTATUS getClipboardFormats_ioctl( void *data, DWORD in_size, DWORD out_size, ULONG_PTR *ret_size )
+{
+    struct ioctl_android_clipboard_formats *res = data;
+    NTSTATUS stat;
+
+    if (in_size < sizeof(*res)) return STATUS_INVALID_PARAMETER;
+    if (out_size < offsetof( struct ioctl_android_clipboard_formats, formats[res->count] ))
+        return STATUS_BUFFER_OVERFLOW;
+
+    if (res->count == 0)
+    {
+        stat = get_clipboard_formats( &res->seqno, NULL, &res->count );
+        if (stat == STATUS_BUFFER_OVERFLOW)
+            stat = STATUS_SUCCESS;
+        *ret_size = sizeof(*res);
+        return stat;
+    }
+
+    stat = get_clipboard_formats( &res->seqno, res->formats, &res->count );
+    if (stat == STATUS_SUCCESS)
+        *ret_size = offsetof( struct ioctl_android_clipboard_formats, formats[res->count] );
+    return stat;
+}
+
+static NTSTATUS getClipboardData_ioctl( void *data, DWORD in_size, DWORD out_size, ULONG_PTR *ret_size )
+{
+    struct ioctl_android_clipboard_data *res = data;
+    NTSTATUS stat;
+
+    if (in_size < sizeof(*res)) return STATUS_INVALID_PARAMETER;
+    if (out_size < offsetof( struct ioctl_android_clipboard_data, data[res->size] ))
+        return STATUS_BUFFER_OVERFLOW;
+
+    stat = handle_ioctl_get_clipboard_data( res->format, &res->format_present, &res->pending, res->data, &res->size );
+
+    *ret_size = offsetof( struct ioctl_android_clipboard_data, data[res->size] );
+    return stat;
+}
+
+static NTSTATUS renderClipboardData_ioctl( void *data, DWORD in_size, DWORD out_size, ULONG_PTR *ret_size )
+{
+    static jmethodID method;
+    jobject object;
+    struct ioctl_android_render_clipboard_data *res = data;
+
+    if (in_size < sizeof(*res)) return STATUS_INVALID_PARAMETER;
+
+    TRACE( "%i\n", res->android_format );
+
+    if (!(object = load_java_method( &method, "renderClipboardData", "(I)V" ))) return STATUS_NOT_SUPPORTED;
+
+    wrap_java_call();
+    (*jni_env)->CallVoidMethod( jni_env, object, method, res->android_format );
+    unwrap_java_call();
+
+    return STATUS_SUCCESS;
+}
+
+static NTSTATUS emptyClipboard_ioctl( void *data, DWORD in_size, DWORD out_size, ULONG_PTR *ret_size )
+{
+    struct ioctl_android_empty_clipboard *res = data;
+
+    if (in_size < sizeof(*res)) return STATUS_INVALID_PARAMETER;
+
+    handle_ioctl_empty_clipboard();
+
+    return STATUS_SUCCESS;
+}
+
+static NTSTATUS setClipboardData_ioctl( void *data, DWORD in_size, DWORD out_size, ULONG_PTR *ret_size )
+{
+    struct ioctl_android_clipboard_data *res = data;
+
+    if (in_size < offsetof(struct ioctl_android_clipboard_data, data[0]) ||
+        in_size < offsetof(struct ioctl_android_clipboard_data, data[res->size]))
+        return STATUS_INVALID_PARAMETER;
+
+    handle_ioctl_set_clipboard_data( res->format, res->format_present, res->data, res->size );
+
+    return STATUS_SUCCESS;
+}
+
+static void do_acquire_clipboard( void )
+{
+    BOOL formats[1];
+    static const int num_formats = sizeof(formats)/sizeof(formats[0]);
+    static jmethodID method;
+    jobject object;
+    jbooleanArray format_array;
+    jboolean *elements;
+    int i;
+
+    get_exported_formats( formats, num_formats );
+
+    if (!(object = load_java_method( &method, "acquireClipboard", "([Z)V" ))) return;
+
+    wrap_java_call();
+    format_array = (*jni_env)->NewBooleanArray( jni_env, num_formats );
+
+    elements = (*jni_env)->GetBooleanArrayElements( jni_env, format_array, NULL );
+    for (i=0; i<num_formats; i++)
+        elements[i] = formats[i];
+    (*jni_env)->ReleaseBooleanArrayElements( jni_env, format_array, elements, JNI_COMMIT );
+
+    (*jni_env)->CallVoidMethod( jni_env, object, method, format_array );
+    (*jni_env)->DeleteLocalRef( jni_env, format_array );
+    unwrap_java_call();
+}
+
+static NTSTATUS endClipboardUpdate_ioctl( void *data, DWORD in_size, DWORD out_size, ULONG_PTR *ret_size )
+{
+    struct ioctl_android_end_clipboard_update *res = data;
+
+    if (in_size < sizeof(*res)) return STATUS_INVALID_PARAMETER;
+
+    handle_ioctl_end_clipboard_update();
+
+    do_acquire_clipboard();
+
+    return STATUS_SUCCESS;
+}
+
+static NTSTATUS acquireClipboard_ioctl( void *data, DWORD in_size, DWORD out_size, ULONG_PTR *ret_size )
+{
+    struct ioctl_android_end_clipboard_update *res = data;
+
+    if (in_size < sizeof(*res)) return STATUS_INVALID_PARAMETER;
+
+    do_acquire_clipboard();
+
+    return STATUS_SUCCESS;
+}
+
+static NTSTATUS exportClipboardData_ioctl( void *data, DWORD in_size, DWORD out_size, ULONG_PTR *ret_size )
+{
+    struct ioctl_android_clipboard_data *res = data;
+    static jmethodID method;
+    jobject object;
+    jbyteArray data_array;
+    jbyte *elements;
+
+    if (in_size < offsetof(struct ioctl_android_clipboard_data, data[0]) ||
+        in_size < offsetof(struct ioctl_android_clipboard_data, data[res->size]))
+        return STATUS_INVALID_PARAMETER;
+
+    if (!(object = load_java_method( &method, "exportClipboardData", "(I[B)V" )))
+        return STATUS_NOT_SUPPORTED;
+
+    wrap_java_call();
+    data_array = (*jni_env)->NewByteArray( jni_env, res->size );
+
+    elements = (*jni_env)->GetByteArrayElements( jni_env, data_array, NULL );
+    memcpy( elements, res->data, res->size );
+    (*jni_env)->ReleaseByteArrayElements( jni_env, data_array, elements, JNI_COMMIT );
+
+    (*jni_env)->CallVoidMethod( jni_env, object, method, (jint)res->format, data_array );
+    (*jni_env)->DeleteLocalRef( jni_env, data_array );
+    unwrap_java_call();
+
+    return STATUS_SUCCESS;
+}
+
+typedef NTSTATUS (*ioctl_func)( void *in, DWORD in_size, DWORD out_size, ULONG_PTR *ret_size );
+static const ioctl_func ioctl_funcs[] =
+{
+    dequeueBuffer_ioctl,        /* IOCTL_ANDROID_DEQUEUE_BUFFER */
+    queueBuffer_ioctl,          /* IOCTL_ANDROID_QUEUE_BUFFER */
+    cancelBuffer_ioctl,         /* IOCTL_ANDROID_CANCEL_BUFFER */
+    query_ioctl,                /* IOCTL_ANDROID_QUERY */
+    perform_ioctl,              /* IOCTL_ANDROID_PERFORM */
+    setSwapInterval_ioctl,      /* IOCTL_ANDROID_SET_SWAP_INT */
+    createWindow_ioctl,         /* IOCTL_ANDROID_CREATE_WINDOW */
+    destroyWindow_ioctl,        /* IOCTL_ANDROID_DESTROY_WINDOW */
+    windowPosChanged_ioctl,     /* IOCTL_ANDROID_WINDOW_POS_CHANGED */
+    setWindowFocus_ioctl,       /* IOCTL_ANDROID_SET_WINDOW_FOCUS */
+    setWindowText_ioctl,        /* IOCTL_ANDROID_SET_WINDOW_TEXT */
+    setWindowIcon_ioctl,        /* IOCTL_ANDROID_SET_WINDOW_ICON */
+    setWindowRgn_ioctl,         /* IOCTL_ANDROID_SET_WINDOW_RGN */
+    setWindowLayered_ioctl,     /* IOCTL_ANDROID_SET_WINDOW_LAYERED */
+    setSurfaceAlpha_ioctl,      /* IOCTL_ANDROID_SET_SURFACE_ALPHA */
+    setCapture_ioctl,           /* IOCTL_ANDROID_SET_CAPTURE */
+    gamepad_query,              /* IOCTL_ANDROID_GAMEPAD_QUERY */
+    imeText_ioctl,              /* IOCTL_ANDROID_IMETEXT */
+    getClipboardFormats_ioctl,  /* IOCTL_ANDROID_GET_CLIPBOARD_FORMATS */
+    getClipboardData_ioctl,     /* IOCTL_ANDROID_GET_CLIPBOARD_DATA */
+    renderClipboardData_ioctl,  /* IOCTL_ANDROID_RENDER_CLIPBOARD_DATA */
+    emptyClipboard_ioctl,       /* IOCTL_ANDROID_EMPTY_CLIPBOARD */
+    setClipboardData_ioctl,     /* IOCTL_ANDROID_SET_CLIPBOARD_DATA */
+    endClipboardUpdate_ioctl,   /* IOCTL_ANDROID_END_CLIPBOARD_UPDATE */
+    acquireClipboard_ioctl,     /* IOCTL_ANDROID_ACQUIRE_CLIPBOARD */
+    exportClipboardData_ioctl,  /* IOCTL_ANDROID_EXPORT_CLIPBOARD_DATA */
+    imeFinish_ioctl,            /* IOCTL_ANDROID_IMEFINISH */
+};
+
+static NTSTATUS WINAPI ioctl_callback( DEVICE_OBJECT *device, IRP *irp )
+{
+    IO_STACK_LOCATION *irpsp = IoGetCurrentIrpStackLocation( irp );
+
+    if (irpsp->Parameters.DeviceIoControl.IoControlCode >= IOCTL_ANDROID_FIRST &&
+        irpsp->Parameters.DeviceIoControl.IoControlCode <= IOCTL_ANDROID_LAST)
+    {
+        struct ioctl_header *header = irp->AssociatedIrp.SystemBuffer;
+        DWORD in_size = irpsp->Parameters.DeviceIoControl.InputBufferLength;
+        ioctl_func func = ioctl_funcs[(irpsp->Parameters.DeviceIoControl.IoControlCode - IOCTL_ANDROID_FIRST) >> 2];
+
+        if (in_size >= sizeof(*header))
+        {
+            irp->IoStatus.Information = 0;
+            irp->IoStatus.u.Status = func( irp->AssociatedIrp.SystemBuffer, in_size,
+                                           irpsp->Parameters.DeviceIoControl.OutputBufferLength,
+                                           &irp->IoStatus.Information );
+            if (irp->IoStatus.u.Status == STATUS_PENDING)
+            {
+                if (!is_client_in_process())
+                    irp->IoStatus.u.Status = queue_irp( LongToHandle(header->hwnd), irp );
+                else  /* we can't wait in the desktop process */
+                    irp->IoStatus.u.Status = STATUS_DEVICE_NOT_READY;
+            }
+        }
+        else irp->IoStatus.u.Status = STATUS_INVALID_PARAMETER;
+    }
+    else
+    {
+        FIXME( "ioctl %x not supported\n", irpsp->Parameters.DeviceIoControl.IoControlCode );
+        irp->IoStatus.u.Status = STATUS_NOT_SUPPORTED;
+    }
+    if (irp->IoStatus.u.Status != STATUS_PENDING) IoCompleteRequest( irp, IO_NO_INCREMENT );
+    return STATUS_SUCCESS;
+}
+
+static NTSTATUS CALLBACK init_android_driver( DRIVER_OBJECT *driver, UNICODE_STRING *name )
+{
+    driver->MajorFunction[IRP_MJ_DEVICE_CONTROL] = ioctl_callback;
+    driver_obj = driver;
+    return STATUS_SUCCESS;
+}
+
+static DWORD CALLBACK device_thread( void *arg )
+{
+    HANDLE start_event = arg;
+    UNICODE_STRING nameW, linkW;
+    NTSTATUS status;
+    JavaVM *java_vm;
+    DWORD ret;
+
+    TRACE( "starting process %x\n", GetCurrentProcessId() );
+
+    if (!(java_vm = wine_get_java_vm())) return 0;  /* not running under Java */
+
+#ifdef __i386__
+    orig_fs = wine_get_fs();
+    (*java_vm)->AttachCurrentThread( java_vm, &jni_env, 0 );
+    java_fs = wine_get_fs();
+    wine_set_fs( orig_fs );
+    if (java_fs != orig_fs) TRACE( "%%fs changed from %04x to %04x by Java VM\n", orig_fs, java_fs );
+#else
+    (*java_vm)->AttachCurrentThread( java_vm, &jni_env, 0 );
+#endif
+
+    create_desktop_window( GetDesktopWindow() );
+
+    RtlInitUnicodeString( &nameW, driver_nameW );
+    if ((status = IoCreateDriver( &nameW, init_android_driver )))
+    {
+        FIXME( "failed to create driver error %x\n", status );
+        return status;
+    }
+
+    RtlInitUnicodeString( &nameW, device_nameW );
+    RtlInitUnicodeString( &linkW, device_linkW );
+
+    if (!(status = IoCreateDevice( driver_obj, 0, &nameW, 0, 0, FALSE, &ioctl_device )))
+        status = IoCreateSymbolicLink( &linkW, &nameW );
+    if (status)
+    {
+        FIXME( "failed to create device error %x\n", status );
+        return status;
+    }
+
+    stop_event = CreateEventW( NULL, TRUE, FALSE, NULL );
+    SetEvent( start_event );
+
+    ret = wine_ntoskrnl_main_loop( stop_event );
+
+    (*java_vm)->DetachCurrentThread( java_vm );
+    return ret;
+}
+
+void start_android_device(void)
+{
+    HANDLE handles[2];
+
+    handles[0] = CreateEventW( NULL, TRUE, FALSE, NULL );
+    handles[1] = thread = CreateThread( NULL, 0, device_thread, handles[0], 0, NULL );
+    WaitForMultipleObjects( 2, handles, FALSE, INFINITE );
+    CloseHandle( handles[0] );
+}
+
+static int android_ioctl( DWORD code, void *in, DWORD in_size, void *out, DWORD *out_size )
+{
+    static const WCHAR deviceW[] = {'\\','\\','.','\\','W','i','n','e','A','n','d','r','o','i','d',0 };
+    static HANDLE device;
+    IO_STATUS_BLOCK iosb;
+    NTSTATUS status;
+
+    if (!device)
+    {
+        HANDLE file = CreateFileW( deviceW, GENERIC_READ,
+                                   FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, 0, 0 );
+        if (file == INVALID_HANDLE_VALUE) return -ENOENT;
+        if (InterlockedCompareExchangePointer( &device, file, NULL )) CloseHandle( file );
+    }
+
+    status = NtDeviceIoControlFile( device, NULL, NULL, NULL, &iosb, code, in, in_size,
+                                    out, out_size ? *out_size : 0 );
+    if (status == STATUS_FILE_DELETED)
+    {
+        WARN( "parent process is gone\n" );
+        ExitProcess( 1 );
+    }
+    if (out_size) *out_size = iosb.Information;
+    return status_to_android_error( status );
+}
+
+static void win_incRef( struct android_native_base_t *base )
+{
+    struct native_win_wrapper *win = (struct native_win_wrapper *)base;
+    InterlockedIncrement( &win->ref );
+}
+
+static void win_decRef( struct android_native_base_t *base )
+{
+    struct native_win_wrapper *win = (struct native_win_wrapper *)base;
+    InterlockedDecrement( &win->ref );
+}
+
+static void buffer_incRef( struct android_native_base_t *base )
+{
+    struct native_buffer_wrapper *buffer = (struct native_buffer_wrapper *)base;
+    InterlockedIncrement( &buffer->ref );
+}
+
+static void buffer_decRef( struct android_native_base_t *base )
+{
+    struct native_buffer_wrapper *buffer = (struct native_buffer_wrapper *)base;
+
+    if (!InterlockedDecrement( &buffer->ref ))
+    {
+        if (!is_in_desktop_process())
+        {
+            if (gralloc_module) gralloc_module->unregisterBuffer( gralloc_module, buffer->buffer.handle );
+            close_native_handle( (native_handle_t *)buffer->buffer.handle );
+        }
+        if (buffer->bits) UnmapViewOfFile( buffer->bits );
+        HeapFree( GetProcessHeap(), 0, buffer );
+    }
+}
+
+static int dequeueBuffer( struct ANativeWindow *window, struct ANativeWindowBuffer **buffer, int *fence )
+{
+    struct native_win_wrapper *win = (struct native_win_wrapper *)window;
+    struct ioctl_android_dequeueBuffer res;
+    DWORD size = sizeof(res);
+    int ret, use_win32 = !gralloc_module;
+
+    res.hdr.hwnd = HandleToLong( win->hwnd );
+    res.win32 = use_win32;
+    ret = android_ioctl( IOCTL_ANDROID_DEQUEUE_BUFFER,
+                         &res, offsetof( struct ioctl_android_dequeueBuffer, native_handle ),
+                         &res, &size );
+    if (ret) return ret;
+
+    /* if we received the native handle, this is a new buffer */
+    if (size > offsetof( struct ioctl_android_dequeueBuffer, native_handle ))
+    {
+        struct native_buffer_wrapper *buf = HeapAlloc( GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(*buf) );
+
+        buf->buffer.common.magic   = ANDROID_NATIVE_BUFFER_MAGIC;
+        buf->buffer.common.version = sizeof( buf->buffer );
+        buf->buffer.common.incRef  = buffer_incRef;
+        buf->buffer.common.decRef  = buffer_decRef;
+        buf->buffer.width          = res.width;
+        buf->buffer.height         = res.height;
+        buf->buffer.stride         = res.stride;
+        buf->buffer.format         = res.format;
+        buf->buffer.usage          = res.usage;
+        buf->buffer.handle         = unmap_native_handle( &res.native_handle.handle );
+        buf->ref                   = 1;
+        buf->hwnd                  = win->hwnd;
+        buf->buffer_id             = res.buffer_id;
+        if (win->buffers[res.buffer_id])
+            win->buffers[res.buffer_id]->buffer.common.decRef(&win->buffers[res.buffer_id]->buffer.common);
+        win->buffers[res.buffer_id] = buf;
+
+        if (use_win32)
+        {
+            HANDLE mapping = LongToHandle( res.native_handle.handle.data[0] );
+            buf->bits = MapViewOfFile( mapping, FILE_MAP_WRITE, 0, 0, 0 );
+            CloseHandle( mapping );
+        }
+        else if (!is_in_desktop_process())
+        {
+            if ((ret = gralloc_module->registerBuffer( gralloc_module, buf->buffer.handle )) < 0)
+                WARN( "hwnd %p, buffer %p failed to register %d %s\n", win->hwnd, &buf->buffer, ret, strerror(-ret) );
+        }
+    }
+
+    *buffer = &win->buffers[res.buffer_id]->buffer;
+    *fence = -1;
+
+    TRACE( "hwnd %p, buffer %p %dx%d stride %d fmt %d usage %d fence %d\n",
+           win->hwnd, *buffer, res.width, res.height, res.stride, res.format, res.usage, *fence );
+    return 0;
+}
+
+static int cancelBuffer( struct ANativeWindow *window, struct ANativeWindowBuffer *buffer, int fence )
+{
+    struct native_win_wrapper *win = (struct native_win_wrapper *)window;
+    struct native_buffer_wrapper *buf = (struct native_buffer_wrapper *)buffer;
+    struct ioctl_android_cancelBuffer cancel;
+
+    TRACE( "hwnd %p buffer %p %dx%d stride %d fmt %d usage %d fence %d\n",
+           win->hwnd, buffer, buffer->width, buffer->height,
+           buffer->stride, buffer->format, buffer->usage, fence );
+    cancel.buffer_id = buf->buffer_id;
+    cancel.hdr.hwnd = HandleToLong( win->hwnd );
+    wait_fence_and_close( fence );
+    return android_ioctl( IOCTL_ANDROID_CANCEL_BUFFER, &cancel, sizeof(cancel), NULL, NULL );
+}
+
+static int queueBuffer( struct ANativeWindow *window, struct ANativeWindowBuffer *buffer, int fence )
+{
+    struct native_win_wrapper *win = (struct native_win_wrapper *)window;
+    struct native_buffer_wrapper *buf = (struct native_buffer_wrapper *)buffer;
+    struct ioctl_android_queueBuffer queue;
+
+    TRACE( "hwnd %p buffer %p %dx%d stride %d fmt %d usage %d fence %d\n",
+           win->hwnd, buffer, buffer->width, buffer->height,
+           buffer->stride, buffer->format, buffer->usage, fence );
+    queue.buffer_id = buf->buffer_id;
+    queue.hdr.hwnd = HandleToLong( win->hwnd );
+    wait_fence_and_close( fence );
+    return android_ioctl( IOCTL_ANDROID_QUEUE_BUFFER, &queue, sizeof(queue), NULL, NULL );
+}
+
+static int dequeueBuffer_DEPRECATED( struct ANativeWindow *window, struct ANativeWindowBuffer **buffer )
+{
+    int fence, ret = dequeueBuffer( window, buffer, &fence );
+
+    if (!ret) wait_fence_and_close( fence );
+    return ret;
+}
+
+static int cancelBuffer_DEPRECATED( struct ANativeWindow *window, struct ANativeWindowBuffer *buffer )
+{
+    return cancelBuffer( window, buffer, -1 );
+}
+
+static int lockBuffer_DEPRECATED( struct ANativeWindow *window, struct ANativeWindowBuffer *buffer )
+{
+    return 0;  /* nothing to do */
+}
+
+static int queueBuffer_DEPRECATED( struct ANativeWindow *window, struct ANativeWindowBuffer *buffer )
+{
+    return queueBuffer( window, buffer, -1 );
+}
+
+static int setSwapInterval( struct ANativeWindow *window, int interval )
+{
+    struct native_win_wrapper *win = (struct native_win_wrapper *)window;
+    struct ioctl_android_set_swap_interval swap;
+
+    TRACE( "hwnd %p interval %d\n", win->hwnd, interval );
+    swap.hdr.hwnd = HandleToLong( win->hwnd );
+    swap.interval = interval;
+    return android_ioctl( IOCTL_ANDROID_SET_SWAP_INT, &swap, sizeof(swap), NULL, NULL );
+}
+
+static int query( const ANativeWindow *window, int what, int *value )
+{
+    struct native_win_wrapper *win = (struct native_win_wrapper *)window;
+    struct ioctl_android_query query;
+    DWORD size = sizeof( query );
+    int ret;
+
+    query.hdr.hwnd = HandleToLong( win->hwnd );
+    query.what = what;
+    ret = android_ioctl( IOCTL_ANDROID_QUERY, &query, sizeof(query), &query, &size );
+    TRACE( "hwnd %p what %d got %d -> %p\n", win->hwnd, what, query.value, value );
+    if (!ret) *value = query.value;
+    return ret;
+}
+
+static int perform( ANativeWindow *window, int operation, ... )
+{
+    static const char * const names[] =
+    {
+        "SET_USAGE", "CONNECT", "DISCONNECT", "SET_CROP", "SET_BUFFER_COUNT", "SET_BUFFERS_GEOMETRY",
+        "SET_BUFFERS_TRANSFORM", "SET_BUFFERS_TIMESTAMP", "SET_BUFFERS_DIMENSIONS", "SET_BUFFERS_FORMAT",
+        "SET_SCALING_MODE", "LOCK", "UNLOCK_AND_POST", "API_CONNECT", "API_DISCONNECT",
+        "SET_BUFFERS_USER_DIMENSIONS", "SET_POST_TRANSFORM_CROP"
+    };
+
+    struct native_win_wrapper *win = (struct native_win_wrapper *)window;
+    struct ioctl_android_perform perf;
+    va_list args;
+
+    perf.hdr.hwnd  = HandleToLong( win->hwnd );
+    perf.operation = operation;
+    memset( perf.args, 0, sizeof(perf.args) );
+
+    va_start( args, operation );
+    switch (operation)
+    {
+    case NATIVE_WINDOW_SET_USAGE:
+    case NATIVE_WINDOW_SET_BUFFERS_TRANSFORM:
+    case NATIVE_WINDOW_SET_BUFFERS_FORMAT:
+    case NATIVE_WINDOW_SET_SCALING_MODE:
+    case NATIVE_WINDOW_API_CONNECT:
+    case NATIVE_WINDOW_API_DISCONNECT:
+        perf.args[0] = va_arg( args, int );
+        TRACE( "hwnd %p %s arg %d\n", win->hwnd, names[operation], perf.args[0] );
+        break;
+    case NATIVE_WINDOW_SET_BUFFER_COUNT:
+        perf.args[0] = va_arg( args, size_t );
+        TRACE( "hwnd %p %s count %d\n", win->hwnd, names[operation], perf.args[0] );
+        break;
+    case NATIVE_WINDOW_SET_BUFFERS_DIMENSIONS:
+    case NATIVE_WINDOW_SET_BUFFERS_USER_DIMENSIONS:
+        perf.args[0] = va_arg( args, int );
+        perf.args[1] = va_arg( args, int );
+        TRACE( "hwnd %p %s arg %dx%d\n", win->hwnd, names[operation], perf.args[0], perf.args[1] );
+        break;
+    case NATIVE_WINDOW_SET_BUFFERS_GEOMETRY:
+        perf.args[0] = va_arg( args, int );
+        perf.args[1] = va_arg( args, int );
+        perf.args[2] = va_arg( args, int );
+        TRACE( "hwnd %p %s arg %dx%d %d\n", win->hwnd, names[operation],
+               perf.args[0], perf.args[1], perf.args[2] );
+        break;
+    case NATIVE_WINDOW_SET_CROP:
+    {
+        android_native_rect_t *rect = va_arg( args, android_native_rect_t * );
+        perf.args[0] = rect->left;
+        perf.args[1] = rect->top;
+        perf.args[2] = rect->right;
+        perf.args[3] = rect->bottom;
+        TRACE( "hwnd %p %s rect %d,%d-%d,%d\n", win->hwnd, names[operation],
+               perf.args[0], perf.args[1], perf.args[2], perf.args[3] );
+        break;
+    }
+    case NATIVE_WINDOW_SET_BUFFERS_TIMESTAMP:
+    {
+        int64_t timestamp = va_arg( args, int64_t );
+        perf.args[0] = timestamp;
+        perf.args[1] = timestamp >> 32;
+        TRACE( "hwnd %p %s arg %08x%08x\n", win->hwnd, names[operation], perf.args[1], perf.args[0] );
+        break;
+    }
+    case NATIVE_WINDOW_LOCK:
+    {
+        struct ANativeWindowBuffer *buffer;
+        struct ANativeWindow_Buffer *buffer_ret = va_arg( args, ANativeWindow_Buffer * );
+        ARect *bounds = va_arg( args, ARect * );
+        int ret = window->dequeueBuffer_DEPRECATED( window, &buffer );
+        if (!ret)
+        {
+            if (gralloc_module)
+            {
+                if ((ret = gralloc_module->lock( gralloc_module, buffer->handle,
+                                                 GRALLOC_USAGE_SW_READ_OFTEN | GRALLOC_USAGE_SW_WRITE_OFTEN,
+                                                 0, 0, buffer->width, buffer->height, &buffer_ret->bits )))
+                {
+                    WARN( "gralloc->lock %p failed %d %s\n", win->hwnd, ret, strerror(-ret) );
+                    window->cancelBuffer( window, buffer, -1 );
+                }
+            }
+            else
+                buffer_ret->bits = ((struct native_buffer_wrapper *)buffer)->bits;
+        }
+        if (!ret)
+        {
+            buffer_ret->width  = buffer->width;
+            buffer_ret->height = buffer->height;
+            buffer_ret->stride = buffer->stride;
+            buffer_ret->format = buffer->format;
+            win->locked_buffer = buffer;
+            if (bounds)
+            {
+                bounds->left   = 0;
+                bounds->top    = 0;
+                bounds->right  = buffer->width;
+                bounds->bottom = buffer->height;
+            }
+        }
+        va_end( args );
+        TRACE( "hwnd %p %s bits %p ret %d %s\n", win->hwnd, names[operation], buffer_ret->bits, ret, strerror(-ret) );
+        return ret;
+    }
+    case NATIVE_WINDOW_UNLOCK_AND_POST:
+    {
+        int ret = -EINVAL;
+        if (win->locked_buffer)
+        {
+            if (gralloc_module) gralloc_module->unlock( gralloc_module, win->locked_buffer->handle );
+            ret = window->queueBuffer( window, win->locked_buffer, -1 );
+            win->locked_buffer = NULL;
+        }
+        va_end( args );
+        TRACE( "hwnd %p %s ret %d\n", win->hwnd, names[operation], ret );
+        return ret;
+    }
+    case NATIVE_WINDOW_CONNECT:
+    case NATIVE_WINDOW_DISCONNECT:
+        TRACE( "hwnd %p %s\n", win->hwnd, names[operation] );
+        break;
+    case NATIVE_WINDOW_SET_POST_TRANSFORM_CROP:
+    default:
+        FIXME( "unsupported perform hwnd %p op %d %s\n", win->hwnd, operation,
+               operation < sizeof(names)/sizeof(names[0]) ? names[operation] : "???" );
+        break;
+    }
+    va_end( args );
+    return android_ioctl( IOCTL_ANDROID_PERFORM, &perf, sizeof(perf), NULL, NULL );
+}
+
+int ioctl_window_pos_changed( HWND hwnd, const RECT *rect, UINT style, UINT flags, HWND after, HWND owner )
+{
+    struct ioctl_android_window_pos_changed req;
+
+    req.hdr.hwnd = HandleToLong( hwnd );
+    req.left     = rect->left;
+    req.top      = rect->top;
+    req.right    = rect->right;
+    req.bottom   = rect->bottom;
+    req.style    = style;
+    req.flags    = flags;
+    req.after    = HandleToLong( after );
+    req.owner    = HandleToLong( owner );
+    return android_ioctl( IOCTL_ANDROID_WINDOW_POS_CHANGED, &req, sizeof(req), NULL, NULL );
+}
+
+int ioctl_set_window_focus( HWND hwnd )
+{
+    struct ioctl_android_set_window_focus req;
+
+    req.hdr.hwnd = HandleToLong( hwnd );
+    return android_ioctl( IOCTL_ANDROID_SET_WINDOW_FOCUS, &req, sizeof(req), NULL, NULL );
+}
+
+int ioctl_set_window_text( HWND hwnd, const WCHAR *text )
+{
+    struct ioctl_android_set_window_text *req;
+    unsigned int size = offsetof( struct ioctl_android_set_window_text, text[strlenW(text)] );
+    int ret;
+
+    if (!(req = HeapAlloc( GetProcessHeap(), 0, size ))) return -ENOMEM;
+    req->hdr.hwnd = HandleToLong( hwnd );
+    memcpy( req->text, text, strlenW( text ) * sizeof(WCHAR) );
+    ret = android_ioctl( IOCTL_ANDROID_SET_WINDOW_TEXT, req, size, NULL, NULL );
+    HeapFree( GetProcessHeap(), 0, req );
+    return ret;
+}
+
+int ioctl_set_window_icon( HWND hwnd, int width, int height, const unsigned int *bits )
+{
+    struct ioctl_android_set_window_icon *req;
+    unsigned int size = offsetof( struct ioctl_android_set_window_icon, bits[width * height] );
+    int ret;
+
+    if (!(req = HeapAlloc( GetProcessHeap(), 0, size ))) return -ENOMEM;
+    req->hdr.hwnd = HandleToLong( hwnd );
+    req->width    = width;
+    req->height   = height;
+    memcpy( req->bits, bits, width * height * sizeof(req->bits[0]) );
+    ret = android_ioctl( IOCTL_ANDROID_SET_WINDOW_ICON, req, size, NULL, NULL );
+    HeapFree( GetProcessHeap(), 0, req );
+    return ret;
+}
+
+int ioctl_set_window_rgn( HWND hwnd, HRGN rgn )
+{
+    struct ioctl_android_set_window_rgn req;
+
+    req.hdr.hwnd   = HandleToLong( hwnd );
+    req.has_region = (rgn != 0);
+    return android_ioctl( IOCTL_ANDROID_SET_WINDOW_RGN, &req, sizeof(req), NULL, NULL );
+}
+
+int ioctl_set_window_layered( HWND hwnd, COLORREF key, BYTE alpha )
+{
+    struct ioctl_android_set_window_layered req;
+
+    req.hdr.hwnd = HandleToLong( hwnd );
+    req.key      = key;
+    req.alpha    = alpha;
+    return android_ioctl( IOCTL_ANDROID_SET_WINDOW_LAYERED, &req, sizeof(req), NULL, NULL );
+}
+
+int ioctl_set_surface_alpha( HWND hwnd, BOOL has_alpha )
+{
+    struct ioctl_android_set_surface_alpha req;
+
+    req.hdr.hwnd  = HandleToLong( hwnd );
+    req.has_alpha = has_alpha;
+    return android_ioctl( IOCTL_ANDROID_SET_SURFACE_ALPHA, &req, sizeof(req), NULL, NULL );
+}
+
+int ioctl_set_capture( HWND hwnd )
+{
+    struct ioctl_android_set_capture req;
+
+    req.hdr.hwnd  = HandleToLong( hwnd );
+    return android_ioctl( IOCTL_ANDROID_SET_CAPTURE, &req, sizeof(req), NULL, NULL );
+}
+
+int ioctl_gamepad_query( int index, int device, void* data)
+{
+    struct ioctl_android_gamepad_value query;
+    DWORD size = sizeof( query );
+    int ret;
+
+    query.index = index;
+    query.device = device;
+    ret = android_ioctl( IOCTL_ANDROID_GAMEPAD_QUERY, &query , sizeof(query), &query, &size );
+    switch (index)
+    {
+        case 0:  /* Count */
+            *(int*)data = query.data.count;
+            break;
+        case 1: /* Name */
+            lstrcpynW((WCHAR*)data, query.data.name, DI_NAME_LENGTH);
+            break;
+        case 2: /* Values*/
+            memcpy(data, query.data.value, sizeof(query.data.value));
+            break;
+    }
+    return ret;
+}
+
+int ioctl_get_clipboard_formats( DWORD* seqno, UINT** formats, DWORD* num_formats )
+{
+    struct ioctl_android_clipboard_formats query;
+    DWORD size = sizeof( query );
+    int ret;
+
+    query.count = 0;
+    ret = android_ioctl( IOCTL_ANDROID_GET_CLIPBOARD_FORMATS, &query, sizeof(query), &query, &size );
+
+    if (!ret)
+    {
+        if (query.count == 0)
+        {
+            *seqno = query.seqno;
+            *formats = NULL;
+            *num_formats = 0;
+        }
+        else
+        {
+            struct ioctl_android_clipboard_formats *dyn_query;
+
+            size = offsetof( struct ioctl_android_clipboard_formats, formats[query.count] );
+            dyn_query = HeapAlloc( GetProcessHeap(), 0, size );
+            if (!dyn_query)
+                return -ENOMEM;
+
+            dyn_query->count = query.count;
+            ret = android_ioctl( IOCTL_ANDROID_GET_CLIPBOARD_FORMATS, dyn_query, size, dyn_query, &size );
+
+            if (!ret)
+            {
+                *formats = HeapAlloc( GetProcessHeap(), 0, dyn_query->count * sizeof(UINT) );
+                if (*formats)
+                {
+                    *seqno = dyn_query->seqno;
+                    memcpy( *formats, dyn_query->formats, dyn_query->count * sizeof(UINT) );
+                    *num_formats = dyn_query->count;
+                }
+                else
+                    ret = -ENOMEM;
+            }
+
+            HeapFree( GetProcessHeap(), 0, dyn_query );
+        }
+    }
+    return ret;
+}
+
+int ioctl_get_clipboard_data( UINT format, HGLOBAL* result, BOOL* pending )
+{
+    struct ioctl_android_clipboard_data query;
+    DWORD size = sizeof( query );
+    int ret;
+
+    *result = NULL;
+    *pending = FALSE;
+
+    query.pending = 0;
+    query.format_present = 0;
+    query.format = format;
+    query.size = 0;
+    ret = android_ioctl( IOCTL_ANDROID_GET_CLIPBOARD_DATA, &query, sizeof(query), &query, &size );
+
+    if (!ret)
+    {
+        if (query.pending)
+        {
+            *pending = TRUE;
+        }
+        else if (query.format_present && query.size == 0)
+        {
+            *result = GlobalAlloc( GMEM_MOVEABLE, 0 );
+        }
+        else if (query.format_present)
+        {
+            struct ioctl_android_clipboard_data *dyn_query;
+
+            size = offsetof( struct ioctl_android_clipboard_data, data[query.size] );
+            dyn_query = HeapAlloc( GetProcessHeap(), 0, size );
+            if (!dyn_query)
+                return -ENOMEM;
+
+            dyn_query->pending = 0;
+            dyn_query->format_present = 0;
+            dyn_query->format = format;
+            dyn_query->size = query.size;
+            ret = android_ioctl( IOCTL_ANDROID_GET_CLIPBOARD_DATA, dyn_query, size, dyn_query, &size );
+
+            if (!ret && !dyn_query->pending && dyn_query->format_present)
+            {
+                *result = GlobalAlloc( GMEM_MOVEABLE, dyn_query->size );
+                if (*result)
+                {
+                    void *lock = GlobalLock( *result );
+                    memcpy( lock, dyn_query->data, dyn_query->size );
+                    GlobalUnlock( *result );
+                }
+                else
+                    ret = -ENOMEM;
+            }
+
+            HeapFree( GetProcessHeap(), 0, dyn_query );
+        }
+    }
+    return ret;
+}
+
+int ioctl_render_clipboard_data( int android_format )
+{
+    struct ioctl_android_render_clipboard_data req;
+
+    req.android_format = android_format;
+    return android_ioctl( IOCTL_ANDROID_RENDER_CLIPBOARD_DATA, &req, sizeof(req), NULL, NULL );
+}
+
+int ioctl_empty_clipboard( void )
+{
+    struct ioctl_android_empty_clipboard req;
+
+    return android_ioctl( IOCTL_ANDROID_EMPTY_CLIPBOARD, &req, sizeof(req), NULL, NULL );
+}
+
+int ioctl_set_clipboard_data( UINT format, BOOL format_present, BYTE* buffer, DWORD buffer_size )
+{
+    struct ioctl_android_clipboard_data *req;
+    DWORD size = offsetof( struct ioctl_android_clipboard_data, data[buffer_size] );
+
+    req = HeapAlloc( GetProcessHeap(), 0, size );
+    if (!req) return -ENOMEM;
+
+    req->pending = 0;
+    req->format_present = format_present;
+    req->format = format;
+    req->size = buffer_size;
+    memcpy( req->data, buffer, buffer_size );
+
+    return android_ioctl( IOCTL_ANDROID_SET_CLIPBOARD_DATA, req, size, NULL, NULL );
+}
+
+int ioctl_end_clipboard_update( void )
+{
+    struct ioctl_android_end_clipboard_update req;
+
+    return android_ioctl( IOCTL_ANDROID_END_CLIPBOARD_UPDATE, &req, sizeof(req), NULL, NULL );
+}
+
+int ioctl_acquire_clipboard( void )
+{
+    struct ioctl_android_acquire_clipboard req;
+
+    return android_ioctl( IOCTL_ANDROID_ACQUIRE_CLIPBOARD, &req, sizeof(req), NULL, NULL );
+}
+
+int ioctl_export_clipboard_data( int android_format, BYTE* buffer, DWORD buffer_size )
+{
+    struct ioctl_android_clipboard_data *req;
+    DWORD size = offsetof( struct ioctl_android_clipboard_data, data[buffer_size] );
+
+    req = HeapAlloc( GetProcessHeap(), 0, size );
+    if (!req) return -ENOMEM;
+
+    req->pending = 0;
+    req->format_present = TRUE;
+    req->format = android_format;
+    req->size = buffer_size;
+    memcpy( req->data, buffer, buffer_size );
+
+    return android_ioctl( IOCTL_ANDROID_EXPORT_CLIPBOARD_DATA, req, size, NULL, NULL );
+}
+
+
+struct ANativeWindow *create_ioctl_window( HWND hwnd )
+{
+    struct ioctl_android_create_window req;
+    struct native_win_wrapper *win = HeapAlloc( GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(*win) );
+
+    if (!win) return NULL;
+
+    win->win.common.magic             = ANDROID_NATIVE_WINDOW_MAGIC;
+    win->win.common.version           = sizeof(ANativeWindow);
+    win->win.common.incRef            = win_incRef;
+    win->win.common.decRef            = win_decRef;
+    win->win.setSwapInterval          = setSwapInterval;
+    win->win.dequeueBuffer_DEPRECATED = dequeueBuffer_DEPRECATED;
+    win->win.lockBuffer_DEPRECATED    = lockBuffer_DEPRECATED;
+    win->win.queueBuffer_DEPRECATED   = queueBuffer_DEPRECATED;
+    win->win.query                    = query;
+    win->win.perform                  = perform;
+    win->win.cancelBuffer_DEPRECATED  = cancelBuffer_DEPRECATED;
+    win->win.dequeueBuffer            = dequeueBuffer;
+    win->win.queueBuffer              = queueBuffer;
+    win->win.cancelBuffer             = cancelBuffer;
+    win->ref  = 1;
+    win->hwnd = hwnd;
+    TRACE( "-> %p %p\n", win, win->hwnd );
+
+    req.hdr.hwnd = HandleToLong( win->hwnd );
+    android_ioctl( IOCTL_ANDROID_CREATE_WINDOW, &req, sizeof(req), NULL, NULL );
+
+    return &win->win;
+}
+
+void destroy_ioctl_window( HWND hwnd )
+{
+    struct ioctl_android_destroy_window req;
+
+    req.hdr.hwnd = HandleToLong( hwnd );
+    android_ioctl( IOCTL_ANDROID_DESTROY_WINDOW, &req, sizeof(req), NULL, NULL );
+}
+
+void grab_ioctl_window( struct ANativeWindow *window )
+{
+    struct native_win_wrapper *win = (struct native_win_wrapper *)window;
+    InterlockedIncrement( &win->ref );
+}
+
+void release_ioctl_window( struct ANativeWindow *window )
+{
+    struct native_win_wrapper *win = (struct native_win_wrapper *)window;
+    unsigned int i;
+
+    if (InterlockedDecrement( &win->ref ) > 0) return;
+
+    TRACE( "%p %p\n", win, win->hwnd );
+    for (i = 0; i < sizeof(win->buffers)/sizeof(win->buffers[0]); i++)
+        if (win->buffers[i]) win->buffers[i]->buffer.common.decRef( &win->buffers[i]->buffer.common );
+
+    destroy_ioctl_window( win->hwnd );
+    HeapFree( GetProcessHeap(), 0, win );
+}
+
+int ioctl_imeText( int target, int *cursor, int *length, WCHAR* string)
+{
+    struct ioctl_android_ime_text *query;
+    DWORD size = sizeof( *query ) + ((*length - 1) * sizeof(WCHAR));
+    int ret;
+
+    query = HeapAlloc(GetProcessHeap(), 0, size);
+
+    query->length = (*length);
+    query->target = target;
+    ret = android_ioctl( IOCTL_ANDROID_IMETEXT, query , size, query, &size );
+    lstrcpynW(string, query->text, query->length);
+    *length = query->length;
+    *cursor = query->cursor;
+
+    HeapFree(GetProcessHeap(), 0, query);
+
+    return ret;
+}
+
+int ioctl_imeFinish( int target )
+{
+    struct ioctl_android_ime_finish *query;
+    DWORD size = sizeof( *query );
+    int ret;
+
+    query = HeapAlloc(GetProcessHeap(), 0, size);
+    query->target = target;
+    ret = android_ioctl( IOCTL_ANDROID_IMEFINISH, query , size, query, &size );
+    HeapFree(GetProcessHeap(), 0, query);
+
+    return ret;
+}
diff -Naur wine-2.0a/dlls/wineandroid.drv/gamepad.c wine-2.0b/dlls/wineandroid.drv/gamepad.c
--- wine-2.0a/dlls/wineandroid.drv/gamepad.c	1970-01-01 01:00:00.000000000 +0100
+++ wine-2.0b/dlls/wineandroid.drv/gamepad.c	2017-07-11 20:37:51.000000000 +0100
@@ -0,0 +1,159 @@
+/*
+ * The interface with the Android Gamepads
+ *
+ * Copyright 2015 CodeWeavers, Aric Stewart
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include "config.h"
+
+#include <stdarg.h>
+#include "windef.h"
+#include "winbase.h"
+#include "wingdi.h"
+#include "winuser.h"
+#include "winerror.h"
+#include "wine/debug.h"
+#include "imm.h"
+#include "ddk/imm.h"
+#include "winnls.h"
+#include "android.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(android);
+
+di_value_set *di_value = NULL;
+di_name      *di_names = NULL;
+int          di_controllers = 0;
+
+static int *di_ids = NULL;
+static int di_controller_alloc = 0;
+
+/*
+ * All the following functions run in the Android process
+ */
+static int get_index_from_id(int device)
+{
+    int dev_index = 0;
+    for (dev_index = 0; dev_index < di_controllers; dev_index++)
+        if (device == di_ids[dev_index])
+            break;
+    if (dev_index >=di_controllers)
+        return -1;
+
+    return dev_index;
+}
+
+void gamepad_count( JNIEnv *env, jobject obj, jint count )
+{
+    if (count > di_controller_alloc)
+    {
+        int i;
+        di_ids = realloc(di_ids, sizeof(int) * count);
+        di_names = realloc(di_names, sizeof(di_name) * count);
+        di_value = realloc(di_value, sizeof(di_value_set) * count);
+        for (i = di_controller_alloc; i < count; i++)
+        {
+            di_ids[i] = 0;
+            di_names[i][0] = '\0';
+            memset(&di_value[i], 0, sizeof(di_value_set));
+        }
+        di_controller_alloc = count;
+    }
+    di_controllers = count;
+}
+
+void gamepad_data( JNIEnv *env, jobject obj, jint index, jint id, jstring name)
+{
+    const jchar* _name;
+    if (index > di_controllers)
+        return;
+
+    _name = (*env)->GetStringChars(env, name, 0);
+    lstrcpynW(di_names[index], (WCHAR*)_name, DI_NAME_LENGTH);
+    (*env)->ReleaseStringChars(env, name, _name);
+    di_ids[index] = id;
+}
+
+void gamepad_sendbutton( JNIEnv *env, jobject obj, jint device, jint key, jint value)
+{
+    int dev_index = get_index_from_id(device);
+    if (dev_index < 0)
+        return;
+
+    if ( key >= 96 && key <= 110)
+    di_value[dev_index][(key-96)+DI_BUTTON_DATA_OFFSET] = value;
+    else if (key >= 188 && key <= 203)
+    di_value[dev_index][(key-188)+DI_BUTTON_DATA_OFFSET+14] = value;
+}
+
+void gamepad_sendaxis(JNIEnv *env, jobject obj, jint device, jfloatArray axis)
+{
+    int i;
+    int dev_index = get_index_from_id(device);
+    jfloat *values;
+
+    if (dev_index < 0)
+        return;
+
+    values = (*env)->GetFloatArrayElements(env, axis, NULL);
+    for (i = 0; i < DI_AXIS_DATA_COUNT; i++)
+        di_value[dev_index][i] = (int)(0xffff * values[i]);
+    (*env)->ReleaseFloatArrayElements(env, axis, values, JNI_ABORT);
+}
+/*
+ * End Android process functions
+ */
+
+/*
+ * All the following functions run in WINE processes
+ */
+INT CDECL GamePadCount(void)
+{
+    int count;
+    ioctl_gamepad_query(0, 0, &count);
+    return count;
+}
+
+VOID CDECL GamePadName(int id, char* name, int len)
+{
+    WCHAR _name[DI_NAME_LENGTH];
+    ioctl_gamepad_query(1, id, _name);
+    WideCharToMultiByte(CP_UTF8, 0, _name, -1, name, len, NULL, NULL);
+}
+
+VOID CDECL GamePadElementCount(int id, DWORD *axis, DWORD *buttons, DWORD *povs, int axis_map[8])
+{
+    int i;
+    *axis = DI_AXIS_COUNT;
+    *povs = DI_POV_COUNT;
+    *buttons = DI_BUTTON_COUNT;
+    for (i = 0; i < DI_AXIS_COUNT; i++)
+        axis_map[i] = min(i,6);
+}
+
+VOID CDECL GamePadElementProps(int id, int element, int *min, int *max)
+{
+    *min = -1 * 0xffff;
+    *max = 0xffff;
+}
+
+VOID CDECL GamePadPollValues(int id, int *values)
+{
+    ioctl_gamepad_query(2, id, values);
+}
+/*
+ * End WINE process functions
+ */
diff -Naur wine-2.0a/dlls/wineandroid.drv/gradlew wine-2.0b/dlls/wineandroid.drv/gradlew
--- wine-2.0a/dlls/wineandroid.drv/gradlew	1970-01-01 01:00:00.000000000 +0100
+++ wine-2.0b/dlls/wineandroid.drv/gradlew	2017-07-11 20:37:51.000000000 +0100
@@ -0,0 +1,160 @@
+#!/usr/bin/env bash
+
+##############################################################################
+##
+##  Gradle start up script for UN*X
+##
+##############################################################################
+
+# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
+DEFAULT_JVM_OPTS=""
+
+APP_NAME="Gradle"
+APP_BASE_NAME=`basename "$0"`
+
+# Use the maximum available, or set MAX_FD != -1 to use that value.
+MAX_FD="maximum"
+
+warn ( ) {
+    echo "$*"
+}
+
+die ( ) {
+    echo
+    echo "$*"
+    echo
+    exit 1
+}
+
+# OS specific support (must be 'true' or 'false').
+cygwin=false
+msys=false
+darwin=false
+case "`uname`" in
+  CYGWIN* )
+    cygwin=true
+    ;;
+  Darwin* )
+    darwin=true
+    ;;
+  MINGW* )
+    msys=true
+    ;;
+esac
+
+# Attempt to set APP_HOME
+# Resolve links: $0 may be a link
+PRG="$0"
+# Need this for relative symlinks.
+while [ -h "$PRG" ] ; do
+    ls=`ls -ld "$PRG"`
+    link=`expr "$ls" : '.*-> \(.*\)$'`
+    if expr "$link" : '/.*' > /dev/null; then
+        PRG="$link"
+    else
+        PRG=`dirname "$PRG"`"/$link"
+    fi
+done
+SAVED="`pwd`"
+cd "`dirname \"$PRG\"`/" >/dev/null
+APP_HOME="`pwd -P`"
+cd "$SAVED" >/dev/null
+
+CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar
+
+# Determine the Java command to use to start the JVM.
+if [ -n "$JAVA_HOME" ] ; then
+    if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
+        # IBM's JDK on AIX uses strange locations for the executables
+        JAVACMD="$JAVA_HOME/jre/sh/java"
+    else
+        JAVACMD="$JAVA_HOME/bin/java"
+    fi
+    if [ ! -x "$JAVACMD" ] ; then
+        die "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME
+
+Please set the JAVA_HOME variable in your environment to match the
+location of your Java installation."
+    fi
+else
+    JAVACMD="java"
+    which java >/dev/null 2>&1 || die "ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
+
+Please set the JAVA_HOME variable in your environment to match the
+location of your Java installation."
+fi
+
+# Increase the maximum file descriptors if we can.
+if [ "$cygwin" = "false" -a "$darwin" = "false" ] ; then
+    MAX_FD_LIMIT=`ulimit -H -n`
+    if [ $? -eq 0 ] ; then
+        if [ "$MAX_FD" = "maximum" -o "$MAX_FD" = "max" ] ; then
+            MAX_FD="$MAX_FD_LIMIT"
+        fi
+        ulimit -n $MAX_FD
+        if [ $? -ne 0 ] ; then
+            warn "Could not set maximum file descriptor limit: $MAX_FD"
+        fi
+    else
+        warn "Could not query maximum file descriptor limit: $MAX_FD_LIMIT"
+    fi
+fi
+
+# For Darwin, add options to specify how the application appears in the dock
+if $darwin; then
+    GRADLE_OPTS="$GRADLE_OPTS \"-Xdock:name=$APP_NAME\" \"-Xdock:icon=$APP_HOME/media/gradle.icns\""
+fi
+
+# For Cygwin, switch paths to Windows format before running java
+if $cygwin ; then
+    APP_HOME=`cygpath --path --mixed "$APP_HOME"`
+    CLASSPATH=`cygpath --path --mixed "$CLASSPATH"`
+    JAVACMD=`cygpath --unix "$JAVACMD"`
+
+    # We build the pattern for arguments to be converted via cygpath
+    ROOTDIRSRAW=`find -L / -maxdepth 1 -mindepth 1 -type d 2>/dev/null`
+    SEP=""
+    for dir in $ROOTDIRSRAW ; do
+        ROOTDIRS="$ROOTDIRS$SEP$dir"
+        SEP="|"
+    done
+    OURCYGPATTERN="(^($ROOTDIRS))"
+    # Add a user-defined pattern to the cygpath arguments
+    if [ "$GRADLE_CYGPATTERN" != "" ] ; then
+        OURCYGPATTERN="$OURCYGPATTERN|($GRADLE_CYGPATTERN)"
+    fi
+    # Now convert the arguments - kludge to limit ourselves to /bin/sh
+    i=0
+    for arg in "$@" ; do
+        CHECK=`echo "$arg"|egrep -c "$OURCYGPATTERN" -`
+        CHECK2=`echo "$arg"|egrep -c "^-"`                                 ### Determine if an option
+
+        if [ $CHECK -ne 0 ] && [ $CHECK2 -eq 0 ] ; then                    ### Added a condition
+            eval `echo args$i`=`cygpath --path --ignore --mixed "$arg"`
+        else
+            eval `echo args$i`="\"$arg\""
+        fi
+        i=$((i+1))
+    done
+    case $i in
+        (0) set -- ;;
+        (1) set -- "$args0" ;;
+        (2) set -- "$args0" "$args1" ;;
+        (3) set -- "$args0" "$args1" "$args2" ;;
+        (4) set -- "$args0" "$args1" "$args2" "$args3" ;;
+        (5) set -- "$args0" "$args1" "$args2" "$args3" "$args4" ;;
+        (6) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" ;;
+        (7) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" ;;
+        (8) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" ;;
+        (9) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" "$args8" ;;
+    esac
+fi
+
+# Split up the JVM_OPTS And GRADLE_OPTS values into an array, following the shell quoting and substitution rules
+function splitJvmOpts() {
+    JVM_OPTS=("$@")
+}
+eval splitJvmOpts $DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS
+JVM_OPTS[${#JVM_OPTS[*]}]="-Dorg.gradle.appname=$APP_BASE_NAME"
+
+exec "$JAVACMD" "${JVM_OPTS[@]}" -classpath "$CLASSPATH" org.gradle.wrapper.GradleWrapperMain "$@"
diff -Naur wine-2.0a/dlls/wineandroid.drv/gradle-wrapper.jar wine-2.0b/dlls/wineandroid.drv/gradle-wrapper.jar
--- wine-2.0a/dlls/wineandroid.drv/gradle-wrapper.jar	1970-01-01 01:00:00.000000000 +0100
+++ wine-2.0b/dlls/wineandroid.drv/gradle-wrapper.jar	2017-07-11 20:37:51.000000000 +0100
@@ -0,0 +1,306 @@
+PK
+   r@qG           	   META-INF/ PK
+   r@qGÃïF?   T      META-INF/MANIFEST.MFóMÌËLK-.ÑK-*ÎÌÏ³R0Ô3àåòÌ-ÈIÍMÍ+I,
+êdä¤Z)¸%¦ä¤bÈÂµéYòrñr PK
+   f@qG              org/ PK
+   f@qG              org/gradle/ PK
+   f@qG              org/gradle/wrapper/ PK
+   f@qGhdf£   Õ   #   org/gradle/wrapper/Download$1.class}M
+Â0ßh5Z+v/×Áp!.<AlCl	IIª½à¡Äqë<æ=Ì|¯÷ã	 CÂÀbB|¶7Ë}©%aºµ­ÑVëJÜa¶3¹¶¾4ê(«-&u+'
+-yëD]KÇ« Br0FºÞKOH;×Â(~ºT2oó?t=|§Ð"BFÃu-} PK
+   f@qGÅÞÖ  p  D   org/gradle/wrapper/Download$SystemPropertiesProxyAuthenticator.class¥SmoA~(ÇÑâ©`­ÚÖzTåoÑ`		1MªML?mag®wdoò¯ôm4ñø£³@ ïÃÎì<óÌ<;»÷ãç×ï Êxj"	k)Ü6±6SXÖî[¸k"ÇÀ¶{É^à©]¸S<dHÔÂ¦`Xª{xÓ=9ò-?ö)b×Ã÷¹ôô~L¨¶1¬ô#%NöeØRy""ï´_íª¶×à*Öë ²æó(ÄyYeËmIÞôÛ¼CTw/ì~ÈóV[BíS¹^(cN±þän ;=©bà>H¾3SK¹¢;Ýa(ÌId0Â®lWOæ*i)2X¤sd1,¶ê:úÈï"!<°PKwð¸àjdÇ@ÙÂC<ÒxÂ°ûÃeÈýV9¬Î Cv@ôyÐr}ÒúÝú[N},EI/hUMIüGjv2F"TXksYS<ª1ä§´8ªéë^qL¬Ñ_fAqÄô­Ò#Z¢K^¶ÏûLNYZ ÇeZ­al\#@ù¹JQå¿!þÞNcÁNÚÆ9R_péæ§rb¬\~XÀnÊ='iaÓµä	#-Ú[ÁÍmuWÉÚä¥QÄ¸NÙÔ/PK
+   f@qGçìXsª   Û   "   org/gradle/wrapper/IDownload.classEÁ
+Â0ÿÌéæ¼
+^õbñ¼«
+APô^·26J;êt>À;Éüùó|Ý è{èz~¢+%5Oé&çWÎ(Ùa_Ê4[gR³#!XÝbQVg=Ë{}1±¨÷A´üYÍëCÂX¥'R°Êð¢5Âðc/¹JÙö¸$þ£æS@pP¹\ËmKuíØôlïÀPK
+   f@qG©zÝ\  Q  -   org/gradle/wrapper/GradleUserHomeLookup.classS[OAþF]ÖõR¬(µ¶j[[ÙZíUÓÄËªT 	Od	®.»dYlüW½$jjÒÇ>ôG5=ÃR+È»É¹Íw¾sæÌÌï??~XÂªQÌÉx¢à)I)`^F\øF° á¹ ½zQFRhMÂK	K[úöúA*_ÚÉ®o¥ôÒANÏvÓtpêØ854Ë°«ZÎsM»ºÊ0Ý+e²éÍK{zahÓ±a{Ãjrâ¿×÷>4¸fÚ¦÷¡?(06
+%¤Lï7kÜÍ}8eÃ*®)üv0àDÊq«ZÕ5*×>»F½Î]m§å4¸»ëÔxÊqNuj}¸Úg'ü-¶mZ0òZÙjw¥ä¦[æb!Ú3)UD0A\>y²IäA$¼R±õfMðî±¨x÷fèûFÓ´*Üe]Ó«xwÔ¯ô«xówuð¿Húð½Pî¬áñÃ`{×!ï!¿}%½nÉx/ qè¸}JhÍ®0,Þ²= q@ãîÇ{ÔÆ,ÝúQzýiÅiÂÝGã7ü !8CÑH3Ò`_[(É`+8$U)<$Â4µOZdô4Ã}è/îýz@¨¾:CÂøY×"D"VvIÎ ¹ëÂ(&ö%Óê¿®)[|SW/ ©þ9Ôðs,öÂnì%Br¦Uvö/PK
+   f@qGâ]ÛÅ  ú
+  3   org/gradle/wrapper/ExclusiveFileAccessManager.classVKpeÿm&iºm!@!Pl ´P(ÓØbhZ ¥·É6]ºÝMK} >êûuðè£2#-XÆGGÇ:ãñÂÅ//Äß·¾ùÿçïÿú6?þûÕ ã ¶¡³¤ÄÒåGw^÷ãD>tËIqê	 WìiA9%¾ N£ß ÎQ#58Ä3x6HSÏqÏû¡0(3dD-*ÃpÎWbº£~~Ö¤':Ïu$SíçzOut$û%Rç1%¦+F.Ök[kP0­v¢U	¶6ªE»« AJJ¨Îº4lÕStAôµjfPM&ú$xf5)ÍP»£ªVuUø33Þ§X¸^{X£XÊ´r±¥du56n)ù¼jÅÚ/dôbAS;4]mËdÔB¡K1j¨OqÚ¢nr-î­hkz,c¢e©K(º.<¶4Ìúøày5cÓ![vÍnfF$Ô¹gÃPõãaL©óá13aÐÍÔÿ 	áÏ5²ÆR¬9êë6ÏÙíYÄÀKÈæÜ,Ap/­]ÿül\ak:ÝrúAÖCÍÛ}Ñ«åÅ.ZÔïjMÇfõð}ÕÅuÒÀUÂÚQebPMèfA=YÔT[ ø{Ö[K¶8LbÃ<sHi­"3+/aÝ2FX¯Y´2¥2Ö¯Üu{²(ò2ÂN»°S<?J/À°qñd)jzVµd`Ë(bí±WÏÈ(.ÈÀ~¼$ãe¼"aÓJEà±Æe\Ä«~\ñ^ÀS~¼!ãML²_îùî)b|ç²!¡2ísÄoqô"ªdÕld\ÑlbVd®¹#îEl32D÷qª½íB~Çwe¼÷ýø@ÆÈûñg)¦ûqÃâP5¯Ê©ö	EôOij¢ÏOneÌõÑå:ðod*º½T£T@1­¶é$ìX¶Å::Õ¬þÌ¨z'
+¶:Ê/M(N¦ë+Ì§(È0³#¾m6U|ëªÌmM¤çí­¸y@ÓÃìæª¼ «*ëëÕE«eªàÛ¦^´Õ=Ì].×}³¨Wzè¾¸s¯÷æÃ`Àª«JFÖ.}ä<üXGøÊÆvì ßDÞ<"$&çvGBbë7pmäm2eÜk§!5n¹
+OcÝU]qw;j^®Û¸nGWÓðR"®°pNÂä#Ï1ì£Ýxêø¡É3ïÀî)ÏÀ70?)T\¦P9¹»Ü)Tâ^)^~ÕÍ>)¾G/µ¾Æ/áT>ýÍ3¨h
+­ÆÚ¸7ìB(^¦ê:GúîÏa*¯{¹P¥lò6\¾;#ì4Í v  ´É)l
+y&¢Í³`¶ÜÜsuâa¢Üê$&Ç&áÝs®ø"\^&x3^9O°ò&3ù9¦qºß}~Âçþ·³9¿z®»÷(sØÀL7R²	ñ<¥ø7­ûùoê:ÇG3ßÄ¸VLâ=µÑW_£ß ßâ(~ÀÓô×_háy·Éû¼?Éû¼;äýC¨r´|ö³1C_ÆJÎV§ô,9§fÊxø6'­2¿!Æ¼¿Ó!ã0ä9ù'(ÿ$)^RêVôÝ¶-¿¥=ËÝã´èw¨j¼$\7ud/«¨æ¶j-'Ií%½4Ûµß	¤2ÕÜÛ¨Û¤G*1 é¸<öPK
+   f@qGÌ^F  ù  -   org/gradle/wrapper/WrapperConfiguration.classmOAÇÿÛçÖ>¢¢"í! à3	U1UH|C®p#åÜ]5ñSi"1ñÀe½[ ¬ÛÄ73³3óýí\ûûÏÏ_ æð(KÉ`6îq?ÇÍ<7÷¹yÀÍBi<dÐöm?ðìV7°]a°qh~2Ç
+­Íõ§Þúé[¥¨§c:m£I5§-÷½3¡ÞTóÀ_XlvÒ_ìãh¢ÞÔ3Û±%xµ¶ÍXu÷©oØõ¶{Ô²¼÷f«ÞíîmÓ³ùY$Áí3Ô®×6Ú¹ß±Ïy|lyÆNäW]ç£Ýîz&g!Ü|Û
+Ö.¼¼P­ÉoÏûrS±z±³¥QÑÓ*§ã.®©ì«ªÿöªFG»gDÙ©·gá#~ßRTN?GÎï=Dh¸¨CÓíz{Öï~TµàYþÑ^_n.¯5ê»[Íúæî«7uÈ3~!þ+ñ5×Pâ¦ÌEÞ8õ_®:_âFëÐÚ0þ RñÅøí¡/_¾$|9ô`ì0v(ÏÈë?ÀôRìq½8A2SaþÊ/Fl	r)`¢1PVQf<Ã\äy-©GæëÙ°gâq\â%êñn}ús\ ÍÍpÂpÔ%&ðHßÊp7 qdR	2Aã q¤F½ÿ0üâ[J¤2£¹­IÊ s¤ïR J¬² ¹£ÉÊ Ió¤HQL)AR2Ès%HUAI³Ò¤$@jJ´RWèj´²N×}@Êd:ÔÜýPK
+   f@qGQ}iå  
+  0   org/gradle/wrapper/SystemPropertiesHandler.classVësUÿmdÃvË£PJJiúl
+*ÐJ¥$P,ºMod7l6´øFýÂÃW>9ÃÀÎÈwÿ(õw7¡ÍÚfzî½çuÏùsÏìßÿüùýøYÃ.¨xCCF4Ä¨75ø%ócò0.w*&UVñVqF®	IÎJrN© ÎkxÓÒìBÞÁÅ\Â»¼'/;'¥ïk00#IRÃ,TkA
+i¦Ë
+C¦eºG4Gº§øÛ³BÁ1ÓìpÎ3rÚÆì¤2SËL6ó
+zÇl'K9ÆlFÄæ#N,±wEö´cóà"Ò°(vâ
+6§[+U°32vÙ¸fÄL;6bfD¼»t,¸f&6näh4­ë#« T¥;jå
+nID5µ/ËG'"ç¶EYó±(sñ¤ÃJÅhfZ)Ô¬á&ÓÂYvîÝìXàýHÆ`8©BVXnµÉË"éRÞd¾ `KQW8kKÛõ¹åteÔdTg¬ ¥¬±ÈejÐrm­¯ )3É.oµerº$Kóª.æu úÚ¡z°ê9Gép]ÂLY[pècxõb®Ù§°NRàêzFKõKS»Aè7­ÜsÒÈ§y+:2`Ólig´ôhé°ÓqUúÞÜ §t®~¦`¹fVT;j³:V03³²Év;íçÓÂ
+glc²ðJuÃsåyI\\Í+Ø_áb¤?Ú­bAÇ">ÐqªøHÇÇ¸¡âY|ÏuÀ*¾ÔqSr¾Â×*¾Ññ-¾Óñ=~PqKÇøIAtíÔö¿½K³Üé.XÚ®G&¯`Û¨ò5K2cç¥3EÝ¾H}³t×±ÊHÇkôË/u5ý kXlH½"5¢"¨àM;ö¼|L^üÏx|¨I;óðY%¥7À9®´R,
+[«rng}zÅlj«ç2¾´tá³¼¥å¡w°2úãiÃI«a%EVFi.ãO°oÎuö§»À9ØmXµ<âVÊM{7Jùïýú/çQ7Ù
+70_C<Ïß.È¿&(r>îá)ÆUáê>ò»'ÞKðÛ±T/) n®ëEµh¬<AòþXBÓôC4EðýÏý%øÉ/A¦çàDo_ëø¯Ý>èïÉ=' O/¡ÚëÛ6±.6ÑÖ÷´myöÞ"¶>FA_È÷ÛÜÁ	¹åïùè,bû` (¢ëö¾"TCj;î¢½'¤öJ­T|p3Îßû÷QÏ}4}ègýxÑ[C8A´P"AB;é¦¸Æ&êÜ.J÷ÒÏõziEóä\"ª×éñ&?¶nqÜÝÆAÜÅK¸OÍ8ì:ùaÔNË>ÞGíbÜÝF'-÷óÓë&= e¾h=À¤q
+/ÓONO¯pâ7ÞgBøC8Ââ\â÷ÖQ¼J¯XÒz»c^swÂÛÿPK
+   f@qG¥y0ºV        org/gradle/wrapper/Logger.classûoÒPÇ¿Ç*¯1ÆpL
+EWo1&d		f&û­®Ki¡ÿÅÄüü£ç¶X³sï9ó*þþúàOHàfp+Û¨&Q,D];BÜp AÐ`§wØ	ÃÚ3Ã2Üç±êIí^m{À²]Ãâ¯§Ã>wÞ©}N6»¶¦Çªc;8¹§Æ¡Ôµ]Ñu`rå££FÜQº¶®s§Å5m¡Pí©TÅT-]é¹aé-PòÉDÕ½+TYÆb|ûTuz|<åÆ[µ·(N$Ö&cbXC3ÙéRãWuÄô:Á+m§Úõf=mdÏ:?2ÄØRþlDL¦BZB3{¸/áAQH£GB<â	å	2ÃÆÿüoúg\£·Î+j®±/ø÷>M\>¤{JQ¿ÃVÞÒ
+\ZWÔHþcÚÞHX¦Å \´âáÅÓ_)ÎG½t
+}ý	Ð éÙã¤FôÖIfÉ:B~@Rþ	&~ ò¬6H®#Jò2bØ&J9Ïò¼<MPiØB!`¾Yù;"üh}Ø2¸	eÒ¯.³spN¶=p;øU Îùà¿¿,¡+¾N!ûèÜÃJî£ËZ£.côÎûè@wgX[W	^#HÝË~ØàBÛ¥Þ"¶GZÔKx-¼ÒÒj:Ò5(¤ÒK:½ÜðâöÿPK
+   f@qGÎrë  n  &   org/gradle/wrapper/PathAssembler.classVùcWþÖÖy8sØµb',ÙIS(IðÕD­¯ú*NÚ¸kk#o*ïº»«Är(÷}ûZ)Ä´~ä¾Ù][¶*Óö½7ïiÞÌ73ß·ÿþÏý7Æ¿â8ÂÅRnÄ)½ CQå(LÙ¶d±ÅqÄQ[$'WæRQÜí[2¬F±ÇA|$ÊgñRâãq|áSq|ÅgEºÅçdþ|Çð²_âQ|)/ÇÑ¯ÄðUQþ_ßé1|KæoÇð¾Ç÷ð}Áq'ÄðC9y'»
+XZqÈp\ÛX(¹e*Ps¦©ÛEÍqtGÁKýC#Ãó3SÃóÇGç§¦'sc$Fnh7µlQ3Ù)0çì´LÇÕLwV+tû&&ÇÞ:µ¯`kù¢>ãèöekY4|3}Â(ê4yÜ0÷¢ÆT÷¬Ð §ÚþÃÔÇJËº=­-uñ/àg5Ûu°r¢î±ìBÖw½ek++ºÐÜ¥~FµLM¤vºoûº»3ó©z¶ñgF{Ý(lMtÏw¿­×oI¸älq»uÍÔu¨ ¶ 9ú&åiÖlËb¶¿Ê\ÒcEÁxê­Õ{qÖ©|´d/kÎ%æÐ®ã¥îá½Ëºãh}È(è« ÃWrôÅm¸kÙÑíS?¼°æ
+;®(Pã¡mVWõ ?ÇsÁÂÚú²uS^uuÓñÒ2½ì(ÌcÎÊû9ëºÌí²¤sÆ.nxSÆWXvq`¼ìwî*ûCRP²Jö¢.dúõÉ	pQÅy<ÅTãÇ*Ã5sxZÅSãEÞnYÅOð,òJ×¢(Å¼n«ø©èü?gF²*~!«ø¥_ôk¼¢àÌ»g¸ØøM¿U1§YºNö$K×\E1¾pC_t£øßã¼ø£CFñGÂU¬ãUÁ_´xGé.;`r¦«õk¢p¯â²u  ­º;Y2]cYßögû U*æ¦å&HÜ¤a®Ü¤O>±]aF(ÜÃßTÜÇ¿KFî»æÚ©â¼Ir³Äf×7ì(¨øèþIn
+3Î%I½¤á$Kæ¦u`ob§ÞáM%ºTw-5Ö´¸p-©º¯UðhWf^Aï;ºà¿¤]¹ÖTp!»jºoC³þbÃò1CÝ¾¼³Ç×ó°½Û«ÛS³(#×-Sð:^©åpý>ñÐÿif~ãÉyæ"c<½{Fwí1é2~C¥º¥%FJ+yÍ¥¹pêêDÉÞ"©¿s(«6]ïe¨îL/ÙÖ-yk½6ñ3àóúêøu1Y;óºÇ)-löáÃ©\}¿òjìÒ_,iE§ÆÞf¯ì¬ÓãêË~'lp×v2ãüÞ:Êo»F´âýx¬*WÈp}nÛº?vVÊ1î±Ñrü WpV8Ó(¯zªâçt Äï³~Jª¯rC'¨)ºq1Î¼ª}$iå8ö Ó³tØ×,$°Ä0mù6ÿKOQÎ·Ó2+¦{*¥{3DÎ6¿bìÙ@|®&®Ô2ö&öqhq(cÍçÂºvè&vèzROõPdçÒ­áÖH-ë[á´!Â1ÅPº±iaÑUfWB»ìÞ
+í6.q\ÁKÈ±<uORjäYOÚcLÍ õG0íìÅ(¥5ùÜÉ¸ÁB¥°±CK	¿£s©¹PïÔ=´®×î4KvÆCöOo¡:æ!P<Ið5P3qU¼gß»<''ûm÷ðÐ(Ö>ÖÓ[FÇÍå=$Oq|}t]s¬ÑÉåã,vç¬õs@14:,vË-øÎ2¾Ú1)hbf¦1C,]gñMßú>|ØCß _ÒkÔ¢µdqêBû]3ëÆö2RÕ¼$¼hbFhy¹÷ü'ý³[ZpÅó¥ÆU<ëÑ!/Úb§ùèíæºØA=ë=¡çËHW=fd`TaF¤2¦fÆ þjUÚ¶¼¶aÏÓG y\Qy}Ä¿Tß8ÿyN22IAÏÄÒ¯¡a=èõVÍB÷Dß=d+xïº%à|â4é®Ùäù#j>K¦>G¯×Xy êÚB:|PÝ;ïóXÇµ|Êÿ PK
+   f@qG8Þ¶Ý  ì)      org/gradle/wrapper/Install.classY|åµ?'»ÙÙ,Ã+ÂÊkD"y7IØð0 êdwì#îÎD­ZJÕ¾P[ÑV¬b-UQIÐ(Øj}¶ö¡µµµÕVkoëí½½÷öÞÛû*÷fv7dâ/¿ýfæ{çÿï|_^ýûÓGh! >ÎÆ'"_4iÆÉ§ 2¯ðñÏ(Àel4\ÈS¤à" ;¸Xé
+4gÈü
+Ïòóì ÏaMáÓtÏð<OzJ¤9SáùÃã\Êeªãrù¬¦Rªq\Í5
+/ðóBÉÅÏK¤©És¹{ b®õó
+y®,àsxUÏåóx«SxuÆê¥i¦Q(¬
+çûy­ô4)|Âòs³×IGKÎãõÒlð¼QáÖ ­åñ~Þ$ÏÍÒTxoUø"ÛdÒ¶ ­çíjáÞ VáÛÂøùRù¸L*õ µq»Â¡ mçv?ýlø¹Cäí,à.6E«Ëý¼S&ªp,@°$ø8îæ+¤I(ÐNnÆ)w)Ü nç^YÐ'^à«øjù¼ZÞ>->¹Zákkê67oº´¡©uÓÆ¦Õ75­o¹tCÝ¦µLÍë»ôë¬iµf¬sÓøúx,ié1kIAòk|xg§`ÑOtÖt&ôpÄ¨éIèÝÝF¢¦ÙÄJ8ÞÄõ0Ól·MéqáÒ­[]uÉ¤må¹n6äÎÁ¢ÓÞP$4wkÌQ
+Éä:=¦Û²Õ¸Qh<áó­4c¦µéÒÑëã59¹Øe[¼õñ°Á4±Ù-©h»Ø¤cP<é-zÂït§×ê2L3]9o"H%Ý2Ì¤Åt¶«['Úav¦ºeÆc+Ê§ñ±¸";ÎTvÊ¤ Qìf{J¾7'"Lò1ÃªÙ¼±	Sr§´vé.kME&GDõA¯CwóÈn&µ)ï£Â0KNjôy£@Ei0YL Ú²l3»å¦lnYTø3ðC©¬#ÿÜÒáTÊÜÉÓeô2±_ÛaÏ"Bf9ÓF(0­¾u&pÙ`vIKVv²<bÝ)t=QU|í©A~ÞöÕ¾ö>A·t¦0u$`>JªÕö*ÐÙiXu±ð#avôåÚjc<H-¡ßhõF!©8×ÕF20»zÃfêLrV`<RÓlÚzN}Ý(ÐFÌ]9Û*Y»Ë=õ]FhgR|³´t´´'ÕqªD/ÀzÈJéÛÓÉx*2lx3z»eíÄTÓÜá«ªWO$æ!f¶´7bÄ0g¢)h5;cºJ£]0¦I¦'«± ²ÄDÔL&È¬Ô¶Ëd#èw°a7zØII+OYY Ú¬×ÄQÝ²ì	ÞRèt·#=çuC".ÉvuÊ8°¡ÑÑdÄóõÙà[½¢)T7;%à$µñ(èw>êãÑ¨C©XO¬ËzÕLn5cØ¦ µ§´l'[tYY6"¤Ó¥0QI¦ìíòâËêb	Ð²Ý5ðÃB(?»Òâs\c)×ùFÌJôe}aÛKkeDÍ8"ësúµÍÒ6dcP®)Y³8rc,5²I\¹2øGsOCtb(ÞÝªK]s»TÖ`-&OD,ÐmÎ[°`S³ëÙîÆòzH³PEC¬
++÷Í2ÃÊuûËÖ8BÐÊ±Ê­2´ÖIsKÖ¡U5ZÛ/ÅÂâ±æÕ¼ÞÅC\	cvwn´dH-³¶²¸ÕNçâÕô¼j¦ÒóôJ¿¡wU:Lý*ý~¡Ò =£Òuô®¡kUzUéF¾ÇTpÊ¢Ïª´nPézú¬Â»U¾oTù&Þ£ðçäãfoá[Uþ<ßíùÄJÍ¬Iè}Aå/ò E®èÖµuU¨Sþ²Ê{ù6vîpzAáÛU¾¿¢òWùN÷ñ]È.îeÂw«ü5þºÊ÷ð~ïåoHsÊ÷¨ü ýÁÐâ©eFlÂfºì|['-·VÐæ$çká¸ÔbqKCAjéfLÓc}À~V­5¦7_ÍkHäÑ}:Ò§-ÌÎë«F1Ä}ûåèVù|@öÊßâýL;N(Dw,âZôI òÃümî!è GåG`î²+-3d§]-Þ¡¹ÉÐ¡ÃAáÓKb%±6ÀÔuNTïÓºô]Ön1ÍÒ£Ý²gk=¦ÕU]³KôDT³ºt¡Íw-ÀçkÝ8Z},Ý'¼°U¥ÁVÚÔ­q¢#%héØìÒËµD<ªéH%Å^NU-i¹Å¦²ªV+IÄ2QPî¬ÅCéò®ÖvÈhuv6j@åG©|Wø	Çæ~ìÖC³.Ðû$}ª<@?Sù?¥òÓò6Ñä@»K¡ÀçlÐ'ªqÁ.S~çº¢qÔ!åKªü,ï*GU>ÆÏ)ü]¿'`,kiZ«aarNëªç´x¢Vè{^áTþ>?ÚQSÐe«vÆT~_©^æaÊz*¿Ê{PS?$^ËL^°©ü6ûãk6¦òúx*¶C=y±[ozRp¦É¹XbNGÄ6{ô%ÑÂÁ_:b67!(ñduåÊ?ä×þÊ?æ¨üS~c=N%¨ò¿Å?GêZþ¨ô!ÿBá·Uþ¥ ãWüNÆÒ£Ê4óo;3G:cý°úmznJÎ?¼+nyO¥?ÑG
+ÿVåßñõ*¿Ïw"·x[@ùéGÍ·hìågm÷åøå²©¥MMòW(qÊNRiÙÈ;é#&å³§º¬µiÆtéXîD>ÑBá±íÃCV½¡b4yÙËÝ¸ònµSVÎ½$óééãLëÙÄF6öÂP
+?fÕÔC8Ða×Îæ
+g|Ì]ÎÌPßÖ/þ]Îæe'¹â¾ð&·¯.kF©î°nIù¦¾pZoi\Lì{ÃqV|íÐ}IQi+Þ|8±tZ]v/±³0gÖ½b©<±®nÓýV<#Çá>2ÑnGD_ísÌ(êÛG»ÇU"7Éä¦2i^	zà²QÆÈºÛg\A%ÃNNÕÎaÚþºöd<²§ád*øÑ-"÷
+`¤:ÎNqé9ºå+"WKF¯i{Øñ8¾ìÔW W3hûæ£lÔË83Ù)Ø 3Ï8ùXLNõz,C)qVêr	`çK >a[2×CwGuÊÆ¤¶^ûdsJðÉÜ±Oxr#w\`ebNçd«áWÓÝÏ÷¢Õ¡¡ôMôú%íë cBæ¨K%ÉÙ;ÉÒ¥*Ó§d9$©[.©6·fÿç3°ÂÎÍñ$NC<rç¸òPPA½ë;NNMöõXÒq¿ë-Q°4×Ãoe\R]zr]<a4F(23 3.fôZéÏf6fÑ¹éòEw:·±Á!7º¬©ÉµÁ°¨áeª-©#q1j~2»A§SQ>éJº®ÆW}
+åx÷B9kÛOí'ÌxNÁÜé&´{ðu(xñW>@åh+7^ õ0/¯8LJyåaòW¦	lC{ùÐÎÅJ¦ÒaÍ¦¼I7c¤Ü¡I·Ð­DöÈÄöHg¿\ô~¾æHÁsUE?M\fRKù4/k½Ao?ÖæËcJ­ýã¾AÚVôó++ª¨¨¦=GÅ³:r%d­¢TÉØr®u¸eå\E_¤/A¢|:¾L{A%@Kè6Ø×µåt;Ý	Íf@Ï}tfÍ¥t7Þ|ô5¬öbå×±çUGnB_ #7N?BÁutZ[Å Íhñ,óNDÏøkó¼yûifU0¿f.óyï9þÊ`¾§JÎ:püÊ~]-ç´V«xùüAßÑûhÁd:ôù_sN¯-ôÓ\ï½4.¨LZÐOgl*Ò5oën?8þzPé§!³¬¡Éh·Bìh"µÛàÂí4.¦ù´ºÎ"æÑù¦dÐeÔA&uÒhûÐw-Elv@ÁË°ú^©. ¥ôºü¢tÖ¬7Ðý0"« !ÅDÚEß¤0k!%é!¬ðF¾EÃ¬«ÀõÛxóá¹Òwà¦\?B¦óFj-å°k~KÕSt&Ã7Ói~[a©÷Y*kóT¶! »âF+Jö§«F{¢ê<JÈ +Ð& s M>»¨zsÞÕ´ÅÛoÁ"yX¹Ñã ÷Ée§{DO®N©?­Ó³°pm¬zêË+¨¦Ö[%¨_p- n-\¤Ø¢W´¶yÑ±¸µ-¿ªµÍô*µùÓÁÓRïZ6³sm§\×Ð88b*"1X<¢l òo¶cÀ> ~>f¨¼ÊV³1«f#=eçyüçÙoOÛq«Ô ä(õ<%Öêi9°|÷Ùûh1µ-UGy=Ëò÷VU¿¨ÖôõÓ}¤V}OÑÊ<Úº;H~·rÈ7³m·A­Ûá;¨¾°þ*¾ÎX /Úï·t*UÀºG±~:p~ÌFÝøô9¼åpYëÒ~ôx//ë=§çIô|×6í÷ð{^pÒ)¿.èÿ:gyRq[Eáª:w·Òym¾g©®ÍS¸®+¬ãà¿ÖjtòÛä7¸îü»è$8eÖÂXMôÓ§ÄÑxôSs?­;@k©¥mÖ·Éütá mLÑj1ßæ¶ZÿTT
+·8Pú[ûiëVäIµ iÛmxç¼^ÜØå2ß1¹^CÐ½ñür<@qÀv	£ÝëßÝMç~{ÆbD}-â~5Ö´#Â{ç×!¾oALïGÄ<(xö~´Ãû°ôaüÇ Äw ¼ßãK|Ûpö ¿O/Âê×aûy^Ç=4^ýà Wé5x¹vÒèð²d×éGè;l¿ýØöYÏ¨ç§ÐôSÚEèyÃv\f¥7ÎmøØVxéºìqÒû©½¹¢0ÔOá¼(ß{Ðs0z6£ÀÏ1´MjDi4o&Ð[vXåÉyÏR°¹¼Âj<uU³*±	^nÃ«rÖ"àk¼²`[òÜíXÁÔCB8ñÿ"ôX½`x&{)ì5$üiÔ¡]	f½M¿ØÐ=Xs&ý
+gÍµ~m+OnûÓ»ÞEà$A°w:d¿ëtÕ%éÙôlâår!v:pì£bÑ¤R>¢Ð¥b@éÄ»ÛÐ@ôJW2è Kà:@ãà§Ê±Ço¦»¤Óo¿ýÇA£t9`AøYö3\x7ÁJ7Ø"ßÂèÛ4	z¡ù<èX	-Ï¡÷1ß¥ßÖ(Nÿ J@ný#h}:ëAé#TÎ&¡yØjß£ßÂ¶;°Íþ«%ÅïÍÚq/}Þ8öªÀnê£AÕöÃ!{&·¶aüOààäÖ[Ð')ìEMÑRQZ¢m÷nPYeW=ÿ`èE§FqAûoPö¯(eþåÜß êe ¢YK Ö[Ä(ö¾½·Í±wl`RLÿdçÓ¬üôÏ îØ9<ò
+lhþ¡RÄga3Ô)ô/i
+ýkÚ&
+DÍ4»·ø_éßÓ!R§ÌÊÄäNZu&8¤±ø? ëèÅ¾S[ü7ÈY\N>»üp_í¹/«ÏÑ
+tþþÇ÷àéü/ý_ÚÌ`I5~õ°ç+%§hñg)ùAÉÙÍý°³³ûéïÃwsð9ÎäêÎ<w6ïÎ»rÜ	¬0s1Øö	Ay,<óØ:@ònÝÁE¨p¬²çÑÿPK
+   f@qGÝÀLÄ  	  -   org/gradle/wrapper/BootstrapMainStarter.classVY[ÛV=Â²ªÀl1pÅNSJ 4	°`:¤°/FD¨,è.iûúÚ¾6/¯|Mßû/úÔÑv®d7òÕw;sÎÌ½cýùÏo/¼eøqWF/f$¼/aVF+ædÜÃ¼,òaI1ËXáÃýz<àõX0$£kÖel`SÂõHp7ø°ÅÇõøPÆGøXÂ'õPùr[FR|S¡ÙÓ<¡ð qÆL11Í`+¹Ì6³ÖÔm$þTõÕÒø¾ í]-+ 3­t4m©)EZêþ>³¢wMÓÎÚ´YV5#n«Í¬IÞ,_
+èmÅöÔ5ª«F:·-ÍHOºÍÎi:tð¨V"´Ô0 »!çÍa¹\~X@«]T-B4Ú3ºÍÆL5ÅHpOÌ®¯ÆJTüpP;"Í%±ÍõËÌÞ5)%ÛÑYÒº:²l/OÜÑ~1y­n§¦¹çÙÃ$Û·5ÓÈJà¥ØÑTLÍÉ]f9dzByªd.îhNuTËê'[Uz¤Ôi´ãfÎJ²9çT Vá"Ü ®)x·t\:J©FÁÒvhØðDAö|
+KAt'zèEÜªEôãÈ=gÏ±(ÈáÐóÔ­ì)xCMçâûÛ{T		G
+>ÃçEd4Ð×µmâ_â+Ïð5ñrÃÃFyKÂ7
+¾ÅwTìó «9ÃÖ2ì¬`fgÌ
+¦Ô©ì6Ú»,èR}ï¬5£(Nimm;Ç=²Ïñ=öÁÿù´è+AäµÍõU*tS(\zÝ&Ë+µP°UYÆÈ²­"×ÅZ·¦?ÊÚ,Sþ°*O8¯ÙTTïp±#]p7º®íZL¥gw)³¸£â¾µ,¬+åà³Ì©ñü;C¯× ÓºðþBÕÍ§`Z±%Ü®qf«êLøUãÊE:jÚq`>¡;|«4{ßËÂDáj¾6R¤º\Ïa(\ÕK$"½¢ò\þ³&ÝT)£3Õ¦@Ûj¥öÜ1-2ª X#5E®é|×èÿÖþó@à-Æë´Ò,Ðì:ðuè£Ñç;ÐO£â` ¯ÓL!²âÿ&;æÍ¡cÔ­ÂðæáÍÃ?Gý1&ÄÈ1×¢_ÉãÒ7àõ_&ëÆ§Mñ<'|@Â3LûÍZ§Ç	 p´ïÂ0®bÝôÍÐC ½ÌyJ&_1ä@ß$ûìÃCÒûC¸4÷á}xÉWnâM²+vuon$"IÞ&/ôOPÈÝ1EôÑ¼tÖÄ°¿ííyt,¼ömb÷Ïèiorªy\ñòèü	¾÷×ç¢ðË¿¢+á¿Z$|îcôüqVv
+
+¤Ý(¼AëqÊ=§:MawÈxqê1):×Läß%­>®ã=ZÞYJDðßvâÜùPK
+   f@qGHÖ·$Ó
+  #  (   org/gradle/wrapper/WrapperExecutor.classWy`UÿM²Én6Ón¶)),%mÒÍEËÝ#ISÈÕlÒ¢ÖÉî4YØìÙÙ
+((*¢"DE­·Aé¢Åïû>ñÂoð÷ÍL6³Ûmì÷½÷½ïø}Ç{ûäs?
+`½òã-~ÜÀ[(Á~ÜD¡ànY¹Ç·p¯oâxg¸/Jôã]ATã`9ß-Ã{d8$Ã{åôûdx¿°| Ê÷C²òa}$ùÞ/ÃGø|íÃ2Ë0+ßex(å;'ÃÇýx$GÅÇýAOËìS2ût øñðûdöY?>ÄÙ8Àòý| _à|)/ð ¾*ËOùñµ ºíëòýOUâøHù¶ß	¢ß%ßâûøöÃ ~ñü4)¨ßÒîíéØ=:Ü·{hxp¨gxdLA¨ï2m¯ÖÔRQËL¤&6)XÒm¤Ò²vhÉ®`e®ÎhGBþæPçÈ6Ïæ¼Íè¶ÎÝÎ<kwt´_Áò]½C»£#Ã==;âÓ¦1­VBO+Xæ±É¡Ü:Í¯ZàÚHÒþ*3at-îÓÌ}ÌXÓ+'ÊF¡szZOÅµq±<f¤ö$&¬ë3Ì	S'õ}¦F&³c§óí¶y2¦f%Õì1Lt³¶$Ly@ÁÅÍùVWy<==ûõXÂ¨Â×mÄéXu_"¥d¦ÆusDK<Ü¡	¡ÝEÍµ!¡u®À¡Ê7'R	ë|çµµécx°CBauíý1}ÚEÇgM&½ÆÅ9ºlÚÔ§5SßH3;Ç3"dÔL(8¡y£ ¥[£Ã½¬´1cñ^Ø	æHûñsÆßÔµ¸-Ò5Ìá<zN¥1ÍÒã;5®Mi¥9§l$¶Î/SAE|AXUÒÐâCDmZ[ bêÚTNÏô¦£Îò&?~Á¨OèÁ¼,TÐÒüBRÖ¯Û»K/=º%Ô+-",º×eíÓ¦û5ñH3%qÐ§D¤¦pD*h8BµãEä£FÂpØ¶Sô¹ð¹`¼×6mÜºböªn90 s[¬¤¸¾GË$çûí¹´«¨¨©_a×³
+w)(Ûë¬c¦ÕH§É·àl0j×Sÿµõ×.ò¬þÿJ¼)® ¹ß!Û\²}¡C«Ä/©ºXMÈÞ¯dH¨ø5~Ã:]px8²Sz®°´º6÷ÐpÓtS8nLVXßÏÒigÍ,ÈîèÇoU<ßÂß³jY=*vãe*Æ°KÅ¥x±à¥*àJ)*þ?RYÜS¯]ZZWñ'<£âu¸IÅE]ÇfMªøpüU6ë¼ÑIh43¥âoU<+lêé(£¡;þ.»ÿÈÛpÿS6þ%5Ez4ì62É¸ô²ð¾"ÀÆl»Àõoøúü_<§âyÎÀ`·çµî¤üúù|q[´°./Ìç®L"ÒögÌä0+YU¥ÝQ SJ=ò.ïÐÍ´íÑ2ïjwRcìI`_;¡QR<3F~oWðøqÓï%ç.°¢*r5¹F7µ
+-\s-m
+k©xþÎµMíáI=­÷%Éð¸6õ)c/¦#ÕJê{8vMnÊk­}SôiÅçWÊ½r·
+þË½õê¹bNÅ¯*¥Â¯U¥R
+ð0üª*K*¿R­*'(Kta»¹Ðk2|¹~ÀQÖcbnÍyìX'z zPî÷¤aMîô¬zìwÔ|åESÚ,c¹]ìiÜWò+9Ë½xÏõÞRN(Þ¾ëÝT_.¼¨6ç?M«¦à:âeCl.ªª&]¹PùÑ¼ÎêÞ\;áVú[AÚvÔÓ^ÂÙq»;9þ562iûrOÆ
+Æ&u©ã%róÑ²Ë$÷Ö[xÁ×åØ£N¾Åxa,³âÊ¸jöTAÛ¢ns·ÑÈýió¹±ù¥ÄQoÂÚbÏc§y¥vOjf¶éyfåýYZòöKJ:3CÖ\ôhçUK¶Ç~a112[ö£Û®Å>$
+S±K´Øv¥-;Eßîãþû­D=¶cTT	ÖñÐ+HzèÒ;<ôÉ¤wzèSI¿ÈC¯EHnvÎCr¹Û_Þïö×>¿U¨q@9O+ç Í¡d,*oec³(oÆçXÎ3@3tËSØcëhaU`"';¿ÍÕÉ"pVÌ¡b,ô=Ê±ÒHôA¨³XòèUWR­ÒF:<jÛ\×dæ¨¼¹µÊv(ãÊldU]MÑ'ÆÒHëa"-Qi;Úu'nki}u¸=eY,·§¡òÉ¢~+³8ÑYkpÖVÙk'9k';kabvJ«ÅSÅFq³¶ÖYk²×¡a£Ï#âÀÑ"pÔûfÑòØýtcîÂ=Xç±K9nëÕ8µ8Q?'á,®Î%µ½ØD86ÃÄy¸çSF'¥\{q!²è¶<ÐÜå¸SABS6³6¨=*±go)ç|r¨ÆyNö	XkQl{õvæ<,Ú¹ÒÁÊâ´`lm[©ý"¨´t5.ñ´Ñµ¢ù=+hIÊÇoûVN÷v{ØC¡õYl8¥s8Y»~gÌâÌZuVaQåv¦è­RuD¸*½29EÏ2ÙåäJßÎf	KYlmâ	mv©ólêü<êºCÑEÝý­¡-eNöªè/´>EÏNRµ­Yl}`ç!TöÛîlÛ)µS´¯fr)±~	ÕÃõ³¸ã,ocå½^\MoÅßýëg¢ìÅ>òïeuHðö\Jðjì·ÈAùGà¢ñJb!á[5Þ1|qí½¿¾CÈ·y[B£ªPGÆ:Æµ.SºAÕVQaÙTÇoáÃ6Ô«rE½ÊÎ?é%µx9®²]wÌº?¾íÜþ²_	eÀ©­þÂNñ;àºªÐkÜóîù29_xø*Ïá²ÜákqIFK	µ:Ú6úÚZêö÷dß5ÄòZðu¹r/»^Eô{v=#RbÏ^×òlfßHP|9 $þü7â:°Ù-Å@¤Eaï8¥Ðë=%Èiàv¬EÒM®¤­TêHj-&éFO $³7rVbË¼Ùy©2»Q°XÙ6lôÕû ¼Þ7Óze­3«îDEù½mFYÐ·²@»XMY!¼ÜÂñ6&ÌíÜ¿ÃccÎÆ-®-2{O+)aØFëÖzCîõÔ`7â¡2·ùìêt¯§îö ÚÓÝàêVh£ðßþ?PK
+   f@qG¤«²
+  B  *   org/gradle/wrapper/GradleWrapperMain.classXxÇþNÚÓjU8	¤ÃÔÎ±ÀY  fm¼éðéVÜíQâb§ØÓH±8=Nâ8'ÙMì'NwzïÍé½;ùgwu:Ý-B_¾Íí¼yý½yïO>óð£ Ö*¶á.ð2¹¼\.¯PðJ\W)8ãÇ«ýxÜ½VÅëp·÷øñzoPQ&±ÊðFyx¯7áÍ
+Þ¢¢Ò¿UÅ¼Mò|»\Þ!wª¸ïRðnïñã~	z¯åx÷«X¨X³
+PQ#¹Ü*øª¨ÅU¤1!¿&åò\öcÊ¨ðã¹TÁ9Åc*ÇÇT|PñI<¡àS
+>­b3Tñ|ÖÏIÏûñ__OÉÃ/KFOùñÉè«~|MÁ×¥-wÉå~Ü.¿éÇ·T|ßQð]?¾'¿¯âø¡\~¤âÇøâg
+~®¢¿¨Úy µ½«ãpoÇÃ»zº;÷ìëëìÙ+è:¦ÐÃ1=>îµÑøÈ63´ô¸5 ÇR@(¼½£¯µ³«£=Ã§ÂEÙßßÙÑ.Í#*ÜG­mëê|mæ0¥uEãÆÞÔØ#Ñ§RI3¢ÇôDTî] Ï&ÖvðHBá	}|ÜHwÚÛAg×­Gã4Ê7Æ_%uòM¶¥ëò«ð8P]Î»õ@©5Ã;¢1§¥ã	VÔHJ0M«=JÜÂq=4ø±:[ÏH,n3ÇÆôø°4vCFE3~$Áe¹½§1¶/#*AÛ4y(æ¸eü<DÚr³è^ÌaK9ö¥¬h,<v:¼ú©ì.svÆÌ©ìE^Qè²IWæB:Ne¿Æp6t{Ç©1mN><ëu³£1{'«:bWä ×çÆr«M¶òº<4A^Ë`Ü°Âý:{OÇ-ýTFaâøcL[ùIUºÒ3`$6Få´«xÂApîUII3­IâúÀânññåIªIEcÃ·2h6ûl-7Ô]8MòÌß>/¢¹rBíµÍpîË¼Û,j¸×jÁ-nÆMá&V£]$¿ÄÓtU®;5þ;¤M)b62)4ü
+¿Vð¿Åïs\ àx*jÐgÿ+¨á÷ø?âO
+þ¬á/ø+jæBíÒ£Ýú¸¿áïþjHâ§ñlîTð/ÿÆz¸¯SÖåXÎã°Ý<ú0ksrRÃóqôâ3³Ý6M±O·F[Ic5!ñþË.@­òU¬iI^K·B,`ªe§Íu(gÊ¢d»P>MBM(¨ðS5QÛXF®a¸5ÅÙ$BÅNc¹OWD&JE"Ê5±HQ¡J±XK4Q%ªé´9î+ý=/Rq+:fd¥AE,ÕÄER_ßQ©eb¹À¶6=7­Ð°Aw1BLÓ³¡£f"äªbçMc¡Ü=ij×$kg¥iÏcFÄÒÄ
+±RJibÛ7¹)á\åY>Z-.fh÷!%ä¢¦«UHÅ)¥Ò«¤k¢F¬ÑÄZQ+°<ÜZÛÅ&7"Ñ£Qc8³"ê4QkY=Ê#×f¦H7ÛCÓ>qå5KcÑ¨u¢×QmXà6E¬÷ã:á¼ÅDRoí!3OöÇoóôL7ºúù4ÞBÓÕ÷rÏñ`=Óut²Ôã2/Õ­Ô·.¤Z¯	FGR	^¬5ye7ßÙò
+ì©c¾ÖxYdvÑc+1¬ì®X=Ý±òÅc®G£ÈâÂÊ¸¥>g/¨Õ*«^ .Æ®¾ð(Aeys;»S­v{N¶é­ÄËyÓ»åO,³íÍézù±ðEå)]7'c¯V1Ý<OgU~[bØVÐ!¼²ÆSÓ<Ï¼º-çâó»;Ë,s»ï.&PLEÌÌOùyeg´àmt2¡(³-Ô°öêrdÔÆxL£J"ÉÍuó
+£×0W;?R_6míÄ±ÖYl¬í¦óY=}]"jçâPì¹1?È·3ñÙÇuæüªÏwÆ
+GN]©737;-·kËô¤àîY¨,­8SNÈÕÙÎêM'{80I§¶ÞÈ¨a¿Hã)=F-Î&wëúD`!ÓÇ+<qÈÆ+=hí;d'5êë@Þ¨^ïEwñÝçrÕuçRZñLA>ÍðùyÏV¾Â#²e4Ì£³Ûóòj;Ã7Ýÿ<ÝÆlõTýB¼3ríü0ù £ÃÜÿÒðpwÎzÝvæ©qÆ¡î`ý Va¶ð!rD¾»(â~(k¯r0k_Âý¡¬}))|Öp½0ä¸4L@<`£æZhWàz® Gø[Ebqâ	{|º'±°oï
+&PØâúÒP¾GàZ(êòÔÞ4ÓÐfÀ%\*ÁS(#eyKA°@Ò.
+úÒ´N¢¢E	*N¡(ÓXFU'Õ-þ ¿iA¹YÚR´.X4ZÔ Ú0eCÁ¢),çX1MaÕPÐ?Õ¸x
+5äµ&µ3ïFë:z-m­¥ÃêQ,G#.Å:ìB3öÓmWc=½³¡§°	·b3nG^­8+ñZmï;"ÞQ;|ò99Já!Dù%Cò £XH9÷ãÄµÇ18½~=½nK!9\Kh
+eµq(Ò6ñÑ"·3ÔëN2"§l9Ýüæ«Ît¼ð·¾BíPC nõ «\PchÆ!¥ThG:è¶QKV¸JÀþ:f¥Ê²+ð27³É®Ñùw6'¿:³ò«ØöÈâæV¯ÊV8uük
+4Âi\2õ¹ìº³ØUeØñõî²»®zï®À46¦qi¥±iÏ}(éÂæ¡Æ	\q2Z[ÒØzª%0p¥ïlZØÐ;íxÖ9WÖ	\uÖUNß\îj²2^ÂíC%ú:L¢«yf¼WÉÝç¾Ió\<p¿|-»º>ÍðwºÚÒhßÓðJl}:%v0uwv5R]Î4vw¯ÆØ#1ÖíåQWÓÙyº¾s{ì³½¼è=çÈ}%¶ÐÁÒÉmö/°ÉßÍïÝö¯cÏúü*¢æ%,UL¤LÅ¦s#}¦¯`Ô·0mw3a÷0Y¥ÐHKo§í²Jµâx!á+	}X³x±£$îpíÞg§.ýØ(JcßÝ¨týi>DïLäì´(!¥LÿXa_ÉÝÂ.÷Í.÷Ò)ôi	%L ?7nÌâRêr¼jë¥ÿPK
+   f@qGÙÎx   ´  "   org/gradle/wrapper/Install$1.classWkwÕÝ×Y<IQ0 +ØJ	$NB;A1!NâÆM[ÆÒ 3QG#'¡ ¼Â#Ð¥whKZ¬8¤v­®Õ~ìG~ edË²â&õZ>÷Þ3ç³ï9û>ôÏÿ|rÀFü}ºqXÄwD|WÄ÷D< Â¡cdc"Cc2xPzù(Æ¥µD3!â[Äd£p¢pePÁ÷£ðÄºh¦ÚpÇÄà¸jÃðÃ6ü?ñpúÑ~Çbx\ââ(â)éñ´Ì&F´ÏFð\'#x^¡}Ê°;m7kØ£VáNË6Vd&)#m¹i÷)´MÎ*ú§pYmäYc%ßr=7É1ýô}´JÌ²®ó /yØ)te\/Î{FÎ6ÓG=£P0½ôHÐö×r~¢1Ìð¸Ñ»iópiR!³'¦çVÜ*vnPèheÐ)úmÝ6Ë±ü
+'2\f£ÚZ/zQQwTÐúÝ³¾2c9æPirÌôöcRxFÊrÐð,W¬R
+ú ã0m&5×,±Î\·Fg,T{²«±¾1²0WýPNÜbu*\2ûvzÐ7¹
+×óIÃ;bzùrÇ4sÅ÷¨c»FNAï2æi/DÖ^ç&Ã
+Ïu}ÕWx¼P[åº)ÛBÞ!(vËÉk1¶¶®J~ï0³iÙ°w¿äÑëÎÅuqÈÕlÉóLÇO÷3S¤YØa·äeÍ`ñz5¿=bÆîv²¶[da÷þ¸Ësà§:~ulÁV°QG¯[p«MØ¬ã6Ü®£/ÑW}(/c·ÂÙU²ìééø9^Ññ¼Êzõ¸GtLË¸¯éxoèxSÄ[¢{ï({
+çëø¥¨_3Z­btºN<ý&wu¼S:ÞÇüVÇïð{â:þÓ|¤ãOøsë?eìça0`Ú¦/NH&ÔõÓÝÌFpVÇ'8Á_tüç¹ÎCV¡ ¶$À:ß¥á§øLÇçøBÇßÄå,ºc)M5TX³d	r~Êi®¾pÍz¦áäÂ¦EÓ-¾ho²ÇçM¯!°âD82&ÍFÚÎfâÛá~êN695©ª¼àÄ¨ï*ëÍN­Æã§Í*ÔJWËÜj+sçXÑµK¾¹×ðÇ#5<g7ð¤Í\ò	Údó¹jÍ	Ìù %Hóì×4½R2n>_ÉÆìU·üRÙK\ÐSc»LêÍêqpr¯@Þvék²ï;`þææºkWÑ
+®(IG¢íwy#7ðA*]}ËÿÝ0yñ¡¾b¡±­ê¥Á>ÙÕü2/Ör{Å!ó]hN¥©Á¼U`v_
+L®ñ¦Ü¼Ýêu·åüÃF¯ÏCÛ$Ðî¿hõÌ¹Z°YôýßozW·]råÄ!ó¨¨°É>CÒhmo»`Û[myÃUZ^r÷\¥åEÈçtÿ}ØÆÙÛÙÛDØÞZ?ºy-©îR	mZ*A8hAkê"Ñ²;([9|¥^éßo¢ò8âMB+zoñ¦%Ô[ç=ú-e,;Ø¡3hFzËã+(ÊXyjCe¬ÆõeÄ§±
+%ÊàÃe³¸üt03þ"Ú)h¡íÓXÒÿsþºËX=">gqeÕ0~?S¥ UWß¿!ºî³è¡;p¶f¤f×ñÓZ­ZB;^ªÓØ.½k>Ctk¸!ÆusjDx×úï§U¿4è,ãÆÿÖYVe¡¨-£x2ýVfW]þ¸À¿­Z%´6s¼~$¡®°Bª:Õ½HC[È¢¹s½ÈdÍIòæCVö<­ÿø7vá+ô«8Tßkqºj÷¨ãÈ¨Ø£^Áz<¦ìã¯ ìÝI¦8s=îb//É»1M¸RåQRMá~U8¬vá^bia¼a¢çU¸_5z|»~÷Q£Q3Ü¾~÷\ä^QSeÜ|z	"« æÜP¨ØÄH¥ýU¾âÛL øs;¿¯PK
+   f@qGj j´  V  8   org/gradle/wrapper/PathAssembler$LocalDistribution.classR[KAþÎfÝÕt«qµ¶Ú[´ykëÚâ[KA!´|(L!NºÙMÿJÁPð¡?ÀU<3Ò¨|Øsû.sØË¿ ¼Å«9Ì`­OMôÌÏ}¼ôQ&øm5ÈT0ßè"VY¼¯ù~Üª+Mðòc5¨ì6îÄ-ÚiÑïKùñÞ` {ÍDjÆyTªò½êôñIÑÉlóàÖ²¶$,4T*?{M©¿	ÂFÖÉ¡ÐÊäã¢km¯Îöµjs¥à M¥®%¥ydwªµÊ-~[Øùÿ%»Ruóæî<Ç[5'_³¡nÉë$Ù6¸ E<`=Àføõ±AxwìÆZIDÚ?7»²
+U³Êò46¬óáñ?S@h<pC@©d,Úoùçì;¸|/G[#PôNôzBôf÷ë,QÌÔeÔ,!A+efc,ùc#£n´ae¬óM|ÏDç(þ#÷lQ[Âàz`LHx|'Ø½	>¹ìà=WÙ-øíÄüºPK
+   f@qGcJ  K  !   org/gradle/wrapper/Download.classWg~f³»3;9X(¦lî"
+´Ô$vÛ4Á,	]Pq²;Ù,ÝÌlgf	Tm½ªõnµU¤^[¶l(ÐâUT<Z­V[üüÔçÝìVÌ/ù÷ûÞã{ç{çËÀvüSec°9ÑÜ/[eã(pUäqLÆ¢
+ÇUÀ*>æ#bÏ*ÂGe|LÆÇU4ã*ðIãSbùÓ
+Qñ|V4Sñy|AÅñ%Ñ<¢íÇ|YÅWð¸¯*øÍøz ÞÏD»o¨xßTñ-T°SL¾-S
+TðßUð=ßWðOÉø¡Óø§e<#ãÇ A¦afuÇ1	ñk,ì·­a»Ãáèøá¼;on&©»-¡qÿÔäSûâñ#£wNOÜ-AIX=j«îÍ"J	«F¦ÇÆöMÇí£h[³`ÖJ§ZÙ8nÙé´­§²ÆÀ¢­çèq`Ü[ÐÄyV8ÌXæ¾`HÕéYÝLÄ];c¦¹-\µmÆ°vtqkÆÌ¸{$D¯ããZs×Jºf$øG­Ý7gLc"¿0kØôÙ¬Ô³3ºóÐïÎgÇMõïµÍ¬¥§÷IËË¤ó¶±2ÁÞ	¢Â³*)HØ-gîÀôT¬jÆËd/LYO¥lÃ¡ïÆÚ­D!e8nÆ,Ùn¬Õ î;4rbÑñ	ÍËnc¦kØ¦e<y;»Âð85óa§èÌül~nNë;<ÂÌüÂ!ÂoÊÙVZD7jåQRæ.Zµò®¶r<y7wzC_ u?sÄx××x%ËL#)å_ë­eýY­&8É|Vwéå(%¬vÕ£JÊôQÅÃL	®¯*NJK-¥
+Û,§HÐåTíä<Å­¼4DªyGÐ/ìhØq·ã=1¢aT4wcwÝ\NPC/ã§~g%ì¹­nþÿwW¸|NÆÏã/j8%Ó0	/i8äçrNG<@T56Ä¤BÕKÂÁEÑ¼,ãðs)ðèª8G_hø%~¥á×xUÆe¿ÁoeüNÃü^ÃD0ÀûàÏ¹FJÆ4¼×%¬)Ã=Y&®ÈrÚu§½J±_DC5©_Æ5üoÈø«¿áMÇëþ!îÁÜ¬ºVÀl*N*ÙrúMt£±îÁ¾±ÓètÚ£Î÷ÛU5ä«Pprö(é,ã-oã*¯0a©³«,oº;¶/§Îó[ºªhb:Ò[âÑ		[£u*c½kÔQ·ÞV"ð
+U[ù:¯ø¬¨áî5æô|ucUÁ«ÙçÙÐªùÇ{%ÂÕmî)Îoy¥ÈîKelÇ+­J¤k±¶T)Vj\KôÚZÖ¯YÐJú¼ÉL¢Y)Z6¬pQSÐÚê¯°17SÆýyò
+.ÛêàRÿÖÈUUG	ëª2T[6×Ô³Û^DtÅj(s`¾¸´:·ËóÚJ[Òüê«\Îêê½ÑÖ	£JLÿ91£V=F
+`þççS.o©V×í¸H¬4jH=ìíuF³¶ÜgÑÎ¸äÌ´Äb"¾n(Of-Ç¨½Y^bÎ²taw#_YêÝ3ÜÈ÷ãv¾ÝÞ 6`79â»Ð[9¿­j¾añ}á8,>1^?êõîÙ}lÇ8s¹×Ï~}÷¤î³ðu÷ECwßYø)
+ñ¬ÝÁvl7q÷f°hÇF´¸+ÝE;á.ï­ºÞó/y#Ï8æÇ®Áçb×ÚpðäËh¼ %!-!tjÅ{#w|ro¥×¨çQ+ê<J¸Ü-lNs·ØßÔ[Àª´Ý=½KX½Ò\ÍõrÜçk/ªÐIì÷\4á½¢fc?%8^v&ý)]Í«Ò4è) q0xMhNÐkËÂ`kEF×Ê¸5"Ðñ°n0Ð²­ù¢2¨v©@D)`}bgÈ÷$&Ï!RÀ'Ðú<6o(`ÓlN·,¡ýRÚzXß¥¶©kqãBèñShí~¾ðMÜ|Ð»Ô¾ÒÐ* óôöV·°-¸%( ÚwÝ}tÆMZýuY¬G´KgxÔ Nò þ]ôúb" ÄL>23wavb#vï&J»¹2ÈÑ¹pßÃÞy¡÷¹ø ÙøSù(a8If<En<C4% /Pã<e¯Rv²×({²·	 -G«ðfpüÏ÷ÒL/ï§Cx»3åð>ÊUVæ«e¯`öá->Cx	d¬~íMÌ"É¾|àX,H °×Hÿx¸T¾'ÜÃv"ÜËvÐî] Ü/º`x@trøfåelO4P«!ð÷ÄH Fñã	¥7hö±!mâçðçÊ©ïðÎÐñ½LA-<Þzu¹Çìã!D¦àêSÁO=uÓÞÅlaæ½)®o#?­à(ÿ´5D¨FÞ>¬^¼8LB-JÐï úÚAÀÕÿPK
+   f@qG'*P   N   #   gradle-wrapper-classpath.propertiesSÎÍO)ÍIUHIMËÌË,ÉÌÏãR)MUðË/S04W0°°20¶24VpvQ0204å*(ÊÏJM.)¶M/JLÉIÕMÎÉä**Í+ÉÌMµå PK
+   Y@qG`pÅÐÎ        build-receipt.properties5OAnÃ ¼ó*hcc¸äV©Ê%Q¯CdÀlõùudo3;³3;®~v§5uLØø .>P©&,Z ¶¨@@õû0BðõÓéQvSCVÒÊ®UÎö ¢ª{iÄ@^Ù-M íhC>eãfâ)OÌs4K¹¥ª¯f.Äîf3ßOQ#W~@°TNóëïÞûcÃáÐÃD²·lÉéN¶êgËöõ[åÿÕ]\mÏ#GSH>¼ñË°3PK
+   Y@qG              org/gradle/cli/ PK
+   Y@qGÈô<  S  1   org/gradle/cli/AbstractCommandLineConverter.classT]oA=+¶m­ßÐå£tÛ>BHÑhBªÒÄÇe×m`C£Âß¢/4ÑÄà2ÞYP´ôaçÞ9{ï¹sæÞÝ?þp#	ìèØ5ÁÏ÷By9yExÅõ\Yeæò§ZÝïpÕëña¯ÍEËjw	I7|ÛêZÂUû	¨ÉÏî¡Ôðc:Âêt¹iw]³ÖHaÙ²î÷z×Qduß;çBrQfØ¸Ìõµÿïè&DV«\%6Ý#Ç¹Æun]ËsÌ·¢XË3Ø»ö·e9H%Ò²¶®IÒk.Õ=,È÷-1àak^ÀÌÁß1½è¬)ë9¶(id0^}±y_º¾7Ð±Çp«é:%®ì`i6¢Êt*­ã°jºBL¨FÓ
+¿vU³Wõm_ÕIÂÀmÌu×D	ûI8Hâ7Ô¼&í%DËÌDÕ3ìqONB¡üä:ACvs×ÏúÒbÁÌ0¼\8´ùy ³3CEwþ&T*µÔôkYú+$@Bèß!KÍ¡5I»YF6V¸ ûANwh`+´&ÇXEìÝKH,£Î­Q¢ûFV#»ùJ#hRqØÞñïÓ
++dAy	¬Ó~#¨TçN*)oÞ°À»OO¢Sx«Î	86'çÇ?Æ?¦ø'äk<Å³@z±ÅV`·ÿPK
+   Y@qG2_e¦   è   (   org/gradle/cli/CommandLineParser$1.classA
+Â0EÿhµZvåºkCÏPEÁÄv¨-iIõp.<S\ºp>ó?fÞëýxÈCDèln¶àm­°ÈMÛJ]îkÍ'iÛu#ï0ßèBWëêÀÝÕ!f¥±¨¬,BÕâçy@wZ³Ít!éBI]ã¥á¢#¤ÿHIê9|gèß|{úüõ-| PK
+   Y@qGRB	¨  ÷  <   org/gradle/cli/CommandLineParser$MissingOptionArgState.class]OÓ`ÇÿÏ6º­ëd  ¾2½ c&/1N4Á`W¬5ÝSÒß/¼ñÆý ^H¢#ñÂà2§-sKÆ&í9OÏù×´þþú 1äUÄQ4%Õ«*gE)ÍD1Å5ÅÚuKD1Ç0ôØpÛÑí»:ö@Ý^3¹ãèÃ\Ù²«ÅªÍ+¦^Ü1âU«qQ)B÷ý&@)Ê!÷ÃB¶@n!²fU(Ai¸¾WÛÖí§|Û¤á²µÃÍMnR#îÒyd8!ª>ò¶]ªZìEGO*%Uão·uÒl×GQ²åü/\T®MnË¹-0·«2¿#/hAlu@tö×ý%Ö-q*Ñ2ßÕN¹wÓ e&»¢BµgsQ\g Ãó¾ÞÝ§ä-FèÍ¼&ãÂ nX{ö~Ï2zÄfZöCÃ Rò6¯AÅ	Ó°Îá¼%GA¬ùþöaª3ÌöÞ@L÷v0Lc8~£cs¸Cª7ð]Saf²=/êµb¯¦!ÝÍiúÅ!WiXN$!9!:"í>i!z&òì ¡|á'Âû¤Èd&Ïw`ï¡²8Ig£¾9NOXF×iÐ¥ ªäuD¾5x
+äRlâ(38ëqhKÎCO ÿp©:ïm¸O.í6pÉ '%¤É0o	Æ%r¶C?7åo@ãÓ¸ <=@QÏþ·Oîìbì«Ó|CMa"Ü!Ë°ß°°ý¶d^7UØÜ°Ë^ã¥t^EYÏ3G5Dh8%hù+aòVÂEÒ3ôD*öPK
+   Y@qG¼¬M2    =   org/gradle/cli/CommandLineParser$OptionStringComparator.classTÏOAþfºeam¡ò£`µZ¡Pd) HJ¤	±Þ¦í¦YvÉîø¯ÀÉ{ñ&Æ³ñÍv­Bkj8tÞ÷¾yïÛoÞôÇÏ/ß ñÌÀæjÑ± cÑ%µ:UlQÇU-éÈ`!?`ÐÊnÝb©HÇzÕ<®ZÞQµ)2ZqkÂ>Tû(¨ÒgHïÒuöO:²{|"<¸Cb×q,¯lß··Yq½ÙðDÝ¶Ì-MÂ§®½oy¹ÞJz-ÜQÓ¹|åH
+ÓNÃl#KÝù]:ãÕ} ^!üC×ÇÞýÞ¬\k´W=²jA©;¢ñ÷ËW{D9!¥×ëûùÅºÜÿ öeÃAS²õ/ªÍ@Úæ%·ºØ¦RÆ¾ÛôjÖ©n5ÝÕnIJ dO±®cáy_eá[»o9¾ä©Õ=Ó}ªã£&fH]çÍ°qÃiºR¬-Ãx/µö¿	ÛrÁaøhfúÁ2=BFâ=Y\	K»aÚdiZ_¸ÿLÇ­*ÈSHhpãPsEòD?!Fq`§pöºöZl{ñïÝº=1¡#Î[Ùså!®µ¾B{Ë./z Õi|þCÀG1ÌÇåãåÈóIùVy&$´ÖnRÞ$¦B;¸C'r«Èà.ÑË"{äi©"¿¤Llr¡ðú"ý.0Øêùõ3m`§Y(NÍV055QáM²<õ3Ýt
+Æ©`ò1<ñ³mcd3B£ä= Ô Ý`OùPK
+   Y@qGè#òG  K  1   org/gradle/cli/CommandLineArgumentException.classÍJ1Oú3£µ¶Zm+êÂî´U×0¸°¥ût¦D23êk¹*¸ð|(1IK-YÜäÜûÝòþñúàÍ
+Ø2aÛEÝEÀ9ç§=ú¡O©QzýTqvK9fUvÅ#¦ti¥æËFCª¸Éçb!ðàÄ*ôBEÇó{2©È
+³ôê9`)¢KàÆ,Ihh©¿\´xû¦&J>ùÖp1 Y¢Iõ¥¥¾ÌTÀ®¹ñÛúËØ©QcB óWì~Í¿ËDÊc¶¸Dyýfå@Ì]õtÓ»ÓîLA^ìý%«6uåVõ©1«Òú¥8(c]3«2gÝèy½»íÎñ¹°=Ý´oa³²ÌÃÌ©kqÓv×>PK
+   Y@qG?hÿÇ    =   org/gradle/cli/CommandLineParser$KnownOptionParserState.classÝXkxå~¿dY& V§dsÐ´!¢¤@L´ÚawL73ÛÙìÅJ[íÝ^Ð6V{±ÚzJB¼Ô^°¢õÖ¢Oÿöyú<}úß­=gfv³Ý°?ûçóïÜ¾sûÎîÅÿ@;Þ±w® %!£cL!XIòòy^l^^\¦OIcBÂ×à¨w1ô0¾X/áËLt·Lâ¿ÂÛ{$|UÆz|={elÃ}2¾oòÉ·d|ßaÂïñ=ÆÜ_ïã¼üPÂøø8? ãðcu°Âø	'yy(ò÷aàgLûó
+ü÷Kø%«yTÂ¯$P¬¤kXækæÙ¡m¯iêvOBsÝhí³ìÖ['ôÖXÂhí±ÆÆ43Þgú~Ívt»&@¹¯AàêË°ú<D]G`ñTÄ³¥Ìq5Wp¸}!ÐRÜÖ,z6u\K¤ø}µq­5åÖ>ÃqélÅ1bjnÊ&Á5wúûf´÷îbqî¨áÔ´]þæ¾L½Ó0·KàB}qòeF¡¸ç;zyÎlõXqòÖLÒ;¤Û´C	ÂDú¬Ôl÷2ÄÞXwiM¾U9ÑÜ^ÜÂ¬ä[Ù2»íÔnº»êóÃÕ°ÜT	ky|q«Ø÷íöëG\R-ÐV¿l«FtwæÌ[^Zßp«wâL&töJ²%FÀÚ¬¼ìuu[s-Î¬
+ËÕí}A*I/´ém^²åE>È	@àßÿéYºÝKá#m¼´óÒÁË^:yÙÊ}`	b(`VÊé7æëòhZ8h
+ö WÁ¸¡'ÖÌ²Û¶µ£Ügøè×
+v¡GÁVlWpv(Ø)èB·A	4.nS:véAø·ÇÍ	:WýV­ÖÕ:ujÜÒÕ´\ÕÕîÔUÍTÓßBýq>ã÷:¬ÇÈ²ßàI6ï)OãÝ¦ª%Ý£6uBsÔ¤mq=®ÞaÙjlÕ-N+8ß*¸7+xC
+ÎbHÂÀ¶¢.ßk8e9tå TÄ³ÍÓ$µßú *Á9	³
+ÎcNÁsxFÂó
+^À
+~ÇÁèÚJ¸ÕjFº£Nè¶¾dù/á÷þ àì?áBïýòQð2»ýÏxEÁE¼*°~!Å®ë6õØ£ºªà5ü×6¤Õ×¶#ÄÕf"z¯HxSÁ[,ümüUÂßÔbªàÞ¸ööj%¶¦ÕpÍËêAMËi ô¦/}ºâ½2h4ÔÚi-§lÓ¨Óo/ðFì[Xuôlxzª
+½o,<¡#î¨§«^ÜÐZ<¾;­^=FÝ5yè±g7ùeÃ¿§ÀÁ%8#ÿñ^ª+´XLwöÎ6jÙ=KÖ 
+xrá¥ò^Éié§ô¶/þ´å=ÀT¾qéÜ¼42b6´úü¡vc&¨é>Ü°ôhå0g|,eÅ¨æðÜCÞgm}C~RqÈâñùá¦l¹>hAdýf^]æ2gb÷V÷ö%%ÃjÝO2Ü!ïÇ·Lê&¥~sÁÁpfºcý¢9Ov­t³YSÀr\w	ÒÈ7ÚV*9dpÅ®ÎñÿÎÞ[ [³Æ3±¯½GÒ©7~vÒOÞrDx¤ (ÂS÷¥ÁÂûÒlá}iî ùïzK°»²³g:ù$íD)a¦hãJ¢b¥Ñ9gP6òhÓ¤hóÂÑêÐVD«	+ñ$ÞDëhÄ<Y<*ñ6¸JB­xâ	ôM'ÊX>öbàAlw±å¥Ä¶<­/#ëöãS%¾?:°iÊpdeèy¬.4pWÌ òÅÆi¬NGò	.oÅ µ§3·ØÈOAOõ§±YAx½â¬wu¾öÌúñimps`ãYOã6jIKxU¨f}³X'0sX?ÌÎÝp:Wõ*¾¾`ªóPÅs:Å¨<%J:<¥ høJÌÈ)g¼x)?á¿%m¤xINeìÈIÔeYè{­º ×Vðþ6úZ7õùl¢ÑuöÏN¤o~e:WÀ,Ý{fñV[EÀÕf¯kú§Qsêýùbj/  sØ<:JÇúHÃ4¢,m&fB¦A¼-þ¾umY
+6¤´÷óM®ãÔûÿ$PÂuX#^¦¬½H±·×0!^Çqñ&ÅxX¼âm\ðxÿïR,þî9¼Ürv²¢÷`nÅAýá3^ÿ*ÅÇóÀtÑøYÜQ	ªG-±M²$b´±©¹:T]6qfAñ´îñé2Y©àÕ·ð XPa
+âA)Ð
+SpWa`Ôë§á0>ê%Y9¶á®Ó÷!þìe}	n§/*ÃXOß¯ÿi;ÇBòÿ PK
+   Y@qGk±Í  Û  7   org/gradle/cli/CommandLineParser$OptionComparator.classUmOÓP~n×ÑQ:oSðDoe b0!ñcÍ,éZÒvÄáá_ÀHbøì"Û6s°JáC{Ï=ç9Ï¹÷¼´®~ýPÀ4ædôòWæ%,È±(c	Ë^JXâû^IXãðu	E	^3tmám2$rù}±dê}ÃÒwÝù¬¤¨Ø5ÍÜ×ïC¥è}5\ÌÞ±gØVÉnkæÙR¶,Ý)ëêXªØN]­;Ú¡©«5ÓP	ÛÐ¬Cææ¸º3y£È Õüú» ð,Æ#òeâ´}¹À0ïÐ/Ò]÷¨i'jjV]­zaÕ S¹6ãÞÁ^ó~
+áÛÂuªÐÆ-	Tøt±Y+yÕ&ïdè®uKó<£ÿµé¦ú¯ñYÚ$j¹j7¾cð¶ÈvçÔ
+2èWð[¶VïØAÛ+màüSÞ*(áuåÍB1lÅ,i®^¶\ÝrÏ8Ñ;cÅ à=Ãx\Ö8n¡pï¹¸v± rCQ¥£o*]]÷ 4¨ý¹|[TuÞ·Ü%`anot¦.AAiÏU¢ìÑWÌGÅµÑ
+ç®S/c¾o½4<}ôu!ð£Ý íTZi®>ðôîâJv! a<@*QèüÈ´®Ì!qñ;Gò'º.!íÎv¨ÖÅ¤ø¾{nD<|ÚÖ1(ÐÁº0Q¹ôý¬à	IÜó9b|§èbã$m:Ý³ðtÉB¼HOÏ\¢g3(§W­`iL9ó¥IøÄk´
+aÎXtÎ² E$ÂÙÈûøiÌøë,Ð:AyLS)²Ù´""J?²QúA©XÅè_PK
+   Y@qGäbÕ'á  n  ?   org/gradle/cli/CommandLineParser$UnknownOptionParserState.class½UËRA==É$a2@ñ(Éá¡""¥¥UZ²`×$SãèdL_ð_\H*~ÿàÆ×Â7º°¼=
+B%qáæÞîÛ÷¾}îÍäýï·ï äq[Aã
+:0ÑA«0ÂäÅÁiÌDq5krÙãÅCüwËº»&êÛÖÝeËzabÅqáò¢¥ç
+[vJ%nWL[¯âFêàó!îÉgüÏYÜ6rkkÚÅXá£Ì>O± Ó6½E=}±9A{ÅgÖÂËNë)«Ò¦î>æ.^ä¸µÎ]Sì`Ø{jHOìç¶óÒ~¸åý-pßeèÞ}^^rJI·=R7Ù °cSë­êÛÞ{2i·OcÒÞi nÛ1^ã#rÊÞ²t1b7Àðê?4°yvÞo²´=)L^)a¦FZÓËÖ[Ðï¢ý©c9â*zÑ'Ì¼n$Tô ©BAaF± â&£¸Å0÷ÏÓÁ0ÕÛ ÔÓ mGdúá6a4Ýj3C'/ïn{._çVöýÆµÕ±+1DÂúX¡UR´È÷Ô%òH¢}4±ý´+Ñ.L¾_c´±=´ìÂÚøä:"L3þ2û}F7û>ö§èL«` g %.dþJ\)ù+QL¢gq.¸:K^dIá×µ{""Â¾ù¼jõ4àe8Á ²¶È#àïu`¹¾@ÊTÁsä¥À?|pªP{þïfrÄ	mÔÚEhQrò!£"XØOÄÙ¯ºUVêH/.\¤ é6? Û9RÕ?SÍ©UÃ@çFcHû:UÆï1-NòÃcjXücÎâ4Uy<blfq=¬üPK
+   Y@qG"zÉZ    &   org/gradle/cli/CommandLineOption.classV[sÓVþË±EÄá cÜ¤P·@H¤IC E±UGT\YæÒû½ý¼ô­å¥´SÂ¤ÌtúÄCgú'úCÚ~GVdÙ²K¦ÎÕÝow¿=òÿúñm;0%c:6Lu`;ÞèÀfô¦xÌ%pó	ÜÄ-ñxKÆÛ	Ü*cAF>Îê©4!½#¤¢x,Æ ÇpG(ßÁª%qÖKFIÆ{d«äèYÐ5~G½«æ*nä¦4gXBÇ^4U§bköÖ¿©nÕ,æ¦[7Ã'yBQíbeI3é%Ú°5Ôr&u#q2QÐÊy[wÁHHÝSYÐJ¶WÉ¬jÔJëf¾²@ØH7ºh[Ò¬î,J8ÜÚ²¹¢­-7ôÜ¨µ´¤qÝÔ&ÝÈnÑÝÔRé 1G³ÕCµ
+(ONT4{Z¼À­¼jÌ¨¶.ö2jyiµéý~\P®SÇ²5â,êìÂc¬¯¡KBO}p¶ÀÐ,Ì®ÙVÔ!^ÔÉUmH(´¯Q×"lbQ-ö¸#a("ÎÀZêr<tNkMGûÓk2S8r'ó?$î¦Õ|ë©µµrÅ`f[BoÏTt£ 	tÒw³£é°¯5¡LÖiÃ°î±¶§8[ýWWH/ZÀ$¾:aZAÂf7·ðÄ)Ô_¨ÍØP¸Ãk²dº,OGÓÿÃKÄ)«bçµóº {OÈêðªà lÒ´á¢Z^d;±KFY½
+öGFh*
+îâû
+`LÁûø@BwcOd|¨à#|ÌÖ\ëe¶;Õ¢Û
+öa¿Oð©Búíô1_kBß`/µ[
+Ò`áçkwu_bTÁWøZÁ7"vß*U|ráw\RÌ¬âv_ÌX:{»z=
+_bºwi±Ðu½\fÉ°ò{B»Ï¨Ó]ê¥
+××QÕ c:l+UK%Í¤Á`Óii=nQC3Á¬ÁíéÑÿ²9VU%"
+!s­£a ¤ËÖ¬»vóó»ßú(e`£¸k£¾MÍß÷ópåÞÊ®sM
+.úvY~Æ%yò!j~G;"\/eBÊ<CÛÜS´?A$ó3Ö=A´¦³+I¸rpb¸ÄóÌ/®@iÃì£þúÞÚãsb|î¤ÿºÐæ²Xå<¥1Z¼D-àïý<æWpø
+G0¸ÒN%òc®UÍq?¯W) jV9îÍ:í±ks(ûÜ U'ë¼ U'#Ô½k\9xìçwÕ<q]õTÍ|¬²×V¡é÷±rÃ¼Î§saÓÙÄj ¶@ C<`îðI8ÝÔÉúfN»ø99QÏÉ^ÂÚ3t²é]ã¬^÷s(Y±.cÃ,×äs¤³ËØøâÙî¾elÍ&7wÂ(é
+ÉÏ6õ½¶½®É2¶Ô  %ÁVÆØÄ.îzÙ],Ð~vba¯æYþ]Æ9\'yæp¿B/Ê¯y	Åpvç\Ç/µSÁ^vª3Á^N¶è¥*áì"ùZuvÂ+v7srN¾yHûD
+Ô»Û¯÷¥æ~Ø·Zømêçróä¡äæÜÍÉðKûLò@ÉÈ¤BÎnÓÀ#ûxÆ}§/Ù8}Zé®4]¹ñ°Þrt'Ü{dÒs¢yI	'¼¸¶òjbfÛ(Ö®¨N®À/Õ±UJùØRÞÅ[g¡Éúã|Ò5Wºþ/PK
+   Y@qGl\Ï§  ¦  8   org/gradle/cli/CommandLineParser$OptionParserState.classR]KA=³Y³vMM´âw)F)n_$"h@
+<ø6IíÈfVf'%ÿ£¿¤O>øú£w6ivÎ»çË=wþüýýà_|d°éÃÅ¦mì©TÒ1dª{m·÷C¾)¸ô;BßóNDÅfÜåQkiïã¤k¾ÉaáöÉÈXÝqÝ2ÜÐ¯ÜµRB7"$(ÇÍXA¨y/A7A#î÷¹êÙ>£ºÊ;:Ã|¬(ÔæFÍ¹=æÞô©U÷&K¿õcEZ¾Pá¢Ú|äßyq-£¥
+ëS+ÎÂ\ñäUÌ|HQåS$ð°Ã ÝêdíÃºÝ3¬1TþMZñ@wÅ¥´K)¾ãØ	sAÖCáhúU0^]ºí<.ùuÊGa(M"¹%zÂ.ìcg"W=ºd1föÁùIÙd}ÿçFøø¸´6,¤¸O).a9Å¢Í,se,~BèÅÙ¿Å#ÂH<V±­§üjÊeèlaÎõ',~&DaöPK
+   Y@qG[xn  Ç  &   org/gradle/cli/ParsedCommandLine.classWÙWþFÛÈÒD±UÇÝ&UÓ8e9$Ðx©ã&MÛ)qIpZ
+k"OgÑÈ[JK¡Ð¥¥}3¤4	&?7øñÎo¼ðW¾;3KÖ¸1/3çÞ9÷;ç|g¹Ò?þûÇ?ø0ÞO 3äQq)¨»°Ä£"ÃN ÅÝ©&±ËI\Á²x<#ãYK FÛñ\ÇeÏ'ñ¾Ç2¾à±/%Ðd|9nq|E¼_ãñ~Uh¼&N~5¯á²X~] |CÆëq¼@¾ÄxKè|K<¾-oÉøífÙÖM£rdyÖ¶t£È©ê:XµõÒà´ZÐ2«Õ®Z_GÝeI5.ÀÈiZ(ió%}ðqÕªh	sqQ5
+Sº¡r,9U¶´fØîV¥Ñø¬fSåÁÆ ¥-KZÁJiWlK·ÕEâs£µgJ¯è½¶6ÁênIèÌÖ)°5K=_ÒFúÎHLMxÏðfªç5ë	ñMBzÊWKgTKko³Åå&BM	!}¯ö:ïc¶iñRvøtÝ*ÝÃôÎìÙx&H;b/è Ý&|êÊföö $t4Ò°\®Qq8@ôîî´ecKgEÆâ¶Y+øöl_PKUÓÖÆÂ¤©¢t2VñeW¨î«v¹jKèj:p¤ª
+H­¬WéVZÒ9Ù ð+ttËºþ¶,¨Z=íÈ6kôÑÖÕ«¹Ón§ 7k'»²u;aJÚ¼Ã·8½½d§´%­ä÷gG°²\àM¶ú¹DÕ¢Ûzµ5ûè¹®UOýdÙ×´¹I ÛÔBÁA<£ªÚ&ô³\£Kî÷ê×:@÷îåÿ«¸Cµf¯§iÖ Ó×Ä¬Yµæµcºhð&øýÂiñ6	]'é¸ZYà¢` û>pð+¼o(8îYÿ:nYê² XÁGðQW¼we|WÁ÷ð}?À%dîæ73¶5Vü?ñ6ÄFîeüTÁÏðs	½q8é©ä3»×x[½ÀSç/²ÌàüWÏ&SwE>£àøF¯)L+ ùý5VeüFÁ'1§à·øGyÝ`§ÕRÍ«£Wæ5®OÞJoÆ0íLA»ÀèûEÆ.È¸¦à:V¼§ü«Íä61'!unQÃºwµ±T¦îÊK7ïrXrúÌ[­1Eã0w$DëÏ¶CîÏmkV%8Óûp¶¼y'ÐØÓZT1Ð¶O~0ÈúÍ¢ËQX|ló«%>o¶ªèwÄ l¤¼(èØt((ÌTãØãyN,áx¡0^*QpKðWj'DG	\ð!®Ùèþú ×6¬Ùèþú!$ù>!ÊÃ40dî¼»)w¡¹[ß@bbìäu1N±bâýkP$Lç×°MÂU¤ðWl¹Vê´Gn"½{$G»¢^FHbûp,÷>"]±®ÈvqvåÎ¿Vî¼wÎ1Âç(|v3äü­ßA©?Íw2ä{1û0]°±/â~¼^&I£<qÙHáa!§ÑGð1þÇ%â8oøxvÂÇ¯!AâàHEÂ	Ê
+ßîÎ¤OâIJ|B|VNº#ö'tÎsK¾³s!&1*Ä¸ÿ®kÒ=Úã8îê÷Üqæf	ÿá;Æ÷éÛè&·÷NGÆ\þ#=ÙCBòîz|ú¾Øu6Þí¼º¢u«ðØÊ¿çoâþk>ÝûÊèC9$èEg­dÐÃ$}uvNrg5&<g±S²ÒF2#ÂSÌÓ¤XçÉÓLBèÇñi×,´Îø¥ÄAì|;"Am¹þÈì2úBXõiL8
+ÂGÇ:Ü¾mÌ÷á$û Øx0ì$aOÞöI<ååêM¾}ÛS×!ÝµiÉ±3¼hduåÎ¿Ã«~
+:H¢¨§nR±$ì¥¯½ôXÎ´	¢e3~ÝöùîôáS¬÷úº;öiý%^v^ü¢hC:»7DçZ§óÃÎÛèKï8ÕÜ/
+özÿ_¯Ú´aM¦Q¾@''3.`C.?)¶¬h½åó÷t¢¢I6¶D©®%¢ EOFÝ(õ²¨Feõ\ßÀ2KûR]ßAEÇA0 ÝC4¼înàeF]Þh}41°îoÊ	ZL*§Ò-"øvv;ÓHr¤	ÇçZJÄÙø¬gûÏöPmvúõ­«º2°\Û)Q·\ôÄýçzèn1=Ã!ù,Ýy·Àóû/øîíâ(}Ø)¦{¿VLC¾ËC£"C%sñPK
+   Y@qGA5l|    :   org/gradle/cli/ProjectPropertiesCommandLineConverter.classKOÂ@ÏD|?PÃ¢ìÀuã#Q+¢$÷C;1m	ÿJW&.üþ(ãª1ØDã,îé9ßôv¦oï/¯ ö±[@ylæ±G)ívÙ
+}FHWkwLSº°Ü!¿]®nY×7ÎZK:Ì¿cJDóØÌèZRy¶§ësÛñÝVò;ÚH+-ø )n´kS#cruLXõøgh|Ó×Bj­õÀFÌöYèÙ­DèèÎè%×LøÜ%Öñ*_¨å½?õÖ:("<ÚbJÕö	®­Øtòfë^*K÷¸Õ
+ßµ¦XUÞðV½£Üi01ÈkÂÁp8wZ±ß8T0gî?Pôa¦ÎmÎí=ÌC
+S³s¦§£|	Ë1\áôZêq-}CÓ_èJEËèjE+	¨ùw'©õPK
+   Y@qG2lW¶J    F   org/gradle/cli/CommandLineParser$CaseInsensitiveStringComparator.class¥S]oA=3|,àb¶øYÅ/»¥úb JbB$jBÓ÷fÙmvÆ¿âàÅø`|öGï,LC{çÎ¹çÎ=wöç¯oß4ð<O2Hé%=½Tt¸j nà©}dK9*8b+'ñ¶;]åÈwÓI_zÇ¢oS$ßuÂ>Òû(>*áA[ø²ãøÒñU Îe/ð3n»3áÀõÌãH¯mßðºëzckì¡-­­,ÂN3ÔU?Ï^ieÁ;ºÆ^¹{*ÎeglÍÍåH¥C9îY \§¡ûY,©³¡Xç
+ûûþ©Íåfç.Ggú¤aÀb@H·¶ùFSÏ¢ô/@tOLµ­¿]u(Ûú#_k¹û#¢ÊôÜ©7ona©Ü¾N2Á5h8)»Jeb[1¼üß1_b7Ä°µª#Ýõj1lFæØí×º>Ãö¤^ ëèI>7Ê¢0®u¢I;,êWð/äpdiMê Oâ:ùæä¡	I%'¯Õ/;ÚùÄÎLûñÙ)¯<$O#Ã30¹²Vç«ö¶Q+åq<Nw0q·Ë½¢w¢o£­Ö~ Q§ÿ³/ÎYÜÅ½°D;äñHbDü,`«(ÌÂ>¤óvCü#Bû7Â>8É^Cî~,r©ßPK
+   Y@qG¥´g  Æ*  &   org/gradle/cli/CommandLineParser.classYxTÕµ^+ó8$ <"Éc Bð2DT0xHNÉL Q¨¢Ô*õQ«¢`}W©­VEIQ¬­ïbm«}Ý>lïíõÞ[Û{o{Ûzk[é¿öÌL&öããì={¯½ÖÚëñïµwÞüø¹D4OæÒúùüE>Éç¯ý-þNëä¡S:í`Ò©Yãti]:ìÖÙÃ^Ö4öiÇ:çéTÀNù<Bã:ñ¨<Îç<.ä3ä3Zã"ðÕi<ÓØ¯Ó$ïã3å÷ùLI:]Ã}\,#gÉgLõñ4hÉÓ}|¶Æ3t
+0äKuªböq´åò	È
+ùT
+*á;S>³DOµnvÃsäS ñ\sµÆótZÊó5^ qNËx¡Nµ¼Hk¼D§óÅ
+KuºPfó¹×êt±0\Æs|\'V9Ofûh§H9_>è|!¯ÞE_Gëx¥ë5nî*¹ÚÇkDïK|Ü(¿×j|©NWãu\ ½õâô_æã&Ù×Zy£ô6ùx³Xçr·ð:¼ÕÇÍ¢	üÑ¢³Å­>nÉvLÄd¬­h]ÈÅ¬ÓUñ`$ÜÃmuN3jÆ#Q·1M®3cÖpÌ
+ÇñàN+)ß^¾n;Ó¸KÃÛÃ]a{rµYÑÆ¸·4AâÅ§ë`*p3Õc1¶gk£mj
+{©m[Q{4¦qi´9?Å»¶B¯3ÜË¬ÖHÔÊ×¸3eÚ]fÔÊ<ÈËÀ~tk1±jõÚ«¶4ÔÖ/ß²ºvíÚå40ùWn3wU]ñ`¨*jµY»«Vqh^È4*b+»¬;ÉcTu½Ù	ÜÆ`[ØwE±Ãå³ì!3ÜVe3X¸2m«j-!«ª9¬Jìme0lÙÊ.\f(ÙUÜmµ$ÌÅÄ°5á/Ì¶XQ«ÙT¾(Ú²*5´>Ä0X1MB)ª[C,î]ãK\%¥ëÜuK6µº:¶ZÑµBQ+#ÍfhÊïÄ ;ÞS>ao¶gD|IJ¯J"/?{ÉÓ)KællÅÒlQK@pÈkø	Ál Ëw7[ÉÄæ¤Q­&²Ãá3Â	1ÍÒÓe¸x­p2î^Ð$ãW,ï ¾fÍÂÚHB¶Ë9ÁiÈ°´TûAÖ/Lgnq×½1·:m^Wy^9ôÖ37=&3ªº;åä¤Y9lÚaysò@«äã´A^WV!½[ÌNlÜf4
+wºCVMAs6l|rú% %,XÄ2Ñ­ÑcÁ9#_z§`Î¥1³Nô§{¦¶³ngßd ôèH´Å&Èµ o­ÊÉü4µVc¢©k»ÕØØiº ÔcãQù½Ün2yU®¸ £È@Cê8Èdq~r4#3r¬ÖÕaîfmAÇðµ¡Ó-tÚÓ1ã¸zîÐÇã:÷¶H¶¨$m}]$²ÇBÚ¬<8&ÄÉéH¶jë60ÜS±+²eÀ1+UÈx·vµ¶OÆ´LÍ¸V)2Ï÷ÊdcKw$ÃÜÔ§ÎèT*êfs³M;s&Óô¡A @Îî+çËÊs³rPÑd±@Xä%~ÌRª,>ÃAÅoèíBBotEQÃ	Ä¢RtÝmÐAºÓ /ÐmÝAw2Oò^ÕïìÃ¦ÙaÐ8nÐ¸Ë Ã¼zP>÷ 6x¡kÇ&qâ;è(wi¼Ûàn¾Ò é1¦â¡AìÆ_eðÞ+?#«ª<öëZY}Æû¾¯Óx¿Áåëþß Ë-oä
+?Ï71U)4½êY7ã¨¨ØxùâÍåßÂ¾¿`ðmüEoç; h%Kc¥	ÅeßÉè.ïæC m5/Ó2KÄiy±ÍeHË48MVË£ÑHÔàÃ¢ôØÁYµHB3öuÉà{ù>ïC<Àwü ?dðÃ|Èà/Ó=?Âj|Äà¯·lÊ6ã¯&"¿%~¾áàµQËf³¸Nu¿&Ç~¿ÜgÔÃÛ­TpÎ&óìKÁOòS[©FÍn924~(6èô+ág>ÆOiÜcÐO¹×àãYËS§Á}qîé±éáÀ³1Úàçøûùy®¼ô)V\,>!i8Æ5~Qè¿"%­FÚ¶!»]8¬S8j/{ëÅ3¦ÇfcÅfÐÒ]Ü" lµT/¿ið·$jêÌp8/6[Z#ikM¬'GmXÜÆwãíÅ3*fTtÝªñË¿Â¯jüdÄõLÉ±8u7GÂq3¢ífÛÛá±fXñ)²T³eFå'¬í|_7øQdBÉ¦¥{6u^Uß½S½-ËJ~¼S%\ÎhÈçC²8ÝKÂpâÝùiö§¿GOóF1wxp:èÉb¸ùýpÁø4¥áà}æ£GùééR/ý¼éÅ­A	öq¼p ¬Ï:¨UY?zÐ-ºæg¡Ê=¯ì
+hãàº°tp?"ºÀ@üà4®¤ôt¥£ÿ4«è4ÖùÆíÃ(¾J}¥¤ÖõT0qe´fl/í*_8x¸ÜnÆ¬Ýqõ ºÑV?F:ßùf÷V¹½GãÉÛdQCY»AÞ'vt¡XAÒ] X1Èjÿ¼M4ÑÍíâÜÜX×ÖX"¢JV8â#$èÓ¶°ÁaÿÌíÛñfdBY½×ÌÆs@Ö³·X»å]À-­¯pÞ® J%+Ó2'×|ZÙy3+v±Ü½¦ºô]y¦Z?IÝÝKUÙfÅQõ¨¯ÛSÈ4ó¬p[¼])	7DÂIæ+Êä6~®6©ÌÎv=§ÀNUÒ¹p#Ú¢®ÎõA[òä!q7cèÌODh²$ÏJ5ç°ÚPèàé¢cC©·`Ff" mÐó¬Xs4|íë'ù6¦¼Û­neõ¦XÇ#	¿øÔk¢ñAü:ûÅ®>ö+ÉÀAzëé/)2{ Ø<­¡®´ídM¤ÃÝÄûÀO¥kfP;¢#\®«ê2fVZññw®EÕí}Q*ÆFà«n¶2ld/¯·-tà\ä7*üÍÒbÅQ«%uèÂÖpU·óOHz¿ÐY´ÈKã¥xF/GnïÄôEÕ¿ÿqWýª-{>Qþ8¹+â÷(ÐâÚïðk1¹ÑÃhY?y·´^ò=­Ü¯h)¤sé>ôî§«¬6GÑN,ë¥\°Óz)ï¹Ð5ÊÝ½4âñ ãBH&Zï°«£	t0Æf ½»è!ØGÓ1gk£¨rËÊÓÈõT­Wé·*UnU.=Bbþú²í¯àÿÃô¹©ë ôÏw?å7õSASÙ³äê£B¦^:£F×÷SQSY{iLCyÅÕÇíw÷Ñ8¦C|Rz~¦oÐøOßÓCgâ'üÂ	=4ñå÷Ó¤&Y:¹áßáâ:ë¥ßâ)=4µÆë÷öÐ4ìÁtEPé÷ä/î¡³«½6e(f­æ×üøå¾B­-Á¢°¨T-:KÑº=	R°õ{¼)ºÉG©ì0ºÔ)¯ðTÅX¢¯lÛïí£ÊDÌáåMHTÚÑ»	Þ5¢Ôû*ú©
+fÎê¡ÙB<»ÎvjÏïë¡9¨ÐïKnªÐÛà©Î-ÊU?Dó±+ü}Í¨Ñ3Yê	zåÜý¹|äÔËGh)tÉIW71¦¥éÊeó|<³¢æ$\*R ß46ÑTÄx-]NÑZKWÛi+uS3]M-tYH±VDY=Kíôé»´~ª÷(DR¢0 ¥NH;¸¢\JqG]ÜH;y#íâmÔÍt%ï¥«ø íáGi/?ßÇh?O×ñ«´ß¦øºO7óéVþ+ÝÆÓí9þû=H°ndÃWékøÞIéqz½Gl2¦A3Ã.6iSèëô$éCÎ?¹Ðj«õAnn¢WJ¯ÓÓ Ó ½ÖýÖz¿kù9z=ó;°Ä1Iõw2Ñ{úáÖÀ¿EnGNå_Q=÷'1FQ=­6Ä½þ	z1:s1"¯¹!¦l làºJJ.-\Yäbq/XÜçÀbý%»¡¹±M½´ ¾¼¡âDµÛUí)ò¹BJyf×xÉÜªÉÁvæÐúýÄï/}´©¡Â[ÀÅ0ZräÔûe19Ö& ¶»ÌD[/¬ÖÃÏà7Ñwü5	q`{EG$«\ÀòúhÜT@Óá'°Ã5 x^ÁØb@®øÌ¥8$±s½ª°ÓÈÞÏIyÊyCñMú¶m×*ðò[ý´´©¼Î|ÖV5ëzé¼¾öÑr¢Îé.¨qW(kÔ Ãö8)½A¼6Í
+°QH¿(Éäb0YÌÖl.¹þÜuÒK@´. Rí~¦ø}NÓGõ`v&LO<}êQ¿¯°á8­¨°ZØ¾Jy÷aÒ
+×`ÀíÏõë}tKèg" ä h=v^	¥Ý$é%´Ó<OÕÇimµá!K.¼¤3µdX¡Ö«åJøÂËÜ/PShÔº=´ZHîg¶RÐÛ\x¹½)Oy;ÁÑ^xê&á§S!x%K@&	ìG
+B»ÙHàÕiFîBJÝ­N ôþösÑûß!>BÐ|L'Y§· ßá|zçÐwù\ú×Ñ÷¹Þá]ô.ßJ?äWèÇü:ýOKÞ¢b8)`E× %ds!û1z¼5H¿¾Co#<ß§i »'1û;ö÷ÔÕÐõ(ÂÝK5dC²~ORiqÐØ¸ÿ>½±5à¨Æ$¨iÞèù\~~D?FøùYú	4pÑl¾ÚÞFnììú©J3I9hm=Òóç U[Ö/0fóx#Åã=¤¥./Ëúçh¡]ÔOWÀf½{Iùkä-\³²¬¶¦&4=QÔx&¦Ü Îüæõ9ìZ¤ç²üµÀ¥RÒVô&"s$¤Ð¯ÿ y@ó(ÿÛoh9} ¼±ÚPný+ýöæG?ú8*u¤zïÃ¶Ëè?À#ÜÏé ¯èÖú ²Gé·	med×'Êë'¸ªÝEîÑ®@{vG!«'Qøû©µ©°- ÆãÔÞKAT8äÛóÛ³çRH,ÓÑCáÃ	H6Í~7 ûÆ~ZÜ$¥g/uÖø¤ã÷¤T*»^î@Þ/Õ4ß?Ñhú3 ýCOm>¢Ëèo("þN{0w-r3=Î81ØEÏã¨IBûhGÕ1hÏA¯vì|¥v7*®Ý8§¥ ýD
+ÚO$ ýøWr"'ßLùïÄéXV<#v?UgW§úaÅÿK¿wXìÊ.ÒÿÁQrÎð$ÿýÑa1C2ìõ§Ô­¨ZÍ?vôPXî>Bn×3TV;Nñg(ô´ª!jäÈ<ôþ¬$}¬E]¸¯b¢Ý;[7Ú+Ñ.C{Ú=h÷ÇgÐ^­ü¸ö¹uºíuv?ÚÏ¢½óEh?ö´7ºsè ÚÏþ&´7nÐôoî? PK
+   Y@qG_>Ò£  )  3   org/gradle/cli/CommandLineParser$AfterOptions.class­mOÓPÇÿ·ëè(Ï@¡¢1Q|ÉDt¼1wkÕ®5wEñ#ø]|!J¢Àe<·«£²1MzÏ9÷Üß9çÞsÛ¿¾ý PÆÓ²é'IW1«!y&TU,2äê~³É=«âx6ÃxÅ³!¸åÚfÝuÌ'\´lkußg!sËñà6Ãät²ûL!½ê[/HÃúv³f§¼æe¸â×¹[åÂzdL[N!çe`ÇoÇ÷¤ºæy¶Xuy«ej&!&âë)ëb¿¯ÙAÛÈ02]yÅßrÓå^ÃÜã5Vf6R\4dr]¾C¨¸Â0ÔÛQi2 6{{ÄJ.¢-÷ßòÏùÞºïý©&÷Ww{Õ/IÅU0¬áÉå°ù*3Le	¶áoºýÀ­1Úå3/Ì#¼|]Ë£%åDú3ïµç¿ózÞØaS2Æu7òXÆM¹cõ Ãìq¶añøÝA78yW¦ºNô°ó*%ù1|èÕëÿ¡aâ­ø¯évÅ¥Ì-ëþN x»Ûö!*JôÅÌB¶ÿ°ì)ú È>#Ë iIShÌéln|AjTôDVÖÐÇêÐÙFÛî(âJËè9ºD£ôRR;¬ä%Ü1C!Ë©1³ã­ è(|Gú¹¡FJfØ÷é °Km×°¥t$äó¸¡ïF5kj|EFß§jr	dY+ªÖ!kmrQ>ñîÑ=°Ý¾eép2¸n&0ft9\9E'ètN*×iÏ¤åÐÀK4¢¥ 9h¿PK
+   Y@qGGÑfì    3   org/gradle/cli/CommandLineParser$OptionString.classSíNA=Ó¶µ]Ê(UÚ-e)â'Æ#ÿíXlwÝÅè£øþD ÑÄð¡w¦+BÛøsçÞ;sî=çÎÌï??~¨âÙ ® &c¦AYs)TÒ¥a!eiªÒ,¦pW]Òp_Ã8÷¹µ=þ[wÖfèÛnsaÀk¶ç³b»v¸Ê0[ì=×)m1$j^C0d×lW¬ï·vÿï8BvòêÜÙâ¾-ã(wíAßP;e(|åºÂ¯9<íZkß´>o8Âª;¶UóZ-î6d7Ü_8'¦_ØAÛá×yúKý¦B¯ãkxÈ ×Òy>ªEìÓ4Ui
+Á1ñz]A¡º´@ðZñêû
+Mozû~]¼´åÐÇ{*ÌKa:ræ,b^©hx¬c+Ý¥ïÛNCø:`UÇL1°ëÒð¡r)êÆÿú;{¢2Ì?3zËE9n£éBîÁ;;Üeës¹¥÷ôÊy»-ÜÑíw 'i¦©æÏã<ý¸ýÖMÆI^NNÖ¤ÊÐ¥h¢8­Yóq³|9wv  c
+ ÷9Ó1È¨(Ë`òù¸(O¶aÊbäÓmDm>¨X1¿#Kaà¦~BÛ>FJg´!ýÿ6Îl|;á4 k±aÅCïÔx0ù¢­r/iAï';`CÍGàGÂ¡å¹cÄºà#'3Ð0Í@Ãôn¡¸ÂmÜéaFâºigM«Ò1Ì*[Ä¤ºÝî=\E7iúPK
+   Y@qGx&âT`    ;   org/gradle/cli/AbstractPropertiesCommandLineConverter.class­V[wUþL2æ¡5&­I­¶i-4JÓÔ`ÉE©i+v	fpfDÿï®å{_ëm\KWýþu d°¥YÂâ\öÙgïoû}øã¯_p?H8Û"%ÅÞ¬H¸O%¬"Í§ñÑ=	¬IXÇÆ6ñù¾@7÷ð¥¶°=q|Å';¼y â!ßÿHÄ×"rþ¤¦kö7Ùb¢Ê0Ñtu½VÉ«æ}%_&I còbj|Þ
+öf1\Ïf)^2bYÊZ<·lS)Ø¦QUM[S­e£RQô"7»lè$TÍÃXI=V:Ü¨Ú¡3#}å@½ÏÚ¦¦HuÂ¥zGµ­¬¦z¬YSkY,ú®Vª9>	¶Ú¦bZá¯:cÙ×ë¶Ñrõ*í&2ÒM
+n»Ð8&»M2j¶V¯)ÕDäÄ2W5(	,MIz¢n)åºR¯ªe9½ØôhsÄt©4%D±ØÆêTmgèÎvÃêñá¹Ö­tÃtK¸¿zAm"ñe7«tÅv²ûãóÙ§ÛÈ)Á®öÈÙ¹ßWv"âQÊêys¥;£íåâ]Â^W/yªpö³FÍ,¨w5Âh}Ûñ6&FOÚñ.¦eÌ`ZÄcïCQ@QÆ,_Q±+¢ÄWöDh2öñDDYFºCFßÊ0Á¯À-6jqïdÔqÈïÎtÅ+#y:§*[ö0íÖîÐJ¥ZEÕíöf~]µ¡r~èÎN¤Âó
+ãÇÕWÞS¬cXDé\¸/ÃÃ´««ä.ÿ'®ëÂìÇ¶k_ÛÃÅþ4©°Ð«âTSâ!î¬ ÍâWn¸[Â0 µª(½®Õ5àRÉ%þÖÕºí<ÃèaÕI÷SØ¾ê¢¦ÕúÆ.C°iþ$Ôhû°{wÅfÐªñCMöx(étÏ'9î%fèÿÅ9ðÆo=µïÐ,N=ÝMøæýB&©õ;Â ¦Àï­£ó¸ /N?ÓêgyO:ïa®e´JÚ^ê/F}¿Á³ãoÀÝ¨²øÖbø×b4Øþ×k µt¾ç"ÁtÓZ3
+ÑÞU 0íf¼x÷þ'y÷Sr¿6 aaýÒd°B3/á¹)LáF}AßÏÑtôc^l?Å$Í¼A_	!è7ðVkéï±gäÁë ¾@ØÄÂÄCðí²GG°D¥oÐph.`÷(øríørôoóõY»Jñ]kçKIrÆInà#¿£)ò ç`,rÒ|4öãõÌmY©íYB²åYÂ-BÝéÇÓòô1>qúÔ?PK
+   Y@qG¼¼     ,   org/gradle/cli/ParsedCommandLineOption.classS[OAþ¶·-í"¥\A(¡-Ê¼P«1!iÄ¤oC;YlwÝ-
+Ï&¾ø JD}öGÏì.¥I|9ûï|ß93¿ÿ|ÿ`+)dPPQL!Bú0¢åI,¤Æ-,&q[~ï¨¸+¿÷ä²¤â¾
+{ÌlqWA¦²ËöÞò©Wë-+è©
+Ãb^Ëá
+fº~³É,C¯z°å2¥$JÂ^YA4_ØT[µëÜWÑjlsçÛ6)­Ø5fn2GÈsy;ä+¶cèÃê&×k¦Ð_2ÇåõU»Ñ`V]Rm4=a[T.ipoSP0/DND=t=¼ÀZÕë+ÑjpËS0?¬ÉþKOr¹¡bjÑ©ªÝrjü¹»ÀêdÒ0a§jWíKÉúÕp³
+&N«®&7YõÇ×ÞÖ¸ÏE4W·¹³l/·ÃöxYû9ÿ2,ÈBS*jx<ÂIy®Ñ2=Ñ4yt	ZÂcº<ÝN5ñDÃS)höÿÆyec{×¨Îî+Þ½[§+G±Þ9ú tGi`]
+ÿÉ¾«Â]k4½}LÒÉÐ¢É.ÒwN"N{j9­)RFv@¦x¥xÈÖ!¢_ûì£¯Ð*ß!(#F9#´Ó<®bÔçÃµ«r-¿!~Þc$¶²ê!?_;B}S'áèÒüö©]q4j©T£øÇ©BÕÚÕÇ)ñ«ëtÿâõ,á§;ãarÐÅ&1ZxFiW$óGèàuw+æ&9#¾PòÉÝ4f|tgCÆR(+ôà¨±dücÆùÙ¶Á9ÿPK
+   Y@qG¶À°s  ª  =   org/gradle/cli/CommandLineParser$OptionAwareParserState.class­UíNQ=·]ºív±¡~àbº
+5È§
+1$Ô4Á·íZ·»æîÖGñ	üãMD$>e[ZÒEâÎÎÌs¦wæîþüõýy¬'Ä:²òiB£&1¥!CÅ´3*f5$0§b^E!YsMîÔKc2\Ñ(4¯Ûf¡f[Ç\xf}óf!æ?·¼ì\t®]($zÍr,ÿ.ÃÃ©px¸|®Â lºuj6%;­fÕOxÕ¦ÈPÉ­q»Â%ý ¨Èv2^úël¼æ"P+ûÜ§¼¾í8¦Ø´¹ç[í2ÛþkºÉßVMòa*íñW¼`s§Q(ûÂr«¹§Q.²á$Äuv\ç y¬ÙûýèÂ;>Þ¦Vv[¢fnYòx2=èY© #´³XÐ13:ncTÅ¢%,«XÑ±5Påg¾)¶,áùåV5H3÷Kµ;3'ã<<ÞíJÚµÅSÎ!ÿ/g©â&ÃW;;ß^Ý¸åv,l×y½þà/xÛ-ó/ËTé¥êQ§óZÍô¼ìÂ]Ü\E¹¤/þË=éÙl÷¨k<§ÑR§wgÃrÅtZ.=E¢Phh²çÈ+"J6mLïì+"F~ÑOA-¨ò,Í Åf1B±å¨ìE ý$5"Äy	£ó
+ù3¦¿@ùÐáA®U±'Öáá2®Pá*Æ=´QEã3¢D5@}Cì2Pw¥'3Ôyü=RHì®ö±£©I¶8[êÒ-vtn×Û5ã¸@Ö å$}_Î+:Ë®)ò+C	²â½EéøoPK
+   Y@qG'H  g  )   org/gradle/cli/CommandLineConverter.classQMKÃ@}ÓÖÆÔ¯ª'Ï"4
+F¯M)HQ
+	Þ·éºlI7²Ýþ6þ ¸M¡By³ï½aæç÷ëÀ=Ît$S®¡ß§lÁü)á¿®Ù8åA	{Oyb¯
+:Ë©¹3I¡É5'ÜÕ	JXd´T"qxö{a¦/4¤ÜORé¿1=çQ615	¥Ú¹³ë¤6¾®ÆEÛWbRhèÀ{'ôq¿j<¬Rå:áO2µú%¹Ñz	\ß®XËíÎ¯îÂÍvâù+³ÙT@h`u-B-íÙ¬eñ65°_TÜJÇVpXÄkäÇÅ{òPK
+   Y@qGCÑæê  |  <   org/gradle/cli/CommandLineParser$BeforeFirstSubCommand.classÅVmSW~n²pq³hH¶ØH@^A«@m6Ø·MXÓÕd×Ùlª¡?¡ÿÂÎ´©ö[gú¥ÿ£?¢Óswc&°Áq¦_îË¹Ï=ç¹Ï{öþõïo/ ¤q_ÆYÌ¢f^Fse,àZ K¸Îñ,s¬Ø2V9Ö°ÎqSÆ>1M¶8ò·úíïõzta,gZTÅRw«Zª\ÕSY³VSÝnh·U«®YB/ên/1¬OzÃ_G8æÝ6\fjAÊ»ÃaØjÔJuG-UÉÊeµº­Zº7 Ë^Ñî¶¦[u»Ð(5}2(¡YÙªZ¯kó$íêN(@»ÓyAÓ(ØªeçÙºip|Î0äÝX´h¯ÉÜõ5UUJª`[ºQÉtZ¦¼©wø&~Õªé:üÑ·3<äÜæMS½n9j*ßq\6¹GßJ*y³N;éæ{2#´hf¢½ìcfÃ*SîÀL¹Ãa¼Ëq!y"Åæ»
+¶ñÇ
+ØaxI¨à¾b÷t×xh.Éxî¨%0&X}Ë?:À²UiÔ4Ã^}RÖþBÓe¤É*á"nÎE&ÆëÓÁüÌheã;*J"báªç68Ðp÷áêÃ7«½rC.?V-í0¡£fO~Áé^y§ë±ã6{*B½^*Y-µz=:7CëR÷yÊÕ°õjêúHÏC*dÍf¸ØNÓÍW{ÛMæñ^ìpCêþØM·PzÚkt¯_gBR³¦,ó]xÞ;^©VµwÙ+âýóeØã×àýø¿ÄMÄ+"ô 
+Ó;¢¼ÓÈ¨öô÷zf7iî§^Å/OìÁÿ3Í}xÚÓb]C[B]Çd¦5Âc|ÃQµ%ÃG¸Øôú7ÐG½¶©O°=ômÅ~ïúÏÁ}øÒô'Ò®ùÔOíC.Æi^yºÁbè´ô;ÎýÉÂ3÷0ôr¡¢Ø^!ßyÚ¢{èfê²U±5$Ø:2lÞ9þeX¾	Lm1¢ì }äIbR$Yºy¸<­HÔsG-v V¿pÃ01Ò
+Ã1Kê3gtÉÑK.ãcç{\q|\ÅÔ¯vgé9|,QêÇ%ñ\^@^Å)êx.g!Ã¸E¸0õI>|Mý7üPK
+   Y@qG ;|  ü  9   org/gradle/cli/SystemPropertiesCommandLineConverter.classËJÃ@ÏØ«mµ¶ÖjÕEÜ5BDÄR/Pé~Ó$&ÓBÞJWÀ'i©AÄY3óÏÿÍ¹¼¼¾Àl "l¡YÍl E Ê<&Ï	dÚú@¶ËÇH ÚgÞLÝ{:rRïs:C*X4NÄ¬°ÀQÛ´;hZ3a Ñ½ÜG!]îºÔGv¹7S"5eb
+o}É¸G ÑÖûtFMz¶9y¶²¶~X{()spL`7e.°KV,øTXxÉ¢õ¿fDT  E¤G ÄPÇWãJm®h~²­Æ49Aíjx­µÑ°­ÓsÃhöÌgÔ¢n8üÇ5©Û] .FÔ¿s°9õàQËÎ¢â²*sû/@Ug	J*æc±e+sÊ+1¾
+Õî$p¦¾ô´6¿¡/t-Í,¢;©h-Í.¢Z
+ª>kìZÿPK
+   Y@qG-h  »  2   org/gradle/cli/CommandLineParser$ParserState.classSßoÒPþN)sÀÜT4706ê|3M$m	f{»@Ãº[sÛ-ú?ùâ&>øøGÏmÙdiÒ÷ï|çÛß~þp ÇFÛ62ØÎ¢jãv,Ô-4Wô¢×T½qB0;ÁÐ%¬v=é^û®ú(ú>{JÝ` ü¡<mOftæÜ±P¡«zØÿ ¥«:¾C[Ý@Cßu¾çtñXÈ¡®äU§ÒÛÂX|é»l©èèSä°^ïKáøB^¤<9j7N	Y/¼
+I	5Ò,gâ+B³°K(&úÞ§sÌ)»¸læäa ¯È¾×ÏÒs
+äTÈ;9´Ð$P«/:hëmªÿM°{Á¸ï=½øn(YU6ö[M{yì£h¡EØ[¦=îîßúçî "¼X~ò­ÅÍÝ(l{hp¦/peYá¿+ýX0ôx	wØrXòFÞýã+lþf´ÊÈ±OX®&3A1*±L@Úehèf)õæ×[01ÌFÀÄÚîpbà(C_G×ì±Íïmf;SÌ(,hÈÍIâKÆ¤­äòô54 §=ã·pe)>©aÅ´9£û,³D!ûPK
+   Y@qGF¶÷=  Ê	  ;   org/gradle/cli/CommandLineParser$AfterFirstSubCommand.classÅVëRÓPþN[¤JÄ;be -´°x)U.R(XEÑ_¡Ä(	ñ| ßgtPqüçâC8îI
+KÂ0ã³{v÷|gw³»9¿þ|û EÍ4ÒÑH²A/pKÀ°Û\3*BÀ;ÆExqOûH0ÔoÔB ÊÐÒ\$gÈ«y%Í«¤¾±!k«)USd£ q²W5Õ¼Ç0Õëlþ¯%^-±÷-1xúªÂÐÂó[+ñT^ÉÄÒ³r~I6T¾/
+=Ü]¶ÄkS1&U£`f¶VÒ¦)F2/
+
+Y8ú8âôf-IMy$Mº1eÃLoª®	H2´Ú¼})MÂzÙZßÊ¼¬å"ÓPµ\¼\Òçìy6ùàO\}9Ý²'§JBKeÕ¾½mðëgòáÃYÅázåK/ZÎ1}ËÈ**¯2	~àC«G&1%`ZÂ3t9eaÌÑgÚº¦okÇ@g%K¸Ì£Úu¼`¶|G%E5e×uSé»5Ï4Ãð©ÚªìÛ²¡©bðä}Båî\EUÀ6¢:³Y¥PF©Jjh>»3·L57ùÔ8" Î)&COéH¯¬)Ysÿl©HÀª#¡½?n¼A;ÎZw¶¦QW+ÚïSê^Í¼8õþWêÂ'AEýå[è=À|>>ÐsÃÅçÍë6ÚMÓÞMT
+>ÃwáþH{Úimæ:¶:ö^AÉ:HGö8ÅÑd"ÃºÍFýx&àúOø+ê\øúùþðïAX¦!ÈvÑ¸³qÛíÁ»
+HêßW6í¸âçì9ZÙ´³eØ+Ë }Ñ;	\G7¹Á¹Ä¹(è(¸	·£ô]LShü¤`ÅÌc®çÙB	¸p . àÅ­¨9BØÊj¿1D'(Íôâê$ÉU¢×<"zÂ×@'bjÅ'½è]ðGZf¦<â_PK
+   Y@qGÇ'S$F   D      gradle-cli-classpath.propertiesSÎÍO)ÍIUHIMËÌË,ÉÌÏãR)MUðË/S04W0°°20²25PpvQ0204å*(ÊÏJM.)¶å**Í+ÉÌMµå PK
+   r@qG           	          íA    META-INF/PK
+   r@qGÃïF?   T              ¤)   META-INF/MANIFEST.MFPK
+   f@qG                     ýA   org/PK
+   f@qG                     ýA¾   org/gradle/PK
+   f@qG                     ýAé   org/gradle/wrapper/PK
+   f@qGhdf£   Õ   #           ´  org/gradle/wrapper/Download$1.classPK
+   f@qGÅÞÖ  p  D           ´   org/gradle/wrapper/Download$SystemPropertiesProxyAuthenticator.classPK
+   f@qGçìXsª   Û   "           ´v  org/gradle/wrapper/IDownload.classPK
+   f@qG©zÝ\  Q  -           ´`  org/gradle/wrapper/GradleUserHomeLookup.classPK
+   f@qGâ]ÛÅ  ú
+  3           ´  org/gradle/wrapper/ExclusiveFileAccessManager.classPK
+   f@qGÌ^F  ù  -           ´  org/gradle/wrapper/WrapperConfiguration.classPK
+   f@qGQ}iå  
+  0           ´ù  org/gradle/wrapper/SystemPropertiesHandler.classPK
+   f@qG¥y0ºV                ´,  org/gradle/wrapper/Logger.classPK
+   f@qGÎrë  n  &           ´¿  org/gradle/wrapper/PathAssembler.classPK
+   f@qG8Þ¶Ý  ì)              ´   org/gradle/wrapper/Install.classPK
+   f@qGÝÀLÄ  	  -           ´q3  org/gradle/wrapper/BootstrapMainStarter.classPK
+   f@qGHÖ·$Ó
+  #  (           ´8  org/gradle/wrapper/WrapperExecutor.classPK
+   f@qG¤«²
+  B  *           ´C  org/gradle/wrapper/GradleWrapperMain.classPK
+   f@qGÙÎx   ´  "           ´N  org/gradle/wrapper/Install$1.classPK
+   f@qGj j´  V  8           ´sU  org/gradle/wrapper/PathAssembler$LocalDistribution.classPK
+   f@qGcJ  K  !           ´}W  org/gradle/wrapper/Download.classPK
+   f@qG'*P   N   #           ´Õ_  gradle-wrapper-classpath.propertiesPK
+   Y@qG`pÅÐÎ                ´f`  build-receipt.propertiesPK
+   Y@qG                     ýAja  org/gradle/cli/PK
+   Y@qGÈô<  S  1           ´a  org/gradle/cli/AbstractCommandLineConverter.classPK
+   Y@qG2_e¦   è   (           ´$d  org/gradle/cli/CommandLineParser$1.classPK
+   Y@qGRB	¨  ÷  <           ´e  org/gradle/cli/CommandLineParser$MissingOptionArgState.classPK
+   Y@qG¼¬M2    =           ´h  org/gradle/cli/CommandLineParser$OptionStringComparator.classPK
+   Y@qGè#òG  K  1           ´þj  org/gradle/cli/CommandLineArgumentException.classPK
+   Y@qG?hÿÇ    =           ´l  org/gradle/cli/CommandLineParser$KnownOptionParserState.classPK
+   Y@qGk±Í  Û  7           ´¶t  org/gradle/cli/CommandLineParser$OptionComparator.classPK
+   Y@qGäbÕ'á  n  ?           ´Øw  org/gradle/cli/CommandLineParser$UnknownOptionParserState.classPK
+   Y@qG"zÉZ    &           ´{  org/gradle/cli/CommandLineOption.classPK
+   Y@qGl\Ï§  ¦  8           ´ì  org/gradle/cli/CommandLineParser$OptionParserState.classPK
+   Y@qG[xn  Ç  &           ´é  org/gradle/cli/ParsedCommandLine.classPK
+   Y@qGA5l|    :           ´Á  org/gradle/cli/ProjectPropertiesCommandLineConverter.classPK
+   Y@qG2lW¶J    F           ´  org/gradle/cli/CommandLineParser$CaseInsensitiveStringComparator.classPK
+   Y@qG¥´g  Æ*  &           ´C  org/gradle/cli/CommandLineParser.classPK
+   Y@qG_>Ò£  )  3           ´î¡  org/gradle/cli/CommandLineParser$AfterOptions.classPK
+   Y@qGGÑfì    3           ´â¤  org/gradle/cli/CommandLineParser$OptionString.classPK
+   Y@qGx&âT`    ;           ´Å§  org/gradle/cli/AbstractPropertiesCommandLineConverter.classPK
+   Y@qG¼¼     ,           ´~¬  org/gradle/cli/ParsedCommandLineOption.classPK
+   Y@qG¶À°s  ª  =           ´¯  org/gradle/cli/CommandLineParser$OptionAwareParserState.classPK
+   Y@qG'H  g  )           ´w²  org/gradle/cli/CommandLineConverter.classPK
+   Y@qGCÑæê  |  <           ´×³  org/gradle/cli/CommandLineParser$BeforeFirstSubCommand.classPK
+   Y@qG ;|  ü  9           ´¸  org/gradle/cli/SystemPropertiesCommandLineConverter.classPK
+   Y@qG-h  »  2           ´î¹  org/gradle/cli/CommandLineParser$ParserState.classPK
+   Y@qGF¶÷=  Ê	  ;           ´E¼  org/gradle/cli/CommandLineParser$AfterFirstSubCommand.classPK
+   Y@qGÇ'S$F   D              ´Û¿  gradle-cli-classpath.propertiesPK    1 1   ^À    
\ No newline at end of file
diff -Naur wine-2.0a/dlls/wineandroid.drv/gradle-wrapper.properties wine-2.0b/dlls/wineandroid.drv/gradle-wrapper.properties
--- wine-2.0a/dlls/wineandroid.drv/gradle-wrapper.properties	1970-01-01 01:00:00.000000000 +0100
+++ wine-2.0b/dlls/wineandroid.drv/gradle-wrapper.properties	2017-07-11 20:37:51.000000000 +0100
@@ -0,0 +1,6 @@
+#Tue Dec 29 07:10:28 CST 2015
+distributionBase=GRADLE_USER_HOME
+distributionPath=wrapper/dists
+zipStoreBase=GRADLE_USER_HOME
+zipStorePath=wrapper/dists
+distributionUrl=https\://services.gradle.org/distributions/gradle-2.5-bin.zip
diff -Naur wine-2.0a/dlls/wineandroid.drv/ime.c wine-2.0b/dlls/wineandroid.drv/ime.c
--- wine-2.0a/dlls/wineandroid.drv/ime.c	1970-01-01 01:00:00.000000000 +0100
+++ wine-2.0b/dlls/wineandroid.drv/ime.c	2017-07-11 20:37:51.000000000 +0100
@@ -0,0 +1,1528 @@
+/*
+ * The IME for interfacing with Android
+ *
+ * Copyright 2014 CodeWeavers, Aric Stewart
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include "config.h"
+
+#include <stdarg.h>
+#include "windef.h"
+#include "winbase.h"
+#include "wingdi.h"
+#include "winuser.h"
+#include "winerror.h"
+#include "wine/debug.h"
+#include "imm.h"
+#include "ddk/imm.h"
+#include "winnls.h"
+#include "android.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(imm);
+
+#define FROM_ANDROID ((HIMC)0xcafe1337)
+
+typedef struct _IMEPRIVATE {
+    BOOL bInComposition;
+    HFONT textfont;
+    HWND hwndDefault;
+} IMEPRIVATE, *LPIMEPRIVATE;
+
+typedef struct _tagTRANSMSG {
+    UINT message;
+    WPARAM wParam;
+    LPARAM lParam;
+} TRANSMSG, *LPTRANSMSG;
+
+static const WCHAR UI_CLASS_NAME[] = {'W','i','n','e','A','r','d','I','M','E',0};
+
+enum {
+    CONTROL_FINISH = 0xf00,
+    CONTROL_CANCEL,
+    CONTROL_TEXT,
+    CONTROL_START
+};
+
+static HIMC *hSelectedFrom = NULL;
+static INT  hSelectedCount = 0;
+
+s_ime_text **java_ime_text = NULL;
+INT java_ime_active_target = -1;
+INT java_ime_count = 0;
+
+/* MSIME messages */
+static UINT WM_MSIME_SERVICE;
+static UINT WM_MSIME_RECONVERTOPTIONS;
+static UINT WM_MSIME_MOUSE;
+static UINT WM_MSIME_RECONVERTREQUEST;
+static UINT WM_MSIME_RECONVERT;
+static UINT WM_MSIME_QUERYPOSITION;
+static UINT WM_MSIME_DOCUMENTFEED;
+
+static LRESULT WINAPI IME_WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam,
+                                          LPARAM lParam);
+
+static HIMC RealIMC(HIMC hIMC)
+{
+    if (hIMC == FROM_ANDROID)
+    {
+        INT i;
+        HWND wnd = GetFocus();
+        HIMC winHimc = ImmGetContext(wnd);
+        for (i = 0; i < hSelectedCount; i++)
+            if (winHimc == hSelectedFrom[i])
+                return winHimc;
+        return NULL;
+    }
+    else
+        return hIMC;
+}
+
+static LPINPUTCONTEXT LockRealIMC(HIMC hIMC)
+{
+    HIMC real_imc = RealIMC(hIMC);
+    if (real_imc)
+        return ImmLockIMC(real_imc);
+    else
+        return NULL;
+}
+
+static BOOL UnlockRealIMC(HIMC hIMC)
+{
+    HIMC real_imc = RealIMC(hIMC);
+    if (real_imc)
+        return ImmUnlockIMC(real_imc);
+    else
+        return FALSE;
+}
+
+static BOOL WINAPI register_classes( INIT_ONCE *once, void *param, void **context )
+{
+    WNDCLASSW wndClass;
+
+    ZeroMemory(&wndClass, sizeof(WNDCLASSW));
+    wndClass.style = CS_GLOBALCLASS | CS_IME | CS_HREDRAW | CS_VREDRAW;
+    wndClass.lpfnWndProc = IME_WindowProc;
+    wndClass.cbClsExtra = 0;
+    wndClass.cbWndExtra = 2 * sizeof(LONG_PTR);
+    wndClass.hInstance = NULL;
+    wndClass.hCursor = LoadCursorW(NULL, (LPWSTR)IDC_ARROW);
+    wndClass.hIcon = LoadIconW(NULL, (LPWSTR)IDI_APPLICATION);
+    wndClass.hbrBackground = (HBRUSH)(COLOR_WINDOW +1);
+    wndClass.lpszMenuName   = 0;
+    wndClass.lpszClassName = UI_CLASS_NAME;
+
+    RegisterClassW(&wndClass);
+
+    WM_MSIME_SERVICE = RegisterWindowMessageA("MSIMEService");
+    WM_MSIME_RECONVERTOPTIONS = RegisterWindowMessageA("MSIMEReconvertOptions");
+    WM_MSIME_MOUSE = RegisterWindowMessageA("MSIMEMouseOperation");
+    WM_MSIME_RECONVERTREQUEST = RegisterWindowMessageA("MSIMEReconvertRequest");
+    WM_MSIME_RECONVERT = RegisterWindowMessageA("MSIMEReconvert");
+    WM_MSIME_QUERYPOSITION = RegisterWindowMessageA("MSIMEQueryPosition");
+    WM_MSIME_DOCUMENTFEED = RegisterWindowMessageA("MSIMEDocumentFeed");
+    return TRUE;
+}
+
+static HIMCC ImeCreateBlankCompStr(void)
+{
+    HIMCC rc;
+    LPCOMPOSITIONSTRING ptr;
+    rc = ImmCreateIMCC(sizeof(COMPOSITIONSTRING));
+    ptr = ImmLockIMCC(rc);
+    memset(ptr,0,sizeof(COMPOSITIONSTRING));
+    ptr->dwSize = sizeof(COMPOSITIONSTRING);
+    ImmUnlockIMCC(rc);
+    return rc;
+}
+
+static int updateField(DWORD origLen, DWORD origOffset, DWORD currentOffset,
+                       LPBYTE target, LPBYTE source, DWORD* lenParam,
+                       DWORD* offsetParam, BOOL wchars )
+{
+     if (origLen > 0 && origOffset > 0)
+     {
+        int truelen = origLen;
+        if (wchars)
+            truelen *= sizeof(WCHAR);
+
+        memcpy(&target[currentOffset], &source[origOffset], truelen);
+
+        *lenParam = origLen;
+        *offsetParam = currentOffset;
+        currentOffset += truelen;
+     }
+     return currentOffset;
+}
+
+static HIMCC updateCompStr(HIMCC old, LPCWSTR compstr, DWORD len, DWORD *flags)
+{
+    /* we need to make sure the CompStr, CompClaus and CompAttr fields are all
+     * set and correct */
+    int needed_size;
+    HIMCC   rc;
+    LPBYTE newdata = NULL;
+    LPBYTE olddata = NULL;
+    LPCOMPOSITIONSTRING new_one;
+    LPCOMPOSITIONSTRING lpcs = NULL;
+    INT current_offset = 0;
+
+    TRACE("%s, %i\n", debugstr_wn(compstr, len), len);
+
+    if (old == NULL && compstr == NULL && len == 0)
+        return NULL;
+
+    if (compstr == NULL && len != 0)
+    {
+        ERR("compstr is NULL however we have a len!  Please report\n");
+        len = 0;
+    }
+
+    if (old != NULL)
+    {
+        olddata = ImmLockIMCC(old);
+        lpcs = (LPCOMPOSITIONSTRING)olddata;
+    }
+
+    needed_size = sizeof(COMPOSITIONSTRING) + len * sizeof(WCHAR) +
+                  len + sizeof(DWORD) * 2;
+
+    if (lpcs != NULL)
+    {
+        needed_size += lpcs->dwCompReadAttrLen;
+        needed_size += lpcs->dwCompReadClauseLen;
+        needed_size += lpcs->dwCompReadStrLen * sizeof(WCHAR);
+        needed_size += lpcs->dwResultReadClauseLen;
+        needed_size += lpcs->dwResultReadStrLen * sizeof(WCHAR);
+        needed_size += lpcs->dwResultClauseLen;
+        needed_size += lpcs->dwResultStrLen * sizeof(WCHAR);
+        needed_size += lpcs->dwPrivateSize;
+    }
+    rc = ImmCreateIMCC(needed_size);
+    newdata = ImmLockIMCC(rc);
+    new_one = (LPCOMPOSITIONSTRING)newdata;
+
+    new_one->dwSize = needed_size;
+    current_offset = sizeof(COMPOSITIONSTRING);
+    if (lpcs != NULL)
+    {
+        current_offset = updateField(lpcs->dwCompReadAttrLen,
+                                     lpcs->dwCompReadAttrOffset,
+                                     current_offset, newdata, olddata,
+                                     &new_one->dwCompReadAttrLen,
+                                     &new_one->dwCompReadAttrOffset, FALSE);
+
+        current_offset = updateField(lpcs->dwCompReadClauseLen,
+                                     lpcs->dwCompReadClauseOffset,
+                                     current_offset, newdata, olddata,
+                                     &new_one->dwCompReadClauseLen,
+                                     &new_one->dwCompReadClauseOffset, FALSE);
+
+        current_offset = updateField(lpcs->dwCompReadStrLen,
+                                     lpcs->dwCompReadStrOffset,
+                                     current_offset, newdata, olddata,
+                                     &new_one->dwCompReadStrLen,
+                                     &new_one->dwCompReadStrOffset, TRUE);
+
+        /* new CompAttr, CompClause, CompStr, dwCursorPos */
+        new_one->dwDeltaStart = 0;
+
+        current_offset = updateField(lpcs->dwResultReadClauseLen,
+                                     lpcs->dwResultReadClauseOffset,
+                                     current_offset, newdata, olddata,
+                                     &new_one->dwResultReadClauseLen,
+                                     &new_one->dwResultReadClauseOffset, FALSE);
+
+        current_offset = updateField(lpcs->dwResultReadStrLen,
+                                     lpcs->dwResultReadStrOffset,
+                                     current_offset, newdata, olddata,
+                                     &new_one->dwResultReadStrLen,
+                                     &new_one->dwResultReadStrOffset, TRUE);
+
+        current_offset = updateField(lpcs->dwResultClauseLen,
+                                     lpcs->dwResultClauseOffset,
+                                     current_offset, newdata, olddata,
+                                     &new_one->dwResultClauseLen,
+                                     &new_one->dwResultClauseOffset, FALSE);
+
+        current_offset = updateField(lpcs->dwResultStrLen,
+                                     lpcs->dwResultStrOffset,
+                                     current_offset, newdata, olddata,
+                                     &new_one->dwResultStrLen,
+                                     &new_one->dwResultStrOffset, TRUE);
+
+        current_offset = updateField(lpcs->dwPrivateSize,
+                                     lpcs->dwPrivateOffset,
+                                     current_offset, newdata, olddata,
+                                     &new_one->dwPrivateSize,
+                                     &new_one->dwPrivateOffset, FALSE);
+    }
+    else
+    {
+        new_one->dwCursorPos = len;
+        *flags |= GCS_CURSORPOS;
+    }
+
+    /* set new data */
+    /* CompAttr */
+    new_one->dwCompAttrLen = len;
+    if (len > 0)
+    {
+        new_one->dwCompAttrOffset = current_offset;
+        memset(&newdata[current_offset], ATTR_INPUT, len);
+        current_offset += len;
+    }
+
+    /* CompClause */
+    if (len > 0)
+    {
+        new_one->dwCompClauseLen = sizeof(DWORD) * 2;
+        new_one->dwCompClauseOffset = current_offset;
+        *(DWORD*)&newdata[current_offset] = 0;
+        current_offset += sizeof(DWORD);
+        *(DWORD*)&newdata[current_offset] = len;
+        current_offset += sizeof(DWORD);
+    }
+    else
+        new_one->dwCompClauseLen = 0;
+
+    /* CompStr */
+    new_one->dwCompStrLen = len;
+    if (len > 0)
+    {
+        new_one->dwCompStrOffset = current_offset;
+        memcpy(&newdata[current_offset], compstr, len * sizeof(WCHAR));
+    }
+
+    ImmUnlockIMCC(rc);
+    if (lpcs)
+        ImmUnlockIMCC(old);
+
+    return rc;
+}
+
+static HIMCC updateResultStr(HIMCC old, LPWSTR resultstr, DWORD len)
+{
+    /* we need to make sure the ResultStr and ResultClause fields are all
+     * set and correct */
+    int needed_size;
+    HIMCC   rc;
+    LPBYTE newdata = NULL;
+    LPBYTE olddata = NULL;
+    LPCOMPOSITIONSTRING new_one;
+    LPCOMPOSITIONSTRING lpcs = NULL;
+    INT current_offset = 0;
+
+    TRACE("%s, %i\n",debugstr_wn(resultstr,len),len);
+
+    if (old == NULL && resultstr == NULL && len == 0)
+        return NULL;
+
+    if (resultstr == NULL && len != 0)
+    {
+        ERR("resultstr is NULL however we have a len!  Please report\n");
+        len = 0;
+    }
+
+    if (old != NULL)
+    {
+        olddata = ImmLockIMCC(old);
+        lpcs = (LPCOMPOSITIONSTRING)olddata;
+    }
+
+    needed_size = sizeof(COMPOSITIONSTRING) + (len * sizeof(WCHAR)) +
+                  (sizeof(DWORD) * 2);
+
+    if (lpcs != NULL)
+    {
+        needed_size += lpcs->dwCompReadAttrLen;
+        needed_size += lpcs->dwCompReadClauseLen;
+        needed_size += lpcs->dwCompReadStrLen * sizeof(WCHAR);
+        needed_size += lpcs->dwCompAttrLen;
+        needed_size += lpcs->dwCompClauseLen;
+        needed_size += lpcs->dwCompStrLen * sizeof(WCHAR);
+        needed_size += lpcs->dwResultReadClauseLen;
+        needed_size += lpcs->dwResultReadStrLen * sizeof(WCHAR);
+        needed_size += lpcs->dwPrivateSize;
+    }
+    rc = ImmCreateIMCC(needed_size);
+    newdata = ImmLockIMCC(rc);
+    new_one = (LPCOMPOSITIONSTRING)newdata;
+
+    new_one->dwSize = needed_size;
+    current_offset = sizeof(COMPOSITIONSTRING);
+    if (lpcs != NULL)
+    {
+        current_offset = updateField(lpcs->dwCompReadAttrLen,
+                                     lpcs->dwCompReadAttrOffset,
+                                     current_offset, newdata, olddata,
+                                     &new_one->dwCompReadAttrLen,
+                                     &new_one->dwCompReadAttrOffset, FALSE);
+
+        current_offset = updateField(lpcs->dwCompReadClauseLen,
+                                     lpcs->dwCompReadClauseOffset,
+                                     current_offset, newdata, olddata,
+                                     &new_one->dwCompReadClauseLen,
+                                     &new_one->dwCompReadClauseOffset, FALSE);
+
+        current_offset = updateField(lpcs->dwCompReadStrLen,
+                                     lpcs->dwCompReadStrOffset,
+                                     current_offset, newdata, olddata,
+                                     &new_one->dwCompReadStrLen,
+                                     &new_one->dwCompReadStrOffset, TRUE);
+
+        current_offset = updateField(lpcs->dwCompAttrLen,
+                                     lpcs->dwCompAttrOffset,
+                                     current_offset, newdata, olddata,
+                                     &new_one->dwCompAttrLen,
+                                     &new_one->dwCompAttrOffset, FALSE);
+
+        current_offset = updateField(lpcs->dwCompClauseLen,
+                                     lpcs->dwCompClauseOffset,
+                                     current_offset, newdata, olddata,
+                                     &new_one->dwCompClauseLen,
+                                     &new_one->dwCompClauseOffset, FALSE);
+
+        current_offset = updateField(lpcs->dwCompStrLen,
+                                     lpcs->dwCompStrOffset,
+                                     current_offset, newdata, olddata,
+                                     &new_one->dwCompStrLen,
+                                     &new_one->dwCompStrOffset, TRUE);
+
+        new_one->dwCursorPos = lpcs->dwCursorPos;
+        new_one->dwDeltaStart = 0;
+
+        current_offset = updateField(lpcs->dwResultReadClauseLen,
+                                     lpcs->dwResultReadClauseOffset,
+                                     current_offset, newdata, olddata,
+                                     &new_one->dwResultReadClauseLen,
+                                     &new_one->dwResultReadClauseOffset, FALSE);
+
+        current_offset = updateField(lpcs->dwResultReadStrLen,
+                                     lpcs->dwResultReadStrOffset,
+                                     current_offset, newdata, olddata,
+                                     &new_one->dwResultReadStrLen,
+                                     &new_one->dwResultReadStrOffset, TRUE);
+
+        /* new ResultClause , ResultStr */
+
+        current_offset = updateField(lpcs->dwPrivateSize,
+                                     lpcs->dwPrivateOffset,
+                                     current_offset, newdata, olddata,
+                                     &new_one->dwPrivateSize,
+                                     &new_one->dwPrivateOffset, FALSE);
+    }
+
+    /* set new data */
+    /* ResultClause */
+    if (len > 0)
+    {
+        new_one->dwResultClauseLen = sizeof(DWORD) * 2;
+        new_one->dwResultClauseOffset = current_offset;
+        *(DWORD*)(&newdata[current_offset]) = 0;
+        current_offset += sizeof(DWORD);
+        *(DWORD*)(&newdata[current_offset]) = len;
+        current_offset += sizeof(DWORD);
+    }
+    else
+        new_one->dwResultClauseLen = 0;
+
+    /* ResultStr */
+    new_one->dwResultStrLen = len;
+    if (len > 0)
+    {
+        new_one->dwResultStrOffset = current_offset;
+        memcpy(&newdata[current_offset],resultstr,len*sizeof(WCHAR));
+    }
+    ImmUnlockIMCC(rc);
+    if (lpcs)
+        ImmUnlockIMCC(old);
+
+    return rc;
+}
+
+static void GenerateIMEMessage(HIMC hIMC, UINT msg, WPARAM wParam,
+                               LPARAM lParam)
+{
+    LPINPUTCONTEXT lpIMC;
+    LPTRANSMSG lpTransMsg;
+
+    lpIMC = LockRealIMC(hIMC);
+    if (lpIMC == NULL)
+        return;
+
+    lpIMC->hMsgBuf = ImmReSizeIMCC(lpIMC->hMsgBuf, (lpIMC->dwNumMsgBuf + 1) *
+                                    sizeof(TRANSMSG));
+    if (!lpIMC->hMsgBuf)
+        return;
+
+    lpTransMsg = ImmLockIMCC(lpIMC->hMsgBuf);
+    if (!lpTransMsg)
+        return;
+
+    lpTransMsg += lpIMC->dwNumMsgBuf;
+    lpTransMsg->message = msg;
+    lpTransMsg->wParam = wParam;
+    lpTransMsg->lParam = lParam;
+
+    ImmUnlockIMCC(lpIMC->hMsgBuf);
+    lpIMC->dwNumMsgBuf++;
+
+    ImmGenerateMessage(RealIMC(hIMC));
+    UnlockRealIMC(hIMC);
+}
+
+static void GenerateIMECHARMessages(HIMC hIMC, LPWSTR String, DWORD length)
+{
+    LPINPUTCONTEXT lpIMC;
+    LPTRANSMSG lpTransMsg;
+    DWORD i;
+
+    if (length <= 0)
+        return;
+
+    lpIMC = LockRealIMC(hIMC);
+    if (lpIMC == NULL)
+        return;
+
+    lpIMC->hMsgBuf = ImmReSizeIMCC(lpIMC->hMsgBuf,
+                                  (lpIMC->dwNumMsgBuf + length) *
+                                    sizeof(TRANSMSG));
+    if (!lpIMC->hMsgBuf)
+        return;
+
+    lpTransMsg = ImmLockIMCC(lpIMC->hMsgBuf);
+    if (!lpTransMsg)
+        return;
+
+    lpTransMsg += lpIMC->dwNumMsgBuf;
+    for (i = 0; i < length; i++)
+    {
+        lpTransMsg->message = WM_IME_CHAR;
+        lpTransMsg->wParam = String[i];
+        lpTransMsg->lParam = 1;
+        lpTransMsg ++;
+    }
+
+    ImmUnlockIMCC(lpIMC->hMsgBuf);
+    lpIMC->dwNumMsgBuf+=length;
+
+    ImmGenerateMessage(RealIMC(hIMC));
+    UnlockRealIMC(hIMC);
+}
+
+static BOOL IME_RemoveFromSelected(HIMC hIMC)
+{
+    int i;
+    for (i = 0; i < hSelectedCount; i++)
+        if (hSelectedFrom[i] == hIMC)
+        {
+            if (i < hSelectedCount - 1)
+                memmove(&hSelectedFrom[i], &hSelectedFrom[i+1], (hSelectedCount - i - 1)*sizeof(HIMC));
+            hSelectedCount --;
+            return TRUE;
+        }
+    return FALSE;
+}
+
+static void IME_AddToSelected(HIMC hIMC)
+{
+    hSelectedCount++;
+    if (hSelectedFrom)
+        hSelectedFrom = HeapReAlloc(GetProcessHeap(), 0, hSelectedFrom, hSelectedCount*sizeof(HIMC));
+    else
+        hSelectedFrom = HeapAlloc(GetProcessHeap(), 0, sizeof(HIMC));
+    hSelectedFrom[hSelectedCount-1] = hIMC;
+}
+
+BOOL WINAPI ImeInquire(LPIMEINFO lpIMEInfo, LPWSTR lpszUIClass,
+                       LPCWSTR lpszOption)
+{
+    static INIT_ONCE init_once = INIT_ONCE_STATIC_INIT;
+
+    TRACE("\n");
+    InitOnceExecuteOnce( &init_once, register_classes, NULL, NULL );
+    lpIMEInfo->dwPrivateDataSize = sizeof (IMEPRIVATE);
+    lpIMEInfo->fdwProperty = IME_PROP_UNICODE | IME_PROP_AT_CARET;
+    lpIMEInfo->fdwConversionCaps = IME_CMODE_NATIVE | IME_CMODE_FULLSHAPE;
+    lpIMEInfo->fdwSentenceCaps = IME_SMODE_AUTOMATIC;
+    lpIMEInfo->fdwUICaps = UI_CAP_2700;
+    /* Tell App we cannot accept ImeSetCompositionString calls */
+    lpIMEInfo->fdwSCSCaps = 0;
+    lpIMEInfo->fdwSelectCaps = SELECT_CAP_CONVERSION;
+
+    lstrcpyW(lpszUIClass,UI_CLASS_NAME);
+
+    return TRUE;
+}
+
+BOOL WINAPI ImeConfigure(HKL hKL,HWND hWnd, DWORD dwMode, LPVOID lpData)
+{
+    FIXME("(%p, %p, %d, %p): stub\n", hKL, hWnd, dwMode, lpData);
+    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
+    return FALSE;
+}
+
+DWORD WINAPI ImeConversionList(HIMC hIMC, LPCWSTR lpSource,
+                LPCANDIDATELIST lpCandList, DWORD dwBufLen, UINT uFlag)
+
+{
+    FIXME("(%p, %s, %p, %d, %d): stub\n", hIMC, debugstr_w(lpSource),
+                                          lpCandList, dwBufLen, uFlag);
+    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
+    return 0;
+}
+
+BOOL WINAPI ImeDestroy(UINT uForce)
+{
+    TRACE("\n");
+    HeapFree(GetProcessHeap(),0,hSelectedFrom);
+    hSelectedFrom = NULL;
+    hSelectedCount = 0;
+    return TRUE;
+}
+
+LRESULT WINAPI ImeEscape(HIMC hIMC, UINT uSubFunc, LPVOID lpData)
+{
+    FIXME("(%p, %d, %p): stub\n", hIMC, uSubFunc, lpData);
+    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
+    return 0;
+}
+
+BOOL WINAPI ImeProcessKey(HIMC hIMC, UINT vKey, LPARAM lKeyData, const LPBYTE lpbKeyState)
+{
+    /* See the comment at the head of this file */
+    TRACE("We do no processing via this route\n");
+    return FALSE;
+}
+
+BOOL WINAPI ImeSelect(HIMC hIMC, BOOL fSelect)
+{
+    LPINPUTCONTEXT lpIMC;
+    TRACE("%p %s\n",hIMC,(fSelect)?"TRUE":"FALSE");
+
+    if (hIMC == FROM_ANDROID)
+    {
+        ERR("ImeSelect should never be called from Android\n");
+        return FALSE;
+    }
+
+    if (!hIMC)
+        return TRUE;
+
+    /* not selected */
+    if (!fSelect)
+        return IME_RemoveFromSelected(hIMC);
+
+    IME_AddToSelected(hIMC);
+
+    /* Initialize our structures */
+    lpIMC = LockRealIMC(hIMC);
+    if (lpIMC != NULL)
+    {
+        LPIMEPRIVATE myPrivate;
+        myPrivate = ImmLockIMCC(lpIMC->hPrivate);
+        myPrivate->bInComposition = FALSE;
+        myPrivate->textfont = NULL;
+        myPrivate->hwndDefault = NULL;
+        ImmUnlockIMCC(lpIMC->hPrivate);
+        UnlockRealIMC(hIMC);
+    }
+
+    return TRUE;
+}
+
+BOOL WINAPI ImeSetActiveContext(HIMC hIMC,BOOL fFlag)
+{
+    FIXME("(%p, %x): stub\n", hIMC, fFlag);
+    return TRUE;
+}
+
+UINT WINAPI ImeToAsciiEx (UINT uVKey, UINT uScanCode, const LPBYTE lpbKeyState,
+                          LPDWORD lpdwTransKey, UINT fuState, HIMC hIMC)
+{
+    /* See the comment at the head of this file */
+    TRACE("We do no processing via this route\n");
+    return 0;
+}
+
+BOOL WINAPI NotifyIME(HIMC hIMC, DWORD dwAction, DWORD dwIndex, DWORD dwValue)
+{
+    BOOL bRet = FALSE;
+    LPINPUTCONTEXT lpIMC;
+
+    TRACE("%p %i %i %i\n",hIMC,dwAction,dwIndex,dwValue);
+
+    lpIMC = LockRealIMC(hIMC);
+    if (lpIMC == NULL)
+        return FALSE;
+
+    switch (dwAction)
+    {
+        case NI_OPENCANDIDATE: FIXME("NI_OPENCANDIDATE\n"); break;
+        case NI_CLOSECANDIDATE: FIXME("NI_CLOSECANDIDATE\n"); break;
+        case NI_SELECTCANDIDATESTR: FIXME("NI_SELECTCANDIDATESTR\n"); break;
+        case NI_CHANGECANDIDATELIST: FIXME("NI_CHANGECANDIDATELIST\n"); break;
+        case NI_SETCANDIDATE_PAGESTART: FIXME("NI_SETCANDIDATE_PAGESTART\n"); break;
+        case NI_SETCANDIDATE_PAGESIZE: FIXME("NI_SETCANDIDATE_PAGESIZE\n"); break;
+        case NI_CONTEXTUPDATED:
+            switch (dwValue)
+            {
+                case IMC_SETCOMPOSITIONWINDOW: FIXME("IMC_SETCOMPOSITIONWINDOW\n"); break;
+                case IMC_SETCONVERSIONMODE: FIXME("IMC_SETCONVERSIONMODE\n"); break;
+                case IMC_SETSENTENCEMODE: FIXME("IMC_SETSENTENCEMODE\n"); break;
+                case IMC_SETCANDIDATEPOS: FIXME("IMC_SETCANDIDATEPOS\n"); break;
+                case IMC_SETCOMPOSITIONFONT:
+                    {
+                        LPIMEPRIVATE myPrivate;
+                        TRACE("IMC_SETCOMPOSITIONFONT\n");
+
+                        myPrivate = ImmLockIMCC(lpIMC->hPrivate);
+                        if (myPrivate->textfont)
+                        {
+                            DeleteObject(myPrivate->textfont);
+                            myPrivate->textfont = NULL;
+                        }
+                        myPrivate->textfont = CreateFontIndirectW(&lpIMC->lfFont.W);
+                        ImmUnlockIMCC(lpIMC->hPrivate);
+                    }
+                    break;
+                case IMC_SETOPENSTATUS:
+                    {
+                        LPIMEPRIVATE myPrivate;
+                        TRACE("IMC_SETOPENSTATUS\n");
+
+                        myPrivate = ImmLockIMCC(lpIMC->hPrivate);
+                        bRet = TRUE;
+                        if (!lpIMC->fOpen)
+                        {
+                            if (myPrivate->bInComposition)
+                            {
+                                GenerateIMEMessage(hIMC, WM_IME_ENDCOMPOSITION, 0, 0);
+                                myPrivate->bInComposition = FALSE;
+                            }
+                        }
+                        else if (!myPrivate->bInComposition)
+                        {
+                            GenerateIMEMessage(hIMC, WM_IME_STARTCOMPOSITION, 0, 0);
+                            GenerateIMEMessage(hIMC, WM_IME_COMPOSITION, 0, 0);
+                            myPrivate->bInComposition = TRUE;
+                        }
+                        ImmUnlockIMCC(lpIMC->hPrivate);
+                    }
+
+                    break;
+                default: FIXME("Unknown\n"); break;
+            }
+            break;
+        case NI_COMPOSITIONSTR:
+            switch (dwIndex)
+            {
+                case CPS_COMPLETE:
+                {
+                    BOOL inComposition;
+                    HIMCC newCompStr;
+                    DWORD cplen = 0;
+                    LPWSTR cpstr;
+                    LPCOMPOSITIONSTRING cs = NULL;
+                    LPBYTE cdata = NULL;
+                    LPIMEPRIVATE myPrivate;
+
+                    TRACE("NI_COMPOSITIONSTR: CPS_COMPLETE\n");
+
+                    /* We can get these in Android when we are not even
+                       composing. So we need to discard those */
+                    myPrivate = ImmLockIMCC(lpIMC->hPrivate);
+                    inComposition = myPrivate->bInComposition;
+                    ImmUnlockIMCC(lpIMC->hPrivate);
+                    if (!inComposition)
+                    {
+                        TRACE("Complete while not composing. Ignoring\n");
+                        bRet = TRUE;
+                        break;
+                    }
+
+                    /* clear existing result */
+                    newCompStr = updateResultStr(lpIMC->hCompStr, NULL, 0);
+                    ImmDestroyIMCC(lpIMC->hCompStr);
+                    lpIMC->hCompStr = newCompStr;
+
+                    if (lpIMC->hCompStr)
+                    {
+                        cdata = ImmLockIMCC(lpIMC->hCompStr);
+                        cs = (LPCOMPOSITIONSTRING)cdata;
+                        cplen = cs->dwCompStrLen;
+                        cpstr = (LPWSTR)&(cdata[cs->dwCompStrOffset]);
+                        ImmUnlockIMCC(lpIMC->hCompStr);
+                    }
+                    if (cplen > 0)
+                    {
+                        WCHAR param = cpstr[0];
+                        DWORD flags = GCS_COMPSTR;
+
+                        newCompStr = updateResultStr(lpIMC->hCompStr, cpstr, cplen);
+                        ImmDestroyIMCC(lpIMC->hCompStr);
+                        lpIMC->hCompStr = newCompStr;
+                        newCompStr = updateCompStr(lpIMC->hCompStr, NULL, 0, &flags);
+                        ImmDestroyIMCC(lpIMC->hCompStr);
+                        lpIMC->hCompStr = newCompStr;
+
+                        GenerateIMEMessage(hIMC, WM_IME_COMPOSITION, 0, flags);
+
+                        GenerateIMEMessage(hIMC, WM_IME_COMPOSITION, param,
+                                            GCS_RESULTSTR|GCS_RESULTCLAUSE);
+                    }
+                    ImmSetOpenStatus(RealIMC(FROM_ANDROID), FALSE);
+                    bRet = TRUE;
+                }
+                break;
+                case CPS_CONVERT: FIXME("CPS_CONVERT\n"); break;
+                case CPS_REVERT: FIXME("CPS_REVERT\n"); break;
+                case CPS_CANCEL:
+                {
+                    LPIMEPRIVATE myPrivate;
+                    BOOL inComposition;
+                    TRACE("NI_COMPOSITIONSTR: CPS_CANCEL\n");
+
+                    myPrivate = ImmLockIMCC(lpIMC->hPrivate);
+                    inComposition = myPrivate->bInComposition;
+                    ImmUnlockIMCC(lpIMC->hPrivate);
+
+                    if (lpIMC->hCompStr)
+                        ImmDestroyIMCC(lpIMC->hCompStr);
+
+                    lpIMC->hCompStr = ImeCreateBlankCompStr();
+
+                    if (inComposition)
+                        GenerateIMEMessage(hIMC, WM_IME_COMPOSITION, 0, 0);
+
+                    ImmSetOpenStatus(RealIMC(FROM_ANDROID), FALSE);
+
+                    bRet = TRUE;
+                }
+                break;
+                default: FIXME("Unknown\n"); break;
+            }
+            break;
+        default: FIXME("Unknown Message\n"); break;
+    }
+
+    UnlockRealIMC(hIMC);
+    return bRet;
+}
+
+BOOL WINAPI ImeRegisterWord(LPCWSTR lpszReading, DWORD dwStyle,
+                            LPCWSTR lpszRegister)
+{
+    FIXME("(%s, %d, %s): stub\n", debugstr_w(lpszReading), dwStyle,
+                                  debugstr_w(lpszRegister));
+    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
+    return FALSE;
+}
+
+BOOL WINAPI ImeUnregisterWord(LPCWSTR lpszReading, DWORD dwStyle,
+                              LPCWSTR lpszUnregister)
+{
+    FIXME("(%s, %d, %s): stub\n", debugstr_w(lpszReading), dwStyle,
+                                  debugstr_w(lpszUnregister));
+    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
+    return FALSE;
+}
+
+UINT WINAPI ImeGetRegisterWordStyle(UINT nItem, LPSTYLEBUFW lpStyleBuf)
+{
+    FIXME("(%d, %p): stub\n", nItem, lpStyleBuf);
+    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
+    return 0;
+}
+
+UINT WINAPI ImeEnumRegisterWord(REGISTERWORDENUMPROCW lpfnEnumProc,
+                                LPCWSTR lpszReading, DWORD dwStyle,
+                                LPCWSTR lpszRegister, LPVOID lpData)
+{
+    FIXME("(%p, %s, %d, %s, %p): stub\n", lpfnEnumProc,
+            debugstr_w(lpszReading), dwStyle, debugstr_w(lpszRegister),
+            lpData);
+    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
+    return 0;
+}
+
+BOOL WINAPI IME_SetCompositionString(HIMC hIMC, DWORD dwIndex, LPCVOID lpComp,
+                                    DWORD dwCompLen, DWORD cursor_pos,
+                                    BOOL cursor_valid)
+{
+    LPINPUTCONTEXT lpIMC;
+    DWORD flags = 0;
+    WCHAR wParam  = 0;
+    LPIMEPRIVATE myPrivate;
+    BOOL inComposition;
+
+    TRACE("(%p, %d, %p, %d):\n",
+         hIMC, dwIndex, lpComp, dwCompLen);
+
+
+    if (hIMC != FROM_ANDROID)
+        FIXME("PROBLEM: This only sets the wine level string\n");
+
+    /*
+    * Explanation:
+    *  this sets the composition string in the imm32.dll level
+    *  of the composition buffer. we cannot manipulate the xim level
+    *  buffer, which means that once the xim level buffer changes again
+    *  any call to this function from the application will be lost
+    */
+
+    lpIMC = LockRealIMC(hIMC);
+
+    if (lpIMC == NULL)
+        return FALSE;
+
+    myPrivate = ImmLockIMCC(lpIMC->hPrivate);
+    inComposition = myPrivate->bInComposition;
+    ImmUnlockIMCC(lpIMC->hPrivate);
+
+    if (dwIndex == SCS_SETSTR)
+    {
+        HIMCC newCompStr;
+
+        if (!inComposition)
+            ImmSetOpenStatus(RealIMC(hIMC), TRUE);
+
+        flags = GCS_COMPSTR;
+
+        if (dwCompLen && lpComp)
+        {
+            newCompStr = updateCompStr(lpIMC->hCompStr, (LPCWSTR)lpComp, dwCompLen / sizeof(WCHAR), &flags);
+            ImmDestroyIMCC(lpIMC->hCompStr);
+            lpIMC->hCompStr = newCompStr;
+
+             wParam = ((const WCHAR*)lpComp)[0];
+             flags |= GCS_COMPCLAUSE | GCS_COMPATTR | GCS_DELTASTART;
+        }
+        else
+        {
+            newCompStr = updateCompStr(lpIMC->hCompStr, NULL, 0, &flags);
+            ImmDestroyIMCC(lpIMC->hCompStr);
+            lpIMC->hCompStr = newCompStr;
+        }
+
+        if (cursor_valid)
+        {
+            LPCOMPOSITIONSTRING compstr;
+            compstr = ImmLockIMCC(lpIMC->hCompStr);
+            compstr->dwCursorPos = cursor_pos;
+            ImmUnlockIMCC(lpIMC->hCompStr);
+            flags |= GCS_CURSORPOS;
+        }
+    }
+
+    GenerateIMEMessage(hIMC, WM_IME_COMPOSITION, wParam, flags);
+    UnlockRealIMC(hIMC);
+
+    return TRUE;
+}
+
+BOOL WINAPI ImeSetCompositionString(HIMC hIMC, DWORD dwIndex, LPCVOID lpComp, DWORD dwCompLen,
+                                    LPCVOID lpRead, DWORD dwReadLen)
+{
+    TRACE("(%p, %d, %p, %d, %p, %d):\n", hIMC, dwIndex, lpComp, dwCompLen, lpRead, dwReadLen);
+
+    if (lpRead && dwReadLen)
+        FIXME("Reading string unimplemented\n");
+
+    return IME_SetCompositionString(hIMC, dwIndex, lpComp, dwCompLen, 0, FALSE);
+}
+
+DWORD WINAPI ImeGetImeMenuItems(HIMC hIMC,  DWORD dwFlags,  DWORD dwType,
+            LPIMEMENUITEMINFOW lpImeParentMenu, LPIMEMENUITEMINFOW lpImeMenu,
+            DWORD dwSize)
+{
+    FIXME("(%p, %x %x %p %p %x): stub\n", hIMC, dwFlags, dwType,
+                                lpImeParentMenu, lpImeMenu, dwSize);
+    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
+    return 0;
+}
+
+/*****
+ * Internal functions to help with IME window management
+ */
+static void PaintDefaultIMEWnd(HIMC hIMC, HWND hwnd)
+{
+    PAINTSTRUCT ps;
+    RECT rect;
+    HDC hdc;
+    LPCOMPOSITIONSTRING compstr;
+    LPBYTE compdata = NULL;
+    HMONITOR monitor;
+    MONITORINFO mon_info;
+    INT offX=0, offY=0;
+    LPINPUTCONTEXT lpIMC;
+
+    lpIMC = LockRealIMC(hIMC);
+    if (lpIMC == NULL)
+        return;
+
+    hdc = BeginPaint(hwnd,&ps);
+
+    GetClientRect(hwnd,&rect);
+    FillRect(hdc, &rect, (HBRUSH)(COLOR_WINDOW + 1));
+
+    compdata = ImmLockIMCC(lpIMC->hCompStr);
+    compstr = (LPCOMPOSITIONSTRING)compdata;
+
+    if (compstr->dwCompStrLen && compstr->dwCompStrOffset)
+    {
+        SIZE size;
+        POINT pt;
+        HFONT oldfont = NULL;
+        LPWSTR CompString;
+        LPIMEPRIVATE myPrivate;
+
+        CompString = (LPWSTR)(compdata + compstr->dwCompStrOffset);
+        myPrivate = ImmLockIMCC(lpIMC->hPrivate);
+
+        if (myPrivate->textfont)
+            oldfont = SelectObject(hdc,myPrivate->textfont);
+
+        ImmUnlockIMCC(lpIMC->hPrivate);
+
+        GetTextExtentPoint32W(hdc, CompString, compstr->dwCompStrLen, &size);
+        pt.x = size.cx;
+        pt.y = size.cy;
+        LPtoDP(hdc,&pt,1);
+
+        /*
+         * How this works based on tests on windows:
+         * CFS_POINT: then we start our window at the point and grow it as large
+         *    as it needs to be for the string.
+         * CFS_RECT:  we still use the ptCurrentPos as a starting point and our
+         *    window is only as large as we need for the string, but we do not
+         *    grow such that our window exceeds the given rect.  Wrapping if
+         *    needed and possible.   If our ptCurrentPos is outside of our rect
+         *    then no window is displayed.
+         * CFS_FORCE_POSITION: appears to behave just like CFS_POINT
+         *    maybe because the default MSIME does not do any IME adjusting.
+         */
+        if (lpIMC->cfCompForm.dwStyle != CFS_DEFAULT)
+        {
+            POINT cpt = lpIMC->cfCompForm.ptCurrentPos;
+            ClientToScreen(lpIMC->hWnd,&cpt);
+            rect.left = cpt.x;
+            rect.top = cpt.y;
+            rect.right = rect.left + pt.x;
+            rect.bottom = rect.top + pt.y;
+            monitor = MonitorFromPoint(cpt, MONITOR_DEFAULTTOPRIMARY);
+        }
+        else /* CFS_DEFAULT */
+        {
+            /* Windows places the default IME window in the bottom left */
+
+            /* However! on Android with the soft keyboard having this window
+               in the bottom left is a terrible place because it is covered
+               by the soft keyboard.  So change this location to the top-left
+               where it will be visible */
+            HWND target = lpIMC->hWnd;
+            if (!target) target = GetFocus();
+
+            GetWindowRect(target,&rect);
+            rect.right = rect.left + pt.x + 20;
+            rect.bottom = rect.top + pt.y + 20;
+            offX=offY=10;
+            monitor = MonitorFromWindow(target, MONITOR_DEFAULTTOPRIMARY);
+        }
+
+        if (lpIMC->cfCompForm.dwStyle == CFS_RECT)
+        {
+            RECT client;
+            client =lpIMC->cfCompForm.rcArea;
+            MapWindowPoints( lpIMC->hWnd, 0, (POINT *)&client, 2 );
+            IntersectRect(&rect,&rect,&client);
+            /* TODO:  Wrap the input if needed */
+        }
+
+        if (lpIMC->cfCompForm.dwStyle == CFS_DEFAULT)
+        {
+            /* make sure we are on the desktop */
+            mon_info.cbSize = sizeof(mon_info);
+            GetMonitorInfoW(monitor, &mon_info);
+
+            if (rect.bottom > mon_info.rcWork.bottom)
+            {
+                int shift = rect.bottom - mon_info.rcWork.bottom;
+                rect.top -= shift;
+                rect.bottom -= shift;
+            }
+            if (rect.left < 0)
+            {
+                rect.right -= rect.left;
+                rect.left = 0;
+            }
+            if (rect.right > mon_info.rcWork.right)
+            {
+                int shift = rect.right - mon_info.rcWork.right;
+                rect.left -= shift;
+                rect.right -= shift;
+            }
+        }
+
+        SetWindowPos(hwnd, HWND_TOPMOST, rect.left, rect.top, rect.right - rect.left, rect.bottom - rect.top, SWP_NOACTIVATE);
+
+        TextOutW(hdc, offX,offY, CompString, compstr->dwCompStrLen);
+
+        if (oldfont)
+            SelectObject(hdc,oldfont);
+    }
+
+    ImmUnlockIMCC(lpIMC->hCompStr);
+
+    EndPaint(hwnd,&ps);
+    UnlockRealIMC(hIMC);
+}
+
+static void UpdateDefaultIMEWindow(HIMC hIMC, HWND hwnd)
+{
+    LPCOMPOSITIONSTRING compstr;
+    LPINPUTCONTEXT lpIMC;
+
+    lpIMC = LockRealIMC(hIMC);
+    if (lpIMC == NULL)
+        return;
+
+    if (lpIMC->hCompStr)
+        compstr = ImmLockIMCC(lpIMC->hCompStr);
+    else
+        compstr = NULL;
+
+    if (compstr == NULL || compstr->dwCompStrLen == 0)
+        ShowWindow(hwnd,SW_HIDE);
+    else
+    {
+        ShowWindow(hwnd,SW_SHOWNOACTIVATE);
+        RedrawWindow(hwnd, NULL, NULL, RDW_ERASENOW | RDW_INVALIDATE);
+    }
+
+    if (compstr != NULL)
+        ImmUnlockIMCC(lpIMC->hCompStr);
+
+    lpIMC->hWnd = GetFocus();
+    UnlockRealIMC(hIMC);
+}
+
+static void DefaultIMEComposition(HIMC hIMC, HWND hwnd, LPARAM lParam)
+{
+    TRACE("IME message WM_IME_COMPOSITION 0x%lx\n", lParam);
+    if (lParam & GCS_RESULTSTR)
+    {
+        LPCOMPOSITIONSTRING compstr;
+        LPBYTE compdata;
+        LPWSTR ResultStr;
+        HIMCC newCompStr;
+        LPINPUTCONTEXT lpIMC;
+
+        lpIMC = LockRealIMC(hIMC);
+        if (lpIMC == NULL)
+            return;
+
+        TRACE("Posting result as IME_CHAR\n");
+        compdata = ImmLockIMCC(lpIMC->hCompStr);
+        compstr = (LPCOMPOSITIONSTRING)compdata;
+        ResultStr = (LPWSTR)(compdata + compstr->dwResultStrOffset);
+        GenerateIMECHARMessages(hIMC, ResultStr, compstr->dwResultStrLen);
+        ImmUnlockIMCC(lpIMC->hCompStr);
+
+        /* clear the buffer */
+        newCompStr = updateResultStr(lpIMC->hCompStr, NULL, 0);
+        ImmDestroyIMCC(lpIMC->hCompStr);
+        lpIMC->hCompStr = newCompStr;
+        UnlockRealIMC(hIMC);
+    }
+    else
+        UpdateDefaultIMEWindow(hIMC, hwnd);
+}
+
+static void DefaultIMEStartComposition(HIMC hIMC, HWND hwnd )
+{
+    TRACE("IME message WM_IME_STARTCOMPOSITION\n");
+    UpdateDefaultIMEWindow(hIMC, hwnd);
+}
+
+static LRESULT ImeHandleNotify(HIMC hIMC, HWND hwnd, UINT msg, WPARAM wParam,
+                               LPARAM lParam)
+{
+    switch (wParam)
+    {
+        case IMN_OPENSTATUSWINDOW:
+            FIXME("WM_IME_NOTIFY:IMN_OPENSTATUSWINDOW\n");
+            break;
+        case IMN_CLOSESTATUSWINDOW:
+            FIXME("WM_IME_NOTIFY:IMN_CLOSESTATUSWINDOW\n");
+            break;
+        case IMN_OPENCANDIDATE:
+            FIXME("WM_IME_NOTIFY:IMN_OPENCANDIDATE\n");
+            break;
+        case IMN_CHANGECANDIDATE:
+            FIXME("WM_IME_NOTIFY:IMN_CHANGECANDIDATE\n");
+            break;
+        case IMN_CLOSECANDIDATE:
+            FIXME("WM_IME_NOTIFY:IMN_CLOSECANDIDATE\n");
+            break;
+        case IMN_SETCONVERSIONMODE:
+            FIXME("WM_IME_NOTIFY:IMN_SETCONVERSIONMODE\n");
+            break;
+        case IMN_SETSENTENCEMODE:
+            FIXME("WM_IME_NOTIFY:IMN_SETSENTENCEMODE\n");
+            break;
+        case IMN_SETOPENSTATUS:
+            TRACE("WM_IME_NOTIFY:IMN_SETOPENSTATUS\n");
+            break;
+        case IMN_SETCANDIDATEPOS:
+            FIXME("WM_IME_NOTIFY:IMN_SETCANDIDATEPOS\n");
+            break;
+        case IMN_SETCOMPOSITIONFONT:
+            FIXME("WM_IME_NOTIFY:IMN_SETCOMPOSITIONFONT\n");
+            break;
+        case IMN_SETCOMPOSITIONWINDOW:
+            FIXME("WM_IME_NOTIFY:IMN_SETCOMPOSITIONWINDOW\n");
+            break;
+        case IMN_GUIDELINE:
+            FIXME("WM_IME_NOTIFY:IMN_GUIDELINE\n");
+            break;
+        case IMN_SETSTATUSWINDOWPOS:
+            FIXME("WM_IME_NOTIFY:IMN_SETSTATUSWINDOWPOS\n");
+            break;
+        default:
+            FIXME("WM_IME_NOTIFY:<Unknown 0x%lx>\n",wParam);
+            break;
+    }
+    return 0;
+}
+
+static LRESULT WINAPI IME_WindowProc(HWND hwnd, UINT msg, WPARAM wParam,
+                                          LPARAM lParam)
+{
+    LRESULT rc = 0;
+    HIMC    hIMC;
+
+    TRACE("Incoming Message 0x%x  (0x%08lx, 0x%08lx)\n", msg, wParam, lParam);
+
+    /*
+     * Each UI window contains the current Input Context.
+     * This Input Context can be obtained by calling GetWindowLong
+     * with IMMGWL_IMC when the UI window receives a WM_IME_xxx message.
+     * The UI window can refer to this Input Context and handles the
+     * messages.
+     */
+
+    hIMC = (HIMC)GetWindowLongPtrW(hwnd,IMMGWL_IMC);
+    if (!hIMC)
+        hIMC = RealIMC(FROM_ANDROID);
+
+    /* if we have no hIMC there are many messages we cannot process */
+    if (hIMC == NULL)
+    {
+        switch (msg) {
+        case WM_IME_STARTCOMPOSITION:
+        case WM_IME_ENDCOMPOSITION:
+        case WM_IME_COMPOSITION:
+        case WM_IME_NOTIFY:
+        case WM_IME_CONTROL:
+        case WM_IME_COMPOSITIONFULL:
+        case WM_IME_SELECT:
+        case WM_IME_CHAR:
+            return 0L;
+        default:
+            break;
+        }
+    }
+
+    switch(msg)
+    {
+        case WM_CREATE:
+        {
+            LPIMEPRIVATE myPrivate;
+            LPINPUTCONTEXT lpIMC;
+
+            SetWindowTextA(hwnd,"Wine Ime Active");
+
+            lpIMC = LockRealIMC(hIMC);
+            if (lpIMC)
+            {
+                myPrivate = ImmLockIMCC(lpIMC->hPrivate);
+                myPrivate->hwndDefault = hwnd;
+                ImmUnlockIMCC(lpIMC->hPrivate);
+            }
+            UnlockRealIMC(hIMC);
+
+            return TRUE;
+        }
+        case WM_PAINT:
+            PaintDefaultIMEWnd(hIMC, hwnd);
+            return FALSE;
+
+        case WM_NCCREATE:
+            return TRUE;
+
+        case WM_SETFOCUS:
+            if (wParam)
+                SetFocus((HWND)wParam);
+            else
+                FIXME("Received focus, should never have focus\n");
+            break;
+        case WM_IME_COMPOSITION:
+            DefaultIMEComposition(hIMC, hwnd, lParam);
+            break;
+        case WM_IME_STARTCOMPOSITION:
+            DefaultIMEStartComposition(hIMC, hwnd);
+            break;
+        case WM_IME_ENDCOMPOSITION:
+            TRACE("IME message %s, 0x%lx, 0x%lx\n",
+                    "WM_IME_ENDCOMPOSITION", wParam, lParam);
+            ShowWindow(hwnd,SW_HIDE);
+            break;
+        case WM_IME_SELECT:
+            TRACE("IME message %s, 0x%lx, 0x%lx\n","WM_IME_SELECT", wParam, lParam);
+            break;
+        case WM_IME_NOTIFY:
+            rc = ImeHandleNotify(hIMC,hwnd,msg,wParam,lParam);
+            break;
+       default:
+            TRACE("Non-standard message 0x%x\n",msg);
+    }
+    /* check the MSIME messages */
+    if (msg == WM_MSIME_SERVICE)
+    {
+            TRACE("IME message %s, 0x%lx, 0x%lx\n","WM_MSIME_SERVICE", wParam, lParam);
+            rc = FALSE;
+    }
+    else if (msg == WM_MSIME_RECONVERTOPTIONS)
+    {
+            TRACE("IME message %s, 0x%lx, 0x%lx\n","WM_MSIME_RECONVERTOPTIONS", wParam, lParam);
+    }
+    else if (msg == WM_MSIME_MOUSE)
+    {
+            TRACE("IME message %s, 0x%lx, 0x%lx\n","WM_MSIME_MOUSE", wParam, lParam);
+    }
+    else if (msg == WM_MSIME_RECONVERTREQUEST)
+    {
+            TRACE("IME message %s, 0x%lx, 0x%lx\n","WM_MSIME_RECONVERTREQUEST", wParam, lParam);
+    }
+    else if (msg == WM_MSIME_RECONVERT)
+    {
+            TRACE("IME message %s, 0x%lx, 0x%lx\n","WM_MSIME_RECONVERT", wParam, lParam);
+    }
+    else if (msg == WM_MSIME_QUERYPOSITION)
+    {
+            TRACE("IME message %s, 0x%lx, 0x%lx\n","WM_MSIME_QUERYPOSITION", wParam, lParam);
+    }
+    else if (msg == WM_MSIME_DOCUMENTFEED)
+    {
+            TRACE("IME message %s, 0x%lx, 0x%lx\n","WM_MSIME_DOCUMENTFEED", wParam, lParam);
+    }
+    /* DefWndProc if not an IME message */
+    if (!rc && !((msg >= WM_IME_STARTCOMPOSITION && msg <= WM_IME_KEYLAST) ||
+                      (msg >= WM_IME_SETCONTEXT && msg <= WM_IME_KEYUP)))
+        rc = DefWindowProcW(hwnd,msg,wParam,lParam);
+
+    return rc;
+}
+
+LRESULT Ime_Control(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp)
+{
+    LRESULT rc;
+
+    TRACE("Incoming IME_CONTROL 0x%x  (0x%08lx, 0x%08lx)\n", msg, wp, lp);
+    switch (wp)
+    {
+        case CONTROL_CANCEL:
+            NotifyIME(FROM_ANDROID, NI_COMPOSITIONSTR, CPS_CANCEL, 0);
+            rc = 0;
+            break;
+        case CONTROL_FINISH:
+        case CONTROL_TEXT:
+        {
+            WCHAR *buffer;
+            INT length, target, cursor;
+
+            length = HIWORD(lp);
+            target = LOWORD(lp);
+
+            if (length > 1)
+            {
+                buffer = HeapAlloc(GetProcessHeap(), 0, length * sizeof(WCHAR));
+                ioctl_imeText(target, &cursor, &length, buffer);
+                /* Skip trailing NULL */
+                length --;
+                if (cursor > 0)
+                    cursor = length - 1 + cursor;
+                else
+                    cursor = -1 * cursor;
+                IME_SetCompositionString(FROM_ANDROID, SCS_SETSTR, buffer, length * sizeof(WCHAR), cursor, TRUE);
+
+                HeapFree(GetProcessHeap(), 0, buffer);
+            }
+            else
+                IME_SetCompositionString(FROM_ANDROID, SCS_SETSTR, NULL, 0, 0, TRUE);
+
+            if (wp == CONTROL_FINISH)
+            {
+                ioctl_imeFinish(target);
+                NotifyIME(FROM_ANDROID, NI_COMPOSITIONSTR, CPS_COMPLETE, 0);
+            }
+        }
+        break;
+        case CONTROL_START:
+        {
+            LPINPUTCONTEXT lpIMC;
+            LPIMEPRIVATE myPrivate;
+            BOOL inComposition;
+
+            lpIMC = LockRealIMC(FROM_ANDROID);
+            myPrivate = ImmLockIMCC(lpIMC->hPrivate);
+            inComposition = myPrivate->bInComposition;
+            ImmUnlockIMCC(lpIMC->hPrivate);
+            UnlockRealIMC(FROM_ANDROID);
+
+            if (!inComposition)
+                ImmSetOpenStatus(RealIMC(FROM_ANDROID), TRUE);
+            rc = 0;
+        }
+        break;
+    }
+    return rc;
+}
+
+/* ANDROID interfaces from the event queue */
+void handle_IME_TEXT(int target, int length)
+{
+    SendMessageTimeoutW(GetForegroundWindow(), WM_ANDROID_IME_CONTROL, CONTROL_TEXT, MAKELONG(target, length), SMTO_ABORTIFHUNG, 1000, NULL);
+}
+
+void handle_IME_FINISH(int target, int length)
+{
+    SendMessageTimeoutW(GetForegroundWindow(), WM_ANDROID_IME_CONTROL, CONTROL_FINISH, MAKELONG(target, length), SMTO_ABORTIFHUNG, 1000, NULL);
+}
+
+void handle_IME_CANCEL()
+{
+    SendMessageTimeoutW(GetForegroundWindow(), WM_ANDROID_IME_CONTROL, CONTROL_CANCEL, 0, SMTO_ABORTIFHUNG, 1000, NULL);
+}
+
+void handle_IME_START()
+{
+    SendMessageTimeoutW(GetForegroundWindow(), WM_ANDROID_IME_CONTROL, CONTROL_START, 0, SMTO_ABORTIFHUNG, 1000, NULL );
+}
+
+void IME_UpdateAssociation(HWND focus)
+{
+    ImmGetContext(focus);
+
+    if (!focus || !hSelectedFrom)
+        return;
+
+    ImmAssociateContext(focus,RealIMC(FROM_ANDROID));
+    /* Ensure UI Window Creation */
+    ImmSetOpenStatus(RealIMC(FROM_ANDROID), FALSE);
+}
+
+/*-------------------------------------------*/
+/* The following are run in the Java process */
+/*-------------------------------------------*/
+void ime_start( JNIEnv *env, jobject obj )
+{
+    union event_data data;
+
+    p__android_log_print( ANDROID_LOG_INFO, "wine", "ime_start\n");
+    memset( &data, 0, sizeof(data) );
+    data.type = IME_START;
+    send_event( desktop_thread, &data );
+}
+
+void ime_text( JNIEnv *env, jobject obj, jstring text, jint length, jint cursor)
+{
+    union event_data data;
+    const jchar* _text = (*env)->GetStringChars(env, text, 0);
+
+    p__android_log_print( ANDROID_LOG_INFO, "wine", "ime_text: %i chars\n", length);
+    p__android_log_print( ANDROID_LOG_INFO, "wine", "ime_text: %i target\n", java_ime_active_target);
+
+    /* Find / ensure target */
+
+    if (java_ime_active_target < 0)
+    {
+        int target;
+
+        if (java_ime_count == 0)
+        {
+            java_ime_count = 5;
+            java_ime_text = malloc(java_ime_count * sizeof(*java_ime_text));
+            memset(java_ime_text, 0, java_ime_count * sizeof(*java_ime_text));
+        }
+        for (target = 0; target < java_ime_count; target++)
+            if (java_ime_text[target] == NULL)
+                break;
+        if (target == java_ime_count)
+        {
+            java_ime_text = realloc(java_ime_text, (java_ime_count*2) * sizeof(*java_ime_text));
+            memset(&java_ime_text[java_ime_count], 0, sizeof(*java_ime_text) * java_ime_count);
+            target = java_ime_count;
+            java_ime_count *= 2;
+        }
+        java_ime_active_target = target;
+        java_ime_text[java_ime_active_target] = malloc(sizeof(s_ime_text));
+        memset(java_ime_text[java_ime_active_target], 0, sizeof(s_ime_text));
+    }
+
+    memset( &data, 0, sizeof(data) );
+    data.type = IME_TEXT;
+    data.ime_text.target = java_ime_active_target;
+    data.ime_text.length = length + 1;
+
+    if (java_ime_text[java_ime_active_target]->text)
+        free(java_ime_text[java_ime_active_target]->text);
+
+    java_ime_text[java_ime_active_target]->text = malloc((length+1) * sizeof(WCHAR));
+    lstrcpynW(java_ime_text[java_ime_active_target]->text, (WCHAR*)_text, length+1);
+    java_ime_text[java_ime_active_target]->length = length+1;
+    java_ime_text[java_ime_active_target]->cursor_pos = cursor;
+
+    (*env)->ReleaseStringChars(env, text, _text);
+
+    send_event( desktop_thread, &data );
+}
+
+void ime_finish( JNIEnv *env, jobject obj)
+{
+    union event_data data;
+    p__android_log_print( ANDROID_LOG_INFO, "wine", "ime_finish: %i\n", java_ime_active_target);
+    if (java_ime_active_target < 0)
+        return;
+    memset( &data, 0, sizeof(data) );
+    data.type = IME_FINISH;
+    data.ime_finish.target = java_ime_active_target;
+    data.ime_finish.length = java_ime_text[java_ime_active_target]->length;
+    java_ime_active_target = -1;
+    send_event( desktop_thread, &data );
+}
+
+void ime_cancel( JNIEnv *env, jobject obj )
+{
+    union event_data data;
+    p__android_log_print( ANDROID_LOG_INFO, "wine", "ime_cancel\n");
+    memset( &data, 0, sizeof(data) );
+    data.type = IME_CANCEL;
+    send_event( desktop_thread, &data );
+}
diff -Naur wine-2.0a/dlls/wineandroid.drv/init.c wine-2.0b/dlls/wineandroid.drv/init.c
--- wine-2.0a/dlls/wineandroid.drv/init.c	1970-01-01 01:00:00.000000000 +0100
+++ wine-2.0b/dlls/wineandroid.drv/init.c	2017-07-11 20:37:51.000000000 +0100
@@ -0,0 +1,889 @@
+/*
+ * Android driver initialisation functions
+ *
+ * Copyright 1996, 2013 Alexandre Julliard
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#define NONAMELESSSTRUCT
+#define NONAMELESSUNION
+#include "config.h"
+#include "wine/port.h"
+
+#include <stdarg.h>
+#include <string.h>
+#include <SLES/OpenSLES.h>
+
+#include "windef.h"
+#include "winbase.h"
+#include "winreg.h"
+#include "android.h"
+#include "wine/server.h"
+#include "wine/library.h"
+#include "wine/debug.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(android);
+
+unsigned int screen_width = 0;
+unsigned int screen_height = 0;
+unsigned int screen_bpp = 32;
+unsigned int screen_dpi = 0;
+RECT virtual_screen_rect = { 0, 0, 0, 0 };
+
+MONITORINFOEXW default_monitor =
+{
+    sizeof(default_monitor),    /* cbSize */
+    { 0, 0, 0, 0 },             /* rcMonitor */
+    { 0, 0, 0, 0 },             /* rcWork */
+    MONITORINFOF_PRIMARY,       /* dwFlags */
+    { '\\','\\','.','\\','D','I','S','P','L','A','Y','1',0 }   /* szDevice */
+};
+
+static int device_init_done;
+
+static const WCHAR dpi_key_name[] = {'S','o','f','t','w','a','r','e','\\','F','o','n','t','s','\0'};
+static const WCHAR dpi_value_name[] = {'L','o','g','P','i','x','e','l','s','\0'};
+
+static const struct gdi_dc_funcs android_drv_funcs;
+
+DWORD thread_data_tls_index = TLS_OUT_OF_INDEXES;
+static JavaVM *java_vm;
+
+
+/******************************************************************************
+ *      set_screen_dpi
+ */
+void set_screen_dpi( DWORD dpi, BOOL force )
+{
+    HKEY hkey;
+
+    if (!dpi) return;
+    if (screen_dpi) return;  /* already set */
+
+    TRACE( "setting to %u force %d\n", dpi, force );
+    if (!force && RegOpenKeyW(HKEY_CURRENT_CONFIG, dpi_key_name, &hkey) == ERROR_SUCCESS)
+    {
+        DWORD tmp, type, size = sizeof(tmp);
+        if (RegQueryValueExW(hkey, dpi_value_name, NULL, &type, (void *)&tmp, &size) == ERROR_SUCCESS)
+        {
+            if (type == REG_DWORD)
+            {
+                RegCloseKey(hkey);
+                goto exit;
+            }
+        }
+        RegCloseKey(hkey);
+    }
+    if (!RegCreateKeyW( HKEY_CURRENT_CONFIG, dpi_key_name, &hkey ))
+    {
+        RegSetValueExW( hkey, dpi_value_name, 0, REG_DWORD, (void *)&dpi, sizeof(DWORD) );
+        RegCloseKey( hkey );
+    }
+ exit:
+    screen_dpi = dpi;
+}
+
+/******************************************************************************
+ *      get_dpi
+ *
+ * get the dpi from the registry
+ */
+static DWORD get_dpi(void)
+{
+    HKEY hkey;
+    DWORD dpi = 0;
+
+    if (RegOpenKeyW(HKEY_CURRENT_CONFIG, dpi_key_name, &hkey) == ERROR_SUCCESS)
+    {
+        DWORD type, size = sizeof(dpi);
+        if (RegQueryValueExW(hkey, dpi_value_name, NULL, &type, (void *)&dpi, &size) == ERROR_SUCCESS)
+        {
+            if (type != REG_DWORD) dpi = 0;
+        }
+        RegCloseKey(hkey);
+    }
+    if (!dpi) dpi = 96;
+    return dpi;
+}
+
+/******************************************************************************
+ *      init_monitors
+ */
+void init_monitors( int width, int height )
+{
+    static const WCHAR trayW[] = {'S','h','e','l','l','_','T','r','a','y','W','n','d',0};
+    RECT rect;
+    HWND hwnd = FindWindowW( trayW, NULL );
+
+    virtual_screen_rect.right = width;
+    virtual_screen_rect.bottom = height;
+    default_monitor.rcMonitor = default_monitor.rcWork = virtual_screen_rect;
+
+    if (!hwnd || !IsWindowVisible( hwnd )) return;
+    if (!GetWindowRect( hwnd, &rect )) return;
+    if (rect.top) default_monitor.rcWork.bottom = rect.top;
+    else default_monitor.rcWork.top = rect.bottom;
+    TRACE( "found tray %p %s work area %s\n", hwnd,
+           wine_dbgstr_rect( &rect ), wine_dbgstr_rect( &default_monitor.rcWork ));
+}
+
+void handle_run_cmdline( LPWSTR cmdline, LPWSTR* wineEnv )
+{
+    STARTUPINFOW si;
+    PROCESS_INFORMATION pi;
+    UNICODE_STRING var, val;
+    WCHAR *env = NULL;
+
+    ZeroMemory( &si, sizeof(STARTUPINFOW) );
+    TRACE( "Running windows cmd: : %s\n", debugstr_w( cmdline ) );
+
+    if (wineEnv && !RtlCreateEnvironment( TRUE, &env ))
+    {
+        while (*wineEnv)
+        {
+            RtlInitUnicodeString( &var, *wineEnv++ );
+            RtlInitUnicodeString( &val, *wineEnv++ );
+            RtlSetEnvironmentVariable( &env, &var, &val );
+        }
+    }
+
+    if (!CreateProcessW( NULL, cmdline, NULL, NULL, FALSE,
+                         DETACHED_PROCESS | CREATE_UNICODE_ENVIRONMENT, env, NULL, &si, &pi ))
+        ERR( "Failed to run cmd : Error %d\n", GetLastError() );
+
+    if (env) RtlDestroyEnvironment( env );
+}
+
+static void fetch_display_metrics(void)
+{
+    if (java_vm) return;  /* for Java threads it will be set when the surface is created */
+
+    SERVER_START_REQ( get_window_rectangles )
+    {
+        req->handle = wine_server_user_handle( GetDesktopWindow() );
+        req->relative = COORDS_CLIENT;
+        if (!wine_server_call( req ))
+        {
+            screen_width  = reply->window.right;
+            screen_height = reply->window.bottom;
+        }
+    }
+    SERVER_END_REQ;
+
+    init_monitors( screen_width, screen_height );
+    screen_dpi = get_dpi();
+    TRACE( "%ux%u %u dpi\n", screen_width, screen_height, screen_dpi );
+}
+
+/**********************************************************************
+ *	     device_init
+ *
+ * Perform initializations needed upon creation of the first device.
+ */
+static void device_init(void)
+{
+    device_init_done = TRUE;
+    fetch_display_metrics();
+}
+
+
+static ANDROID_PDEVICE *create_android_physdev(void)
+{
+    ANDROID_PDEVICE *physdev;
+
+    if (!device_init_done) device_init();
+
+    if (!(physdev = HeapAlloc( GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(*physdev) ))) return NULL;
+    return physdev;
+}
+
+/**********************************************************************
+ *	     ANDROID_CreateDC
+ */
+static BOOL ANDROID_CreateDC( PHYSDEV *pdev, LPCWSTR driver, LPCWSTR device,
+                              LPCWSTR output, const DEVMODEW* initData )
+{
+    ANDROID_PDEVICE *physdev = create_android_physdev();
+
+    if (!physdev) return FALSE;
+
+    push_dc_driver( pdev, &physdev->dev, &android_drv_funcs );
+    return TRUE;
+}
+
+
+/**********************************************************************
+ *	     ANDROID_CreateCompatibleDC
+ */
+static BOOL ANDROID_CreateCompatibleDC( PHYSDEV orig, PHYSDEV *pdev )
+{
+    ANDROID_PDEVICE *physdev = create_android_physdev();
+
+    if (!physdev) return FALSE;
+
+    push_dc_driver( pdev, &physdev->dev, &android_drv_funcs );
+    return TRUE;
+}
+
+
+/**********************************************************************
+ *	     ANDROID_DeleteDC
+ */
+static BOOL ANDROID_DeleteDC( PHYSDEV dev )
+{
+    ANDROID_PDEVICE *physdev = get_android_dev( dev );
+
+    HeapFree( GetProcessHeap(), 0, physdev );
+    return TRUE;
+}
+
+
+/***********************************************************************
+ *           GetDeviceCaps
+ */
+static INT ANDROID_GetDeviceCaps( PHYSDEV dev, INT cap )
+{
+    switch(cap)
+    {
+    case DRIVERVERSION:
+        return 0x300;
+    case TECHNOLOGY:
+        return DT_RASDISPLAY;
+    case HORZSIZE:
+        return MulDiv( screen_width, 254, screen_dpi * 10 );
+    case VERTSIZE:
+        return MulDiv( screen_height, 254, screen_dpi * 10 );
+    case HORZRES:
+        return screen_width;
+    case VERTRES:
+        return screen_height;
+    case DESKTOPHORZRES:
+        return virtual_screen_rect.right - virtual_screen_rect.left;
+    case DESKTOPVERTRES:
+        return virtual_screen_rect.bottom - virtual_screen_rect.top;
+    case BITSPIXEL:
+        return screen_bpp;
+    case PLANES:
+        return 1;
+    case NUMBRUSHES:
+        return -1;
+    case NUMPENS:
+        return -1;
+    case NUMMARKERS:
+        return 0;
+    case NUMFONTS:
+        return 0;
+    case NUMCOLORS:
+        /* MSDN: Number of entries in the device's color table, if the device has
+         * a color depth of no more than 8 bits per pixel.For devices with greater
+         * color depths, -1 is returned. */
+        return -1;
+    case PDEVICESIZE:
+        return sizeof(ANDROID_PDEVICE);
+    case CURVECAPS:
+        return (CC_CIRCLES | CC_PIE | CC_CHORD | CC_ELLIPSES | CC_WIDE |
+                CC_STYLED | CC_WIDESTYLED | CC_INTERIORS | CC_ROUNDRECT);
+    case LINECAPS:
+        return (LC_POLYLINE | LC_MARKER | LC_POLYMARKER | LC_WIDE |
+                LC_STYLED | LC_WIDESTYLED | LC_INTERIORS);
+    case POLYGONALCAPS:
+        return (PC_POLYGON | PC_RECTANGLE | PC_WINDPOLYGON | PC_SCANLINE |
+                PC_WIDE | PC_STYLED | PC_WIDESTYLED | PC_INTERIORS);
+    case TEXTCAPS:
+        return (TC_OP_CHARACTER | TC_OP_STROKE | TC_CP_STROKE |
+                TC_CR_ANY | TC_SF_X_YINDEP | TC_SA_DOUBLE | TC_SA_INTEGER |
+                TC_SA_CONTIN | TC_UA_ABLE | TC_SO_ABLE | TC_RA_ABLE | TC_VA_ABLE);
+    case CLIPCAPS:
+        return CP_REGION;
+    case COLORRES:
+        /* The observed correspondence between BITSPIXEL and COLORRES is:
+         * BITSPIXEL: 8  -> COLORRES: 18
+         * BITSPIXEL: 16 -> COLORRES: 16
+         * BITSPIXEL: 24 -> COLORRES: 24
+         * BITSPIXEL: 32 -> COLORRES: 24 */
+        return (screen_bpp <= 8) ? 18 : min( 24, screen_bpp );
+    case RASTERCAPS:
+        return (RC_BITBLT | RC_BANDING | RC_SCALING | RC_BITMAP64 | RC_DI_BITMAP |
+                RC_DIBTODEV | RC_BIGFONT | RC_STRETCHBLT | RC_STRETCHDIB | RC_DEVBITS);
+    case SHADEBLENDCAPS:
+        return (SB_GRAD_RECT | SB_GRAD_TRI | SB_CONST_ALPHA | SB_PIXEL_ALPHA);
+    case ASPECTX:
+    case ASPECTY:
+        return 36;
+    case ASPECTXY:
+        return 51;
+    case LOGPIXELSX:
+        return screen_dpi;
+    case LOGPIXELSY:
+        return screen_dpi;
+    case CAPS1:
+        FIXME("(%p): CAPS1 is unimplemented, will return 0\n", dev->hdc );
+        /* please see wingdi.h for the possible bit-flag values that need
+           to be returned. */
+        return 0;
+    case SIZEPALETTE:
+        return 0;
+    case NUMRESERVED:
+    case PHYSICALWIDTH:
+    case PHYSICALHEIGHT:
+    case PHYSICALOFFSETX:
+    case PHYSICALOFFSETY:
+    case SCALINGFACTORX:
+    case SCALINGFACTORY:
+    case VREFRESH:
+    case BLTALIGNMENT:
+        return 0;
+    default:
+        FIXME("(%p): unsupported capability %d, will return 0\n", dev->hdc, cap );
+        return 0;
+    }
+}
+
+
+/***********************************************************************
+ *		ANDROID_ChangeDisplaySettingsEx
+ */
+LONG CDECL ANDROID_ChangeDisplaySettingsEx( LPCWSTR devname, LPDEVMODEW devmode,
+                                            HWND hwnd, DWORD flags, LPVOID lpvoid )
+{
+    FIXME( "(%s,%p,%p,0x%08x,%p)\n", debugstr_w( devname ), devmode, hwnd, flags, lpvoid );
+    return DISP_CHANGE_SUCCESSFUL;
+}
+
+
+/***********************************************************************
+ *		ANDROID_GetMonitorInfo
+ */
+BOOL CDECL ANDROID_GetMonitorInfo( HMONITOR handle, LPMONITORINFO info )
+{
+    if (handle != (HMONITOR)1)
+    {
+        SetLastError( ERROR_INVALID_HANDLE );
+        return FALSE;
+    }
+    info->rcMonitor = default_monitor.rcMonitor;
+    info->rcWork = default_monitor.rcWork;
+    info->dwFlags = default_monitor.dwFlags;
+    if (info->cbSize >= sizeof(MONITORINFOEXW))
+        lstrcpyW( ((MONITORINFOEXW *)info)->szDevice, default_monitor.szDevice );
+    return TRUE;
+}
+
+
+/***********************************************************************
+ *		ANDROID_EnumDisplayMonitors
+ */
+BOOL CDECL ANDROID_EnumDisplayMonitors( HDC hdc, LPRECT rect, MONITORENUMPROC proc, LPARAM lp )
+{
+    if (hdc)
+    {
+        POINT origin;
+        RECT limit, monrect;
+
+        if (!GetDCOrgEx( hdc, &origin )) return FALSE;
+        if (GetClipBox( hdc, &limit ) == ERROR) return FALSE;
+
+        if (rect && !IntersectRect( &limit, &limit, rect )) return TRUE;
+
+        monrect = default_monitor.rcMonitor;
+        OffsetRect( &monrect, -origin.x, -origin.y );
+        if (IntersectRect( &monrect, &monrect, &limit ))
+            if (!proc( (HMONITOR)1, hdc, &monrect, lp ))
+                return FALSE;
+    }
+    else
+    {
+        RECT unused;
+        if (!rect || IntersectRect( &unused, &default_monitor.rcMonitor, rect ))
+            if (!proc( (HMONITOR)1, 0, &default_monitor.rcMonitor, lp ))
+                return FALSE;
+    }
+    return TRUE;
+}
+
+
+/***********************************************************************
+ *		ANDROID_EnumDisplaySettingsEx
+ */
+BOOL CDECL ANDROID_EnumDisplaySettingsEx( LPCWSTR name, DWORD n, LPDEVMODEW devmode, DWORD flags)
+{
+    static const WCHAR dev_name[CCHDEVICENAME] =
+        { 'W','i','n','e',' ','A','n','d','r','o','i','d',' ','d','r','i','v','e','r',0 };
+
+    devmode->dmSize = offsetof( DEVMODEW, dmICMMethod );
+    devmode->dmSpecVersion = DM_SPECVERSION;
+    devmode->dmDriverVersion = DM_SPECVERSION;
+    memcpy( devmode->dmDeviceName, dev_name, sizeof(dev_name) );
+    devmode->dmDriverExtra = 0;
+    devmode->u2.dmDisplayFlags = 0;
+    devmode->dmDisplayFrequency = 0;
+    devmode->u1.s2.dmPosition.x = 0;
+    devmode->u1.s2.dmPosition.y = 0;
+    devmode->u1.s2.dmDisplayOrientation = 0;
+    devmode->u1.s2.dmDisplayFixedOutput = 0;
+
+    if (n == ENUM_CURRENT_SETTINGS)
+    {
+        n = 0;
+    }
+    if (n == ENUM_REGISTRY_SETTINGS)
+    {
+        n = 0;
+    }
+    if (n == 0)
+    {
+        devmode->dmPelsWidth = screen_width;
+        devmode->dmPelsHeight = screen_height;
+        devmode->dmBitsPerPel = screen_bpp;
+        devmode->dmDisplayFrequency = 60;
+        devmode->dmFields = DM_PELSWIDTH | DM_PELSHEIGHT | DM_BITSPERPEL | DM_DISPLAYFLAGS;
+        if (devmode->dmDisplayFrequency)
+        {
+            devmode->dmFields |= DM_DISPLAYFREQUENCY;
+            TRACE("mode %d -- %dx%dx%dbpp @%d Hz\n", n,
+                  devmode->dmPelsWidth, devmode->dmPelsHeight, devmode->dmBitsPerPel,
+                  devmode->dmDisplayFrequency);
+        }
+        else
+        {
+            TRACE("mode %d -- %dx%dx%dbpp\n", n,
+                  devmode->dmPelsWidth, devmode->dmPelsHeight, devmode->dmBitsPerPel);
+        }
+        return TRUE;
+    }
+    TRACE("mode %d -- not present\n", n);
+    SetLastError(ERROR_NO_MORE_FILES);
+    return FALSE;
+}
+
+
+/**********************************************************************
+ *           ANDROID_wine_get_wgl_driver
+ */
+static struct opengl_funcs * ANDROID_wine_get_wgl_driver( PHYSDEV dev, UINT version )
+{
+    struct opengl_funcs *ret;
+
+    if (!(ret = get_wgl_driver( version )))
+    {
+        dev = GET_NEXT_PHYSDEV( dev, wine_get_wgl_driver );
+        ret = dev->funcs->wine_get_wgl_driver( dev, version );
+    }
+    return ret;
+}
+
+
+static const struct gdi_dc_funcs android_drv_funcs =
+{
+    NULL,                               /* pAbortDoc */
+    NULL,                               /* pAbortPath */
+    NULL,                               /* pAlphaBlend */
+    NULL,                               /* pAngleArc */
+    NULL,                               /* pArc */
+    NULL,                               /* pArcTo */
+    NULL,                               /* pBeginPath */
+    NULL,                               /* pBlendImage */
+    NULL,                               /* pChord */
+    NULL,                               /* pCloseFigure */
+    ANDROID_CreateCompatibleDC,         /* pCreateCompatibleDC */
+    ANDROID_CreateDC,                   /* pCreateDC */
+    ANDROID_DeleteDC,                   /* pDeleteDC */
+    NULL,                               /* pDeleteObject */
+    NULL,                               /* pDeviceCapabilities */
+    NULL,                               /* pEllipse */
+    NULL,                               /* pEndDoc */
+    NULL,                               /* pEndPage */
+    NULL,                               /* pEndPath */
+    NULL,                               /* pEnumFonts */
+    NULL,                               /* pEnumICMProfiles */
+    NULL,                               /* pExcludeClipRect */
+    NULL,                               /* pExtDeviceMode */
+    NULL,                               /* pExtEscape */
+    NULL,                               /* pExtFloodFill */
+    NULL,                               /* pExtSelectClipRgn */
+    NULL,                               /* pExtTextOut */
+    NULL,                               /* pFillPath */
+    NULL,                               /* pFillRgn */
+    NULL,                               /* pFlattenPath */
+    NULL,                               /* pFontIsLinked */
+    NULL,                               /* pFrameRgn */
+    NULL,                               /* pGdiComment */
+    NULL,                               /* pGetBoundsRect */
+    NULL,                               /* pGetCharABCWidths */
+    NULL,                               /* pGetCharABCWidthsI */
+    NULL,                               /* pGetCharWidth */
+    ANDROID_GetDeviceCaps,              /* pGetDeviceCaps */
+    NULL,                               /* pGetDeviceGammaRamp */
+    NULL,                               /* pGetFontData */
+    NULL,                               /* pGetFontRealizationInfo */
+    NULL,                               /* pGetFontUnicodeRanges */
+    NULL,                               /* pGetGlyphIndices */
+    NULL,                               /* pGetGlyphOutline */
+    NULL,                               /* pGetICMProfile */
+    NULL,                               /* pGetImage */
+    NULL,                               /* pGetKerningPairs */
+    NULL,                               /* pGetNearestColor */
+    NULL,                               /* pGetOutlineTextMetrics */
+    NULL,                               /* pGetPixel */
+    NULL,                               /* pGetSystemPaletteEntries */
+    NULL,                               /* pGetTextCharsetInfo */
+    NULL,                               /* pGetTextExtentExPoint */
+    NULL,                               /* pGetTextExtentExPointI */
+    NULL,                               /* pGetTextFace */
+    NULL,                               /* pGetTextMetrics */
+    NULL,                               /* pGradientFill */
+    NULL,                               /* pIntersectClipRect */
+    NULL,                               /* pInvertRgn */
+    NULL,                               /* pLineTo */
+    NULL,                               /* pModifyWorldTransform */
+    NULL,                               /* pMoveTo */
+    NULL,                               /* pOffsetClipRgn */
+    NULL,                               /* pOffsetViewportOrg */
+    NULL,                               /* pOffsetWindowOrg */
+    NULL,                               /* pPaintRgn */
+    NULL,                               /* pPatBlt */
+    NULL,                               /* pPie */
+    NULL,                               /* pPolyBezier */
+    NULL,                               /* pPolyBezierTo */
+    NULL,                               /* pPolyDraw */
+    NULL,                               /* pPolyPolygon */
+    NULL,                               /* pPolyPolyline */
+    NULL,                               /* pPolygon */
+    NULL,                               /* pPolyline */
+    NULL,                               /* pPolylineTo */
+    NULL,                               /* pPutImage */
+    NULL,                               /* pRealizeDefaultPalette */
+    NULL,                               /* pRealizePalette */
+    NULL,                               /* pRectangle */
+    NULL,                               /* pResetDC */
+    NULL,                               /* pRestoreDC */
+    NULL,                               /* pRoundRect */
+    NULL,                               /* pSaveDC */
+    NULL,                               /* pScaleViewportExt */
+    NULL,                               /* pScaleWindowExt */
+    NULL,                               /* pSelectBitmap */
+    NULL,                               /* pSelectBrush */
+    NULL,                               /* pSelectClipPath */
+    NULL,                               /* pSelectFont */
+    NULL,                               /* pSelectPalette */
+    NULL,                               /* pSelectPen */
+    NULL,                               /* pSetArcDirection */
+    NULL,                               /* pSetBkColor */
+    NULL,                               /* pSetBkMode */
+    NULL,                               /* pSetBoundsRect */
+    NULL,                               /* pSetDCBrushColor */
+    NULL,                               /* pSetDCPenColor */
+    NULL,                               /* pSetDIBitsToDevice */
+    NULL,                               /* pSetDeviceClipping */
+    NULL,                               /* pSetDeviceGammaRamp */
+    NULL,                               /* pSetLayout */
+    NULL,                               /* pSetMapMode */
+    NULL,                               /* pSetMapperFlags */
+    NULL,                               /* pSetPixel */
+    NULL,                               /* pSetPolyFillMode */
+    NULL,                               /* pSetROP2 */
+    NULL,                               /* pSetRelAbs */
+    NULL,                               /* pSetStretchBltMode */
+    NULL,                               /* pSetTextAlign */
+    NULL,                               /* pSetTextCharacterExtra */
+    NULL,                               /* pSetTextColor */
+    NULL,                               /* pSetTextJustification */
+    NULL,                               /* pSetViewportExt */
+    NULL,                               /* pSetViewportOrg */
+    NULL,                               /* pSetWindowExt */
+    NULL,                               /* pSetWindowOrg */
+    NULL,                               /* pSetWorldTransform */
+    NULL,                               /* pStartDoc */
+    NULL,                               /* pStartPage */
+    NULL,                               /* pStretchBlt */
+    NULL,                               /* pStretchDIBits */
+    NULL,                               /* pStrokeAndFillPath */
+    NULL,                               /* pStrokePath */
+    NULL,                               /* pUnrealizePalette */
+    NULL,                               /* pWidenPath */
+    ANDROID_wine_get_wgl_driver,        /* wine_get_wgl_driver */
+    GDI_PRIORITY_GRAPHICS_DRV           /* priority */
+};
+
+
+/******************************************************************************
+ *      ANDROID_get_gdi_driver
+ */
+const struct gdi_dc_funcs * CDECL ANDROID_get_gdi_driver( unsigned int version )
+{
+    if (version != WINE_GDI_DRIVER_VERSION)
+    {
+        ERR( "version mismatch, gdi32 wants %u but winex11 has %u\n", version, WINE_GDI_DRIVER_VERSION );
+        return NULL;
+    }
+    return &android_drv_funcs;
+}
+
+static int create_event_pipe( int fd[2] )
+{
+    int ret;
+#ifdef HAVE_PIPE2
+    if (!(ret = pipe2( fd, O_CLOEXEC | O_NONBLOCK ))) return ret;
+#endif
+    if (!(ret = pipe( fd )))
+    {
+        fcntl( fd[0], F_SETFD, FD_CLOEXEC );
+        fcntl( fd[1], F_SETFD, FD_CLOEXEC );
+        fcntl( fd[0], F_SETFL, O_NONBLOCK );
+        fcntl( fd[1], F_SETFL, O_NONBLOCK );
+    }
+    return ret;
+}
+
+static void set_queue_event_fd( int fd )
+{
+    HANDLE handle;
+    int ret;
+
+    if (wine_server_fd_to_handle( fd, GENERIC_READ | SYNCHRONIZE, 0, &handle ))
+    {
+        ERR( "Can't allocate handle for event fd\n" );
+        ExitProcess(1);
+    }
+    SERVER_START_REQ( set_queue_fd )
+    {
+        req->handle = wine_server_obj_handle( handle );
+        ret = wine_server_call( req );
+    }
+    SERVER_END_REQ;
+    if (ret)
+    {
+        ERR( "Can't store handle for event fd %x\n", ret );
+        ExitProcess(1);
+    }
+    CloseHandle( handle );
+}
+
+struct android_thread_data *android_init_thread_data(void)
+{
+    struct android_thread_data *data = android_thread_data();
+
+    if (data) return data;
+
+    if (!(data = HeapAlloc( GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(*data) )) ||
+        create_event_pipe( data->event_pipe ) == -1)
+    {
+        ERR( "could not create data\n" );
+        ExitProcess(1);
+    }
+    TlsSetValue( thread_data_tls_index, data );
+    set_queue_event_fd( data->event_pipe[0] );
+    list_init( &data->event_queue );
+
+    return data;
+}
+
+static void thread_detach(void)
+{
+    struct android_thread_data *data = TlsGetValue( thread_data_tls_index );
+
+    if (data)
+    {
+        close( data->event_pipe[0] );
+        close( data->event_pipe[1] );
+        HeapFree( GetProcessHeap(), 0, data );
+    }
+}
+
+static const JNINativeMethod methods[] =
+{
+    { "wine_keyboard_event", "(IIIII)Z", keyboard_event },
+    { "wine_clear_meta_key_states", "(I)V", clear_meta_key_states },
+    { "wine_motion_event", "(IIIIII)Z", motion_event },
+    { "wine_surface_changed", "(ILandroid/view/Surface;)V", surface_changed },
+    { "wine_desktop_changed", "(II)V", desktop_changed },
+    { "wine_config_changed", "(IZ)V", config_changed },
+    { "wine_clipboard_changed", "([Z)V", clipboard_changed },
+    { "wine_import_clipboard_data", "(I[B)V", import_clipboard_data },
+    { "wine_clipboard_request", "(I)V", clipboard_request },
+    { "wine_ime_settext", "(Ljava/lang/String;II)V", ime_text},
+    { "wine_ime_finishtext", "()V", ime_finish},
+    { "wine_ime_canceltext", "()V", ime_cancel},
+    { "wine_ime_start", "()V", ime_start},
+
+    { "wine_send_gamepad_count", "(I)V", gamepad_count},
+    { "wine_send_gamepad_data", "(IILjava/lang/String;)V", gamepad_data},
+    { "wine_send_gamepad_axis", "(I[F)V", gamepad_sendaxis},
+    { "wine_send_gamepad_button", "(III)V", gamepad_sendbutton},
+
+    { "wine_run_commandline", "(Ljava/lang/String;[Ljava/lang/String;)V", run_commandline }
+};
+
+#define DECL_FUNCPTR(f) typeof(f) * p##f = NULL
+#define LOAD_FUNCPTR(lib, func) do { \
+    if ((p##func = wine_dlsym( lib, #func, NULL, 0 )) == NULL) \
+        { ERR( "can't find symbol %s\n", #func); return; } \
+    } while(0)
+
+DECL_FUNCPTR( __android_log_print );
+DECL_FUNCPTR( ANativeWindow_fromSurface );
+DECL_FUNCPTR( ANativeWindow_release );
+DECL_FUNCPTR( hw_get_module );
+DECL_FUNCPTR( slCreateEngine );
+DECL_FUNCPTR( SL_IID_ANDROIDSIMPLEBUFFERQUEUE );
+DECL_FUNCPTR( SL_IID_ENGINE );
+DECL_FUNCPTR( SL_IID_PLAY );
+DECL_FUNCPTR( SL_IID_PLAYBACKRATE );
+DECL_FUNCPTR( SL_IID_RECORD );
+
+void run_commandline( JNIEnv *env, jobject obj, jobject _cmdline, jobjectArray _wineEnv )
+{
+    union event_data data;
+    const jchar* cmdline = (*env)->GetStringChars(env, _cmdline, 0);
+    jsize len = (*env)->GetStringLength( env, _cmdline );
+    int j;
+    
+    memset( &data, 0, sizeof(data) );
+    data.type = RUN_CMDLINE;
+    data.runcmd.cmdline = malloc( sizeof(WCHAR) * (len + 1) );
+    lstrcpynW( data.runcmd.cmdline, (WCHAR*)cmdline, len + 1 );
+    (*env)->ReleaseStringChars(env, _cmdline, cmdline);
+
+    if (_wineEnv)
+    {
+        int count = (*env)->GetArrayLength( env, _wineEnv );
+
+        data.runcmd.env = malloc( sizeof(LPWSTR*) * (count + 1) );
+        for (j = 0; j < count; j++)
+        {
+            jobject s = (*env)->GetObjectArrayElement( env, _wineEnv, j );
+            const jchar *key_val_str = (*env)->GetStringChars( env, s, NULL );
+            len = (*env)->GetStringLength( env, s );
+            data.runcmd.env[j] = malloc( sizeof(WCHAR) * (len + 1) );
+            lstrcpynW( data.runcmd.env[j], (WCHAR*)key_val_str, len + 1 );
+            (*env)->ReleaseStringChars( env, s, key_val_str );
+        }
+        data.runcmd.env[j] = 0;
+    }
+
+    send_event( desktop_thread, &data );
+}
+
+struct gralloc_module_t *gralloc_module = NULL;
+
+static void load_hardware_libs(void)
+{
+    const struct hw_module_t *module;
+    void *libhardware;
+    char error[256];
+
+    if (!(libhardware = wine_dlopen( "libhardware.so", RTLD_GLOBAL, error, sizeof(error) )))
+    {
+        ERR( "failed to load libhardware.so: %s\n", error );
+        return;
+    }
+    LOAD_FUNCPTR( libhardware, hw_get_module );
+
+    if (phw_get_module( GRALLOC_HARDWARE_MODULE_ID, &module ) == 0)
+        gralloc_module = (struct gralloc_module_t *)module;
+    else
+        ERR( "failed to load gralloc module\n" );
+}
+
+static void load_android_libs(void)
+{
+    void *libandroid, *liblog;
+    char error[1024];
+
+    if (!(libandroid = wine_dlopen( "libandroid.so", RTLD_GLOBAL, error, sizeof(error) )))
+    {
+        ERR( "failed to load libandroid.so: %s\n", error );
+        return;
+    }
+    if (!(liblog = wine_dlopen( "liblog.so", RTLD_GLOBAL, error, sizeof(error) )))
+    {
+        ERR( "failed to load liblog.so: %s\n", error );
+        return;
+    }
+    LOAD_FUNCPTR( liblog, __android_log_print );
+    LOAD_FUNCPTR( libandroid, ANativeWindow_fromSurface );
+    LOAD_FUNCPTR( libandroid, ANativeWindow_release );
+}
+
+static void load_opensles_libs(void)
+{
+    void *libopensles;
+    char error[1024];
+
+    if (!(libopensles = wine_dlopen( "libOpenSLES.so", RTLD_GLOBAL, error, sizeof(error) )))
+    {
+        ERR( "failed to load libOpenSLES.so: %s\n", error );
+        return;
+    }
+    LOAD_FUNCPTR( libopensles, slCreateEngine );
+    LOAD_FUNCPTR( libopensles, SL_IID_ANDROIDSIMPLEBUFFERQUEUE );
+    LOAD_FUNCPTR( libopensles, SL_IID_ENGINE );
+    LOAD_FUNCPTR( libopensles, SL_IID_PLAY );
+    LOAD_FUNCPTR( libopensles, SL_IID_PLAYBACKRATE );
+    LOAD_FUNCPTR( libopensles, SL_IID_RECORD );
+}
+
+#undef DECL_FUNCPTR
+#undef LOAD_FUNCPTR
+
+static BOOL process_attach(void)
+{
+    jclass class;
+    jobject object = wine_get_java_object();
+    JNIEnv *jni_env;
+
+    if ((thread_data_tls_index = TlsAlloc()) == TLS_OUT_OF_INDEXES) return FALSE;
+
+    load_hardware_libs();
+
+    load_opensles_libs();
+    g_timer_q = CreateTimerQueue();
+
+    if ((java_vm = wine_get_java_vm()))  /* running under Java */
+    {
+#ifdef __i386__
+        WORD old_fs = wine_get_fs();
+#endif
+
+        load_android_libs();
+        (*java_vm)->AttachCurrentThread( java_vm, &jni_env, 0 );
+        class = (*jni_env)->GetObjectClass( jni_env, object );
+        (*jni_env)->RegisterNatives( jni_env, class, methods, sizeof(methods)/sizeof(methods[0]) );
+        (*jni_env)->DeleteLocalRef( jni_env, class );
+
+#ifdef __i386__
+        wine_set_fs( old_fs );  /* the Java VM hijacks %fs for its own purposes, restore it */
+#endif
+    }
+    return TRUE;
+}
+
+/***********************************************************************
+ *       dll initialisation routine
+ */
+BOOL WINAPI DllMain( HINSTANCE inst, DWORD reason, LPVOID reserved )
+{
+    switch (reason)
+    {
+    case DLL_PROCESS_ATTACH:
+        return process_attach();
+    case DLL_THREAD_DETACH:
+        thread_detach();
+        break;
+    }
+    return TRUE;
+}
+
diff -Naur wine-2.0a/dlls/wineandroid.drv/keyboard.c wine-2.0b/dlls/wineandroid.drv/keyboard.c
--- wine-2.0a/dlls/wineandroid.drv/keyboard.c	1970-01-01 01:00:00.000000000 +0100
+++ wine-2.0b/dlls/wineandroid.drv/keyboard.c	2017-07-11 20:37:51.000000000 +0100
@@ -0,0 +1,913 @@
+/*
+ * Keyboard related functions
+ *
+ * Copyright 1993 Bob Amstadt
+ * Copyright 1996 Albrecht Kleine
+ * Copyright 1997 David Faure
+ * Copyright 1998 Morten Welinder
+ * Copyright 1998 Ulrich Weigand
+ * Copyright 1999 Ove KÃ¥ven
+ * Copyright 2011, 2012, 2013 Ken Thomases for CodeWeavers Inc.
+ * Copyright 2013, Alexandre Julliard
+ * Copyright 2015, Josh DuBois for CodeWeavers Inc.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#define NONAMELESSUNION
+#define NONAMELESSSTRUCT
+ 
+#include "config.h"
+
+
+#include "android.h"
+#include "winuser.h"
+#include "wine/debug.h"
+#include "wine/unicode.h"
+#include "wine/server.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(keyboard);
+WINE_DECLARE_DEBUG_CHANNEL(key);
+
+static const UINT keycode_to_vkey[] =
+{
+    0,             /* AKEYCODE_UNKNOWN */
+    0,             /* AKEYCODE_SOFT_LEFT */
+    0,             /* AKEYCODE_SOFT_RIGHT */
+    0,             /* AKEYCODE_HOME */
+    0,             /* AKEYCODE_BACK */
+    0,             /* AKEYCODE_CALL */
+    0,             /* AKEYCODE_ENDCALL */
+    '0',           /* AKEYCODE_0 */
+    '1',           /* AKEYCODE_1 */
+    '2',           /* AKEYCODE_2 */
+    '3',           /* AKEYCODE_3 */
+    '4',           /* AKEYCODE_4 */
+    '5',           /* AKEYCODE_5 */
+    '6',           /* AKEYCODE_6 */
+    '7',           /* AKEYCODE_7 */
+    '8',           /* AKEYCODE_8 */
+    '9',           /* AKEYCODE_9 */
+    0,             /* AKEYCODE_STAR */
+    0,             /* AKEYCODE_POUND */
+    VK_UP,         /* AKEYCODE_DPAD_UP */
+    VK_DOWN,       /* AKEYCODE_DPAD_DOWN */
+    VK_LEFT,       /* AKEYCODE_DPAD_LEFT */
+    VK_RIGHT,      /* AKEYCODE_DPAD_RIGHT */
+    0,             /* AKEYCODE_DPAD_CENTER */
+    0,             /* AKEYCODE_VOLUME_UP */
+    0,             /* AKEYCODE_VOLUME_DOWN */
+    0,             /* AKEYCODE_POWER */
+    0,             /* AKEYCODE_CAMERA */
+    0,             /* AKEYCODE_CLEAR */
+    'A',           /* AKEYCODE_A */
+    'B',           /* AKEYCODE_B */
+    'C',           /* AKEYCODE_C */
+    'D',           /* AKEYCODE_D */
+    'E',           /* AKEYCODE_E */
+    'F',           /* AKEYCODE_F */
+    'G',           /* AKEYCODE_G */
+    'H',           /* AKEYCODE_H */
+    'I',           /* AKEYCODE_I */
+    'J',           /* AKEYCODE_J */
+    'K',           /* AKEYCODE_K */
+    'L',           /* AKEYCODE_L */
+    'M',           /* AKEYCODE_M */
+    'N',           /* AKEYCODE_N */
+    'O',           /* AKEYCODE_O */
+    'P',           /* AKEYCODE_P */
+    'Q',           /* AKEYCODE_Q */
+    'R',           /* AKEYCODE_R */
+    'S',           /* AKEYCODE_S */
+    'T',           /* AKEYCODE_T */
+    'U',           /* AKEYCODE_U */
+    'V',           /* AKEYCODE_V */
+    'W',           /* AKEYCODE_W */
+    'X',           /* AKEYCODE_X */
+    'Y',           /* AKEYCODE_Y */
+    'Z',           /* AKEYCODE_Z */
+    VK_OEM_COMMA,  /* AKEYCODE_COMMA */
+    VK_OEM_PERIOD, /* AKEYCODE_PERIOD */
+    VK_LMENU,      /* AKEYCODE_ALT_LEFT */
+    VK_RMENU,      /* AKEYCODE_ALT_RIGHT */
+    VK_LSHIFT,     /* AKEYCODE_SHIFT_LEFT */
+    VK_RSHIFT,     /* AKEYCODE_SHIFT_RIGHT */
+    VK_TAB,        /* AKEYCODE_TAB */
+    VK_SPACE,      /* AKEYCODE_SPACE */
+    0,             /* AKEYCODE_SYM */
+    0,             /* AKEYCODE_EXPLORER */
+    0,             /* AKEYCODE_ENVELOPE */
+    VK_RETURN,     /* AKEYCODE_ENTER */
+    VK_BACK,       /* AKEYCODE_DEL */
+    VK_OEM_3,      /* AKEYCODE_GRAVE */
+    VK_OEM_MINUS,  /* AKEYCODE_MINUS */
+    VK_OEM_PLUS,   /* AKEYCODE_EQUALS */
+    VK_OEM_4,      /* AKEYCODE_LEFT_BRACKET */
+    VK_OEM_6,      /* AKEYCODE_RIGHT_BRACKET */
+    VK_OEM_5,      /* AKEYCODE_BACKSLASH */
+    VK_OEM_1,      /* AKEYCODE_SEMICOLON */
+    VK_OEM_7,      /* AKEYCODE_APOSTROPHE */
+    VK_OEM_2,      /* AKEYCODE_SLASH */
+    0,             /* AKEYCODE_AT */
+    0,             /* AKEYCODE_NUM */
+    0,             /* AKEYCODE_HEADSETHOOK */
+    0,             /* AKEYCODE_FOCUS */
+    0,             /* AKEYCODE_PLUS */
+    0,             /* AKEYCODE_MENU */
+    0,             /* AKEYCODE_NOTIFICATION */
+    0,             /* AKEYCODE_SEARCH */
+    VK_MEDIA_PLAY_PAUSE, /* AKEYCODE_MEDIA_PLAY_PAUSE */
+    VK_MEDIA_STOP,       /* AKEYCODE_MEDIA_STOP */
+    VK_MEDIA_NEXT_TRACK, /* AKEYCODE_MEDIA_NEXT */
+    VK_MEDIA_PREV_TRACK, /* AKEYCODE_MEDIA_PREVIOUS */
+    0,             /* AKEYCODE_MEDIA_REWIND */
+    0,             /* AKEYCODE_MEDIA_FAST_FORWARD */
+    0,             /* AKEYCODE_MUTE */
+    VK_PRIOR,      /* AKEYCODE_PAGE_UP */
+    VK_NEXT,       /* AKEYCODE_PAGE_DOWN */
+    0,             /* AKEYCODE_PICTSYMBOLS */
+    0,             /* AKEYCODE_SWITCH_CHARSET */
+    0,             /* AKEYCODE_BUTTON_A */
+    0,             /* AKEYCODE_BUTTON_B */
+    0,             /* AKEYCODE_BUTTON_C */
+    0,             /* AKEYCODE_BUTTON_X */
+    0,             /* AKEYCODE_BUTTON_Y */
+    0,             /* AKEYCODE_BUTTON_Z */
+    0,             /* AKEYCODE_BUTTON_L1 */
+    0,             /* AKEYCODE_BUTTON_R1 */
+    0,             /* AKEYCODE_BUTTON_L2 */
+    0,             /* AKEYCODE_BUTTON_R2 */
+    0,             /* AKEYCODE_BUTTON_THUMBL */
+    0,             /* AKEYCODE_BUTTON_THUMBR */
+    0,             /* AKEYCODE_BUTTON_START */
+    0,             /* AKEYCODE_BUTTON_SELECT */
+    0,             /* AKEYCODE_BUTTON_MODE */
+    VK_ESCAPE,     /* AKEYCODE_ESCAPE */
+    VK_DELETE,     /* AKEYCODE_FORWARD_DEL */
+    VK_LCONTROL,   /* AKEYCODE_CTRL_LEFT */
+    VK_RCONTROL,   /* AKEYCODE_CTRL_RIGHT */
+    VK_CAPITAL,    /* AKEYCODE_CAPS_LOCK */
+    VK_SCROLL,     /* AKEYCODE_SCROLL_LOCK */
+    VK_LWIN,       /* AKEYCODE_META_LEFT */
+    VK_RWIN,       /* AKEYCODE_META_RIGHT */
+    0,             /* AKEYCODE_FUNCTION */
+    0,             /* AKEYCODE_SYSRQ */
+    0,             /* AKEYCODE_BREAK */
+    VK_HOME,       /* AKEYCODE_MOVE_HOME */
+    VK_END,        /* AKEYCODE_MOVE_END */
+    VK_INSERT,     /* AKEYCODE_INSERT */
+    0,             /* AKEYCODE_FORWARD */
+    0,             /* AKEYCODE_MEDIA_PLAY */
+    0,             /* AKEYCODE_MEDIA_PAUSE */
+    0,             /* AKEYCODE_MEDIA_CLOSE */
+    0,             /* AKEYCODE_MEDIA_EJECT */
+    0,             /* AKEYCODE_MEDIA_RECORD */
+    VK_F1,         /* AKEYCODE_F1 */
+    VK_F2,         /* AKEYCODE_F2 */
+    VK_F3,         /* AKEYCODE_F3 */
+    VK_F4,         /* AKEYCODE_F4 */
+    VK_F5,         /* AKEYCODE_F5 */
+    VK_F6,         /* AKEYCODE_F6 */
+    VK_F7,         /* AKEYCODE_F7 */
+    VK_F8,         /* AKEYCODE_F8 */
+    VK_F9,         /* AKEYCODE_F9 */
+    VK_F10,        /* AKEYCODE_F10 */
+    VK_F11,        /* AKEYCODE_F11 */
+    VK_F12,        /* AKEYCODE_F12 */
+    VK_NUMLOCK,    /* AKEYCODE_NUM_LOCK */
+    VK_NUMPAD0,    /* AKEYCODE_NUMPAD_0 */
+    VK_NUMPAD1,    /* AKEYCODE_NUMPAD_1 */
+    VK_NUMPAD2,    /* AKEYCODE_NUMPAD_2 */
+    VK_NUMPAD3,    /* AKEYCODE_NUMPAD_3 */
+    VK_NUMPAD4,    /* AKEYCODE_NUMPAD_4 */
+    VK_NUMPAD5,    /* AKEYCODE_NUMPAD_5 */
+    VK_NUMPAD6,    /* AKEYCODE_NUMPAD_6 */
+    VK_NUMPAD7,    /* AKEYCODE_NUMPAD_7 */
+    VK_NUMPAD8,    /* AKEYCODE_NUMPAD_8 */
+    VK_NUMPAD9,    /* AKEYCODE_NUMPAD_9 */
+    VK_DIVIDE,     /* AKEYCODE_NUMPAD_DIVIDE */
+    VK_MULTIPLY,   /* AKEYCODE_NUMPAD_MULTIPLY */
+    VK_SUBTRACT,   /* AKEYCODE_NUMPAD_SUBTRACT */
+    VK_ADD,        /* AKEYCODE_NUMPAD_ADD */
+    VK_DECIMAL,    /* AKEYCODE_NUMPAD_DOT */
+    0,             /* AKEYCODE_NUMPAD_COMMA */
+    0,             /* AKEYCODE_NUMPAD_ENTER */
+    0,             /* AKEYCODE_NUMPAD_EQUALS */
+    0,             /* AKEYCODE_NUMPAD_LEFT_PAREN */
+    0,             /* AKEYCODE_NUMPAD_RIGHT_PAREN */
+    0,             /* AKEYCODE_VOLUME_MUTE */
+    0,             /* AKEYCODE_INFO */
+    0,             /* AKEYCODE_CHANNEL_UP */
+    0,             /* AKEYCODE_CHANNEL_DOWN */
+    0,             /* AKEYCODE_ZOOM_IN */
+    0,             /* AKEYCODE_ZOOM_OUT */
+    0,             /* AKEYCODE_TV */
+    0,             /* AKEYCODE_WINDOW */
+    0,             /* AKEYCODE_GUIDE */
+    0,             /* AKEYCODE_DVR */
+    0,             /* AKEYCODE_BOOKMARK */
+    0,             /* AKEYCODE_CAPTIONS */
+    0,             /* AKEYCODE_SETTINGS */
+    0,             /* AKEYCODE_TV_POWER */
+    0,             /* AKEYCODE_TV_INPUT */
+    0,             /* AKEYCODE_STB_POWER */
+    0,             /* AKEYCODE_STB_INPUT */
+    0,             /* AKEYCODE_AVR_POWER */
+    0,             /* AKEYCODE_AVR_INPUT */
+    0,             /* AKEYCODE_PROG_RED */
+    0,             /* AKEYCODE_PROG_GREEN */
+    0,             /* AKEYCODE_PROG_YELLOW */
+    0,             /* AKEYCODE_PROG_BLUE */
+    0,             /* AKEYCODE_APP_SWITCH */
+    0,             /* AKEYCODE_BUTTON_1 */
+    0,             /* AKEYCODE_BUTTON_2 */
+    0,             /* AKEYCODE_BUTTON_3 */
+    0,             /* AKEYCODE_BUTTON_4 */
+    0,             /* AKEYCODE_BUTTON_5 */
+    0,             /* AKEYCODE_BUTTON_6 */
+    0,             /* AKEYCODE_BUTTON_7 */
+    0,             /* AKEYCODE_BUTTON_8 */
+    0,             /* AKEYCODE_BUTTON_9 */
+    0,             /* AKEYCODE_BUTTON_10 */
+    0,             /* AKEYCODE_BUTTON_11 */
+    0,             /* AKEYCODE_BUTTON_12 */
+    0,             /* AKEYCODE_BUTTON_13 */
+    0,             /* AKEYCODE_BUTTON_14 */
+    0,             /* AKEYCODE_BUTTON_15 */
+    0,             /* AKEYCODE_BUTTON_16 */
+    0,             /* AKEYCODE_LANGUAGE_SWITCH */
+    0,             /* AKEYCODE_MANNER_MODE */
+    0,             /* AKEYCODE_3D_MODE */
+    0,             /* AKEYCODE_CONTACTS */
+    0,             /* AKEYCODE_CALENDAR */
+    0,             /* AKEYCODE_MUSIC */
+    0,             /* AKEYCODE_CALCULATOR */
+    0,             /* AKEYCODE_ZENKAKU_HANKAKU */
+    0,             /* AKEYCODE_EISU */
+    0,             /* AKEYCODE_MUHENKAN */
+    0,             /* AKEYCODE_HENKAN */
+    0,             /* AKEYCODE_KATAKANA_HIRAGANA */
+    0,             /* AKEYCODE_YEN */
+    0,             /* AKEYCODE_RO */
+    VK_KANA,       /* AKEYCODE_KANA */
+    0,             /* AKEYCODE_ASSIST */
+};
+
+static const struct
+{
+    WORD vkey;
+    WORD scancode;
+} default_vkey_scancode_map[] = {
+    { 'A',               0x1E         },
+    { 'S',               0x1F         },
+    { 'D',               0x20         },
+    { 'F',               0x21         },
+    { 'H',               0x23         },
+    { 'G',               0x22         },
+    { 'Z',               0x2C         },
+    { 'X',               0x2D         },
+    { 'C',               0x2E         },
+    { 'V',               0x2F         },
+    { VK_OEM_102,        0x56         },
+    { 'B',               0x30         },
+    { 'Q',               0x10         },
+    { 'W',               0x11         },
+    { 'E',               0x12         },
+    { 'R',               0x13         },
+    { 'Y',               0x15         },
+    { 'T',               0x14         },
+    { '1',               0x02         },
+    { '2',               0x03         },
+    { '3',               0x04         },
+    { '4',               0x05         },
+    { '6',               0x07         },
+    { '5',               0x06         },
+    { VK_OEM_PLUS,       0x0D         },
+    { '9',               0x0A         },
+    { '7',               0x08         },
+    { VK_OEM_MINUS,      0x0C         },
+    { '8',               0x09         },
+    { '0',               0x0B         },
+    { VK_OEM_6,          0x1B         },
+    { 'O',               0x18         },
+    { 'U',               0x16         },
+    { VK_OEM_4,          0x1A         },
+    { 'I',               0x17         },
+    { 'P',               0x19         },
+    { VK_RETURN,         0x1C         },
+    { 'L',               0x26         },
+    { 'J',               0x24         },
+    { VK_OEM_7,          0x28         },
+    { 'K',               0x25         },
+    { VK_OEM_1,          0x27         },
+    { VK_OEM_5,          0x2B         },
+    { VK_OEM_COMMA,      0x33         },
+    { VK_OEM_2,          0x35         },
+    { 'N',               0x31         },
+    { 'M',               0x32         },
+    { VK_OEM_PERIOD,     0x34         },
+    { VK_TAB,            0x0F         },
+    { VK_SPACE,          0x39         },
+    { VK_OEM_3,          0x29         },
+    { VK_BACK,           0x0E         },
+    { VK_ESCAPE,         0x01         },
+    { VK_RMENU,          0x38 | 0x100 },
+    { VK_LMENU,          0x38         },
+    { VK_LSHIFT,         0x2A         },
+    { VK_CAPITAL,        0x3A         },
+    { VK_LCONTROL,       0x1D         },
+    { VK_RSHIFT,         0x36         },
+    { VK_RCONTROL,       0x1D | 0x100 },
+    { VK_F17,            0x68         },
+    { VK_DECIMAL,        0x53         },
+    { VK_MULTIPLY,       0x37         },
+    { VK_ADD,            0x4E         },
+    { VK_OEM_CLEAR,      0x59         },
+    { VK_VOLUME_UP,      0x00 | 0x100 },
+    { VK_VOLUME_DOWN,    0x00 | 0x100 },
+    { VK_VOLUME_MUTE,    0x00 | 0x100 },
+    { VK_DIVIDE,         0x35 | 0x100 },
+    { VK_RETURN,         0x1C | 0x100 },
+    { VK_SUBTRACT,       0x4A         },
+    { VK_F18,            0x69         },
+    { VK_F19,            0x6A         },
+    { VK_OEM_NEC_EQUAL,  0x0D | 0x100 },
+    { VK_NUMPAD0,        0x52         },
+    { VK_NUMPAD1,        0x4F         },
+    { VK_NUMPAD2,        0x50         },
+    { VK_NUMPAD3,        0x51         },
+    { VK_NUMPAD4,        0x4B         },
+    { VK_NUMPAD5,        0x4C         },
+    { VK_NUMPAD6,        0x4D         },
+    { VK_NUMPAD7,        0x47         },
+    { VK_F20,            0x6B         },
+    { VK_NUMPAD8,        0x48         },
+    { VK_NUMPAD9,        0x49         },
+    { 0xFF,              0x7D         },
+    { 0xC1,              0x73         },
+    { VK_SEPARATOR,      0x7E         },
+    { VK_F5,             0x3F         },
+    { VK_F6,             0x40         },
+    { VK_F7,             0x41         },
+    { VK_F3,             0x3D         },
+    { VK_F8,             0x42         },
+    { VK_F9,             0x43         },
+    { 0xFF,              0x72         },
+    { VK_F11,            0x57         },
+    { VK_OEM_RESET,      0x71         },
+    { VK_F13,            0x64         },
+    { VK_F16,            0x67         },
+    { VK_F14,            0x65         },
+    { VK_F10,            0x44         },
+    { VK_F12,            0x58         },
+    { VK_F15,            0x66         },
+    { VK_INSERT,         0x52 | 0x100 },
+    { VK_HOME,           0x47 | 0x100 },
+    { VK_PRIOR,          0x49 | 0x100 },
+    { VK_DELETE,         0x53 | 0x100 },
+    { VK_F4,             0x3E         },
+    { VK_END,            0x4F | 0x100 },
+    { VK_F2,             0x3C         },
+    { VK_NEXT,           0x51 | 0x100 },
+    { VK_F1,             0x3B         },
+    { VK_LEFT,           0x4B | 0x100 },
+    { VK_RIGHT,          0x4D | 0x100 },
+    { VK_DOWN,           0x50 | 0x100 },
+    { VK_UP,             0x48 | 0x100 },
+};
+
+static const struct
+{
+    DWORD       vkey;
+    const char *name;
+} vkey_names[] = {
+    { VK_ADD,                   "Num +" },
+    { VK_BACK,                  "Backspace" },
+    { VK_CAPITAL,               "Caps Lock" },
+    { VK_CONTROL,               "Ctrl" },
+    { VK_DECIMAL,               "Num Del" },
+    { VK_DELETE | 0x100,        "Delete" },
+    { VK_DIVIDE | 0x100,        "Num /" },
+    { VK_DOWN | 0x100,          "Down" },
+    { VK_END | 0x100,           "End" },
+    { VK_ESCAPE,                "Esc" },
+    { VK_F1,                    "F1" },
+    { VK_F2,                    "F2" },
+    { VK_F3,                    "F3" },
+    { VK_F4,                    "F4" },
+    { VK_F5,                    "F5" },
+    { VK_F6,                    "F6" },
+    { VK_F7,                    "F7" },
+    { VK_F8,                    "F8" },
+    { VK_F9,                    "F9" },
+    { VK_F10,                   "F10" },
+    { VK_F11,                   "F11" },
+    { VK_F12,                   "F12" },
+    { VK_F13,                   "F13" },
+    { VK_F14,                   "F14" },
+    { VK_F15,                   "F15" },
+    { VK_F16,                   "F16" },
+    { VK_F17,                   "F17" },
+    { VK_F18,                   "F18" },
+    { VK_F19,                   "F19" },
+    { VK_F20,                   "F20" },
+    { VK_F21,                   "F21" },
+    { VK_F22,                   "F22" },
+    { VK_F23,                   "F23" },
+    { VK_F24,                   "F24" },
+    { VK_HELP | 0x100,          "Help" },
+    { VK_HOME | 0x100,          "Home" },
+    { VK_INSERT | 0x100,        "Insert" },
+    { VK_LCONTROL,              "Ctrl" },
+    { VK_LEFT | 0x100,          "Left" },
+    { VK_LMENU,                 "Alt" },
+    { VK_LSHIFT,                "Shift" },
+    { VK_LWIN | 0x100,          "Win" },
+    { VK_MENU,                  "Alt" },
+    { VK_MULTIPLY,              "Num *" },
+    { VK_NEXT | 0x100,          "Page Down" },
+    { VK_NUMLOCK | 0x100,       "Num Lock" },
+    { VK_NUMPAD0,               "Num 0" },
+    { VK_NUMPAD1,               "Num 1" },
+    { VK_NUMPAD2,               "Num 2" },
+    { VK_NUMPAD3,               "Num 3" },
+    { VK_NUMPAD4,               "Num 4" },
+    { VK_NUMPAD5,               "Num 5" },
+    { VK_NUMPAD6,               "Num 6" },
+    { VK_NUMPAD7,               "Num 7" },
+    { VK_NUMPAD8,               "Num 8" },
+    { VK_NUMPAD9,               "Num 9" },
+    { VK_OEM_CLEAR,             "Num Clear" },
+    { VK_OEM_NEC_EQUAL | 0x100, "Num =" },
+    { VK_PRIOR | 0x100,         "Page Up" },
+    { VK_RCONTROL | 0x100,      "Right Ctrl" },
+    { VK_RETURN,                "Return" },
+    { VK_RETURN | 0x100,        "Num Enter" },
+    { VK_RIGHT | 0x100,         "Right" },
+    { VK_RMENU | 0x100,         "Right Alt" },
+    { VK_RSHIFT,                "Right Shift" },
+    { VK_RWIN | 0x100,          "Right Win" },
+    { VK_SEPARATOR,             "Num ," },
+    { VK_SHIFT,                 "Shift" },
+    { VK_SPACE,                 "Space" },
+    { VK_SUBTRACT,              "Num -" },
+    { VK_TAB,                   "Tab" },
+    { VK_UP | 0x100,            "Up" },
+    { VK_VOLUME_DOWN | 0x100,   "Volume Down" },
+    { VK_VOLUME_MUTE | 0x100,   "Mute" },
+    { VK_VOLUME_UP | 0x100,     "Volume Up" },
+    { VK_OEM_MINUS,             "-" },
+    { VK_OEM_PLUS,              "=" },
+    { VK_OEM_1,                 ";" },
+    { VK_OEM_2,                 "/" },
+    { VK_OEM_3,                 "`" },
+    { VK_OEM_4,                 "[" },
+    { VK_OEM_5,                 "\\" },
+    { VK_OEM_6,                 "]" },
+    { VK_OEM_7,                 "'" },
+    { VK_OEM_COMMA,             "," },
+    { VK_OEM_PERIOD,            "." },
+};
+
+static const SHORT char_vkey_map[] =
+{
+    0x332, 0x241, 0x242, 0x003, 0x244, 0x245, 0x246, 0x247, 0x008, 0x009,
+    0x20d, 0x24b, 0x24c, 0x00d, 0x24e, 0x24f, 0x250, 0x251, 0x252, 0x253,
+    0x254, 0x255, 0x256, 0x257, 0x258, 0x259, 0x25a, 0x01b, 0x2dc, 0x2dd,
+    0x336, 0x3bd, 0x020, 0x131, 0x1de, 0x133, 0x134, 0x135, 0x137, 0x0de,
+    0x139, 0x130, 0x138, 0x1bb, 0x0bc, 0x0bd, 0x0be, 0x0bf, 0x030, 0x031,
+    0x032, 0x033, 0x034, 0x035, 0x036, 0x037, 0x038, 0x039, 0x1ba, 0x0ba,
+    0x1bc, 0x0bb, 0x1be, 0x1bf, 0x132, 0x141, 0x142, 0x143, 0x144, 0x145,
+    0x146, 0x147, 0x148, 0x149, 0x14a, 0x14b, 0x14c, 0x14d, 0x14e, 0x14f,
+    0x150, 0x151, 0x152, 0x153, 0x154, 0x155, 0x156, 0x157, 0x158, 0x159,
+    0x15a, 0x0db, 0x0dc, 0x0dd, 0x136, 0x1bd, 0x0c0, 0x041, 0x042, 0x043,
+    0x044, 0x045, 0x046, 0x047, 0x048, 0x049, 0x04a, 0x04b, 0x04c, 0x04d,
+    0x04e, 0x04f, 0x050, 0x051, 0x052, 0x053, 0x054, 0x055, 0x056, 0x057,
+    0x058, 0x059, 0x05a, 0x1db, 0x1dc, 0x1dd, 0x1c0, 0x208
+};
+
+static int scancode_to_vkey( int scan )
+{
+    int ret = 0;
+    int j;
+    for (j = 0; j < sizeof(default_vkey_scancode_map)/sizeof(default_vkey_scancode_map[0]); j++)
+        if (default_vkey_scancode_map[j].scancode == scan)
+            ret = default_vkey_scancode_map[j].vkey;
+    return ret;
+}
+
+static int vkey_to_scancode( int vkey )
+{
+    int ret = 0;
+    int j;
+    for (j = 0; j < sizeof(default_vkey_scancode_map)/sizeof(default_vkey_scancode_map[0]); j++)
+        if (default_vkey_scancode_map[j].vkey == vkey)
+            ret = default_vkey_scancode_map[j].scancode;
+    return ret;
+}
+
+static const char* vkey_to_name( int vkey )
+{
+    int j;
+
+    for (j = 0; j < sizeof(vkey_names)/sizeof(vkey_names[0]); j++)
+        if (vkey_names[j].vkey == vkey)
+            return vkey_names[j].name;
+
+    return NULL;
+}
+
+static SHORT char_to_vkey( WCHAR ch )
+{
+    if (ch > 127) return -1;
+    return char_vkey_map[ch];
+}
+
+static BOOL get_async_key_state( BYTE state[256] )
+{
+    BOOL ret;
+
+    SERVER_START_REQ( get_key_state )
+    {
+        req->tid = 0;
+        req->key = -1;
+        wine_server_set_reply( req, state, 256 );
+        ret = !wine_server_call( req );
+    }
+    SERVER_END_REQ;
+    return ret;
+}
+
+static void send_keyboard_input( HWND hwnd, WORD vkey, WORD scan, DWORD flags )
+{
+    INPUT input;
+
+    input.type             = INPUT_KEYBOARD;
+    input.u.ki.wVk         = vkey;
+    input.u.ki.wScan       = scan;
+    input.u.ki.dwFlags     = flags;
+    input.u.ki.time        = 0;
+    input.u.ki.dwExtraInfo = 0;
+
+    __wine_send_input( hwnd, &input );
+}
+
+static void clear_key_state( int key, int state,
+                             int alt_key, int alt_state )
+{
+    int key_down = state & 0x80;
+    int alt_key_down = alt_state & 0x80;
+
+    if (key_down)
+        send_keyboard_input( 0, key, vkey_to_scancode(key), KEYEVENTF_KEYUP );
+
+    if (alt_key_down)
+        send_keyboard_input( 0, alt_key, vkey_to_scancode(alt_key), KEYEVENTF_KEYUP );
+}
+
+void handle_clear_meta_key_states( int states )
+{
+    BYTE keystate[256];
+
+    TRACE( " states : 0x%0x\n", states );
+
+    if (get_async_key_state( keystate ))
+    {
+        if (states & AMETA_SHIFT_ON)
+        {
+            clear_key_state( VK_LSHIFT, keystate[VK_LSHIFT],
+                             VK_RSHIFT, keystate[VK_RSHIFT] );
+        }
+        if (states & AMETA_ALT_ON)
+        {
+            clear_key_state( VK_LMENU, keystate[VK_LMENU],
+                             VK_RMENU, keystate[VK_RMENU] );
+        }
+    }
+}
+
+void update_keyboard_lock_state( WORD vkey, UINT state )
+{
+    BYTE keystate[256];
+
+    if (!get_async_key_state( keystate )) return;
+
+    if (!(keystate[VK_CAPITAL] & 0x01) != !(state & AMETA_CAPS_LOCK_ON) && vkey != VK_CAPITAL)
+    {
+        TRACE( "adjusting CapsLock state (%02x)\n", keystate[VK_CAPITAL] );
+        send_keyboard_input( 0, VK_CAPITAL, 0x3a, 0 );
+        send_keyboard_input( 0, VK_CAPITAL, 0x3a, KEYEVENTF_KEYUP );
+    }
+
+    if (!(keystate[VK_NUMLOCK] & 0x01) != !(state & AMETA_NUM_LOCK_ON) && (vkey & 0xff) != VK_NUMLOCK)
+    {
+        TRACE( "adjusting NumLock state (%02x)\n", keystate[VK_NUMLOCK] );
+        send_keyboard_input( 0, VK_NUMLOCK, 0x45, KEYEVENTF_EXTENDEDKEY );
+        send_keyboard_input( 0, VK_NUMLOCK, 0x45, KEYEVENTF_EXTENDEDKEY | KEYEVENTF_KEYUP );
+    }
+
+    if (!(keystate[VK_SCROLL] & 0x01) != !(state & AMETA_SCROLL_LOCK_ON) && vkey != VK_SCROLL)
+    {
+        TRACE( "adjusting ScrollLock state (%02x)\n", keystate[VK_SCROLL] );
+        send_keyboard_input( 0, VK_SCROLL, 0x46, 0 );
+        send_keyboard_input( 0, VK_SCROLL, 0x46, KEYEVENTF_KEYUP );
+    }
+}
+
+/***********************************************************************
+ *  Entry points from Java (JNI exports)
+ */
+
+jboolean keyboard_event( JNIEnv *env, jobject obj, jint win, jint action, jint keycode, jint scancode, jint state )
+{
+    union event_data data;
+    int vkey;
+
+    if ((unsigned int)keycode >= sizeof(keycode_to_vkey)/sizeof(keycode_to_vkey[0]) || !keycode_to_vkey[keycode])
+    {
+        p__android_log_print(ANDROID_LOG_INFO, "wine", "EVENT_TYPE_KEY: win %x code %x scan %x meta %x unmapped key, ignoring\n",
+                             win, keycode, scancode, state );
+        return JNI_FALSE;
+    }
+    vkey = keycode_to_vkey[keycode];
+    p__android_log_print( ANDROID_LOG_INFO, "wine", "Got vkey 0x%x\n", vkey );
+    scancode = vkey_to_scancode( vkey );
+    p__android_log_print( ANDROID_LOG_INFO, "wine", "Injecting default scancode 0x%x.\n", scancode );
+    data.type = HARDWARE_INPUT;
+    data.hw.hwnd = LongToHandle( win );
+    p__android_log_print(ANDROID_LOG_INFO, "wine", "EVENT_TYPE_KEY: win %x code %x scan %x meta %x\n",
+                         win, keycode, scancode, state );
+    data.hw.input.type             = INPUT_KEYBOARD;
+    data.hw.input.u.ki.wVk         = keycode_to_vkey[keycode];
+    data.hw.input.u.ki.wScan       = scancode;
+    data.hw.input.u.ki.time        = 0;
+    data.hw.input.u.ki.dwExtraInfo = state;
+    data.hw.input.u.ki.dwFlags = (scancode & 0x100) ? KEYEVENTF_EXTENDEDKEY : 0;
+    if (action == AKEY_EVENT_ACTION_UP)
+        data.hw.input.u.ki.dwFlags |= KEYEVENTF_KEYUP;
+    send_event( desktop_thread, &data );
+    return JNI_TRUE;
+}
+
+jboolean clear_meta_key_states( JNIEnv *env, jobject obj, jint states )
+{
+    union event_data data;
+    data.type = CLEAR_META;
+    data.clearmeta.states = states;
+    send_event( desktop_thread, &data );
+    return TRUE;
+}
+
+/***********************************************************************
+ *  Windows API Functions
+ */
+
+
+/***********************************************************************
+ *           ToUnicodeEx
+ */
+INT CDECL ANDROID_ToUnicodeEx( UINT virt, UINT scan, const BYTE *state,
+                               LPWSTR buf, int size, UINT flags, HKL hkl )
+{
+    WCHAR buffer[2];
+    BOOL shift = (state[VK_SHIFT] & 0x80) || (state[VK_CAPITAL] & 0x01);
+    BOOL ctrl = state[VK_CONTROL] & 0x80;
+    BOOL numlock = state[VK_NUMLOCK] & 0x01;
+
+    buffer[0] = buffer[1] = 0;
+
+    if (scan & 0x8000) return 0;  /* key up */
+
+    /* FIXME: hardcoded layout */
+
+    if (!ctrl)
+    {
+        switch (virt)
+        {
+        case VK_BACK:       buffer[0] = '\b'; break;
+        case VK_OEM_1:      buffer[0] = shift ? ':' : ';'; break;
+        case VK_OEM_2:      buffer[0] = shift ? '?' : '/'; break;
+        case VK_OEM_3:      buffer[0] = shift ? '~' : '`'; break;
+        case VK_OEM_4:      buffer[0] = shift ? '{' : '['; break;
+        case VK_OEM_5:      buffer[0] = shift ? '|' : '\\'; break;
+        case VK_OEM_6:      buffer[0] = shift ? '}' : ']'; break;
+        case VK_OEM_7:      buffer[0] = shift ? '"' : '\''; break;
+        case VK_OEM_COMMA:  buffer[0] = shift ? '<' : ','; break;
+        case VK_OEM_MINUS:  buffer[0] = shift ? '_' : '-'; break;
+        case VK_OEM_PERIOD: buffer[0] = shift ? '>' : '.'; break;
+        case VK_OEM_PLUS:   buffer[0] = shift ? '+' : '='; break;
+        case VK_RETURN:     buffer[0] = '\r'; break;
+        case VK_SPACE:      buffer[0] = ' '; break;
+        case VK_TAB:        buffer[0] = '\t'; break;
+        case VK_MULTIPLY:   buffer[0] = '*'; break;
+        case VK_ADD:        buffer[0] = '+'; break;
+        case VK_SUBTRACT:   buffer[0] = '-'; break;
+        case VK_DIVIDE:     buffer[0] = '/'; break;
+        default:
+            if (virt >= '0' && virt <= '9')
+            {
+                buffer[0] = shift ? ")!@#$%^&*("[virt - '0'] : virt;
+                break;
+            }
+            if (virt >= 'A' && virt <= 'Z')
+            {
+                buffer[0] = shift ? virt : virt + 'a' - 'A';
+                break;
+            }
+            if (virt >= VK_NUMPAD0 && virt <= VK_NUMPAD9 && numlock && !shift)
+            {
+                buffer[0] = '0' + virt - VK_NUMPAD0;
+                break;
+            }
+            if (virt == VK_DECIMAL && numlock && !shift)
+            {
+                buffer[0] = '.';
+                break;
+            }
+            break;
+        }
+    }
+    else /* Control codes */
+    {
+        if (virt >= 'A' && virt <= 'Z')
+            buffer[0] = virt - 'A' + 1;
+        else
+        {
+            switch (virt)
+            {
+            case VK_OEM_4:
+                buffer[0] = 0x1b;
+                break;
+            case VK_OEM_5:
+                buffer[0] = 0x1c;
+                break;
+            case VK_OEM_6:
+                buffer[0] = 0x1d;
+                break;
+            case VK_SUBTRACT:
+                buffer[0] = 0x1e;
+                break;
+            }
+        }
+    }
+
+    lstrcpynW( buf, buffer, size );
+    TRACE("returning %d / %s\n", strlenW( buffer ), debugstr_wn(buf, strlenW( buffer ) ) );
+    return strlenW( buffer );
+}
+
+/***********************************************************************
+ *           GetKeyNameText
+ */
+INT CDECL ANDROID_GetKeyNameText(LONG lparam, LPWSTR buffer, INT size)
+{
+    int scancode, vkey, len;
+    const char *name;
+    char key[2];
+    
+    scancode = (lparam >> 16) & 0x1FF;
+    vkey = scancode_to_vkey( scancode );
+
+    if (lparam & (1 << 25))
+    {
+        /* Caller doesn't care about distinctions between left and
+           right keys. */
+        switch (vkey)
+        {
+        case VK_LSHIFT:
+        case VK_RSHIFT:
+            vkey = VK_SHIFT; break;
+        case VK_LCONTROL:
+        case VK_RCONTROL:
+            vkey = VK_CONTROL; break;
+        case VK_LMENU:
+        case VK_RMENU:
+            vkey = VK_MENU; break;
+        }
+    }
+
+    if (scancode & 0x100) vkey |= 0x100;
+
+    if ((vkey >= 0x30 && vkey <= 0x39) || (vkey >= 0x41 && vkey <= 0x5a))
+    {
+        key[0] = vkey;
+        if (vkey >= 0x41)
+            key[0] += 0x20;
+        key[1] = 0;
+        name = key;
+    }
+    else
+    {
+        name = vkey_to_name( vkey );
+    }
+
+    len = MultiByteToWideChar(CP_UTF8, 0, name, -1, buffer, size);
+    if (len) len--;
+
+    if (!len)
+    {
+        static const WCHAR format[] = {'K','e','y',' ','0','x','%','0','2','x',0};
+        snprintfW( buffer, size, format, vkey );
+        len = strlenW( buffer );
+    }
+    
+    TRACE( "lparam 0x%08x -> %s\n", lparam, debugstr_w( buffer ) );
+    return len;
+}
+
+
+/***********************************************************************
+ *              MapVirtualKeyEx (MACDRV.@)
+ */
+UINT CDECL ANDROID_MapVirtualKeyEx(UINT code, UINT maptype, HKL hkl)
+{
+    UINT ret = 0;
+    const char *s;
+
+    TRACE_(key)( "code=0x%x, maptype=%d, hkl %p\n", code, maptype, hkl );
+
+    switch (maptype)
+    {
+    case MAPVK_VK_TO_VSC_EX:
+    case MAPVK_VK_TO_VSC:
+        /* vkey to scancode */
+        switch (code)
+        {
+        case VK_SHIFT:
+            code = VK_LSHIFT;
+            break;
+        case VK_CONTROL:
+            code = VK_LCONTROL;
+            break;
+        case VK_MENU:
+            code = VK_LMENU;
+            break;
+        }
+        ret = vkey_to_scancode( code );
+        break;
+    case MAPVK_VSC_TO_VK: 
+    case MAPVK_VSC_TO_VK_EX:
+        /* scancode to vkey */
+        ret = scancode_to_vkey( code );
+        if (maptype == MAPVK_VSC_TO_VK)
+            switch (ret)
+            {
+            case VK_LSHIFT:
+            case VK_RSHIFT:
+                ret = VK_SHIFT; break;
+            case VK_LCONTROL:
+            case VK_RCONTROL:
+                ret = VK_CONTROL; break;
+            case VK_LMENU:
+            case VK_RMENU:
+                ret = VK_MENU; break;
+            }
+        break;
+    case MAPVK_VK_TO_CHAR:
+        s = vkey_to_name( code );
+        if (s && (strlen( s ) == 1))
+            ret = s[0];
+        else
+            ret = 0;
+        break;
+    default:
+        FIXME("Unknown maptype %d\n", maptype);
+        break;
+    }
+    TRACE_(key)("returning 0x%04x\n", ret);    
+    return ret;
+}
+
+HKL CDECL ANDROID_GetKeyboardLayout(DWORD thread_id)
+{
+    ULONG_PTR layout = GetUserDefaultLCID();
+    LANGID langid;
+
+    langid = PRIMARYLANGID(LANGIDFROMLCID( layout ));
+    if (langid == LANG_CHINESE || langid == LANG_JAPANESE || langid == LANG_KOREAN)
+        layout = MAKELONG( layout, 0xe001 ); /* IME */
+    else
+        layout |= layout << 16;
+
+    FIXME( "returning %lx\n", layout );
+    return (HKL)layout;
+}
+
+SHORT CDECL ANDROID_VkKeyScanEx( WCHAR ch, HKL hkl )
+{
+    SHORT ret = char_to_vkey( ch );
+    TRACE_(key)( "ch %04x hkl %p -> %04x\n", ch, hkl, ret );
+    return ret;
+}
diff -Naur wine-2.0a/dlls/wineandroid.drv/Makefile.in wine-2.0b/dlls/wineandroid.drv/Makefile.in
--- wine-2.0a/dlls/wineandroid.drv/Makefile.in	1970-01-01 01:00:00.000000000 +0100
+++ wine-2.0b/dlls/wineandroid.drv/Makefile.in	2017-07-11 20:37:51.000000000 +0100
@@ -0,0 +1,104 @@
+MODULE    = wineandroid.drv
+IMPORTS   = uuid user32 gdi32 advapi32 ole32 psapi
+DELAYIMPORTS = imm32 ntoskrnl
+ANDROID_TOP_LIB_DIR = wineandroid
+ANDROID_LIB_DIR = $(ANDROID_TOP_LIB_DIR)/src/main
+
+C_SRCS = \
+	clipboard.c \
+	device.c \
+	gamepad.c \
+	ime.c \
+	init.c \
+	mmdevdrv.c \
+	opengl.c \
+	window.c \
+	keyboard.c
+
+RC_SRCS = version.rc
+
+JAVA_SRCS = \
+	WineDriver.java \
+	WineProvider.java
+
+ANDROID_PROJECT_SRCS = \
+	AndroidManifest.xml \
+	build.gradle
+
+ANDROID_VALUE_RES_SRCS = \
+	strings.xml
+
+# Manual dependencies
+
+.PHONY: install-lib
+
+install-lib:: $(JAVA_SRCS:%=$(ANDROID_LIB_DIR)/java/org/winehq/wine/%) \
+			 $(ANDROID_TOP_LIB_DIR)/build.gradle \
+			 $(ANDROID_TOP_LIB_DIR)/gradlew \
+			 $(ANDROID_TOP_LIB_DIR)/gradle/wrapper/gradle-wrapper.jar \
+			 $(ANDROID_TOP_LIB_DIR)/gradle/wrapper/gradle-wrapper.properties \
+			 $(ANDROID_LIB_DIR)/AndroidManifest.xml \
+			 $(ANDROID_VALUE_RES_SRCS:%=$(ANDROID_LIB_DIR)/res/values/%) \
+			 $(ANDROID_LIB_DIR)/res/drawable-ldpi/wine_launcher.png \
+			 $(ANDROID_LIB_DIR)/res/drawable-mdpi/wine_launcher.png \
+			 $(ANDROID_LIB_DIR)/res/drawable-hdpi/wine_launcher.png \
+			 $(ANDROID_LIB_DIR)/res/drawable-xhdpi/wine_launcher.png
+	cd $(ANDROID_TOP_LIB_DIR) && ./gradlew build --console plain
+
+$(ANDROID_LIB_DIR)/java/org/winehq/wine/WineDriver.java: $(srcdir)/WineDriver.java
+	mkdir -p `dirname $@`
+	cp $(srcdir)/WineDriver.java $@
+
+$(ANDROID_LIB_DIR)/java/org/winehq/wine/WineProvider.java: $(srcdir)/WineProvider.java
+	mkdir -p `dirname $@`
+	cp $(srcdir)/WineProvider.java $@
+
+$(ANDROID_LIB_DIR)/AndroidManifest.xml: $(srcdir)/AndroidManifest.xml
+	mkdir -p `dirname $@`
+	cp $(srcdir)/AndroidManifest.xml $@
+
+$(ANDROID_TOP_LIB_DIR)/build.gradle: $(srcdir)/build.gradle
+	mkdir -p `dirname $@`
+	cp $(srcdir)/build.gradle $@
+
+$(ANDROID_TOP_LIB_DIR)/gradlew: $(srcdir)/gradlew
+	mkdir -p `dirname $@`
+	cp $(srcdir)/gradlew $@
+
+$(ANDROID_TOP_LIB_DIR)/gradle/wrapper/gradle-wrapper.jar: $(srcdir)/gradle-wrapper.jar
+	mkdir -p `dirname $@`
+	cp $(srcdir)/gradle-wrapper.jar $@
+
+$(ANDROID_TOP_LIB_DIR)/gradle/wrapper/gradle-wrapper.properties: $(srcdir)/gradle-wrapper.properties
+	mkdir -p `dirname $@`
+	cp $(srcdir)/gradle-wrapper.properties $@
+
+$(ANDROID_LIB_DIR)/res/values/strings.xml: $(srcdir)/strings.xml
+	mkdir -p `dirname $@`
+	cp $(srcdir)/strings.xml $@
+
+$(ANDROID_LIB_DIR)/res/drawable-ldpi/wine_launcher.png: $(srcdir)/wine_launcher_ldpi.png
+	mkdir -p `dirname $@`
+	cp $(srcdir)/wine_launcher_ldpi.png $@
+
+$(ANDROID_LIB_DIR)/res/drawable-mdpi/wine_launcher.png: $(srcdir)/wine_launcher_mdpi.png
+	mkdir -p `dirname $@`
+	cp $(srcdir)/wine_launcher_mdpi.png $@
+
+$(ANDROID_LIB_DIR)/res/drawable-hdpi/wine_launcher.png: $(srcdir)/wine_launcher_hdpi.png
+	mkdir -p `dirname $@`
+	cp $(srcdir)/wine_launcher_hdpi.png $@
+
+$(ANDROID_LIB_DIR)/res/drawable-xhdpi/wine_launcher.png: $(srcdir)/wine_launcher_xhdpi.png
+	mkdir -p `dirname $@`
+	cp $(srcdir)/wine_launcher_xhdpi.png $@
+
+wine_launcher_%dpi.png: $(srcdir)/wine_launcher.svg
+	if [ -n "$$RSVG" -a -n "$$CONVERT" ]; \
+	then \
+		if [ $* = "l" ] ; then size=32 ; fi  && \
+		if [ $* = "m" ] ; then size=48 ; fi  && \
+		if [ $* = "h" ] ; then size=72 ; fi  && \
+		if [ $* = "xh" ] ; then size=96 ; fi  && \
+	    RSVG=$(RSVG) CONVERT=$(CONVERT) $(TOOLSDIR)/tools/buildimage $(top_srcdir)/dlls/user32/resources/oic_winlogo.svg $@ --size $$size; \
+	fi
diff -Naur wine-2.0a/dlls/wineandroid.drv/mmdevdrv.c wine-2.0b/dlls/wineandroid.drv/mmdevdrv.c
--- wine-2.0a/dlls/wineandroid.drv/mmdevdrv.c	1970-01-01 01:00:00.000000000 +0100
+++ wine-2.0b/dlls/wineandroid.drv/mmdevdrv.c	2017-07-11 20:37:51.000000000 +0100
@@ -0,0 +1,2898 @@
+/*
+ * Copyright 2015 Andrew Eikum for CodeWeavers
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#define NONAMELESSUNION
+#define COBJMACROS
+#include "config.h"
+
+#include <stdarg.h>
+#include <errno.h>
+#include <limits.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/ioctl.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <math.h>
+
+#include <SLES/OpenSLES.h>
+#include <SLES/OpenSLES_Android.h>
+
+#include "android.h"
+
+#include "windef.h"
+#include "winbase.h"
+#include "winnls.h"
+#include "winreg.h"
+#include "wine/debug.h"
+#include "wine/unicode.h"
+#include "wine/list.h"
+
+#include "ole2.h"
+#include "mmdeviceapi.h"
+#include "devpkey.h"
+#include "dshow.h"
+#include "dsound.h"
+
+#include "initguid.h"
+#include "endpointvolume.h"
+#include "audiopolicy.h"
+#include "audioclient.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(androidaudio);
+
+#define SLCALL_N(obj, func) (*obj)->func(obj)
+#define SLCALL(obj, func, ...) (*obj)->func(obj, __VA_ARGS__)
+
+#define NULL_PTR_ERR MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, RPC_X_NULL_REF_POINTER)
+
+static const REFERENCE_TIME DefaultPeriod = 100000;
+static const REFERENCE_TIME MinimumPeriod = 50000;
+
+struct ACImpl;
+typedef struct ACImpl ACImpl;
+
+typedef struct _AudioSession {
+    GUID guid;
+    struct list clients;
+
+    IMMDevice *device;
+
+    float master_vol;
+    UINT32 channel_count;
+    float *channel_vols;
+    BOOL mute;
+
+    CRITICAL_SECTION lock;
+
+    struct list entry;
+} AudioSession;
+
+typedef struct _AudioSessionWrapper {
+    IAudioSessionControl2 IAudioSessionControl2_iface;
+    IChannelAudioVolume IChannelAudioVolume_iface;
+    ISimpleAudioVolume ISimpleAudioVolume_iface;
+
+    LONG ref;
+
+    ACImpl *client;
+    AudioSession *session;
+} AudioSessionWrapper;
+
+struct ACImpl {
+    IAudioClient IAudioClient_iface;
+    IAudioRenderClient IAudioRenderClient_iface;
+    IAudioCaptureClient IAudioCaptureClient_iface;
+    IAudioClock IAudioClock_iface;
+    IAudioClock2 IAudioClock2_iface;
+    IAudioStreamVolume IAudioStreamVolume_iface;
+
+    LONG ref;
+
+    IMMDevice *parent;
+    IUnknown *pUnkFTMarshal;
+
+    WAVEFORMATEX *fmt;
+
+    EDataFlow dataflow;
+    DWORD flags;
+    AUDCLNT_SHAREMODE share;
+    HANDLE event;
+    float *vols;
+
+    SLObjectItf outputmix;
+    SLObjectItf player;
+    SLObjectItf recorder;
+    SLAndroidSimpleBufferQueueItf bufq;
+    SLPlayItf playitf;
+    SLRecordItf recorditf;
+
+    BOOL initted, playing;
+    UINT64 written_frames, last_pos_frames;
+    UINT32 period_us, period_frames, bufsize_frames, held_frames, tmp_buffer_frames, wrap_buffer_frames, in_sl_frames;
+    UINT32 oss_bufsize_bytes, lcl_offs_frames; /* offs into local_buffer where valid data starts */
+
+    BYTE *local_buffer, *tmp_buffer, *wrap_buffer;
+    LONG32 getbuf_last; /* <0 when using tmp_buffer */
+    HANDLE timer;
+
+    CRITICAL_SECTION lock;
+
+    AudioSession *session;
+    AudioSessionWrapper *session_wrapper;
+
+    struct list entry;
+};
+
+typedef struct _SessionMgr {
+    IAudioSessionManager2 IAudioSessionManager2_iface;
+
+    LONG ref;
+
+    IMMDevice *device;
+} SessionMgr;
+
+static struct list g_devices = LIST_INIT(g_devices);
+
+HANDLE g_timer_q;
+
+static CRITICAL_SECTION g_sessions_lock;
+static CRITICAL_SECTION_DEBUG g_sessions_lock_debug =
+{
+    0, 0, &g_sessions_lock,
+    { &g_sessions_lock_debug.ProcessLocksList, &g_sessions_lock_debug.ProcessLocksList },
+      0, 0, { (DWORD_PTR)(__FILE__ ": g_sessions_lock") }
+};
+static CRITICAL_SECTION g_sessions_lock = { &g_sessions_lock_debug, -1, 0, 0, 0, 0 };
+static struct list g_sessions = LIST_INIT(g_sessions);
+
+static AudioSessionWrapper *AudioSessionWrapper_Create(ACImpl *client);
+
+static const IAudioClientVtbl AudioClient_Vtbl;
+static const IAudioRenderClientVtbl AudioRenderClient_Vtbl;
+static const IAudioCaptureClientVtbl AudioCaptureClient_Vtbl;
+static const IAudioSessionControl2Vtbl AudioSessionControl2_Vtbl;
+static const ISimpleAudioVolumeVtbl SimpleAudioVolume_Vtbl;
+static const IAudioClockVtbl AudioClock_Vtbl;
+static const IAudioClock2Vtbl AudioClock2_Vtbl;
+static const IAudioStreamVolumeVtbl AudioStreamVolume_Vtbl;
+static const IChannelAudioVolumeVtbl ChannelAudioVolume_Vtbl;
+static const IAudioSessionManager2Vtbl AudioSessionManager2_Vtbl;
+
+static inline ACImpl *impl_from_IAudioClient(IAudioClient *iface)
+{
+    return CONTAINING_RECORD(iface, ACImpl, IAudioClient_iface);
+}
+
+static inline ACImpl *impl_from_IAudioRenderClient(IAudioRenderClient *iface)
+{
+    return CONTAINING_RECORD(iface, ACImpl, IAudioRenderClient_iface);
+}
+
+static inline ACImpl *impl_from_IAudioCaptureClient(IAudioCaptureClient *iface)
+{
+    return CONTAINING_RECORD(iface, ACImpl, IAudioCaptureClient_iface);
+}
+
+static inline AudioSessionWrapper *impl_from_IAudioSessionControl2(IAudioSessionControl2 *iface)
+{
+    return CONTAINING_RECORD(iface, AudioSessionWrapper, IAudioSessionControl2_iface);
+}
+
+static inline AudioSessionWrapper *impl_from_ISimpleAudioVolume(ISimpleAudioVolume *iface)
+{
+    return CONTAINING_RECORD(iface, AudioSessionWrapper, ISimpleAudioVolume_iface);
+}
+
+static inline AudioSessionWrapper *impl_from_IChannelAudioVolume(IChannelAudioVolume *iface)
+{
+    return CONTAINING_RECORD(iface, AudioSessionWrapper, IChannelAudioVolume_iface);
+}
+
+static inline ACImpl *impl_from_IAudioClock(IAudioClock *iface)
+{
+    return CONTAINING_RECORD(iface, ACImpl, IAudioClock_iface);
+}
+
+static inline ACImpl *impl_from_IAudioClock2(IAudioClock2 *iface)
+{
+    return CONTAINING_RECORD(iface, ACImpl, IAudioClock2_iface);
+}
+
+static inline ACImpl *impl_from_IAudioStreamVolume(IAudioStreamVolume *iface)
+{
+    return CONTAINING_RECORD(iface, ACImpl, IAudioStreamVolume_iface);
+}
+
+static inline SessionMgr *impl_from_IAudioSessionManager2(IAudioSessionManager2 *iface)
+{
+    return CONTAINING_RECORD(iface, SessionMgr, IAudioSessionManager2_iface);
+}
+
+/* From <dlls/mmdevapi/mmdevapi.h> */
+enum DriverPriority {
+    Priority_Unavailable = 0,
+    Priority_Low,
+    Priority_Neutral,
+    Priority_Preferred
+};
+
+int WINAPI AUDDRV_GetPriority(void)
+{
+    if(!pslCreateEngine)
+        return Priority_Unavailable;
+
+    return Priority_Preferred;
+}
+
+static SLObjectItf sl;
+static SLEngineItf engine;
+
+HRESULT AUDDRV_Init(void)
+{
+    SLresult sr;
+    SLEngineOption options[] = { {SL_ENGINEOPTION_THREADSAFE, SL_BOOLEAN_TRUE} };
+
+    sr = pslCreateEngine(&sl, 1, options, 0, NULL, NULL);
+    if(sr != SL_RESULT_SUCCESS){
+        WARN("slCreateEngine failed: 0x%x\n", sr);
+        return E_FAIL;
+    }
+
+    sr = SLCALL(sl, Realize, SL_BOOLEAN_FALSE);
+    if(sr != SL_RESULT_SUCCESS){
+        SLCALL_N(sl, Destroy);
+        WARN("Engine Realize failed: 0x%x\n", sr);
+        return E_FAIL;
+    }
+
+    sr = SLCALL(sl, GetInterface, *pSL_IID_ENGINE, (void*)&engine);
+    if(sr != SL_RESULT_SUCCESS){
+        SLCALL_N(sl, Destroy);
+        WARN("GetInterface failed: 0x%x\n", sr);
+        return E_FAIL;
+    }
+
+    return S_OK;
+}
+
+static const GUID outGuid = {0x0a047ace, 0x22b1, 0x4342, {0x98, 0xbb, 0xf8, 0x56, 0x32, 0x26, 0x61, 0x00}};
+static const GUID inGuid = {0x0a047ace, 0x22b1, 0x4342, {0x98, 0xbb, 0xf8, 0x56, 0x32, 0x26, 0x61, 0x01}};
+
+HRESULT WINAPI AUDDRV_GetEndpointIDs(EDataFlow flow, WCHAR ***ids, GUID **guids,
+        UINT *num, UINT *def_index)
+{
+    static const WCHAR outName[] = {'A','n','d','r','o','i','d',' ','A','u','d','i','o',' ','O','u','t',0};
+    static const WCHAR inName[] = {'A','n','d','r','o','i','d',' ','A','u','d','i','o',' ','I','n',0};
+
+    TRACE("%u %p %p %p %p\n", flow, ids, guids, num, def_index);
+
+    *def_index = 0;
+    *num = 1;
+    *ids = HeapAlloc(GetProcessHeap(), 0, sizeof(WCHAR *));
+    *guids = HeapAlloc(GetProcessHeap(), 0, sizeof(GUID));
+    if(flow == eRender){
+        (*ids)[0] = HeapAlloc(GetProcessHeap(), 0, sizeof(outName));
+        memcpy((*ids)[0], outName, sizeof(outName));
+        memcpy(&(*guids)[0], &outGuid, sizeof(outGuid));
+    }else{
+        (*ids)[0] = HeapAlloc(GetProcessHeap(), 0, sizeof(inName));
+        memcpy((*ids)[0], inName, sizeof(inName));
+        memcpy(&(*guids)[0], &inGuid, sizeof(inGuid));
+    }
+
+    return S_OK;
+}
+
+HRESULT WINAPI AUDDRV_GetAudioEndpoint(GUID *guid, IMMDevice *dev,
+        IAudioClient **out)
+{
+    ACImpl *This;
+    HRESULT hr;
+    EDataFlow flow;
+    SLresult sr;
+
+    TRACE("%s %p %p\n", debugstr_guid(guid), dev, out);
+
+    if(!sl)
+        AUDDRV_Init();
+
+    if(IsEqualGUID(guid, &outGuid))
+        flow = eRender;
+    else if(IsEqualGUID(guid, &inGuid))
+        flow = eCapture;
+    else
+        return AUDCLNT_E_DEVICE_INVALIDATED;
+
+    This = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(ACImpl));
+    if(!This)
+        return E_OUTOFMEMORY;
+
+    hr = CoCreateFreeThreadedMarshaler((IUnknown *)&This->IAudioClient_iface,
+        (IUnknown **)&This->pUnkFTMarshal);
+    if (FAILED(hr)) {
+         HeapFree(GetProcessHeap(), 0, This);
+         return hr;
+    }
+
+    if(flow == eRender){
+        sr = SLCALL(engine, CreateOutputMix, &This->outputmix, 0, NULL, NULL);
+        if(sr != SL_RESULT_SUCCESS){
+            WARN("CreateOutputMix failed: 0x%x\n", sr);
+            HeapFree(GetProcessHeap(), 0, This);
+            return E_FAIL;
+        }
+
+        sr = SLCALL(This->outputmix, Realize, SL_BOOLEAN_FALSE);
+        if(sr != SL_RESULT_SUCCESS){
+            SLCALL_N(This->outputmix, Destroy);
+            This->outputmix = NULL;
+            HeapFree(GetProcessHeap(), 0, This);
+            WARN("outputmix Realize failed: 0x%x\n", sr);
+            return E_FAIL;
+        }
+    }
+
+    This->dataflow = flow;
+
+    This->IAudioClient_iface.lpVtbl = &AudioClient_Vtbl;
+    This->IAudioRenderClient_iface.lpVtbl = &AudioRenderClient_Vtbl;
+    This->IAudioCaptureClient_iface.lpVtbl = &AudioCaptureClient_Vtbl;
+    This->IAudioClock_iface.lpVtbl = &AudioClock_Vtbl;
+    This->IAudioClock2_iface.lpVtbl = &AudioClock2_Vtbl;
+    This->IAudioStreamVolume_iface.lpVtbl = &AudioStreamVolume_Vtbl;
+
+    InitializeCriticalSection(&This->lock);
+    This->lock.DebugInfo->Spare[0] = (DWORD_PTR)(__FILE__ ": ACImpl.lock");
+
+    This->parent = dev;
+    IMMDevice_AddRef(This->parent);
+
+    IAudioClient_AddRef(&This->IAudioClient_iface);
+
+    *out = &This->IAudioClient_iface;
+
+    return S_OK;
+}
+
+static HRESULT WINAPI AudioClient_QueryInterface(IAudioClient *iface,
+        REFIID riid, void **ppv)
+{
+    ACImpl *This = impl_from_IAudioClient(iface);
+    TRACE("(%p)->(%s, %p)\n", iface, debugstr_guid(riid), ppv);
+
+    if(!ppv)
+        return E_POINTER;
+    *ppv = NULL;
+    if(IsEqualIID(riid, &IID_IUnknown) || IsEqualIID(riid, &IID_IAudioClient))
+        *ppv = iface;
+    else if(IsEqualIID(riid, &IID_IMarshal))
+        return IUnknown_QueryInterface(This->pUnkFTMarshal, riid, ppv);
+    if(*ppv){
+        IUnknown_AddRef((IUnknown*)*ppv);
+        return S_OK;
+    }
+    WARN("Unknown interface %s\n", debugstr_guid(riid));
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI AudioClient_AddRef(IAudioClient *iface)
+{
+    ACImpl *This = impl_from_IAudioClient(iface);
+    ULONG ref;
+    ref = InterlockedIncrement(&This->ref);
+    TRACE("(%p) Refcount now %u\n", This, ref);
+    return ref;
+}
+
+static ULONG WINAPI AudioClient_Release(IAudioClient *iface)
+{
+    ACImpl *This = impl_from_IAudioClient(iface);
+    ULONG ref;
+
+    ref = InterlockedDecrement(&This->ref);
+    TRACE("(%p) Refcount now %u\n", This, ref);
+    if(!ref){
+        if(This->timer){
+            HANDLE event;
+            DWORD wait;
+            event = CreateEventW(NULL, TRUE, FALSE, NULL);
+            wait = !DeleteTimerQueueTimer(g_timer_q, This->timer, event);
+            wait = wait && GetLastError() == ERROR_IO_PENDING;
+            if(event && wait)
+                WaitForSingleObject(event, INFINITE);
+            CloseHandle(event);
+        }
+
+        IAudioClient_Stop(iface);
+
+        IMMDevice_Release(This->parent);
+        IUnknown_Release(This->pUnkFTMarshal);
+        This->lock.DebugInfo->Spare[0] = 0;
+        DeleteCriticalSection(&This->lock);
+
+        if(This->recorder)
+            SLCALL_N(This->recorder, Destroy);
+        if(This->player)
+            SLCALL_N(This->player, Destroy);
+        if(This->outputmix)
+            SLCALL_N(This->outputmix, Destroy);
+
+        if(This->initted){
+            EnterCriticalSection(&g_sessions_lock);
+            list_remove(&This->entry);
+            LeaveCriticalSection(&g_sessions_lock);
+        }
+        HeapFree(GetProcessHeap(), 0, This->vols);
+        HeapFree(GetProcessHeap(), 0, This->local_buffer);
+        HeapFree(GetProcessHeap(), 0, This->tmp_buffer);
+        HeapFree(GetProcessHeap(), 0, This->wrap_buffer);
+        CoTaskMemFree(This->fmt);
+        HeapFree(GetProcessHeap(), 0, This);
+    }
+    return ref;
+}
+
+static void dump_fmt(const WAVEFORMATEX *fmt)
+{
+    TRACE("wFormatTag: 0x%x (", fmt->wFormatTag);
+    switch(fmt->wFormatTag){
+    case WAVE_FORMAT_PCM:
+        TRACE("WAVE_FORMAT_PCM");
+        break;
+    case WAVE_FORMAT_IEEE_FLOAT:
+        TRACE("WAVE_FORMAT_IEEE_FLOAT");
+        break;
+    case WAVE_FORMAT_EXTENSIBLE:
+        TRACE("WAVE_FORMAT_EXTENSIBLE");
+        break;
+    default:
+        TRACE("Unknown");
+        break;
+    }
+    TRACE(")\n");
+
+    TRACE("nChannels: %u\n", fmt->nChannels);
+    TRACE("nSamplesPerSec: %u\n", fmt->nSamplesPerSec);
+    TRACE("nAvgBytesPerSec: %u\n", fmt->nAvgBytesPerSec);
+    TRACE("nBlockAlign: %u\n", fmt->nBlockAlign);
+    TRACE("wBitsPerSample: %u\n", fmt->wBitsPerSample);
+    TRACE("cbSize: %u\n", fmt->cbSize);
+
+    if(fmt->wFormatTag == WAVE_FORMAT_EXTENSIBLE){
+        WAVEFORMATEXTENSIBLE *fmtex = (void*)fmt;
+        TRACE("dwChannelMask: %08x\n", fmtex->dwChannelMask);
+        TRACE("Samples: %04x\n", fmtex->Samples.wReserved);
+        TRACE("SubFormat: %s\n", wine_dbgstr_guid(&fmtex->SubFormat));
+    }
+}
+
+static DWORD get_channel_mask(unsigned int channels)
+{
+    switch(channels){
+    case 0:
+        return 0;
+    case 1:
+        return KSAUDIO_SPEAKER_MONO;
+    case 2:
+        return KSAUDIO_SPEAKER_STEREO;
+    case 3:
+        return KSAUDIO_SPEAKER_STEREO | SPEAKER_LOW_FREQUENCY;
+    case 4:
+        return KSAUDIO_SPEAKER_QUAD;    /* not _SURROUND */
+    case 5:
+        return KSAUDIO_SPEAKER_QUAD | SPEAKER_LOW_FREQUENCY;
+    case 6:
+        return KSAUDIO_SPEAKER_5POINT1; /* not 5POINT1_SURROUND */
+    case 7:
+        return KSAUDIO_SPEAKER_5POINT1 | SPEAKER_BACK_CENTER;
+    case 8:
+        return KSAUDIO_SPEAKER_7POINT1_SURROUND; /* Vista deprecates 7POINT1 */
+    }
+    FIXME("Unknown speaker configuration: %u\n", channels);
+    return 0;
+}
+
+static WAVEFORMATEX *clone_format(const WAVEFORMATEX *fmt)
+{
+    WAVEFORMATEX *ret;
+    size_t size;
+
+    if(fmt->wFormatTag == WAVE_FORMAT_EXTENSIBLE)
+        size = sizeof(WAVEFORMATEXTENSIBLE);
+    else
+        size = sizeof(WAVEFORMATEX);
+
+    ret = CoTaskMemAlloc(size);
+    if(!ret)
+        return NULL;
+
+    memcpy(ret, fmt, size);
+
+    ret->cbSize = size - sizeof(WAVEFORMATEX);
+
+    return ret;
+}
+
+static void session_init_vols(AudioSession *session, UINT channels)
+{
+    if(session->channel_count < channels){
+        UINT i;
+
+        if(session->channel_vols)
+            session->channel_vols = HeapReAlloc(GetProcessHeap(), 0,
+                    session->channel_vols, sizeof(float) * channels);
+        else
+            session->channel_vols = HeapAlloc(GetProcessHeap(), 0,
+                    sizeof(float) * channels);
+        if(!session->channel_vols)
+            return;
+
+        for(i = session->channel_count; i < channels; ++i)
+            session->channel_vols[i] = 1.f;
+
+        session->channel_count = channels;
+    }
+}
+
+static AudioSession *create_session(const GUID *guid, IMMDevice *device,
+        UINT num_channels)
+{
+    AudioSession *ret;
+
+    ret = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(AudioSession));
+    if(!ret)
+        return NULL;
+
+    memcpy(&ret->guid, guid, sizeof(GUID));
+
+    ret->device = device;
+
+    list_init(&ret->clients);
+
+    list_add_head(&g_sessions, &ret->entry);
+
+    InitializeCriticalSection(&ret->lock);
+    ret->lock.DebugInfo->Spare[0] = (DWORD_PTR)(__FILE__ ": AudioSession.lock");
+
+    session_init_vols(ret, num_channels);
+
+    ret->master_vol = 1.f;
+
+    return ret;
+}
+
+/* if channels == 0, then this will return or create a session with
+ * matching dataflow and GUID. otherwise, channels must also match */
+static HRESULT get_audio_session(const GUID *sessionguid,
+        IMMDevice *device, UINT channels, AudioSession **out)
+{
+    AudioSession *session;
+
+    if(!sessionguid || IsEqualGUID(sessionguid, &GUID_NULL)){
+        *out = create_session(&GUID_NULL, device, channels);
+        if(!*out)
+            return E_OUTOFMEMORY;
+
+        return S_OK;
+    }
+
+    *out = NULL;
+    LIST_FOR_EACH_ENTRY(session, &g_sessions, AudioSession, entry){
+        if(session->device == device &&
+                IsEqualGUID(sessionguid, &session->guid)){
+            session_init_vols(session, channels);
+            *out = session;
+            break;
+        }
+    }
+
+    if(!*out){
+        *out = create_session(sessionguid, device, channels);
+        if(!*out)
+            return E_OUTOFMEMORY;
+    }
+
+    return S_OK;
+}
+
+static HRESULT waveformat_to_pcm(ACImpl *This, const WAVEFORMATEX *fmt, SLDataFormat_PCM *pcm)
+{
+    /* only support non-float PCM */
+    if(fmt->wFormatTag != WAVE_FORMAT_PCM &&
+            !(fmt->wFormatTag == WAVE_FORMAT_EXTENSIBLE &&
+                IsEqualGUID(&((WAVEFORMATEXTENSIBLE*)fmt)->SubFormat, &KSDATAFORMAT_SUBTYPE_PCM)))
+        return AUDCLNT_E_UNSUPPORTED_FORMAT;
+
+    /* TODO: does android only support 16-bit PCM? */
+
+    if(fmt->nSamplesPerSec < 8000 || fmt->nSamplesPerSec > 48000)
+        return AUDCLNT_E_UNSUPPORTED_FORMAT;
+
+    pcm->formatType = SL_DATAFORMAT_PCM;
+    pcm->numChannels = fmt->nChannels;
+    pcm->samplesPerSec = fmt->nSamplesPerSec * 1000; /* no typo, actually in milli-Hz */
+    pcm->bitsPerSample = fmt->wBitsPerSample;
+    pcm->containerSize = fmt->wBitsPerSample;
+    /* only up to stereo */
+    if(pcm->numChannels == 1)
+        pcm->channelMask = SL_SPEAKER_FRONT_LEFT;
+    else if(This->dataflow == eRender && pcm->numChannels == 2)
+        pcm->channelMask = SL_SPEAKER_FRONT_LEFT | SL_SPEAKER_FRONT_RIGHT;
+    else
+        return AUDCLNT_E_UNSUPPORTED_FORMAT;
+    pcm->endianness = SL_BYTEORDER_LITTLEENDIAN;
+
+    return S_OK;
+}
+
+static HRESULT WINAPI AudioClient_Initialize(IAudioClient *iface,
+        AUDCLNT_SHAREMODE mode, DWORD flags, REFERENCE_TIME duration,
+        REFERENCE_TIME period, const WAVEFORMATEX *fmt,
+        const GUID *sessionguid)
+{
+    ACImpl *This = impl_from_IAudioClient(iface);
+    int i;
+    HRESULT hr;
+    SLresult sr;
+    SLDataFormat_PCM pcm;
+    SLDataLocator_AndroidSimpleBufferQueue loc_bq;
+
+    TRACE("(%p)->(%x, %x, %s, %s, %p, %s)\n", This, mode, flags,
+          wine_dbgstr_longlong(duration), wine_dbgstr_longlong(period), fmt, debugstr_guid(sessionguid));
+
+    if(!fmt)
+        return E_POINTER;
+
+    dump_fmt(fmt);
+
+    if(mode != AUDCLNT_SHAREMODE_SHARED && mode != AUDCLNT_SHAREMODE_EXCLUSIVE)
+        return AUDCLNT_E_NOT_INITIALIZED;
+
+    if(flags & ~(AUDCLNT_STREAMFLAGS_CROSSPROCESS |
+                AUDCLNT_STREAMFLAGS_LOOPBACK |
+                AUDCLNT_STREAMFLAGS_EVENTCALLBACK |
+                AUDCLNT_STREAMFLAGS_NOPERSIST |
+                AUDCLNT_STREAMFLAGS_RATEADJUST |
+                AUDCLNT_SESSIONFLAGS_EXPIREWHENUNOWNED |
+                AUDCLNT_SESSIONFLAGS_DISPLAY_HIDE |
+                AUDCLNT_SESSIONFLAGS_DISPLAY_HIDEWHENEXPIRED)){
+        TRACE("Unknown flags: %08x\n", flags);
+        return E_INVALIDARG;
+    }
+
+    if(mode == AUDCLNT_SHAREMODE_SHARED){
+        period = DefaultPeriod;
+        if( duration < 3 * period)
+            duration = 3 * period;
+    }else{
+        if(!period)
+            period = DefaultPeriod; /* not minimum */
+        if(period < MinimumPeriod || period > 5000000)
+            return AUDCLNT_E_INVALID_DEVICE_PERIOD;
+        if(duration > 20000000) /* the smaller the period, the lower this limit */
+            return AUDCLNT_E_BUFFER_SIZE_ERROR;
+        if(flags & AUDCLNT_STREAMFLAGS_EVENTCALLBACK){
+            if(duration != period)
+                return AUDCLNT_E_BUFDURATION_PERIOD_NOT_EQUAL;
+            FIXME("EXCLUSIVE mode with EVENTCALLBACK\n");
+            return AUDCLNT_E_DEVICE_IN_USE;
+        }else{
+            if( duration < 8 * period)
+                duration = 8 * period; /* may grow above 2s */
+        }
+    }
+
+    EnterCriticalSection(&This->lock);
+
+    if(This->initted){
+        LeaveCriticalSection(&This->lock);
+        return AUDCLNT_E_ALREADY_INITIALIZED;
+    }
+
+    This->period_us = period / 10;
+    This->period_frames = MulDiv(fmt->nSamplesPerSec, period, 10000000);
+
+    This->bufsize_frames = MulDiv(duration, fmt->nSamplesPerSec, 10000000);
+    if(mode == AUDCLNT_SHAREMODE_EXCLUSIVE)
+        This->bufsize_frames -= This->bufsize_frames % This->period_frames;
+    else if(This->bufsize_frames % This->period_frames != 0)
+        /* hack: round up to integer multiple */
+        This->bufsize_frames += This->period_frames - This->bufsize_frames % This->period_frames;
+
+    hr = waveformat_to_pcm(This, fmt, &pcm);
+    if(FAILED(hr)){
+        LeaveCriticalSection(&This->lock);
+        return hr;
+    }
+
+    if(This->dataflow == eRender){
+        SLDataSource source;
+        SLDataSink sink;
+        SLDataLocator_OutputMix loc_outmix;
+        SLboolean required[2];
+        SLInterfaceID iids[2];
+
+        loc_bq.locatorType = SL_DATALOCATOR_ANDROIDSIMPLEBUFFERQUEUE;
+        loc_bq.numBuffers = This->bufsize_frames / This->period_frames;
+        source.pLocator = &loc_bq;
+        source.pFormat = &pcm;
+
+        loc_outmix.locatorType = SL_DATALOCATOR_OUTPUTMIX;
+        loc_outmix.outputMix = This->outputmix;
+        sink.pLocator = &loc_outmix;
+        sink.pFormat = NULL;
+
+        required[0] = SL_BOOLEAN_TRUE;
+        iids[0] = *pSL_IID_ANDROIDSIMPLEBUFFERQUEUE;
+        required[1] = SL_BOOLEAN_TRUE;
+        iids[1] = *pSL_IID_PLAYBACKRATE;
+
+        sr = SLCALL(engine, CreateAudioPlayer, &This->player, &source, &sink,
+                2, iids, required);
+        if(sr != SL_RESULT_SUCCESS){
+            WARN("CreateAudioPlayer failed: 0x%x\n", sr);
+            LeaveCriticalSection(&This->lock);
+            return E_FAIL;
+        }
+
+        sr = SLCALL(This->player, Realize, SL_BOOLEAN_FALSE);
+        if(sr != SL_RESULT_SUCCESS){
+            SLCALL_N(This->player, Destroy);
+            This->player = NULL;
+            WARN("Player Realize failed: 0x%x\n", sr);
+            LeaveCriticalSection(&This->lock);
+            return E_FAIL;
+        }
+
+        sr = SLCALL(This->player, GetInterface, *pSL_IID_ANDROIDSIMPLEBUFFERQUEUE, &This->bufq);
+        if(sr != SL_RESULT_SUCCESS){
+            SLCALL_N(This->player, Destroy);
+            This->player = NULL;
+            WARN("Player GetInterface(BufferQueue) failed: 0x%x\n", sr);
+            LeaveCriticalSection(&This->lock);
+            return E_FAIL;
+        }
+
+        sr = SLCALL(This->player, GetInterface, *pSL_IID_PLAY, &This->playitf);
+        if(sr != SL_RESULT_SUCCESS){
+            SLCALL_N(This->player, Destroy);
+            This->player = NULL;
+            WARN("Player GetInterface(Play) failed: 0x%x\n", sr);
+            LeaveCriticalSection(&This->lock);
+            return E_FAIL;
+        }
+    }else{
+        SLDataSource source;
+        SLDataSink sink;
+        SLDataLocator_IODevice loc_mic;
+        SLboolean required[1];
+        SLInterfaceID iids[1];
+
+        loc_mic.locatorType = SL_DATALOCATOR_IODEVICE;
+        loc_mic.deviceType = SL_IODEVICE_AUDIOINPUT;
+        loc_mic.deviceID = SL_DEFAULTDEVICEID_AUDIOINPUT;
+        loc_mic.device = NULL;
+        source.pLocator = &loc_mic;
+        source.pFormat = NULL;
+
+        loc_bq.locatorType = SL_DATALOCATOR_ANDROIDSIMPLEBUFFERQUEUE;
+        loc_bq.numBuffers = This->bufsize_frames / This->period_frames;
+        sink.pLocator = &loc_bq;
+        sink.pFormat = &pcm;
+
+        required[0] = SL_BOOLEAN_TRUE;
+        iids[0] = *pSL_IID_ANDROIDSIMPLEBUFFERQUEUE;
+
+        sr = SLCALL(engine, CreateAudioRecorder, &This->recorder, &source, &sink,
+                1, iids, required);
+        if(sr != SL_RESULT_SUCCESS){
+            WARN("CreateAudioRecorder failed: 0x%x\n", sr);
+            LeaveCriticalSection(&This->lock);
+            return E_FAIL;
+        }
+
+        sr = SLCALL(This->recorder, Realize, SL_BOOLEAN_FALSE);
+        if(sr != SL_RESULT_SUCCESS){
+            SLCALL_N(This->recorder, Destroy);
+            This->recorder = NULL;
+            WARN("Recorder Realize failed: 0x%x\n", sr);
+            LeaveCriticalSection(&This->lock);
+            return E_FAIL;
+        }
+
+        sr = SLCALL(This->recorder, GetInterface, *pSL_IID_ANDROIDSIMPLEBUFFERQUEUE, &This->bufq);
+        if(sr != SL_RESULT_SUCCESS){
+            SLCALL_N(This->recorder, Destroy);
+            This->recorder = NULL;
+            WARN("Recorder GetInterface(BufferQueue) failed: 0x%x\n", sr);
+            LeaveCriticalSection(&This->lock);
+            return E_FAIL;
+        }
+
+        sr = SLCALL(This->recorder, GetInterface, *pSL_IID_RECORD, &This->recorditf);
+        if(sr != SL_RESULT_SUCCESS){
+            SLCALL_N(This->recorder, Destroy);
+            This->recorder = NULL;
+            WARN("Recorder GetInterface(Record) failed: 0x%x\n", sr);
+            LeaveCriticalSection(&This->lock);
+            return E_FAIL;
+        }
+    }
+
+    This->fmt = clone_format(fmt);
+    if(!This->fmt){
+        if(This->player){
+            SLCALL_N(This->player, Destroy);
+            This->player = NULL;
+        }
+        if(This->recorder){
+            SLCALL_N(This->recorder, Destroy);
+            This->recorder = NULL;
+        }
+        LeaveCriticalSection(&This->lock);
+        return E_OUTOFMEMORY;
+    }
+
+    This->local_buffer = HeapAlloc(GetProcessHeap(), 0,
+            This->bufsize_frames * fmt->nBlockAlign);
+    if(!This->local_buffer){
+        CoTaskMemFree(This->fmt);
+        This->fmt = NULL;
+        if(This->player){
+            SLCALL_N(This->player, Destroy);
+            This->player = NULL;
+        }
+        if(This->recorder){
+            SLCALL_N(This->recorder, Destroy);
+            This->recorder = NULL;
+        }
+        LeaveCriticalSection(&This->lock);
+        return E_OUTOFMEMORY;
+    }
+
+    if(This->dataflow == eCapture){
+        while(This->in_sl_frames < This->bufsize_frames){
+            TRACE("enqueueing: %u frames from %u\n", This->period_frames, (This->lcl_offs_frames + This->in_sl_frames) % This->bufsize_frames);
+            sr = SLCALL(This->bufq, Enqueue,
+                    This->local_buffer + ((This->lcl_offs_frames + This->in_sl_frames) % This->bufsize_frames) * This->fmt->nBlockAlign,
+                    This->period_frames * This->fmt->nBlockAlign);
+            if(sr != SL_RESULT_SUCCESS)
+                WARN("Enqueue failed: 0x%x\n", sr);
+            This->in_sl_frames += This->period_frames;
+        }
+    }
+
+    This->vols = HeapAlloc(GetProcessHeap(), 0, fmt->nChannels * sizeof(float));
+    if(!This->vols){
+        CoTaskMemFree(This->fmt);
+        This->fmt = NULL;
+        if(This->player){
+            SLCALL_N(This->player, Destroy);
+            This->player = NULL;
+        }
+        if(This->recorder){
+            SLCALL_N(This->recorder, Destroy);
+            This->recorder = NULL;
+        }
+        LeaveCriticalSection(&This->lock);
+        return E_OUTOFMEMORY;
+    }
+
+    for(i = 0; i < fmt->nChannels; ++i)
+        This->vols[i] = 1.f;
+
+    This->share = mode;
+    This->flags = flags;
+    This->oss_bufsize_bytes = 0;
+
+    EnterCriticalSection(&g_sessions_lock);
+
+    hr = get_audio_session(sessionguid, This->parent, fmt->nChannels,
+            &This->session);
+    if(FAILED(hr)){
+        LeaveCriticalSection(&g_sessions_lock);
+        HeapFree(GetProcessHeap(), 0, This->vols);
+        This->vols = NULL;
+        CoTaskMemFree(This->fmt);
+        This->fmt = NULL;
+        if(This->player){
+            SLCALL_N(This->player, Destroy);
+            This->player = NULL;
+        }
+        if(This->recorder){
+            SLCALL_N(This->recorder, Destroy);
+            This->recorder = NULL;
+        }
+        LeaveCriticalSection(&This->lock);
+        return hr;
+    }
+
+    list_add_tail(&This->session->clients, &This->entry);
+
+    LeaveCriticalSection(&g_sessions_lock);
+
+    This->initted = TRUE;
+
+    TRACE("numBuffers: %u, bufsize: %u, period: %u\n", loc_bq.numBuffers,
+            This->bufsize_frames, This->period_frames);
+
+    LeaveCriticalSection(&This->lock);
+
+    return S_OK;
+}
+
+static HRESULT WINAPI AudioClient_GetBufferSize(IAudioClient *iface,
+        UINT32 *frames)
+{
+    ACImpl *This = impl_from_IAudioClient(iface);
+
+    TRACE("(%p)->(%p)\n", This, frames);
+
+    if(!frames)
+        return E_POINTER;
+
+    EnterCriticalSection(&This->lock);
+
+    if(!This->initted){
+        LeaveCriticalSection(&This->lock);
+        return AUDCLNT_E_NOT_INITIALIZED;
+    }
+
+    *frames = This->bufsize_frames;
+
+    TRACE("buffer size: %u\n", *frames);
+
+    LeaveCriticalSection(&This->lock);
+
+    return S_OK;
+}
+
+static HRESULT WINAPI AudioClient_GetStreamLatency(IAudioClient *iface,
+        REFERENCE_TIME *latency)
+{
+    ACImpl *This = impl_from_IAudioClient(iface);
+
+    TRACE("(%p)->(%p)\n", This, latency);
+
+    if(!latency)
+        return E_POINTER;
+
+    EnterCriticalSection(&This->lock);
+
+    if(!This->initted){
+        LeaveCriticalSection(&This->lock);
+        return AUDCLNT_E_NOT_INITIALIZED;
+    }
+
+    /* pretend we process audio in Period chunks, so max latency includes
+     * the period time.  Some native machines add .6666ms in shared mode. */
+    *latency = This->period_us * 10 + 6666;
+
+    LeaveCriticalSection(&This->lock);
+
+    return S_OK;
+}
+
+static HRESULT WINAPI AudioClient_GetCurrentPadding(IAudioClient *iface,
+        UINT32 *numpad)
+{
+    ACImpl *This = impl_from_IAudioClient(iface);
+
+    TRACE("(%p)->(%p)\n", This, numpad);
+
+    if(!numpad)
+        return E_POINTER;
+
+    EnterCriticalSection(&This->lock);
+
+    if(!This->initted){
+        LeaveCriticalSection(&This->lock);
+        return AUDCLNT_E_NOT_INITIALIZED;
+    }
+
+    *numpad = This->held_frames;
+
+    TRACE("padding: %u\n", *numpad);
+
+    LeaveCriticalSection(&This->lock);
+
+    return S_OK;
+}
+
+static HRESULT WINAPI AudioClient_IsFormatSupported(IAudioClient *iface,
+        AUDCLNT_SHAREMODE mode, const WAVEFORMATEX *pwfx,
+        WAVEFORMATEX **outpwfx)
+{
+    ACImpl *This = impl_from_IAudioClient(iface);
+    SLDataFormat_PCM pcm;
+    HRESULT hr;
+
+    TRACE("(%p)->(%x, %p, %p)\n", This, mode, pwfx, outpwfx);
+
+    if(!pwfx || (mode == AUDCLNT_SHAREMODE_SHARED && !outpwfx))
+        return E_POINTER;
+
+    if(mode != AUDCLNT_SHAREMODE_SHARED && mode != AUDCLNT_SHAREMODE_EXCLUSIVE)
+        return E_INVALIDARG;
+
+    if(pwfx->wFormatTag == WAVE_FORMAT_EXTENSIBLE &&
+            pwfx->cbSize < sizeof(WAVEFORMATEXTENSIBLE) - sizeof(WAVEFORMATEX))
+        return E_INVALIDARG;
+
+    dump_fmt(pwfx);
+
+    if(outpwfx){
+        *outpwfx = NULL;
+        if(mode != AUDCLNT_SHAREMODE_SHARED)
+            outpwfx = NULL;
+    }
+
+    hr = waveformat_to_pcm(This, pwfx, &pcm);
+    TRACE("returning: %08x\n", hr);
+    return hr;
+}
+
+static HRESULT WINAPI AudioClient_GetMixFormat(IAudioClient *iface,
+        WAVEFORMATEX **pwfx)
+{
+    ACImpl *This = impl_from_IAudioClient(iface);
+    WAVEFORMATEXTENSIBLE *fmt;
+
+    TRACE("(%p)->(%p)\n", This, pwfx);
+
+    if(!pwfx)
+        return E_POINTER;
+    *pwfx = NULL;
+
+    fmt = CoTaskMemAlloc(sizeof(WAVEFORMATEXTENSIBLE));
+    if(!fmt)
+        return E_OUTOFMEMORY;
+
+    fmt->Format.wFormatTag = WAVE_FORMAT_EXTENSIBLE;
+    fmt->Format.wBitsPerSample = 16;
+    fmt->SubFormat = KSDATAFORMAT_SUBTYPE_PCM;
+    if(This->dataflow == eRender)
+        fmt->Format.nChannels = 2;
+    else
+        fmt->Format.nChannels = 1;
+    fmt->Format.nSamplesPerSec = 48000; /* TODO: query supported? recording? */
+    fmt->Format.nBlockAlign = (fmt->Format.wBitsPerSample *
+            fmt->Format.nChannels) / 8;
+    fmt->Format.nAvgBytesPerSec = fmt->Format.nSamplesPerSec *
+        fmt->Format.nBlockAlign;
+    fmt->Samples.wValidBitsPerSample = fmt->Format.wBitsPerSample;
+    fmt->dwChannelMask = get_channel_mask(fmt->Format.nChannels);
+    fmt->Format.cbSize = sizeof(WAVEFORMATEXTENSIBLE) - sizeof(WAVEFORMATEX);
+
+    *pwfx = (WAVEFORMATEX*)fmt;
+    dump_fmt(*pwfx);
+
+    return S_OK;
+}
+
+static HRESULT WINAPI AudioClient_GetDevicePeriod(IAudioClient *iface,
+        REFERENCE_TIME *defperiod, REFERENCE_TIME *minperiod)
+{
+    ACImpl *This = impl_from_IAudioClient(iface);
+
+    TRACE("(%p)->(%p, %p)\n", This, defperiod, minperiod);
+
+    if(!defperiod && !minperiod)
+        return E_POINTER;
+
+    if(defperiod)
+        *defperiod = DefaultPeriod;
+    if(minperiod)
+        *minperiod = MinimumPeriod;
+
+    return S_OK;
+}
+
+static void silence_buffer(ACImpl *This, BYTE *buffer, UINT32 frames)
+{
+    WAVEFORMATEXTENSIBLE *fmtex = (WAVEFORMATEXTENSIBLE*)This->fmt;
+    if((This->fmt->wFormatTag == WAVE_FORMAT_PCM ||
+            (This->fmt->wFormatTag == WAVE_FORMAT_EXTENSIBLE &&
+             IsEqualGUID(&fmtex->SubFormat, &KSDATAFORMAT_SUBTYPE_PCM))) &&
+            This->fmt->wBitsPerSample == 8)
+        memset(buffer, 128, frames * This->fmt->nBlockAlign);
+    else
+        memset(buffer, 0, frames * This->fmt->nBlockAlign);
+}
+
+static void sl_read_data(ACImpl *This)
+{
+    SLAndroidSimpleBufferQueueState state;
+    SLresult sr;
+    SLuint32 elapsed;
+
+    memset(&state, 0, sizeof(state));
+
+    sr = SLCALL(This->bufq, GetState, &state);
+    if(sr != SL_RESULT_SUCCESS){
+        WARN("GetState failed: 0x%x\n", sr);
+        return;
+    }
+    TRACE("got: count: %u, index: %u, held: %u, in_sl: %u\n", state.count, state.index, This->held_frames, This->in_sl_frames);
+
+    elapsed = This->in_sl_frames - state.count * This->period_frames;
+    This->held_frames += elapsed;
+    This->in_sl_frames = state.count * This->period_frames;
+
+    if(This->held_frames == This->bufsize_frames){
+        /* overrun */
+        TRACE("overrun??\n");
+        This->lcl_offs_frames += This->period_frames;
+        This->held_frames -= This->period_frames;
+    }
+
+    TRACE("good range: %u, %u\n", This->lcl_offs_frames, This->lcl_offs_frames + This->held_frames);
+    TRACE("held: %u, in_sl: %u\n", This->held_frames, This->in_sl_frames);
+    while(This->held_frames + This->in_sl_frames < This->bufsize_frames){
+        TRACE("enqueueing: %u frames from %u\n", This->period_frames, (This->lcl_offs_frames + This->held_frames + This->in_sl_frames) % This->bufsize_frames);
+        sr = SLCALL(This->bufq, Enqueue,
+                This->local_buffer + ((This->lcl_offs_frames + This->held_frames + This->in_sl_frames) % This->bufsize_frames) * This->fmt->nBlockAlign,
+                This->period_frames * This->fmt->nBlockAlign);
+        if(sr != SL_RESULT_SUCCESS)
+            WARN("Enqueue failed: 0x%x\n", sr);
+        This->in_sl_frames += This->period_frames;
+    }
+}
+
+static DWORD wrap_enqueue(ACImpl *This)
+{
+    DWORD to_enqueue = min(This->held_frames, This->period_frames);
+    DWORD offs = (This->lcl_offs_frames + This->in_sl_frames) % This->bufsize_frames;
+    BYTE *buf = This->local_buffer + offs * This->fmt->nBlockAlign;
+
+    if(offs + to_enqueue > This->bufsize_frames){
+        DWORD chunk = This->bufsize_frames - This->lcl_offs_frames;
+
+        if(This->wrap_buffer_frames < to_enqueue){
+            HeapFree(GetProcessHeap(), 0, This->wrap_buffer);
+            This->wrap_buffer = HeapAlloc(GetProcessHeap(), 0, to_enqueue * This->fmt->nBlockAlign);
+            This->wrap_buffer_frames = to_enqueue;
+        }
+
+        memcpy(This->wrap_buffer, This->local_buffer + offs * This->fmt->nBlockAlign, chunk * This->fmt->nBlockAlign);
+        memcpy(This->wrap_buffer + chunk * This->fmt->nBlockAlign, This->local_buffer, (to_enqueue - chunk) * This->fmt->nBlockAlign);
+
+        buf = This->wrap_buffer;
+    }
+
+    SLCALL(This->bufq, Enqueue, buf,
+            to_enqueue * This->fmt->nBlockAlign);
+
+    return to_enqueue;
+}
+
+static void sl_write_data(ACImpl *This)
+{
+    SLAndroidSimpleBufferQueueState state;
+    SLresult sr;
+    SLuint32 elapsed;
+
+    memset(&state, 0, sizeof(state));
+
+    sr = SLCALL(This->bufq, GetState, &state);
+    if(sr != SL_RESULT_SUCCESS){
+        WARN("GetState failed: 0x%x\n", sr);
+        return;
+    }
+    TRACE("got: count: %u, index: %u\n", state.count, state.index);
+
+    elapsed = This->in_sl_frames - state.count * This->period_frames;
+
+    if(elapsed > This->held_frames)
+        This->held_frames = 0;
+    else
+        This->held_frames -= elapsed;
+
+    This->lcl_offs_frames += elapsed;
+    This->lcl_offs_frames %= This->bufsize_frames;
+
+    This->in_sl_frames = state.count * This->period_frames;
+
+    while(This->held_frames >= This->in_sl_frames + This->period_frames){
+        /* have at least a period to write, so write it */
+        TRACE("enqueueing: %u frames from %u\n", This->period_frames, (This->lcl_offs_frames + This->in_sl_frames) % This->bufsize_frames);
+        This->in_sl_frames += wrap_enqueue(This);
+    }
+
+    if(This->held_frames && This->in_sl_frames < This->period_frames * 3){
+        /* write out the last bit with a partial period */
+        TRACE("enqueueing partial period: %u frames from %u\n", This->held_frames, (This->lcl_offs_frames + This->in_sl_frames) % This->bufsize_frames);
+        This->in_sl_frames += wrap_enqueue(This);
+    }
+
+    TRACE("done with enqueue, lcl_offs: %u, in_sl: %u, held: %u\n", This->lcl_offs_frames, This->in_sl_frames, This->held_frames);
+}
+
+static void CALLBACK sl_period_callback(void *user, BOOLEAN timer)
+{
+    ACImpl *This = user;
+
+    EnterCriticalSection(&This->lock);
+
+    if(This->playing){
+        if(This->dataflow == eRender)
+            sl_write_data(This);
+        else if(This->dataflow == eCapture)
+            sl_read_data(This);
+    }
+
+    LeaveCriticalSection(&This->lock);
+
+    if(This->event)
+        SetEvent(This->event);
+}
+
+static HRESULT WINAPI AudioClient_Start(IAudioClient *iface)
+{
+    ACImpl *This = impl_from_IAudioClient(iface);
+    SLresult sr;
+
+    TRACE("(%p)\n", This);
+
+    EnterCriticalSection(&This->lock);
+
+    if(!This->initted){
+        LeaveCriticalSection(&This->lock);
+        return AUDCLNT_E_NOT_INITIALIZED;
+    }
+
+    if((This->flags & AUDCLNT_STREAMFLAGS_EVENTCALLBACK) && !This->event){
+        LeaveCriticalSection(&This->lock);
+        return AUDCLNT_E_EVENTHANDLE_NOT_SET;
+    }
+
+    if(This->playing){
+        LeaveCriticalSection(&This->lock);
+        return AUDCLNT_E_NOT_STOPPED;
+    }
+
+    if(This->dataflow == eRender){
+        sr = SLCALL(This->playitf, SetPlayState, SL_PLAYSTATE_PLAYING);
+        if(sr != SL_RESULT_SUCCESS){
+            WARN("SetPlayState failed: 0x%x\n", sr);
+            LeaveCriticalSection(&This->lock);
+            return E_FAIL;
+        }
+    }else{
+        sr = SLCALL(This->recorditf, SetRecordState, SL_RECORDSTATE_RECORDING);
+        if(sr != SL_RESULT_SUCCESS){
+            WARN("SetRecordState failed: 0x%x\n", sr);
+            LeaveCriticalSection(&This->lock);
+            return E_FAIL;
+        }
+    }
+
+    if(!This->timer){
+        if(!CreateTimerQueueTimer(&This->timer, g_timer_q,
+                    sl_period_callback, This, 0, This->period_us / 1000,
+                    WT_EXECUTEINTIMERTHREAD))
+            WARN("Unable to create period timer: %u\n", GetLastError());
+    }
+
+    This->playing = TRUE;
+
+    LeaveCriticalSection(&This->lock);
+
+    return S_OK;
+}
+
+static HRESULT WINAPI AudioClient_Stop(IAudioClient *iface)
+{
+    ACImpl *This = impl_from_IAudioClient(iface);
+    SLresult sr;
+
+    TRACE("(%p)\n", This);
+
+    EnterCriticalSection(&This->lock);
+
+    if(!This->initted){
+        LeaveCriticalSection(&This->lock);
+        return AUDCLNT_E_NOT_INITIALIZED;
+    }
+
+    if(!This->playing){
+        LeaveCriticalSection(&This->lock);
+        return S_FALSE;
+    }
+
+    if(This->dataflow == eRender){
+        sr = SLCALL(This->playitf, SetPlayState, SL_PLAYSTATE_PAUSED);
+        if(sr != SL_RESULT_SUCCESS){
+            WARN("SetPlayState failed: 0x%x\n", sr);
+            LeaveCriticalSection(&This->lock);
+            return E_FAIL;
+        }
+    }else{
+        sr = SLCALL(This->recorditf, SetRecordState, SL_RECORDSTATE_STOPPED);
+        if(sr != SL_RESULT_SUCCESS){
+            WARN("SetRecordState failed: 0x%x\n", sr);
+            LeaveCriticalSection(&This->lock);
+            return E_FAIL;
+        }
+    }
+
+    This->playing = FALSE;
+
+    LeaveCriticalSection(&This->lock);
+
+    return S_OK;
+}
+
+static HRESULT WINAPI AudioClient_Reset(IAudioClient *iface)
+{
+    ACImpl *This = impl_from_IAudioClient(iface);
+    SLresult sr;
+
+    TRACE("(%p)\n", This);
+
+    EnterCriticalSection(&This->lock);
+
+    if(!This->initted){
+        LeaveCriticalSection(&This->lock);
+        return AUDCLNT_E_NOT_INITIALIZED;
+    }
+
+    if(This->playing){
+        LeaveCriticalSection(&This->lock);
+        return AUDCLNT_E_NOT_STOPPED;
+    }
+
+    if(This->getbuf_last){
+        LeaveCriticalSection(&This->lock);
+        return AUDCLNT_E_BUFFER_OPERATION_PENDING;
+    }
+
+    sr = SLCALL_N(This->bufq, Clear);
+    if(sr != SL_RESULT_SUCCESS){
+        WARN("Clear failed: 0x%x\n", sr);
+        LeaveCriticalSection(&This->lock);
+        return E_FAIL;
+    }
+
+    This->lcl_offs_frames = 0;
+    This->in_sl_frames = 0;
+
+    if(This->dataflow == eRender){
+        This->written_frames = 0;
+        This->last_pos_frames = 0;
+    }else{
+        This->written_frames += This->held_frames;
+        while(This->in_sl_frames < This->bufsize_frames){
+            TRACE("enqueueing: %u frames from %u\n", This->period_frames, (This->lcl_offs_frames + This->in_sl_frames) % This->bufsize_frames);
+            sr = SLCALL(This->bufq, Enqueue,
+                    This->local_buffer + ((This->lcl_offs_frames + This->in_sl_frames) % This->bufsize_frames) * This->fmt->nBlockAlign,
+                    This->period_frames * This->fmt->nBlockAlign);
+            if(sr != SL_RESULT_SUCCESS)
+                WARN("Enqueue failed: 0x%x\n", sr);
+            This->in_sl_frames += This->period_frames;
+        }
+    }
+
+    This->held_frames = 0;
+
+    LeaveCriticalSection(&This->lock);
+
+    return S_OK;
+}
+
+static HRESULT WINAPI AudioClient_SetEventHandle(IAudioClient *iface,
+        HANDLE event)
+{
+    ACImpl *This = impl_from_IAudioClient(iface);
+
+    TRACE("(%p)->(%p)\n", This, event);
+
+    if(!event)
+        return E_INVALIDARG;
+
+    EnterCriticalSection(&This->lock);
+
+    if(!This->initted){
+        LeaveCriticalSection(&This->lock);
+        return AUDCLNT_E_NOT_INITIALIZED;
+    }
+
+    if(!(This->flags & AUDCLNT_STREAMFLAGS_EVENTCALLBACK)){
+        LeaveCriticalSection(&This->lock);
+        return AUDCLNT_E_EVENTHANDLE_NOT_EXPECTED;
+    }
+
+    if (This->event){
+        LeaveCriticalSection(&This->lock);
+        FIXME("called twice\n");
+        return HRESULT_FROM_WIN32(ERROR_INVALID_NAME);
+    }
+
+    This->event = event;
+
+    LeaveCriticalSection(&This->lock);
+
+    return S_OK;
+}
+
+static HRESULT WINAPI AudioClient_GetService(IAudioClient *iface, REFIID riid,
+        void **ppv)
+{
+    ACImpl *This = impl_from_IAudioClient(iface);
+
+    TRACE("(%p)->(%s, %p)\n", This, debugstr_guid(riid), ppv);
+
+    if(!ppv)
+        return E_POINTER;
+    *ppv = NULL;
+
+    EnterCriticalSection(&This->lock);
+
+    if(!This->initted){
+        LeaveCriticalSection(&This->lock);
+        return AUDCLNT_E_NOT_INITIALIZED;
+    }
+
+    if(IsEqualIID(riid, &IID_IAudioRenderClient)){
+        if(This->dataflow != eRender){
+            LeaveCriticalSection(&This->lock);
+            return AUDCLNT_E_WRONG_ENDPOINT_TYPE;
+        }
+        IAudioRenderClient_AddRef(&This->IAudioRenderClient_iface);
+        *ppv = &This->IAudioRenderClient_iface;
+    }else if(IsEqualIID(riid, &IID_IAudioCaptureClient)){
+        if(This->dataflow != eCapture){
+            LeaveCriticalSection(&This->lock);
+            return AUDCLNT_E_WRONG_ENDPOINT_TYPE;
+        }
+        IAudioCaptureClient_AddRef(&This->IAudioCaptureClient_iface);
+        *ppv = &This->IAudioCaptureClient_iface;
+    }else if(IsEqualIID(riid, &IID_IAudioClock)){
+        IAudioClock_AddRef(&This->IAudioClock_iface);
+        *ppv = &This->IAudioClock_iface;
+    }else if(IsEqualIID(riid, &IID_IAudioStreamVolume)){
+        IAudioStreamVolume_AddRef(&This->IAudioStreamVolume_iface);
+        *ppv = &This->IAudioStreamVolume_iface;
+    }else if(IsEqualIID(riid, &IID_IAudioSessionControl)){
+        if(!This->session_wrapper){
+            This->session_wrapper = AudioSessionWrapper_Create(This);
+            if(!This->session_wrapper){
+                LeaveCriticalSection(&This->lock);
+                return E_OUTOFMEMORY;
+            }
+        }else
+            IAudioSessionControl2_AddRef(&This->session_wrapper->IAudioSessionControl2_iface);
+
+        *ppv = &This->session_wrapper->IAudioSessionControl2_iface;
+    }else if(IsEqualIID(riid, &IID_IChannelAudioVolume)){
+        if(!This->session_wrapper){
+            This->session_wrapper = AudioSessionWrapper_Create(This);
+            if(!This->session_wrapper){
+                LeaveCriticalSection(&This->lock);
+                return E_OUTOFMEMORY;
+            }
+        }else
+            IChannelAudioVolume_AddRef(&This->session_wrapper->IChannelAudioVolume_iface);
+
+        *ppv = &This->session_wrapper->IChannelAudioVolume_iface;
+    }else if(IsEqualIID(riid, &IID_ISimpleAudioVolume)){
+        if(!This->session_wrapper){
+            This->session_wrapper = AudioSessionWrapper_Create(This);
+            if(!This->session_wrapper){
+                LeaveCriticalSection(&This->lock);
+                return E_OUTOFMEMORY;
+            }
+        }else
+            ISimpleAudioVolume_AddRef(&This->session_wrapper->ISimpleAudioVolume_iface);
+
+        *ppv = &This->session_wrapper->ISimpleAudioVolume_iface;
+    }
+
+    if(*ppv){
+        LeaveCriticalSection(&This->lock);
+        return S_OK;
+    }
+
+    LeaveCriticalSection(&This->lock);
+
+    FIXME("stub %s\n", debugstr_guid(riid));
+    return E_NOINTERFACE;
+}
+
+static const IAudioClientVtbl AudioClient_Vtbl =
+{
+    AudioClient_QueryInterface,
+    AudioClient_AddRef,
+    AudioClient_Release,
+    AudioClient_Initialize,
+    AudioClient_GetBufferSize,
+    AudioClient_GetStreamLatency,
+    AudioClient_GetCurrentPadding,
+    AudioClient_IsFormatSupported,
+    AudioClient_GetMixFormat,
+    AudioClient_GetDevicePeriod,
+    AudioClient_Start,
+    AudioClient_Stop,
+    AudioClient_Reset,
+    AudioClient_SetEventHandle,
+    AudioClient_GetService
+};
+
+static HRESULT WINAPI AudioRenderClient_QueryInterface(
+        IAudioRenderClient *iface, REFIID riid, void **ppv)
+{
+    ACImpl *This = impl_from_IAudioRenderClient(iface);
+    TRACE("(%p)->(%s, %p)\n", iface, debugstr_guid(riid), ppv);
+
+    if(!ppv)
+        return E_POINTER;
+    *ppv = NULL;
+
+    if(IsEqualIID(riid, &IID_IUnknown) ||
+            IsEqualIID(riid, &IID_IAudioRenderClient))
+        *ppv = iface;
+    else if(IsEqualIID(riid, &IID_IMarshal))
+        return IUnknown_QueryInterface(This->pUnkFTMarshal, riid, ppv);
+    if(*ppv){
+        IUnknown_AddRef((IUnknown*)*ppv);
+        return S_OK;
+    }
+
+    WARN("Unknown interface %s\n", debugstr_guid(riid));
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI AudioRenderClient_AddRef(IAudioRenderClient *iface)
+{
+    ACImpl *This = impl_from_IAudioRenderClient(iface);
+    return AudioClient_AddRef(&This->IAudioClient_iface);
+}
+
+static ULONG WINAPI AudioRenderClient_Release(IAudioRenderClient *iface)
+{
+    ACImpl *This = impl_from_IAudioRenderClient(iface);
+    return AudioClient_Release(&This->IAudioClient_iface);
+}
+
+static HRESULT WINAPI AudioRenderClient_GetBuffer(IAudioRenderClient *iface,
+        UINT32 frames, BYTE **data)
+{
+    ACImpl *This = impl_from_IAudioRenderClient(iface);
+    UINT32 write_pos;
+
+    TRACE("(%p)->(%u, %p)\n", This, frames, data);
+
+    if(!data)
+        return E_POINTER;
+
+    *data = NULL;
+
+    EnterCriticalSection(&This->lock);
+
+    if(This->getbuf_last){
+        LeaveCriticalSection(&This->lock);
+        return AUDCLNT_E_OUT_OF_ORDER;
+    }
+
+    if(!frames){
+        LeaveCriticalSection(&This->lock);
+        return S_OK;
+    }
+
+    if(This->held_frames + frames > This->bufsize_frames){
+        LeaveCriticalSection(&This->lock);
+        return AUDCLNT_E_BUFFER_TOO_LARGE;
+    }
+
+    write_pos =
+        (This->lcl_offs_frames + This->held_frames) % This->bufsize_frames;
+    if(write_pos + frames > This->bufsize_frames){
+        if(This->tmp_buffer_frames < frames){
+            DWORD alloc = frames < This->period_frames ? This->period_frames : frames;
+            HeapFree(GetProcessHeap(), 0, This->tmp_buffer);
+            This->tmp_buffer = HeapAlloc(GetProcessHeap(), 0,
+                    alloc * This->fmt->nBlockAlign);
+            if(!This->tmp_buffer){
+                LeaveCriticalSection(&This->lock);
+                return E_OUTOFMEMORY;
+            }
+            This->tmp_buffer_frames = alloc;
+        }
+        *data = This->tmp_buffer;
+        This->getbuf_last = -frames;
+    }else{
+        *data = This->local_buffer + write_pos * This->fmt->nBlockAlign;
+        This->getbuf_last = frames;
+    }
+
+    silence_buffer(This, *data, frames);
+
+    LeaveCriticalSection(&This->lock);
+
+    return S_OK;
+}
+
+static void oss_wrap_buffer(ACImpl *This, BYTE *buffer, UINT32 written_frames)
+{
+    UINT32 write_offs_frames =
+        (This->lcl_offs_frames + This->held_frames) % This->bufsize_frames;
+    UINT32 write_offs_bytes = write_offs_frames * This->fmt->nBlockAlign;
+    UINT32 chunk_frames = This->bufsize_frames - write_offs_frames;
+    UINT32 chunk_bytes = chunk_frames * This->fmt->nBlockAlign;
+    UINT32 written_bytes = written_frames * This->fmt->nBlockAlign;
+
+    if(written_bytes <= chunk_bytes){
+        memcpy(This->local_buffer + write_offs_bytes, buffer, written_bytes);
+    }else{
+        memcpy(This->local_buffer + write_offs_bytes, buffer, chunk_bytes);
+        memcpy(This->local_buffer, buffer + chunk_bytes,
+                written_bytes - chunk_bytes);
+    }
+}
+
+static HRESULT WINAPI AudioRenderClient_ReleaseBuffer(
+        IAudioRenderClient *iface, UINT32 written_frames, DWORD flags)
+{
+    ACImpl *This = impl_from_IAudioRenderClient(iface);
+    BYTE *buffer;
+
+    TRACE("(%p)->(%u, %x)\n", This, written_frames, flags);
+
+    EnterCriticalSection(&This->lock);
+
+    if(!written_frames){
+        This->getbuf_last = 0;
+        LeaveCriticalSection(&This->lock);
+        return S_OK;
+    }
+
+    if(!This->getbuf_last){
+        LeaveCriticalSection(&This->lock);
+        return AUDCLNT_E_OUT_OF_ORDER;
+    }
+
+    if(written_frames > (This->getbuf_last >= 0 ? This->getbuf_last : -This->getbuf_last)){
+        LeaveCriticalSection(&This->lock);
+        return AUDCLNT_E_INVALID_SIZE;
+    }
+
+    if(This->getbuf_last >= 0)
+        buffer = This->local_buffer + This->fmt->nBlockAlign *
+          ((This->lcl_offs_frames + This->held_frames) % This->bufsize_frames);
+    else
+        buffer = This->tmp_buffer;
+
+    if(flags & AUDCLNT_BUFFERFLAGS_SILENT)
+        silence_buffer(This, buffer, written_frames);
+
+    if(This->getbuf_last < 0)
+        oss_wrap_buffer(This, buffer, written_frames);
+
+    This->held_frames += written_frames;
+    This->written_frames += written_frames;
+    This->getbuf_last = 0;
+
+    LeaveCriticalSection(&This->lock);
+
+    return S_OK;
+}
+
+static const IAudioRenderClientVtbl AudioRenderClient_Vtbl = {
+    AudioRenderClient_QueryInterface,
+    AudioRenderClient_AddRef,
+    AudioRenderClient_Release,
+    AudioRenderClient_GetBuffer,
+    AudioRenderClient_ReleaseBuffer
+};
+
+static HRESULT WINAPI AudioCaptureClient_QueryInterface(
+        IAudioCaptureClient *iface, REFIID riid, void **ppv)
+{
+    ACImpl *This = impl_from_IAudioCaptureClient(iface);
+    TRACE("(%p)->(%s, %p)\n", iface, debugstr_guid(riid), ppv);
+
+    if(!ppv)
+        return E_POINTER;
+    *ppv = NULL;
+
+    if(IsEqualIID(riid, &IID_IUnknown) ||
+            IsEqualIID(riid, &IID_IAudioCaptureClient))
+        *ppv = iface;
+    else if(IsEqualIID(riid, &IID_IMarshal))
+        return IUnknown_QueryInterface(This->pUnkFTMarshal, riid, ppv);
+    if(*ppv){
+        IUnknown_AddRef((IUnknown*)*ppv);
+        return S_OK;
+    }
+
+    WARN("Unknown interface %s\n", debugstr_guid(riid));
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI AudioCaptureClient_AddRef(IAudioCaptureClient *iface)
+{
+    ACImpl *This = impl_from_IAudioCaptureClient(iface);
+    return IAudioClient_AddRef(&This->IAudioClient_iface);
+}
+
+static ULONG WINAPI AudioCaptureClient_Release(IAudioCaptureClient *iface)
+{
+    ACImpl *This = impl_from_IAudioCaptureClient(iface);
+    return IAudioClient_Release(&This->IAudioClient_iface);
+}
+
+static HRESULT WINAPI AudioCaptureClient_GetBuffer(IAudioCaptureClient *iface,
+        BYTE **data, UINT32 *frames, DWORD *flags, UINT64 *devpos,
+        UINT64 *qpcpos)
+{
+    ACImpl *This = impl_from_IAudioCaptureClient(iface);
+
+    TRACE("(%p)->(%p, %p, %p, %p, %p)\n", This, data, frames, flags,
+            devpos, qpcpos);
+
+    if(!data || !frames || !flags)
+        return E_POINTER;
+
+    EnterCriticalSection(&This->lock);
+
+    if(This->getbuf_last){
+        LeaveCriticalSection(&This->lock);
+        return AUDCLNT_E_OUT_OF_ORDER;
+    }
+
+    if(This->held_frames < This->period_frames){
+        *frames = 0;
+        LeaveCriticalSection(&This->lock);
+        return AUDCLNT_S_BUFFER_EMPTY;
+    }
+
+    *flags = 0;
+
+    *frames = This->period_frames;
+
+    if(This->lcl_offs_frames + *frames > This->bufsize_frames){
+        UINT32 chunk_bytes, offs_bytes, frames_bytes;
+        if(This->tmp_buffer_frames < *frames){
+            HeapFree(GetProcessHeap(), 0, This->tmp_buffer);
+            This->tmp_buffer = HeapAlloc(GetProcessHeap(), 0,
+                    *frames * This->fmt->nBlockAlign);
+            if(!This->tmp_buffer){
+                LeaveCriticalSection(&This->lock);
+                return E_OUTOFMEMORY;
+            }
+            This->tmp_buffer_frames = *frames;
+        }
+
+        *data = This->tmp_buffer;
+        chunk_bytes = (This->bufsize_frames - This->lcl_offs_frames) *
+            This->fmt->nBlockAlign;
+        offs_bytes = This->lcl_offs_frames * This->fmt->nBlockAlign;
+        frames_bytes = *frames * This->fmt->nBlockAlign;
+        memcpy(This->tmp_buffer, This->local_buffer + offs_bytes, chunk_bytes);
+        memcpy(This->tmp_buffer + chunk_bytes, This->local_buffer,
+                frames_bytes - chunk_bytes);
+    }else
+        *data = This->local_buffer +
+            This->lcl_offs_frames * This->fmt->nBlockAlign;
+    TRACE("returning %u from %u\n", This->period_frames, This->lcl_offs_frames);
+
+    This->getbuf_last = *frames;
+
+    if(devpos)
+       *devpos = This->written_frames;
+    if(qpcpos){
+        LARGE_INTEGER stamp, freq;
+        QueryPerformanceCounter(&stamp);
+        QueryPerformanceFrequency(&freq);
+        *qpcpos = (stamp.QuadPart * (INT64)10000000) / freq.QuadPart;
+    }
+
+    LeaveCriticalSection(&This->lock);
+
+    return *frames ? S_OK : AUDCLNT_S_BUFFER_EMPTY;
+}
+
+static HRESULT WINAPI AudioCaptureClient_ReleaseBuffer(
+        IAudioCaptureClient *iface, UINT32 done)
+{
+    ACImpl *This = impl_from_IAudioCaptureClient(iface);
+
+    TRACE("(%p)->(%u)\n", This, done);
+
+    EnterCriticalSection(&This->lock);
+
+    if(!done){
+        This->getbuf_last = 0;
+        LeaveCriticalSection(&This->lock);
+        return S_OK;
+    }
+
+    if(!This->getbuf_last){
+        LeaveCriticalSection(&This->lock);
+        return AUDCLNT_E_OUT_OF_ORDER;
+    }
+
+    if(This->getbuf_last != done){
+        LeaveCriticalSection(&This->lock);
+        return AUDCLNT_E_INVALID_SIZE;
+    }
+
+    This->written_frames += done;
+    This->held_frames -= done;
+    This->lcl_offs_frames += done;
+    This->lcl_offs_frames %= This->bufsize_frames;
+    This->getbuf_last = 0;
+    TRACE("lcl: %u, held: %u\n", This->lcl_offs_frames, This->held_frames);
+
+    LeaveCriticalSection(&This->lock);
+
+    return S_OK;
+}
+
+static HRESULT WINAPI AudioCaptureClient_GetNextPacketSize(
+        IAudioCaptureClient *iface, UINT32 *frames)
+{
+    ACImpl *This = impl_from_IAudioCaptureClient(iface);
+
+    TRACE("(%p)->(%p)\n", This, frames);
+
+    if(!frames)
+        return E_POINTER;
+
+    EnterCriticalSection(&This->lock);
+
+    *frames = This->held_frames < This->period_frames ? 0 : This->period_frames;
+
+    LeaveCriticalSection(&This->lock);
+
+    return S_OK;
+}
+
+static const IAudioCaptureClientVtbl AudioCaptureClient_Vtbl =
+{
+    AudioCaptureClient_QueryInterface,
+    AudioCaptureClient_AddRef,
+    AudioCaptureClient_Release,
+    AudioCaptureClient_GetBuffer,
+    AudioCaptureClient_ReleaseBuffer,
+    AudioCaptureClient_GetNextPacketSize
+};
+
+static HRESULT WINAPI AudioClock_QueryInterface(IAudioClock *iface,
+        REFIID riid, void **ppv)
+{
+    ACImpl *This = impl_from_IAudioClock(iface);
+
+    TRACE("(%p)->(%s, %p)\n", iface, debugstr_guid(riid), ppv);
+
+    if(!ppv)
+        return E_POINTER;
+    *ppv = NULL;
+
+    if(IsEqualIID(riid, &IID_IUnknown) || IsEqualIID(riid, &IID_IAudioClock))
+        *ppv = iface;
+    else if(IsEqualIID(riid, &IID_IAudioClock2))
+        *ppv = &This->IAudioClock2_iface;
+    if(*ppv){
+        IUnknown_AddRef((IUnknown*)*ppv);
+        return S_OK;
+    }
+
+    WARN("Unknown interface %s\n", debugstr_guid(riid));
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI AudioClock_AddRef(IAudioClock *iface)
+{
+    ACImpl *This = impl_from_IAudioClock(iface);
+    return IAudioClient_AddRef(&This->IAudioClient_iface);
+}
+
+static ULONG WINAPI AudioClock_Release(IAudioClock *iface)
+{
+    ACImpl *This = impl_from_IAudioClock(iface);
+    return IAudioClient_Release(&This->IAudioClient_iface);
+}
+
+static HRESULT WINAPI AudioClock_GetFrequency(IAudioClock *iface, UINT64 *freq)
+{
+    ACImpl *This = impl_from_IAudioClock(iface);
+
+    TRACE("(%p)->(%p)\n", This, freq);
+
+    if(This->share == AUDCLNT_SHAREMODE_SHARED)
+        *freq = (UINT64)This->fmt->nSamplesPerSec * This->fmt->nBlockAlign;
+    else
+        *freq = This->fmt->nSamplesPerSec;
+
+    return S_OK;
+}
+
+static HRESULT WINAPI AudioClock_GetPosition(IAudioClock *iface, UINT64 *pos,
+        UINT64 *qpctime)
+{
+    ACImpl *This = impl_from_IAudioClock(iface);
+
+    TRACE("(%p)->(%p, %p)\n", This, pos, qpctime);
+
+    if(!pos)
+        return E_POINTER;
+
+    EnterCriticalSection(&This->lock);
+
+    if(This->dataflow == eRender){
+        *pos = This->written_frames - This->held_frames;
+        if(*pos < This->last_pos_frames)
+            *pos = This->last_pos_frames;
+    }else if(This->dataflow == eCapture){
+        *pos = This->written_frames - This->held_frames;
+    }
+
+    This->last_pos_frames = *pos;
+
+    TRACE("returning: 0x%s\n", wine_dbgstr_longlong(*pos));
+    if(This->share == AUDCLNT_SHAREMODE_SHARED)
+        *pos *= This->fmt->nBlockAlign;
+
+    LeaveCriticalSection(&This->lock);
+
+    if(qpctime){
+        LARGE_INTEGER stamp, freq;
+        QueryPerformanceCounter(&stamp);
+        QueryPerformanceFrequency(&freq);
+        *qpctime = (stamp.QuadPart * (INT64)10000000) / freq.QuadPart;
+    }
+
+    return S_OK;
+}
+
+static HRESULT WINAPI AudioClock_GetCharacteristics(IAudioClock *iface,
+        DWORD *chars)
+{
+    ACImpl *This = impl_from_IAudioClock(iface);
+
+    TRACE("(%p)->(%p)\n", This, chars);
+
+    if(!chars)
+        return E_POINTER;
+
+    *chars = AUDIOCLOCK_CHARACTERISTIC_FIXED_FREQ;
+
+    return S_OK;
+}
+
+static const IAudioClockVtbl AudioClock_Vtbl =
+{
+    AudioClock_QueryInterface,
+    AudioClock_AddRef,
+    AudioClock_Release,
+    AudioClock_GetFrequency,
+    AudioClock_GetPosition,
+    AudioClock_GetCharacteristics
+};
+
+static HRESULT WINAPI AudioClock2_QueryInterface(IAudioClock2 *iface,
+        REFIID riid, void **ppv)
+{
+    ACImpl *This = impl_from_IAudioClock2(iface);
+    return IAudioClock_QueryInterface(&This->IAudioClock_iface, riid, ppv);
+}
+
+static ULONG WINAPI AudioClock2_AddRef(IAudioClock2 *iface)
+{
+    ACImpl *This = impl_from_IAudioClock2(iface);
+    return IAudioClient_AddRef(&This->IAudioClient_iface);
+}
+
+static ULONG WINAPI AudioClock2_Release(IAudioClock2 *iface)
+{
+    ACImpl *This = impl_from_IAudioClock2(iface);
+    return IAudioClient_Release(&This->IAudioClient_iface);
+}
+
+static HRESULT WINAPI AudioClock2_GetDevicePosition(IAudioClock2 *iface,
+        UINT64 *pos, UINT64 *qpctime)
+{
+    ACImpl *This = impl_from_IAudioClock2(iface);
+
+    FIXME("(%p)->(%p, %p)\n", This, pos, qpctime);
+
+    return E_NOTIMPL;
+}
+
+static const IAudioClock2Vtbl AudioClock2_Vtbl =
+{
+    AudioClock2_QueryInterface,
+    AudioClock2_AddRef,
+    AudioClock2_Release,
+    AudioClock2_GetDevicePosition
+};
+
+static AudioSessionWrapper *AudioSessionWrapper_Create(ACImpl *client)
+{
+    AudioSessionWrapper *ret;
+
+    ret = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY,
+            sizeof(AudioSessionWrapper));
+    if(!ret)
+        return NULL;
+
+    ret->IAudioSessionControl2_iface.lpVtbl = &AudioSessionControl2_Vtbl;
+    ret->ISimpleAudioVolume_iface.lpVtbl = &SimpleAudioVolume_Vtbl;
+    ret->IChannelAudioVolume_iface.lpVtbl = &ChannelAudioVolume_Vtbl;
+
+    ret->ref = 1;
+
+    ret->client = client;
+    if(client){
+        ret->session = client->session;
+        AudioClient_AddRef(&client->IAudioClient_iface);
+    }
+
+    return ret;
+}
+
+static HRESULT WINAPI AudioSessionControl_QueryInterface(
+        IAudioSessionControl2 *iface, REFIID riid, void **ppv)
+{
+    TRACE("(%p)->(%s, %p)\n", iface, debugstr_guid(riid), ppv);
+
+    if(!ppv)
+        return E_POINTER;
+    *ppv = NULL;
+
+    if(IsEqualIID(riid, &IID_IUnknown) ||
+            IsEqualIID(riid, &IID_IAudioSessionControl) ||
+            IsEqualIID(riid, &IID_IAudioSessionControl2))
+        *ppv = iface;
+    if(*ppv){
+        IUnknown_AddRef((IUnknown*)*ppv);
+        return S_OK;
+    }
+
+    WARN("Unknown interface %s\n", debugstr_guid(riid));
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI AudioSessionControl_AddRef(IAudioSessionControl2 *iface)
+{
+    AudioSessionWrapper *This = impl_from_IAudioSessionControl2(iface);
+    ULONG ref;
+    ref = InterlockedIncrement(&This->ref);
+    TRACE("(%p) Refcount now %u\n", This, ref);
+    return ref;
+}
+
+static ULONG WINAPI AudioSessionControl_Release(IAudioSessionControl2 *iface)
+{
+    AudioSessionWrapper *This = impl_from_IAudioSessionControl2(iface);
+    ULONG ref;
+    ref = InterlockedDecrement(&This->ref);
+    TRACE("(%p) Refcount now %u\n", This, ref);
+    if(!ref){
+        if(This->client){
+            EnterCriticalSection(&This->client->lock);
+            This->client->session_wrapper = NULL;
+            LeaveCriticalSection(&This->client->lock);
+            AudioClient_Release(&This->client->IAudioClient_iface);
+        }
+        HeapFree(GetProcessHeap(), 0, This);
+    }
+    return ref;
+}
+
+static HRESULT WINAPI AudioSessionControl_GetState(IAudioSessionControl2 *iface,
+        AudioSessionState *state)
+{
+    AudioSessionWrapper *This = impl_from_IAudioSessionControl2(iface);
+    ACImpl *client;
+
+    TRACE("(%p)->(%p)\n", This, state);
+
+    if(!state)
+        return NULL_PTR_ERR;
+
+    EnterCriticalSection(&g_sessions_lock);
+
+    if(list_empty(&This->session->clients)){
+        *state = AudioSessionStateExpired;
+        LeaveCriticalSection(&g_sessions_lock);
+        return S_OK;
+    }
+
+    LIST_FOR_EACH_ENTRY(client, &This->session->clients, ACImpl, entry){
+        EnterCriticalSection(&client->lock);
+        if(client->playing){
+            *state = AudioSessionStateActive;
+            LeaveCriticalSection(&client->lock);
+            LeaveCriticalSection(&g_sessions_lock);
+            return S_OK;
+        }
+        LeaveCriticalSection(&client->lock);
+    }
+
+    LeaveCriticalSection(&g_sessions_lock);
+
+    *state = AudioSessionStateInactive;
+
+    return S_OK;
+}
+
+static HRESULT WINAPI AudioSessionControl_GetDisplayName(
+        IAudioSessionControl2 *iface, WCHAR **name)
+{
+    AudioSessionWrapper *This = impl_from_IAudioSessionControl2(iface);
+
+    FIXME("(%p)->(%p) - stub\n", This, name);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI AudioSessionControl_SetDisplayName(
+        IAudioSessionControl2 *iface, const WCHAR *name, const GUID *session)
+{
+    AudioSessionWrapper *This = impl_from_IAudioSessionControl2(iface);
+
+    FIXME("(%p)->(%p, %s) - stub\n", This, name, debugstr_guid(session));
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI AudioSessionControl_GetIconPath(
+        IAudioSessionControl2 *iface, WCHAR **path)
+{
+    AudioSessionWrapper *This = impl_from_IAudioSessionControl2(iface);
+
+    FIXME("(%p)->(%p) - stub\n", This, path);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI AudioSessionControl_SetIconPath(
+        IAudioSessionControl2 *iface, const WCHAR *path, const GUID *session)
+{
+    AudioSessionWrapper *This = impl_from_IAudioSessionControl2(iface);
+
+    FIXME("(%p)->(%p, %s) - stub\n", This, path, debugstr_guid(session));
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI AudioSessionControl_GetGroupingParam(
+        IAudioSessionControl2 *iface, GUID *group)
+{
+    AudioSessionWrapper *This = impl_from_IAudioSessionControl2(iface);
+
+    FIXME("(%p)->(%p) - stub\n", This, group);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI AudioSessionControl_SetGroupingParam(
+        IAudioSessionControl2 *iface, const GUID *group, const GUID *session)
+{
+    AudioSessionWrapper *This = impl_from_IAudioSessionControl2(iface);
+
+    FIXME("(%p)->(%s, %s) - stub\n", This, debugstr_guid(group),
+            debugstr_guid(session));
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI AudioSessionControl_RegisterAudioSessionNotification(
+        IAudioSessionControl2 *iface, IAudioSessionEvents *events)
+{
+    AudioSessionWrapper *This = impl_from_IAudioSessionControl2(iface);
+
+    FIXME("(%p)->(%p) - stub\n", This, events);
+
+    return S_OK;
+}
+
+static HRESULT WINAPI AudioSessionControl_UnregisterAudioSessionNotification(
+        IAudioSessionControl2 *iface, IAudioSessionEvents *events)
+{
+    AudioSessionWrapper *This = impl_from_IAudioSessionControl2(iface);
+
+    FIXME("(%p)->(%p) - stub\n", This, events);
+
+    return S_OK;
+}
+
+static HRESULT WINAPI AudioSessionControl_GetSessionIdentifier(
+        IAudioSessionControl2 *iface, WCHAR **id)
+{
+    AudioSessionWrapper *This = impl_from_IAudioSessionControl2(iface);
+
+    FIXME("(%p)->(%p) - stub\n", This, id);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI AudioSessionControl_GetSessionInstanceIdentifier(
+        IAudioSessionControl2 *iface, WCHAR **id)
+{
+    AudioSessionWrapper *This = impl_from_IAudioSessionControl2(iface);
+
+    FIXME("(%p)->(%p) - stub\n", This, id);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI AudioSessionControl_GetProcessId(
+        IAudioSessionControl2 *iface, DWORD *pid)
+{
+    AudioSessionWrapper *This = impl_from_IAudioSessionControl2(iface);
+
+    TRACE("(%p)->(%p)\n", This, pid);
+
+    if(!pid)
+        return E_POINTER;
+
+    *pid = GetCurrentProcessId();
+
+    return S_OK;
+}
+
+static HRESULT WINAPI AudioSessionControl_IsSystemSoundsSession(
+        IAudioSessionControl2 *iface)
+{
+    AudioSessionWrapper *This = impl_from_IAudioSessionControl2(iface);
+
+    TRACE("(%p)\n", This);
+
+    return S_FALSE;
+}
+
+static HRESULT WINAPI AudioSessionControl_SetDuckingPreference(
+        IAudioSessionControl2 *iface, BOOL optout)
+{
+    AudioSessionWrapper *This = impl_from_IAudioSessionControl2(iface);
+
+    TRACE("(%p)->(%d)\n", This, optout);
+
+    return S_OK;
+}
+
+static const IAudioSessionControl2Vtbl AudioSessionControl2_Vtbl =
+{
+    AudioSessionControl_QueryInterface,
+    AudioSessionControl_AddRef,
+    AudioSessionControl_Release,
+    AudioSessionControl_GetState,
+    AudioSessionControl_GetDisplayName,
+    AudioSessionControl_SetDisplayName,
+    AudioSessionControl_GetIconPath,
+    AudioSessionControl_SetIconPath,
+    AudioSessionControl_GetGroupingParam,
+    AudioSessionControl_SetGroupingParam,
+    AudioSessionControl_RegisterAudioSessionNotification,
+    AudioSessionControl_UnregisterAudioSessionNotification,
+    AudioSessionControl_GetSessionIdentifier,
+    AudioSessionControl_GetSessionInstanceIdentifier,
+    AudioSessionControl_GetProcessId,
+    AudioSessionControl_IsSystemSoundsSession,
+    AudioSessionControl_SetDuckingPreference
+};
+
+static HRESULT WINAPI SimpleAudioVolume_QueryInterface(
+        ISimpleAudioVolume *iface, REFIID riid, void **ppv)
+{
+    TRACE("(%p)->(%s, %p)\n", iface, debugstr_guid(riid), ppv);
+
+    if(!ppv)
+        return E_POINTER;
+    *ppv = NULL;
+
+    if(IsEqualIID(riid, &IID_IUnknown) ||
+            IsEqualIID(riid, &IID_ISimpleAudioVolume))
+        *ppv = iface;
+    if(*ppv){
+        IUnknown_AddRef((IUnknown*)*ppv);
+        return S_OK;
+    }
+
+    WARN("Unknown interface %s\n", debugstr_guid(riid));
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI SimpleAudioVolume_AddRef(ISimpleAudioVolume *iface)
+{
+    AudioSessionWrapper *This = impl_from_ISimpleAudioVolume(iface);
+    return AudioSessionControl_AddRef(&This->IAudioSessionControl2_iface);
+}
+
+static ULONG WINAPI SimpleAudioVolume_Release(ISimpleAudioVolume *iface)
+{
+    AudioSessionWrapper *This = impl_from_ISimpleAudioVolume(iface);
+    return AudioSessionControl_Release(&This->IAudioSessionControl2_iface);
+}
+
+static HRESULT WINAPI SimpleAudioVolume_SetMasterVolume(
+        ISimpleAudioVolume *iface, float level, const GUID *context)
+{
+    AudioSessionWrapper *This = impl_from_ISimpleAudioVolume(iface);
+    AudioSession *session = This->session;
+
+    TRACE("(%p)->(%f, %s)\n", session, level, wine_dbgstr_guid(context));
+
+    if(level < 0.f || level > 1.f)
+        return E_INVALIDARG;
+
+    if(context)
+        FIXME("Notifications not supported yet\n");
+
+    EnterCriticalSection(&session->lock);
+
+    session->master_vol = level;
+
+    TRACE("OSS doesn't support setting volume\n");
+
+    LeaveCriticalSection(&session->lock);
+
+    return S_OK;
+}
+
+static HRESULT WINAPI SimpleAudioVolume_GetMasterVolume(
+        ISimpleAudioVolume *iface, float *level)
+{
+    AudioSessionWrapper *This = impl_from_ISimpleAudioVolume(iface);
+    AudioSession *session = This->session;
+
+    TRACE("(%p)->(%p)\n", session, level);
+
+    if(!level)
+        return NULL_PTR_ERR;
+
+    *level = session->master_vol;
+
+    return S_OK;
+}
+
+static HRESULT WINAPI SimpleAudioVolume_SetMute(ISimpleAudioVolume *iface,
+        BOOL mute, const GUID *context)
+{
+    AudioSessionWrapper *This = impl_from_ISimpleAudioVolume(iface);
+    AudioSession *session = This->session;
+
+    TRACE("(%p)->(%u, %p)\n", session, mute, context);
+
+    EnterCriticalSection(&session->lock);
+
+    session->mute = mute;
+
+    LeaveCriticalSection(&session->lock);
+
+    return S_OK;
+}
+
+static HRESULT WINAPI SimpleAudioVolume_GetMute(ISimpleAudioVolume *iface,
+        BOOL *mute)
+{
+    AudioSessionWrapper *This = impl_from_ISimpleAudioVolume(iface);
+    AudioSession *session = This->session;
+
+    TRACE("(%p)->(%p)\n", session, mute);
+
+    if(!mute)
+        return NULL_PTR_ERR;
+
+    *mute = This->session->mute;
+
+    return S_OK;
+}
+
+static const ISimpleAudioVolumeVtbl SimpleAudioVolume_Vtbl  =
+{
+    SimpleAudioVolume_QueryInterface,
+    SimpleAudioVolume_AddRef,
+    SimpleAudioVolume_Release,
+    SimpleAudioVolume_SetMasterVolume,
+    SimpleAudioVolume_GetMasterVolume,
+    SimpleAudioVolume_SetMute,
+    SimpleAudioVolume_GetMute
+};
+
+static HRESULT WINAPI AudioStreamVolume_QueryInterface(
+        IAudioStreamVolume *iface, REFIID riid, void **ppv)
+{
+    TRACE("(%p)->(%s, %p)\n", iface, debugstr_guid(riid), ppv);
+
+    if(!ppv)
+        return E_POINTER;
+    *ppv = NULL;
+
+    if(IsEqualIID(riid, &IID_IUnknown) ||
+            IsEqualIID(riid, &IID_IAudioStreamVolume))
+        *ppv = iface;
+    if(*ppv){
+        IUnknown_AddRef((IUnknown*)*ppv);
+        return S_OK;
+    }
+
+    WARN("Unknown interface %s\n", debugstr_guid(riid));
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI AudioStreamVolume_AddRef(IAudioStreamVolume *iface)
+{
+    ACImpl *This = impl_from_IAudioStreamVolume(iface);
+    return IAudioClient_AddRef(&This->IAudioClient_iface);
+}
+
+static ULONG WINAPI AudioStreamVolume_Release(IAudioStreamVolume *iface)
+{
+    ACImpl *This = impl_from_IAudioStreamVolume(iface);
+    return IAudioClient_Release(&This->IAudioClient_iface);
+}
+
+static HRESULT WINAPI AudioStreamVolume_GetChannelCount(
+        IAudioStreamVolume *iface, UINT32 *out)
+{
+    ACImpl *This = impl_from_IAudioStreamVolume(iface);
+
+    TRACE("(%p)->(%p)\n", This, out);
+
+    if(!out)
+        return E_POINTER;
+
+    *out = This->fmt->nChannels;
+
+    return S_OK;
+}
+
+static HRESULT WINAPI AudioStreamVolume_SetChannelVolume(
+        IAudioStreamVolume *iface, UINT32 index, float level)
+{
+    ACImpl *This = impl_from_IAudioStreamVolume(iface);
+
+    TRACE("(%p)->(%d, %f)\n", This, index, level);
+
+    if(level < 0.f || level > 1.f)
+        return E_INVALIDARG;
+
+    if(index >= This->fmt->nChannels)
+        return E_INVALIDARG;
+
+    EnterCriticalSection(&This->lock);
+
+    This->vols[index] = level;
+
+    TRACE("OSS doesn't support setting volume\n");
+
+    LeaveCriticalSection(&This->lock);
+
+    return S_OK;
+}
+
+static HRESULT WINAPI AudioStreamVolume_GetChannelVolume(
+        IAudioStreamVolume *iface, UINT32 index, float *level)
+{
+    ACImpl *This = impl_from_IAudioStreamVolume(iface);
+
+    TRACE("(%p)->(%d, %p)\n", This, index, level);
+
+    if(!level)
+        return E_POINTER;
+
+    if(index >= This->fmt->nChannels)
+        return E_INVALIDARG;
+
+    *level = This->vols[index];
+
+    return S_OK;
+}
+
+static HRESULT WINAPI AudioStreamVolume_SetAllVolumes(
+        IAudioStreamVolume *iface, UINT32 count, const float *levels)
+{
+    ACImpl *This = impl_from_IAudioStreamVolume(iface);
+    int i;
+
+    TRACE("(%p)->(%d, %p)\n", This, count, levels);
+
+    if(!levels)
+        return E_POINTER;
+
+    if(count != This->fmt->nChannels)
+        return E_INVALIDARG;
+
+    EnterCriticalSection(&This->lock);
+
+    for(i = 0; i < count; ++i)
+        This->vols[i] = levels[i];
+
+    TRACE("OSS doesn't support setting volume\n");
+
+    LeaveCriticalSection(&This->lock);
+
+    return S_OK;
+}
+
+static HRESULT WINAPI AudioStreamVolume_GetAllVolumes(
+        IAudioStreamVolume *iface, UINT32 count, float *levels)
+{
+    ACImpl *This = impl_from_IAudioStreamVolume(iface);
+    int i;
+
+    TRACE("(%p)->(%d, %p)\n", This, count, levels);
+
+    if(!levels)
+        return E_POINTER;
+
+    if(count != This->fmt->nChannels)
+        return E_INVALIDARG;
+
+    EnterCriticalSection(&This->lock);
+
+    for(i = 0; i < count; ++i)
+        levels[i] = This->vols[i];
+
+    LeaveCriticalSection(&This->lock);
+
+    return S_OK;
+}
+
+static const IAudioStreamVolumeVtbl AudioStreamVolume_Vtbl =
+{
+    AudioStreamVolume_QueryInterface,
+    AudioStreamVolume_AddRef,
+    AudioStreamVolume_Release,
+    AudioStreamVolume_GetChannelCount,
+    AudioStreamVolume_SetChannelVolume,
+    AudioStreamVolume_GetChannelVolume,
+    AudioStreamVolume_SetAllVolumes,
+    AudioStreamVolume_GetAllVolumes
+};
+
+static HRESULT WINAPI ChannelAudioVolume_QueryInterface(
+        IChannelAudioVolume *iface, REFIID riid, void **ppv)
+{
+    TRACE("(%p)->(%s, %p)\n", iface, debugstr_guid(riid), ppv);
+
+    if(!ppv)
+        return E_POINTER;
+    *ppv = NULL;
+
+    if(IsEqualIID(riid, &IID_IUnknown) ||
+            IsEqualIID(riid, &IID_IChannelAudioVolume))
+        *ppv = iface;
+    if(*ppv){
+        IUnknown_AddRef((IUnknown*)*ppv);
+        return S_OK;
+    }
+
+    WARN("Unknown interface %s\n", debugstr_guid(riid));
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI ChannelAudioVolume_AddRef(IChannelAudioVolume *iface)
+{
+    AudioSessionWrapper *This = impl_from_IChannelAudioVolume(iface);
+    return AudioSessionControl_AddRef(&This->IAudioSessionControl2_iface);
+}
+
+static ULONG WINAPI ChannelAudioVolume_Release(IChannelAudioVolume *iface)
+{
+    AudioSessionWrapper *This = impl_from_IChannelAudioVolume(iface);
+    return AudioSessionControl_Release(&This->IAudioSessionControl2_iface);
+}
+
+static HRESULT WINAPI ChannelAudioVolume_GetChannelCount(
+        IChannelAudioVolume *iface, UINT32 *out)
+{
+    AudioSessionWrapper *This = impl_from_IChannelAudioVolume(iface);
+    AudioSession *session = This->session;
+
+    TRACE("(%p)->(%p)\n", session, out);
+
+    if(!out)
+        return NULL_PTR_ERR;
+
+    *out = session->channel_count;
+
+    return S_OK;
+}
+
+static HRESULT WINAPI ChannelAudioVolume_SetChannelVolume(
+        IChannelAudioVolume *iface, UINT32 index, float level,
+        const GUID *context)
+{
+    AudioSessionWrapper *This = impl_from_IChannelAudioVolume(iface);
+    AudioSession *session = This->session;
+
+    TRACE("(%p)->(%d, %f, %s)\n", session, index, level,
+            wine_dbgstr_guid(context));
+
+    if(level < 0.f || level > 1.f)
+        return E_INVALIDARG;
+
+    if(index >= session->channel_count)
+        return E_INVALIDARG;
+
+    if(context)
+        FIXME("Notifications not supported yet\n");
+
+    EnterCriticalSection(&session->lock);
+
+    session->channel_vols[index] = level;
+
+    TRACE("OSS doesn't support setting volume\n");
+
+    LeaveCriticalSection(&session->lock);
+
+    return S_OK;
+}
+
+static HRESULT WINAPI ChannelAudioVolume_GetChannelVolume(
+        IChannelAudioVolume *iface, UINT32 index, float *level)
+{
+    AudioSessionWrapper *This = impl_from_IChannelAudioVolume(iface);
+    AudioSession *session = This->session;
+
+    TRACE("(%p)->(%d, %p)\n", session, index, level);
+
+    if(!level)
+        return NULL_PTR_ERR;
+
+    if(index >= session->channel_count)
+        return E_INVALIDARG;
+
+    *level = session->channel_vols[index];
+
+    return S_OK;
+}
+
+static HRESULT WINAPI ChannelAudioVolume_SetAllVolumes(
+        IChannelAudioVolume *iface, UINT32 count, const float *levels,
+        const GUID *context)
+{
+    AudioSessionWrapper *This = impl_from_IChannelAudioVolume(iface);
+    AudioSession *session = This->session;
+    int i;
+
+    TRACE("(%p)->(%d, %p, %s)\n", session, count, levels,
+            wine_dbgstr_guid(context));
+
+    if(!levels)
+        return NULL_PTR_ERR;
+
+    if(count != session->channel_count)
+        return E_INVALIDARG;
+
+    if(context)
+        FIXME("Notifications not supported yet\n");
+
+    EnterCriticalSection(&session->lock);
+
+    for(i = 0; i < count; ++i)
+        session->channel_vols[i] = levels[i];
+
+    TRACE("OSS doesn't support setting volume\n");
+
+    LeaveCriticalSection(&session->lock);
+
+    return S_OK;
+}
+
+static HRESULT WINAPI ChannelAudioVolume_GetAllVolumes(
+        IChannelAudioVolume *iface, UINT32 count, float *levels)
+{
+    AudioSessionWrapper *This = impl_from_IChannelAudioVolume(iface);
+    AudioSession *session = This->session;
+    int i;
+
+    TRACE("(%p)->(%d, %p)\n", session, count, levels);
+
+    if(!levels)
+        return NULL_PTR_ERR;
+
+    if(count != session->channel_count)
+        return E_INVALIDARG;
+
+    for(i = 0; i < count; ++i)
+        levels[i] = session->channel_vols[i];
+
+    return S_OK;
+}
+
+static const IChannelAudioVolumeVtbl ChannelAudioVolume_Vtbl =
+{
+    ChannelAudioVolume_QueryInterface,
+    ChannelAudioVolume_AddRef,
+    ChannelAudioVolume_Release,
+    ChannelAudioVolume_GetChannelCount,
+    ChannelAudioVolume_SetChannelVolume,
+    ChannelAudioVolume_GetChannelVolume,
+    ChannelAudioVolume_SetAllVolumes,
+    ChannelAudioVolume_GetAllVolumes
+};
+
+static HRESULT WINAPI AudioSessionManager_QueryInterface(IAudioSessionManager2 *iface,
+        REFIID riid, void **ppv)
+{
+    TRACE("(%p)->(%s, %p)\n", iface, debugstr_guid(riid), ppv);
+
+    if(!ppv)
+        return E_POINTER;
+    *ppv = NULL;
+
+    if(IsEqualIID(riid, &IID_IUnknown) ||
+            IsEqualIID(riid, &IID_IAudioSessionManager) ||
+            IsEqualIID(riid, &IID_IAudioSessionManager2))
+        *ppv = iface;
+    if(*ppv){
+        IUnknown_AddRef((IUnknown*)*ppv);
+        return S_OK;
+    }
+
+    WARN("Unknown interface %s\n", debugstr_guid(riid));
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI AudioSessionManager_AddRef(IAudioSessionManager2 *iface)
+{
+    SessionMgr *This = impl_from_IAudioSessionManager2(iface);
+    ULONG ref;
+    ref = InterlockedIncrement(&This->ref);
+    TRACE("(%p) Refcount now %u\n", This, ref);
+    return ref;
+}
+
+static ULONG WINAPI AudioSessionManager_Release(IAudioSessionManager2 *iface)
+{
+    SessionMgr *This = impl_from_IAudioSessionManager2(iface);
+    ULONG ref;
+    ref = InterlockedDecrement(&This->ref);
+    TRACE("(%p) Refcount now %u\n", This, ref);
+    if(!ref)
+        HeapFree(GetProcessHeap(), 0, This);
+    return ref;
+}
+
+static HRESULT WINAPI AudioSessionManager_GetAudioSessionControl(
+        IAudioSessionManager2 *iface, const GUID *session_guid, DWORD flags,
+        IAudioSessionControl **out)
+{
+    SessionMgr *This = impl_from_IAudioSessionManager2(iface);
+    AudioSession *session;
+    AudioSessionWrapper *wrapper;
+    HRESULT hr;
+
+    TRACE("(%p)->(%s, %x, %p)\n", This, debugstr_guid(session_guid),
+            flags, out);
+
+    hr = get_audio_session(session_guid, This->device, 0, &session);
+    if(FAILED(hr))
+        return hr;
+
+    wrapper = AudioSessionWrapper_Create(NULL);
+    if(!wrapper)
+        return E_OUTOFMEMORY;
+
+    wrapper->session = session;
+
+    *out = (IAudioSessionControl*)&wrapper->IAudioSessionControl2_iface;
+
+    return S_OK;
+}
+
+static HRESULT WINAPI AudioSessionManager_GetSimpleAudioVolume(
+        IAudioSessionManager2 *iface, const GUID *session_guid, DWORD flags,
+        ISimpleAudioVolume **out)
+{
+    SessionMgr *This = impl_from_IAudioSessionManager2(iface);
+    AudioSession *session;
+    AudioSessionWrapper *wrapper;
+    HRESULT hr;
+
+    TRACE("(%p)->(%s, %x, %p)\n", This, debugstr_guid(session_guid),
+            flags, out);
+
+    hr = get_audio_session(session_guid, This->device, 0, &session);
+    if(FAILED(hr))
+        return hr;
+
+    wrapper = AudioSessionWrapper_Create(NULL);
+    if(!wrapper)
+        return E_OUTOFMEMORY;
+
+    wrapper->session = session;
+
+    *out = &wrapper->ISimpleAudioVolume_iface;
+
+    return S_OK;
+}
+
+static HRESULT WINAPI AudioSessionManager_GetSessionEnumerator(
+        IAudioSessionManager2 *iface, IAudioSessionEnumerator **out)
+{
+    SessionMgr *This = impl_from_IAudioSessionManager2(iface);
+    FIXME("(%p)->(%p) - stub\n", This, out);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI AudioSessionManager_RegisterSessionNotification(
+        IAudioSessionManager2 *iface, IAudioSessionNotification *notification)
+{
+    SessionMgr *This = impl_from_IAudioSessionManager2(iface);
+    FIXME("(%p)->(%p) - stub\n", This, notification);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI AudioSessionManager_UnregisterSessionNotification(
+        IAudioSessionManager2 *iface, IAudioSessionNotification *notification)
+{
+    SessionMgr *This = impl_from_IAudioSessionManager2(iface);
+    FIXME("(%p)->(%p) - stub\n", This, notification);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI AudioSessionManager_RegisterDuckNotification(
+        IAudioSessionManager2 *iface, const WCHAR *session_id,
+        IAudioVolumeDuckNotification *notification)
+{
+    SessionMgr *This = impl_from_IAudioSessionManager2(iface);
+    FIXME("(%p)->(%p) - stub\n", This, notification);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI AudioSessionManager_UnregisterDuckNotification(
+        IAudioSessionManager2 *iface,
+        IAudioVolumeDuckNotification *notification)
+{
+    SessionMgr *This = impl_from_IAudioSessionManager2(iface);
+    FIXME("(%p)->(%p) - stub\n", This, notification);
+    return E_NOTIMPL;
+}
+
+static const IAudioSessionManager2Vtbl AudioSessionManager2_Vtbl =
+{
+    AudioSessionManager_QueryInterface,
+    AudioSessionManager_AddRef,
+    AudioSessionManager_Release,
+    AudioSessionManager_GetAudioSessionControl,
+    AudioSessionManager_GetSimpleAudioVolume,
+    AudioSessionManager_GetSessionEnumerator,
+    AudioSessionManager_RegisterSessionNotification,
+    AudioSessionManager_UnregisterSessionNotification,
+    AudioSessionManager_RegisterDuckNotification,
+    AudioSessionManager_UnregisterDuckNotification
+};
+
+HRESULT WINAPI AUDDRV_GetAudioSessionManager(IMMDevice *device,
+        IAudioSessionManager2 **out)
+{
+    SessionMgr *This;
+
+    This = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(SessionMgr));
+    if(!This)
+        return E_OUTOFMEMORY;
+
+    This->IAudioSessionManager2_iface.lpVtbl = &AudioSessionManager2_Vtbl;
+    This->device = device;
+    This->ref = 1;
+
+    *out = &This->IAudioSessionManager2_iface;
+
+    return S_OK;
+}
diff -Naur wine-2.0a/dlls/wineandroid.drv/opengl.c wine-2.0b/dlls/wineandroid.drv/opengl.c
--- wine-2.0a/dlls/wineandroid.drv/opengl.c	1970-01-01 01:00:00.000000000 +0100
+++ wine-2.0b/dlls/wineandroid.drv/opengl.c	2017-07-11 20:37:51.000000000 +0100
@@ -0,0 +1,883 @@
+/*
+ * X11DRV OpenGL functions
+ *
+ * Copyright 2000 Lionel Ulmer
+ * Copyright 2005 Alex Woods
+ * Copyright 2005 Raphael Junqueira
+ * Copyright 2006-2009 Roderick Colenbrander
+ * Copyright 2006 Tomas Carnecky
+ * Copyright 2013 Matteo Bruni
+ * Copyright 2012, 2013, 2014 Alexandre Julliard
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include "config.h"
+#include "wine/port.h"
+
+#include <assert.h>
+#include <stdarg.h>
+#include <stdlib.h>
+#include <string.h>
+#include <EGL/egl.h>
+#include <EGL/eglext.h>
+
+#include "android.h"
+#include "winternl.h"
+
+#define GLAPIENTRY /* nothing */
+#include "wine/wgl.h"
+#undef GLAPIENTRY
+#include "wine/wgl_driver.h"
+#include "wine/wglext.h"
+#include "wine/library.h"
+#include "wine/debug.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(android);
+
+#define SONAME_LIBEGL "libEGL.so"
+#define SONAME_LIBGLES "libGLESv2.so"
+
+#define DECL_FUNCPTR(f) typeof(f) * p_##f = NULL
+DECL_FUNCPTR( eglCreateContext );
+DECL_FUNCPTR( eglCreateWindowSurface );
+DECL_FUNCPTR( eglDestroyContext );
+DECL_FUNCPTR( eglDestroySurface );
+DECL_FUNCPTR( eglGetConfigAttrib );
+DECL_FUNCPTR( eglGetConfigs );
+DECL_FUNCPTR( eglGetDisplay );
+DECL_FUNCPTR( eglGetProcAddress );
+DECL_FUNCPTR( eglInitialize );
+DECL_FUNCPTR( eglMakeCurrent );
+DECL_FUNCPTR( eglSwapBuffers );
+DECL_FUNCPTR( eglSwapInterval );
+#undef DECL_FUNCPTR
+
+static const int egl_client_version = 2;
+
+struct wgl_pixel_format
+{
+    EGLConfig config;
+};
+
+struct wgl_context
+{
+    EGLConfig  config;
+    EGLContext context;
+    EGLSurface surface;
+};
+
+struct gl_drawable
+{
+    struct list     entry;
+    HWND            hwnd;
+    HDC             hdc;
+    int             format;
+    ANativeWindow  *window;
+    EGLSurface      surface;
+};
+
+static void *egl_handle;
+static void *opengl_handle;
+static struct wgl_pixel_format *pixel_formats;
+static int nb_pixel_formats, nb_onscreen_formats;
+static EGLDisplay display;
+static int swap_interval;
+static char wgl_extensions[4096];
+static struct opengl_funcs egl_funcs;
+
+static struct list gl_drawables = LIST_INIT( gl_drawables );
+
+static CRITICAL_SECTION drawable_section;
+static CRITICAL_SECTION_DEBUG critsect_debug =
+{
+    0, 0, &drawable_section,
+    { &critsect_debug.ProcessLocksList, &critsect_debug.ProcessLocksList },
+      0, 0, { (DWORD_PTR)(__FILE__ ": drawable_section") }
+};
+static CRITICAL_SECTION drawable_section = { &critsect_debug, -1, 0, 0, 0, 0 };
+
+static inline BOOL is_valid_pixel_format( int format )
+{
+    return format > 0 && format <= nb_pixel_formats;
+}
+
+static inline BOOL is_onscreen_pixel_format( int format )
+{
+    return format > 0 && format <= nb_onscreen_formats;
+}
+
+static struct gl_drawable *create_gl_drawable( HWND hwnd, HDC hdc, int format )
+{
+    struct gl_drawable *gl = HeapAlloc( GetProcessHeap(), 0, sizeof(*gl) );
+    gl->hwnd   = hwnd;
+    gl->hdc    = hdc;
+    gl->format = format;
+    gl->window = get_ioctl_window( hwnd );
+    gl->surface = p_eglCreateWindowSurface( display, pixel_formats[format - 1].config, gl->window, NULL );
+    if (gl->surface == EGL_NO_SURFACE) ERR("Failed to create EGL surface.\n");
+    EnterCriticalSection( &drawable_section );
+    list_add_head( &gl_drawables, &gl->entry );
+    return gl;
+}
+
+static struct gl_drawable *get_gl_drawable( HWND hwnd, HDC hdc )
+{
+    struct gl_drawable *gl;
+
+    EnterCriticalSection( &drawable_section );
+    LIST_FOR_EACH_ENTRY( gl, &gl_drawables, struct gl_drawable, entry )
+    {
+        if (hwnd && gl->hwnd == hwnd) return gl;
+        if (hdc && gl->hdc == hdc) return gl;
+    }
+    LeaveCriticalSection( &drawable_section );
+    return NULL;
+}
+
+static void release_gl_drawable( struct gl_drawable *gl )
+{
+    if (gl) LeaveCriticalSection( &drawable_section );
+}
+
+void destroy_gl_drawable( HWND hwnd )
+{
+    struct gl_drawable *gl;
+
+    EnterCriticalSection( &drawable_section );
+    LIST_FOR_EACH_ENTRY( gl, &gl_drawables, struct gl_drawable, entry )
+    {
+        if (gl->hwnd != hwnd) continue;
+        list_remove( &gl->entry );
+        p_eglDestroySurface( display, gl->surface );
+        release_ioctl_window( gl->window );
+        HeapFree( GetProcessHeap(), 0, gl );
+        break;
+    }
+    LeaveCriticalSection( &drawable_section );
+}
+
+static BOOL set_pixel_format( HDC hdc, int format, BOOL allow_change )
+{
+    struct gl_drawable *gl;
+    HWND hwnd = WindowFromDC( hdc );
+    int prev = 0;
+
+    if (!hwnd || hwnd == GetDesktopWindow())
+    {
+        WARN( "not a proper window DC %p/%p\n", hdc, hwnd );
+        return FALSE;
+    }
+    if (!is_onscreen_pixel_format( format ))
+    {
+        WARN( "Invalid format %d\n", format );
+        return FALSE;
+    }
+    TRACE( "%p/%p format %d\n", hdc, hwnd, format );
+
+    if ((gl = get_gl_drawable( hwnd, 0 )))
+    {
+        prev = gl->format;
+        if (allow_change)
+        {
+            EGLint pf;
+            p_eglGetConfigAttrib( display, pixel_formats[format - 1].config, EGL_NATIVE_VISUAL_ID, &pf );
+            gl->window->perform( gl->window, NATIVE_WINDOW_SET_BUFFERS_FORMAT, pf );
+            gl->format = format;
+        }
+    }
+    else gl = create_gl_drawable( hwnd, 0, format );
+
+    release_gl_drawable( gl );
+
+    if (prev && prev != format && !allow_change) return FALSE;
+    if (__wine_set_pixel_format( hwnd, format )) return TRUE;
+    destroy_gl_drawable( hwnd );
+    return FALSE;
+}
+
+static struct wgl_context *create_context( HDC hdc, struct wgl_context *share, const int *attribs )
+{
+    struct gl_drawable *gl;
+    struct wgl_context *ctx;
+
+    if (!(gl = get_gl_drawable( WindowFromDC( hdc ), hdc ))) return NULL;
+
+    ctx = HeapAlloc( GetProcessHeap(), 0, sizeof(*ctx) );
+
+    ctx->config  = pixel_formats[gl->format - 1].config;
+    ctx->surface = 0;
+    ctx->context = p_eglCreateContext( display, ctx->config,
+                                       share ? share->context : EGL_NO_CONTEXT, attribs );
+    TRACE( "%p fmt %d ctx %p\n", hdc, gl->format, ctx->context );
+    release_gl_drawable( gl );
+    return ctx;
+}
+
+static void dump_PIXELFORMATDESCRIPTOR(const PIXELFORMATDESCRIPTOR *ppfd)
+{
+    TRACE("  - size / version : %d / %d\n", ppfd->nSize, ppfd->nVersion);
+    TRACE("  - dwFlags : ");
+#define TEST_AND_DUMP(t,tv) if ((t) & (tv)) TRACE(#tv " ")
+    TEST_AND_DUMP(ppfd->dwFlags, PFD_DEPTH_DONTCARE);
+    TEST_AND_DUMP(ppfd->dwFlags, PFD_DOUBLEBUFFER);
+    TEST_AND_DUMP(ppfd->dwFlags, PFD_DOUBLEBUFFER_DONTCARE);
+    TEST_AND_DUMP(ppfd->dwFlags, PFD_DRAW_TO_WINDOW);
+    TEST_AND_DUMP(ppfd->dwFlags, PFD_DRAW_TO_BITMAP);
+    TEST_AND_DUMP(ppfd->dwFlags, PFD_GENERIC_ACCELERATED);
+    TEST_AND_DUMP(ppfd->dwFlags, PFD_GENERIC_FORMAT);
+    TEST_AND_DUMP(ppfd->dwFlags, PFD_NEED_PALETTE);
+    TEST_AND_DUMP(ppfd->dwFlags, PFD_NEED_SYSTEM_PALETTE);
+    TEST_AND_DUMP(ppfd->dwFlags, PFD_STEREO);
+    TEST_AND_DUMP(ppfd->dwFlags, PFD_STEREO_DONTCARE);
+    TEST_AND_DUMP(ppfd->dwFlags, PFD_SUPPORT_GDI);
+    TEST_AND_DUMP(ppfd->dwFlags, PFD_SUPPORT_OPENGL);
+    TEST_AND_DUMP(ppfd->dwFlags, PFD_SWAP_COPY);
+    TEST_AND_DUMP(ppfd->dwFlags, PFD_SWAP_EXCHANGE);
+    TEST_AND_DUMP(ppfd->dwFlags, PFD_SWAP_LAYER_BUFFERS);
+    /* PFD_SUPPORT_COMPOSITION is new in Vista, it is similar to composition
+     * under X e.g. COMPOSITE + GLX_EXT_TEXTURE_FROM_PIXMAP. */
+    TEST_AND_DUMP(ppfd->dwFlags, PFD_SUPPORT_COMPOSITION);
+#undef TEST_AND_DUMP
+    TRACE("\n");
+
+    TRACE("  - iPixelType : ");
+    switch (ppfd->iPixelType) {
+    case PFD_TYPE_RGBA: TRACE("PFD_TYPE_RGBA"); break;
+    case PFD_TYPE_COLORINDEX: TRACE("PFD_TYPE_COLORINDEX"); break;
+    }
+    TRACE("\n");
+
+    TRACE("  - Color   : %d\n", ppfd->cColorBits);
+    TRACE("  - Red     : %d\n", ppfd->cRedBits);
+    TRACE("  - Green   : %d\n", ppfd->cGreenBits);
+    TRACE("  - Blue    : %d\n", ppfd->cBlueBits);
+    TRACE("  - Alpha   : %d\n", ppfd->cAlphaBits);
+    TRACE("  - Accum   : %d\n", ppfd->cAccumBits);
+    TRACE("  - Depth   : %d\n", ppfd->cDepthBits);
+    TRACE("  - Stencil : %d\n", ppfd->cStencilBits);
+    TRACE("  - Aux     : %d\n", ppfd->cAuxBuffers);
+
+    TRACE("  - iLayerType : ");
+    switch (ppfd->iLayerType) {
+    case PFD_MAIN_PLANE: TRACE("PFD_MAIN_PLANE"); break;
+    case PFD_OVERLAY_PLANE: TRACE("PFD_OVERLAY_PLANE"); break;
+    case (BYTE)PFD_UNDERLAY_PLANE: TRACE("PFD_UNDERLAY_PLANE"); break;
+    }
+    TRACE("\n");
+}
+
+/***********************************************************************
+ *		android_wglGetExtensionsStringARB
+ */
+static const char *android_wglGetExtensionsStringARB( HDC hdc )
+{
+    TRACE( "() returning \"%s\"\n", wgl_extensions );
+    return wgl_extensions;
+}
+
+/***********************************************************************
+ *		android_wglGetExtensionsStringEXT
+ */
+static const char *android_wglGetExtensionsStringEXT(void)
+{
+    TRACE( "() returning \"%s\"\n", wgl_extensions );
+    return wgl_extensions;
+}
+
+/***********************************************************************
+ *		android_wglCreateContextAttribsARB
+ */
+static struct wgl_context *android_wglCreateContextAttribsARB( HDC hdc, struct wgl_context *share,
+                                                               const int *attribs )
+{
+    int count = 0, egl_attribs[3];
+    BOOL opengl_es = FALSE;
+
+    while (attribs && *attribs && count < 2)
+    {
+        switch (*attribs)
+        {
+        case WGL_CONTEXT_PROFILE_MASK_ARB:
+            if (attribs[1] == WGL_CONTEXT_ES2_PROFILE_BIT_EXT)
+                opengl_es = TRUE;
+            break;
+        case WGL_CONTEXT_MAJOR_VERSION_ARB:
+            egl_attribs[count++] = EGL_CONTEXT_CLIENT_VERSION;
+            egl_attribs[count++] = attribs[1];
+            break;
+        default:
+            FIXME("Unhandled attributes: %#x %#x\n", attribs[0], attribs[1]);
+        }
+        attribs += 2;
+    }
+    if (!opengl_es)
+    {
+        WARN("Requested creation of an OpenGL (non ES) context, that's not supported.\n");
+        return NULL;
+    }
+    if (!count)  /* FIXME: force version if not specified */
+    {
+        egl_attribs[count++] = EGL_CONTEXT_CLIENT_VERSION;
+        egl_attribs[count++] = egl_client_version;
+    }
+    egl_attribs[count] = EGL_NONE;
+
+    return create_context( hdc, share, egl_attribs );
+}
+
+/***********************************************************************
+ *		android_wglMakeContextCurrentARB
+ */
+static BOOL android_wglMakeContextCurrentARB( HDC draw_hdc, HDC read_hdc, struct wgl_context *ctx )
+{
+    BOOL ret = FALSE;
+    struct gl_drawable *draw_gl, *read_gl = NULL;
+
+    TRACE( "%p %p %p\n", draw_hdc, read_hdc, ctx );
+
+    if (!ctx)
+    {
+        p_eglMakeCurrent( display, EGL_NO_SURFACE, EGL_NO_SURFACE, EGL_NO_CONTEXT );
+        NtCurrentTeb()->glContext = NULL;
+        return TRUE;
+    }
+
+    if ((draw_gl = get_gl_drawable( WindowFromDC( draw_hdc ), draw_hdc )))
+    {
+        read_gl = get_gl_drawable( WindowFromDC( read_hdc ), read_hdc );
+        TRACE( "%p/%p context %p surface %p/%p\n",
+               draw_hdc, read_hdc, ctx->context, draw_gl->surface, read_gl->surface );
+        ret = p_eglMakeCurrent( display, draw_gl->surface, read_gl->surface, ctx->context );
+        if (ret)
+        {
+            ctx->surface = draw_gl->surface;
+            NtCurrentTeb()->glContext = ctx;
+            goto done;
+        }
+    }
+    SetLastError( ERROR_INVALID_HANDLE );
+
+done:
+    release_gl_drawable( read_gl );
+    release_gl_drawable( draw_gl );
+    return ret;
+}
+
+/***********************************************************************
+ *		android_wglSwapIntervalEXT
+ */
+static BOOL android_wglSwapIntervalEXT( int interval )
+{
+    BOOL ret = TRUE;
+
+    TRACE("(%d)\n", interval);
+
+    if (interval < 0)
+    {
+        SetLastError(ERROR_INVALID_DATA);
+        return FALSE;
+    }
+
+    ret = p_eglSwapInterval( display, interval );
+
+    if (ret)
+        swap_interval = interval;
+    else
+        SetLastError( ERROR_DC_NOT_FOUND );
+
+    return ret;
+}
+
+/***********************************************************************
+ *		android_wglGetSwapIntervalEXT
+ */
+static int android_wglGetSwapIntervalEXT(void)
+{
+    return swap_interval;
+}
+
+/***********************************************************************
+ *		android_wglSetPixelFormatWINE
+ */
+static BOOL android_wglSetPixelFormatWINE( HDC hdc, int format )
+{
+    return set_pixel_format( hdc, format, TRUE );
+}
+
+/***********************************************************************
+ *		android_wglCopyContext
+ */
+static BOOL android_wglCopyContext( struct wgl_context *src, struct wgl_context *dst, UINT mask )
+{
+    FIXME( "%p -> %p mask %#x unsupported\n", src, dst, mask );
+    return FALSE;
+}
+
+/***********************************************************************
+ *		android_wglCreateContext
+ */
+static struct wgl_context *android_wglCreateContext( HDC hdc )
+{
+    int egl_attribs[3] = { EGL_CONTEXT_CLIENT_VERSION, egl_client_version, EGL_NONE };
+
+    return create_context( hdc, NULL, egl_attribs );
+}
+
+/***********************************************************************
+ *		android_wglDeleteContext
+ */
+static void android_wglDeleteContext( struct wgl_context *ctx )
+{
+    p_eglDestroyContext( display, ctx->context );
+    HeapFree( GetProcessHeap(), 0, ctx );
+}
+
+/***********************************************************************
+ *		android_wglDescribePixelFormat
+ */
+static int android_wglDescribePixelFormat( HDC hdc, int fmt, UINT size, PIXELFORMATDESCRIPTOR *pfd )
+{
+    EGLint val;
+    EGLConfig config;
+
+    if (!pfd) return nb_onscreen_formats;
+    if (!is_onscreen_pixel_format( fmt )) return 0;
+    if (size < sizeof(*pfd)) return 0;
+    config = pixel_formats[fmt - 1].config;
+
+    memset( pfd, 0, sizeof(*pfd) );
+    pfd->nSize = sizeof(*pfd);
+    pfd->nVersion = 1;
+    pfd->dwFlags = PFD_SUPPORT_OPENGL | PFD_DRAW_TO_WINDOW | PFD_DOUBLEBUFFER;
+    pfd->iPixelType = PFD_TYPE_RGBA;
+    pfd->iLayerType = PFD_MAIN_PLANE;
+
+    p_eglGetConfigAttrib( display, config, EGL_BUFFER_SIZE, &val );
+    pfd->cColorBits = val;
+    p_eglGetConfigAttrib( display, config, EGL_RED_SIZE, &val );
+    pfd->cRedBits = val;
+    p_eglGetConfigAttrib( display, config, EGL_GREEN_SIZE, &val );
+    pfd->cGreenBits = val;
+    p_eglGetConfigAttrib( display, config, EGL_BLUE_SIZE, &val );
+    pfd->cBlueBits = val;
+    p_eglGetConfigAttrib( display, config, EGL_ALPHA_SIZE, &val );
+    pfd->cAlphaBits = val;
+    p_eglGetConfigAttrib( display, config, EGL_DEPTH_SIZE, &val );
+    pfd->cDepthBits = val;
+    p_eglGetConfigAttrib( display, config, EGL_STENCIL_SIZE, &val );
+    pfd->cStencilBits = val;
+
+    pfd->cAlphaShift = 0;
+    pfd->cBlueShift = pfd->cAlphaShift + pfd->cAlphaBits;
+    pfd->cGreenShift = pfd->cBlueShift + pfd->cBlueBits;
+    pfd->cRedShift = pfd->cGreenShift + pfd->cGreenBits;
+
+    dump_PIXELFORMATDESCRIPTOR( pfd );
+    return nb_onscreen_formats;
+}
+
+/***********************************************************************
+ *		android_wglGetPixelFormat
+ */
+static int android_wglGetPixelFormat( HDC hdc )
+{
+    struct gl_drawable *gl;
+    int ret = 0;
+
+    if ((gl = get_gl_drawable( WindowFromDC( hdc ), hdc )))
+    {
+        ret = gl->format;
+        /* offscreen formats can't be used with traditional WGL calls */
+        if (!is_onscreen_pixel_format( ret )) ret = 1;
+        release_gl_drawable( gl );
+    }
+    return ret;
+}
+
+/***********************************************************************
+ *		android_wglGetProcAddress
+ */
+static PROC android_wglGetProcAddress( LPCSTR name )
+{
+    PROC ret;
+    if (!strncmp( name, "wgl", 3 )) return NULL;
+    ret = (PROC)p_eglGetProcAddress( name );
+    TRACE( "%s -> %p\n", name, ret );
+    return ret;
+}
+
+/***********************************************************************
+ *		android_wglMakeCurrent
+ */
+static BOOL android_wglMakeCurrent( HDC hdc, struct wgl_context *ctx )
+{
+    BOOL ret = FALSE;
+    struct gl_drawable *gl;
+
+    TRACE( "%p %p\n", hdc, ctx );
+
+    if (!ctx)
+    {
+        p_eglMakeCurrent( display, EGL_NO_SURFACE, EGL_NO_SURFACE, EGL_NO_CONTEXT );
+        NtCurrentTeb()->glContext = NULL;
+        return TRUE;
+    }
+
+    if ((gl = get_gl_drawable( WindowFromDC( hdc ), hdc )))
+    {
+        TRACE( "%p context %p surface %p\n", hdc, ctx->context, gl->surface );
+        ret = p_eglMakeCurrent( display, gl->surface, gl->surface, ctx->context );
+        if (ret)
+        {
+            ctx->surface = gl->surface;
+            NtCurrentTeb()->glContext = ctx;
+            goto done;
+        }
+    }
+    SetLastError( ERROR_INVALID_HANDLE );
+
+done:
+    release_gl_drawable( gl );
+    return ret;
+}
+
+/***********************************************************************
+ *		android_wglSetPixelFormat
+ */
+static BOOL android_wglSetPixelFormat( HDC hdc, int format, const PIXELFORMATDESCRIPTOR *pfd )
+{
+    return set_pixel_format( hdc, format, FALSE );
+}
+
+/***********************************************************************
+ *		android_wglShareLists
+ */
+static BOOL android_wglShareLists( struct wgl_context *org, struct wgl_context *dest )
+{
+    FIXME( "%p %p\n", org, dest );
+    return FALSE;
+}
+
+/***********************************************************************
+ *		android_wglSwapBuffers
+ */
+static BOOL android_wglSwapBuffers( HDC hdc )
+{
+    struct wgl_context *ctx = NtCurrentTeb()->glContext;
+
+    TRACE( "%p context %p surface %p\n", hdc, ctx->context, ctx->surface );
+    if (ctx) p_eglSwapBuffers( display, ctx->surface );
+    return TRUE;
+}
+
+static void register_extension( const char *ext )
+{
+    if (wgl_extensions[0]) strcat( wgl_extensions, " " );
+    strcat( wgl_extensions, ext );
+    TRACE( "%s\n", ext );
+}
+
+static void init_extensions(void)
+{
+    void *ptr;
+
+    register_extension("WGL_ARB_create_context");
+    register_extension("WGL_ARB_create_context_profile");
+    egl_funcs.ext.p_wglCreateContextAttribsARB = android_wglCreateContextAttribsARB;
+
+    register_extension("WGL_ARB_extensions_string");
+    egl_funcs.ext.p_wglGetExtensionsStringARB = android_wglGetExtensionsStringARB;
+
+    register_extension("WGL_ARB_make_current_read");
+    egl_funcs.ext.p_wglGetCurrentReadDCARB   = (void *)1;  /* never called */
+    egl_funcs.ext.p_wglMakeContextCurrentARB = android_wglMakeContextCurrentARB;
+
+#if 0  /* FIXME */
+    register_extension("WGL_ARB_pbuffer");
+    egl_funcs.ext.p_wglCreatePbufferARB    = android_wglCreatePbufferARB;
+    egl_funcs.ext.p_wglDestroyPbufferARB   = android_wglDestroyPbufferARB;
+    egl_funcs.ext.p_wglGetPbufferDCARB     = android_wglGetPbufferDCARB;
+    egl_funcs.ext.p_wglQueryPbufferARB     = android_wglQueryPbufferARB;
+    egl_funcs.ext.p_wglReleasePbufferDCARB = android_wglReleasePbufferDCARB;
+    egl_funcs.ext.p_wglSetPbufferAttribARB = android_wglSetPbufferAttribARB;
+#endif
+
+#if 0  /* FIXME */
+    register_extension("WGL_ARB_pixel_format");
+    egl_funcs.ext.p_wglChoosePixelFormatARB      = android_wglChoosePixelFormatARB;
+    egl_funcs.ext.p_wglGetPixelFormatAttribfvARB = android_wglGetPixelFormatAttribfvARB;
+    egl_funcs.ext.p_wglGetPixelFormatAttribivARB = android_wglGetPixelFormatAttribivARB;
+#endif
+
+    /* EXT Extensions */
+
+    register_extension("WGL_EXT_extensions_string");
+    egl_funcs.ext.p_wglGetExtensionsStringEXT = android_wglGetExtensionsStringEXT;
+
+    register_extension("WGL_EXT_swap_control");
+    egl_funcs.ext.p_wglSwapIntervalEXT = android_wglSwapIntervalEXT;
+    egl_funcs.ext.p_wglGetSwapIntervalEXT = android_wglGetSwapIntervalEXT;
+
+    register_extension("WGL_EXT_framebuffer_sRGB");
+
+    /* WINE-specific WGL Extensions */
+
+    /* In WineD3D we need the ability to set the pixel format more than once (e.g. after a device reset).
+     * The default wglSetPixelFormat doesn't allow this, so add our own which allows it.
+     */
+    register_extension("WGL_WINE_pixel_format_passthrough");
+    egl_funcs.ext.p_wglSetPixelFormatWINE = android_wglSetPixelFormatWINE;
+
+    /* standard functions available through eglGetProcAddress */
+
+#define USE_GL_FUNC(func) if ((ptr = p_eglGetProcAddress( #func ))) egl_funcs.gl.p_##func = ptr;
+    ALL_WGL_FUNCS
+#undef USE_GL_FUNC
+
+    /* extensions exported from the OpenGL library */
+
+#define LOAD_FUNCPTR(func) egl_funcs.ext.p_##func = wine_dlsym( opengl_handle, #func, NULL, 0 )
+    LOAD_FUNCPTR( glActiveTexture );
+    LOAD_FUNCPTR( glAttachShader );
+    LOAD_FUNCPTR( glBindAttribLocation );
+    LOAD_FUNCPTR( glBindBuffer );
+    LOAD_FUNCPTR( glBindFramebuffer );
+    LOAD_FUNCPTR( glBindRenderbuffer );
+    LOAD_FUNCPTR( glBlendColor );
+    LOAD_FUNCPTR( glBlendEquation );
+    LOAD_FUNCPTR( glBlendEquationSeparate );
+    LOAD_FUNCPTR( glBlendFuncSeparate );
+    LOAD_FUNCPTR( glBufferData );
+    LOAD_FUNCPTR( glBufferSubData );
+    LOAD_FUNCPTR( glCheckFramebufferStatus );
+    LOAD_FUNCPTR( glClearDepthf );
+    LOAD_FUNCPTR( glCompileShader );
+    LOAD_FUNCPTR( glCompressedTexImage2D );
+    LOAD_FUNCPTR( glCompressedTexSubImage2D );
+    LOAD_FUNCPTR( glCreateProgram );
+    LOAD_FUNCPTR( glCreateShader );
+    LOAD_FUNCPTR( glDeleteBuffers );
+    LOAD_FUNCPTR( glDeleteFramebuffers );
+    LOAD_FUNCPTR( glDeleteProgram );
+    LOAD_FUNCPTR( glDeleteRenderbuffers );
+    LOAD_FUNCPTR( glDeleteShader );
+    LOAD_FUNCPTR( glDepthRangef );
+    LOAD_FUNCPTR( glDetachShader );
+    LOAD_FUNCPTR( glDisableVertexAttribArray );
+    LOAD_FUNCPTR( glEnableVertexAttribArray );
+    LOAD_FUNCPTR( glFramebufferRenderbuffer );
+    LOAD_FUNCPTR( glFramebufferTexture2D );
+    LOAD_FUNCPTR( glGenBuffers );
+    LOAD_FUNCPTR( glGenFramebuffers );
+    LOAD_FUNCPTR( glGenRenderbuffers );
+    LOAD_FUNCPTR( glGenerateMipmap );
+    LOAD_FUNCPTR( glGetActiveAttrib );
+    LOAD_FUNCPTR( glGetActiveUniform );
+    LOAD_FUNCPTR( glGetAttachedShaders );
+    LOAD_FUNCPTR( glGetAttribLocation );
+    LOAD_FUNCPTR( glGetBufferParameteriv );
+    LOAD_FUNCPTR( glGetFramebufferAttachmentParameteriv );
+    LOAD_FUNCPTR( glGetProgramInfoLog );
+    LOAD_FUNCPTR( glGetProgramiv );
+    LOAD_FUNCPTR( glGetRenderbufferParameteriv );
+    LOAD_FUNCPTR( glGetShaderInfoLog );
+    LOAD_FUNCPTR( glGetShaderPrecisionFormat );
+    LOAD_FUNCPTR( glGetShaderSource );
+    LOAD_FUNCPTR( glGetShaderiv );
+    LOAD_FUNCPTR( glGetUniformLocation );
+    LOAD_FUNCPTR( glGetUniformfv );
+    LOAD_FUNCPTR( glGetUniformiv );
+    LOAD_FUNCPTR( glGetVertexAttribPointerv );
+    LOAD_FUNCPTR( glGetVertexAttribfv );
+    LOAD_FUNCPTR( glGetVertexAttribiv );
+    LOAD_FUNCPTR( glIsBuffer );
+    LOAD_FUNCPTR( glIsFramebuffer );
+    LOAD_FUNCPTR( glIsProgram );
+    LOAD_FUNCPTR( glIsRenderbuffer );
+    LOAD_FUNCPTR( glIsShader );
+    LOAD_FUNCPTR( glLinkProgram );
+    LOAD_FUNCPTR( glReleaseShaderCompiler );
+    LOAD_FUNCPTR( glRenderbufferStorage );
+    LOAD_FUNCPTR( glSampleCoverage );
+    LOAD_FUNCPTR( glShaderBinary );
+    LOAD_FUNCPTR( glShaderSource );
+    LOAD_FUNCPTR( glStencilFuncSeparate );
+    LOAD_FUNCPTR( glStencilMaskSeparate );
+    LOAD_FUNCPTR( glStencilOpSeparate );
+    LOAD_FUNCPTR( glUniform1f );
+    LOAD_FUNCPTR( glUniform1fv );
+    LOAD_FUNCPTR( glUniform1i );
+    LOAD_FUNCPTR( glUniform1iv );
+    LOAD_FUNCPTR( glUniform2f );
+    LOAD_FUNCPTR( glUniform2fv );
+    LOAD_FUNCPTR( glUniform2i );
+    LOAD_FUNCPTR( glUniform2iv );
+    LOAD_FUNCPTR( glUniform3f );
+    LOAD_FUNCPTR( glUniform3fv );
+    LOAD_FUNCPTR( glUniform3i );
+    LOAD_FUNCPTR( glUniform3iv );
+    LOAD_FUNCPTR( glUniform4f );
+    LOAD_FUNCPTR( glUniform4fv );
+    LOAD_FUNCPTR( glUniform4i );
+    LOAD_FUNCPTR( glUniform4iv );
+    LOAD_FUNCPTR( glUniformMatrix2fv );
+    LOAD_FUNCPTR( glUniformMatrix3fv );
+    LOAD_FUNCPTR( glUniformMatrix4fv );
+    LOAD_FUNCPTR( glUseProgram );
+    LOAD_FUNCPTR( glValidateProgram );
+    LOAD_FUNCPTR( glVertexAttrib1f );
+    LOAD_FUNCPTR( glVertexAttrib1fv );
+    LOAD_FUNCPTR( glVertexAttrib2f );
+    LOAD_FUNCPTR( glVertexAttrib2fv );
+    LOAD_FUNCPTR( glVertexAttrib3f );
+    LOAD_FUNCPTR( glVertexAttrib3fv );
+    LOAD_FUNCPTR( glVertexAttrib4f );
+    LOAD_FUNCPTR( glVertexAttrib4fv );
+    LOAD_FUNCPTR( glVertexAttribPointer );
+#undef LOAD_FUNCPTR
+}
+
+static BOOL egl_init(void)
+{
+    static int retval = -1;
+    EGLConfig *configs;
+    EGLint major, minor, count, i, pass;
+    char buffer[200];
+
+    if (retval != -1) return retval;
+    retval = 0;
+
+    if (!(egl_handle = wine_dlopen( SONAME_LIBEGL, RTLD_NOW|RTLD_GLOBAL, buffer, sizeof(buffer) )))
+    {
+        ERR( "failed to load %s: %s\n", SONAME_LIBEGL, buffer );
+        return FALSE;
+    }
+    if (!(opengl_handle = wine_dlopen( SONAME_LIBGLES, RTLD_NOW|RTLD_GLOBAL, buffer, sizeof(buffer) )))
+    {
+        ERR( "failed to load %s: %s\n", SONAME_LIBGLES, buffer );
+        return FALSE;
+    }
+
+#define LOAD_FUNCPTR(func) do { \
+        if (!(p_##func = wine_dlsym( egl_handle, #func, NULL, 0 ))) \
+        { ERR( "can't find symbol %s\n", #func); return FALSE; }    \
+    } while(0)
+    LOAD_FUNCPTR( eglCreateContext );
+    LOAD_FUNCPTR( eglCreateWindowSurface );
+    LOAD_FUNCPTR( eglDestroyContext );
+    LOAD_FUNCPTR( eglDestroySurface );
+    LOAD_FUNCPTR( eglGetConfigAttrib );
+    LOAD_FUNCPTR( eglGetConfigs );
+    LOAD_FUNCPTR( eglGetDisplay );
+    LOAD_FUNCPTR( eglGetProcAddress );
+    LOAD_FUNCPTR( eglInitialize );
+    LOAD_FUNCPTR( eglMakeCurrent );
+    LOAD_FUNCPTR( eglSwapBuffers );
+    LOAD_FUNCPTR( eglSwapInterval );
+#undef LOAD_FUNCPTR
+
+    display = p_eglGetDisplay( EGL_DEFAULT_DISPLAY );
+    if (!p_eglInitialize( display, &major, &minor )) return 0;
+    TRACE( "display %p version %u.%u\n", display, major, minor );
+
+    p_eglGetConfigs( display, NULL, 0, &count );
+    configs = HeapAlloc( GetProcessHeap(), 0, count * sizeof(*configs) );
+    pixel_formats = HeapAlloc( GetProcessHeap(), 0, count * sizeof(*pixel_formats) );
+    p_eglGetConfigs( display, configs, count, &count );
+    if (!count || !configs || !pixel_formats)
+    {
+        HeapFree( GetProcessHeap(), 0, configs );
+        HeapFree( GetProcessHeap(), 0, pixel_formats );
+        ERR( "eglGetConfigs returned no configs\n" );
+        return 0;
+    }
+
+    for (pass = 0; pass < 2; pass++)
+    {
+        for (i = 0; i < count; i++)
+        {
+            EGLint id, type, visual_id, native, render, color, r, g, b, d, s;
+
+            p_eglGetConfigAttrib( display, configs[i], EGL_SURFACE_TYPE, &type );
+            if (!(type & EGL_WINDOW_BIT) == !pass) continue;
+            p_eglGetConfigAttrib( display, configs[i], EGL_RENDERABLE_TYPE, &render );
+            if (egl_client_version == 2 && !(render & EGL_OPENGL_ES2_BIT)) continue;
+
+            pixel_formats[nb_pixel_formats++].config = configs[i];
+
+            p_eglGetConfigAttrib( display, configs[i], EGL_CONFIG_ID, &id );
+            p_eglGetConfigAttrib( display, configs[i], EGL_NATIVE_VISUAL_ID, &visual_id );
+            p_eglGetConfigAttrib( display, configs[i], EGL_NATIVE_RENDERABLE, &native );
+            p_eglGetConfigAttrib( display, configs[i], EGL_COLOR_BUFFER_TYPE, &color );
+            p_eglGetConfigAttrib( display, configs[i], EGL_RED_SIZE, &r );
+            p_eglGetConfigAttrib( display, configs[i], EGL_GREEN_SIZE, &g );
+            p_eglGetConfigAttrib( display, configs[i], EGL_BLUE_SIZE, &b );
+            p_eglGetConfigAttrib( display, configs[i], EGL_DEPTH_SIZE, &d );
+            p_eglGetConfigAttrib( display, configs[i], EGL_STENCIL_SIZE, &s );
+            TRACE( "%u: config %u id %u type %x visual %u native %u render %x colortype %u rgb %u,%u,%u depth %u stencil %u\n",
+                   nb_pixel_formats, i, id, type, visual_id, native, render, color, r, g, b, d, s );
+        }
+        if (!pass) nb_onscreen_formats = nb_pixel_formats;
+    }
+
+    init_extensions();
+    retval = 1;
+    return TRUE;
+}
+
+
+/* generate stubs for GL functions that are not exported on Android */
+
+#define USE_GL_FUNC(name) \
+static void glstub_##name(void) \
+{ \
+    ERR( #name " called\n" ); \
+    assert( 0 ); \
+    ExitProcess( 1 ); \
+}
+
+ALL_WGL_FUNCS
+#undef USE_GL_FUNC
+
+static struct opengl_funcs egl_funcs =
+{
+    {
+        android_wglCopyContext,
+        android_wglCreateContext,
+        android_wglDeleteContext,
+        android_wglDescribePixelFormat,
+        android_wglGetPixelFormat,
+        android_wglGetProcAddress,
+        android_wglMakeCurrent,
+        android_wglSetPixelFormat,
+        android_wglShareLists,
+        android_wglSwapBuffers,
+    },
+#define USE_GL_FUNC(name) (void *)glstub_##name,
+    { ALL_WGL_FUNCS }
+#undef USE_GL_FUNC
+};
+
+struct opengl_funcs *get_wgl_driver( UINT version )
+{
+    if (version != WINE_WGL_DRIVER_VERSION)
+    {
+        ERR( "version mismatch, opengl32 wants %u but driver has %u\n", version, WINE_WGL_DRIVER_VERSION );
+        return NULL;
+    }
+    if (!egl_init()) return NULL;
+    return &egl_funcs;
+}
diff -Naur wine-2.0a/dlls/wineandroid.drv/strings.xml wine-2.0b/dlls/wineandroid.drv/strings.xml
--- wine-2.0a/dlls/wineandroid.drv/strings.xml	1970-01-01 01:00:00.000000000 +0100
+++ wine-2.0b/dlls/wineandroid.drv/strings.xml	2017-07-11 20:37:51.000000000 +0100
@@ -0,0 +1,4 @@
+<?xml version="1.0" encoding="utf-8"?>
+<resources>
+    <string name="org_winehq_wine_app_name">CrossOver</string>
+</resources>
diff -Naur wine-2.0a/dlls/wineandroid.drv/version.rc wine-2.0b/dlls/wineandroid.drv/version.rc
--- wine-2.0a/dlls/wineandroid.drv/version.rc	1970-01-01 01:00:00.000000000 +0100
+++ wine-2.0b/dlls/wineandroid.drv/version.rc	2017-07-11 20:37:51.000000000 +0100
@@ -0,0 +1,22 @@
+/*
+ * Copyright (c) 2007 Alexandre Julliard
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#define WINE_FILEDESCRIPTION_STR "Wine Android driver"
+#define WINE_FILENAME_STR "wineandroid.drv"
+
+#include "wine/wine_common_ver.rc"
diff -Naur wine-2.0a/dlls/wineandroid.drv/window.c wine-2.0b/dlls/wineandroid.drv/window.c
--- wine-2.0a/dlls/wineandroid.drv/window.c	1970-01-01 01:00:00.000000000 +0100
+++ wine-2.0b/dlls/wineandroid.drv/window.c	2017-07-11 20:37:51.000000000 +0100
@@ -0,0 +1,1503 @@
+/*
+ * Window related functions
+ *
+ * Copyright 1993, 1994, 1995, 1996, 2001, 2013 Alexandre Julliard
+ * Copyright 1993 David Metcalfe
+ * Copyright 1995, 1996 Alex Korobka
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#define NONAMELESSUNION
+#define NONAMELESSSTRUCT
+
+#include "config.h"
+#include "wine/port.h"
+
+#include <fcntl.h>
+#include <math.h>
+#include <poll.h>
+#include <errno.h>
+#include <stdarg.h>
+#include <stdlib.h>
+#include <stdio.h>
+#ifdef HAVE_UNISTD_H
+# include <unistd.h>
+#endif
+
+#include "windef.h"
+#include "winbase.h"
+#include "wingdi.h"
+#include "winuser.h"
+#include "wine/unicode.h"
+
+#include "android.h"
+#include "wine/debug.h"
+#include "wine/server.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(android);
+
+#define SWP_AGG_NOPOSCHANGE (SWP_NOSIZE | SWP_NOMOVE | SWP_NOCLIENTSIZE | SWP_NOCLIENTMOVE | SWP_NOZORDER)
+
+static CRITICAL_SECTION win_data_section;
+static CRITICAL_SECTION_DEBUG critsect_debug =
+{
+    0, 0, &win_data_section,
+    { &critsect_debug.ProcessLocksList, &critsect_debug.ProcessLocksList },
+      0, 0, { (DWORD_PTR)(__FILE__ ": win_data_section") }
+};
+static CRITICAL_SECTION win_data_section = { &critsect_debug, -1, 0, 0, 0, 0 };
+
+ANativeWindow *main_window = NULL;
+
+/* FIXME: quick & dirty handle context management */
+static void *context[65536];
+
+static void save_context( HWND hwnd, void *data )
+{
+    context[LOWORD(hwnd)] = data;
+}
+
+static void *find_context( HWND hwnd )
+{
+    return context[LOWORD(hwnd)];
+}
+
+static void delete_context( HWND hwnd )
+{
+    context[LOWORD(hwnd)] = NULL;
+}
+
+/* only for use on sanitized BITMAPINFO structures */
+static inline int get_dib_info_size( const BITMAPINFO *info, UINT coloruse )
+{
+    if (info->bmiHeader.biCompression == BI_BITFIELDS)
+        return sizeof(BITMAPINFOHEADER) + 3 * sizeof(DWORD);
+    if (coloruse == DIB_PAL_COLORS)
+        return sizeof(BITMAPINFOHEADER) + info->bmiHeader.biClrUsed * sizeof(WORD);
+    return FIELD_OFFSET( BITMAPINFO, bmiColors[info->bmiHeader.biClrUsed] );
+}
+
+static inline int get_dib_stride( int width, int bpp )
+{
+    return ((width * bpp + 31) >> 3) & ~3;
+}
+
+static inline int get_dib_image_size( const BITMAPINFO *info )
+{
+    return get_dib_stride( info->bmiHeader.biWidth, info->bmiHeader.biBitCount )
+        * abs( info->bmiHeader.biHeight );
+}
+
+
+/***********************************************************************
+ *		alloc_win_data
+ */
+static struct android_win_data *alloc_win_data( HWND hwnd )
+{
+    struct android_win_data *data;
+
+    if ((data = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(*data))))
+    {
+        data->hwnd = hwnd;
+        data->window = create_ioctl_window( hwnd );
+        EnterCriticalSection( &win_data_section );
+        save_context( hwnd, data );
+    }
+    return data;
+}
+
+
+/***********************************************************************
+ *		free_win_data
+ */
+static void free_win_data( struct android_win_data *data )
+{
+    delete_context( data->hwnd );
+    LeaveCriticalSection( &win_data_section );
+    if (data->window) release_ioctl_window( data->window );
+    HeapFree( GetProcessHeap(), 0, data );
+}
+
+
+/***********************************************************************
+ *		get_win_data
+ *
+ * Lock and return the data structure associated with a window.
+ */
+struct android_win_data *get_win_data( HWND hwnd )
+{
+    struct android_win_data *data;
+
+    if (!hwnd) return NULL;
+    EnterCriticalSection( &win_data_section );
+    if ((data = find_context( hwnd )) && data->hwnd == hwnd) return data;
+    LeaveCriticalSection( &win_data_section );
+    return NULL;
+}
+
+
+/***********************************************************************
+ *		release_win_data
+ *
+ * Release the data returned by get_win_data.
+ */
+void release_win_data( struct android_win_data *data )
+{
+    if (data) LeaveCriticalSection( &win_data_section );
+}
+
+
+/***********************************************************************
+ *		get_ioctl_window
+ */
+struct ANativeWindow *get_ioctl_window( HWND hwnd )
+{
+    struct ANativeWindow *ret;
+    struct android_win_data *data = get_win_data( hwnd );
+
+    if (!data || !data->window) return NULL;
+    grab_ioctl_window( data->window );
+    ret = data->window;
+    release_win_data( data );
+    return ret;
+}
+
+
+/***********************************************************************
+ *		apply_line_region
+ *
+ * Apply the window region to a single line of the destination image.
+ */
+static void apply_line_region( DWORD *dst, int width, int x, int y, const RECT *rect, const RECT *end )
+{
+    while (rect < end && rect->top <= y && width > 0)
+    {
+        if (rect->left > x)
+        {
+            memset( dst, 0, min( rect->left - x, width ) * sizeof(*dst) );
+            dst += rect->left - x;
+            width -= rect->left - x;
+            x = rect->left;
+        }
+        if (rect->right > x)
+        {
+            dst += rect->right - x;
+            width -= rect->right - x;
+            x = rect->right;
+        }
+        rect++;
+    }
+    if (width > 0) memset( dst, 0, width * sizeof(*dst) );
+}
+
+
+
+struct android_thread_data *desktop_thread;
+
+struct java_event
+{
+    struct list      entry;
+    union event_data data;
+};
+
+int send_event( struct android_thread_data *thread, const union event_data *data )
+{
+    int res;
+
+    if (!thread || (res = write( thread->event_pipe[1], data, sizeof(*data) )) != sizeof(*data))
+    {
+        p__android_log_print(ANDROID_LOG_ERROR, "wine", "failed to send event");
+        return -1;
+    }
+    return 0;
+}
+
+jboolean motion_event( JNIEnv *env, jobject obj, jint win, jint action, jint x, jint y, jint state, jint vscroll )
+{
+    static LONG button_state;
+    union event_data data;
+    int prev_state;
+
+    int mask = action & AMOTION_EVENT_ACTION_MASK;
+
+    if (!( mask == AMOTION_EVENT_ACTION_DOWN ||
+           mask == AMOTION_EVENT_ACTION_UP ||
+           mask == AMOTION_EVENT_ACTION_SCROLL ||
+           mask == AMOTION_EVENT_ACTION_MOVE ||
+           mask == AMOTION_EVENT_ACTION_HOVER_MOVE ))
+        return JNI_FALSE;
+
+    prev_state = InterlockedExchange( &button_state, state );
+
+    data.type = HARDWARE_INPUT;
+    data.hw.hwnd = LongToHandle( win );
+    data.hw.input.type             = INPUT_MOUSE;
+    data.hw.input.u.mi.dx          = x;
+    data.hw.input.u.mi.dy          = y;
+    data.hw.input.u.mi.mouseData   = 0;
+    data.hw.input.u.mi.time        = 0;
+    data.hw.input.u.mi.dwExtraInfo = 0;
+    data.hw.input.u.mi.dwFlags     = MOUSEEVENTF_MOVE | MOUSEEVENTF_ABSOLUTE;
+    switch (action & AMOTION_EVENT_ACTION_MASK)
+    {
+    case AMOTION_EVENT_ACTION_DOWN:
+        if ((state & ~prev_state) & AMOTION_EVENT_BUTTON_PRIMARY)
+            data.hw.input.u.mi.dwFlags |= MOUSEEVENTF_LEFTDOWN;
+        if ((state & ~prev_state) & AMOTION_EVENT_BUTTON_SECONDARY)
+            data.hw.input.u.mi.dwFlags |= MOUSEEVENTF_RIGHTDOWN;
+        if ((state & ~prev_state) & AMOTION_EVENT_BUTTON_TERTIARY)
+            data.hw.input.u.mi.dwFlags |= MOUSEEVENTF_MIDDLEDOWN;
+        if (!(state & ~prev_state)) /* touch event */
+            data.hw.input.u.mi.dwFlags |= MOUSEEVENTF_LEFTDOWN;
+        break;
+    case AMOTION_EVENT_ACTION_UP:
+        if ((prev_state & ~state) & AMOTION_EVENT_BUTTON_PRIMARY)
+            data.hw.input.u.mi.dwFlags |= MOUSEEVENTF_LEFTUP;
+        if ((prev_state & ~state) & AMOTION_EVENT_BUTTON_SECONDARY)
+            data.hw.input.u.mi.dwFlags |= MOUSEEVENTF_RIGHTUP;
+        if ((prev_state & ~state) & AMOTION_EVENT_BUTTON_TERTIARY)
+            data.hw.input.u.mi.dwFlags |= MOUSEEVENTF_MIDDLEUP;
+        if (!(prev_state & ~state)) /* touch event */
+            data.hw.input.u.mi.dwFlags |= MOUSEEVENTF_LEFTUP;
+        break;
+    case AMOTION_EVENT_ACTION_SCROLL:
+        data.hw.input.u.mi.dwFlags |= MOUSEEVENTF_WHEEL;
+        data.hw.input.u.mi.mouseData = vscroll < 0 ? -WHEEL_DELTA : WHEEL_DELTA;
+        break;
+    case AMOTION_EVENT_ACTION_MOVE:
+    case AMOTION_EVENT_ACTION_HOVER_MOVE:
+        break;
+    default:
+        return JNI_FALSE;
+    }
+    send_event( desktop_thread, &data );
+    return JNI_TRUE;
+}
+
+void surface_changed( JNIEnv *env, jobject obj, jint win, jobject surface )
+{
+    union event_data data;
+
+    memset( &data, 0, sizeof(data) );
+    data.surface.hwnd = LongToHandle( win );
+    if (surface)
+    {
+        int width, height;
+        ANativeWindow *win = pANativeWindow_fromSurface( env, surface );
+
+        if (win->query( win, NATIVE_WINDOW_WIDTH, &width ) < 0) width = 0;
+        if (win->query( win, NATIVE_WINDOW_HEIGHT, &height ) < 0) height = 0;
+        data.surface.window = win;
+        data.surface.width = width;
+        data.surface.height = height;
+        p__android_log_print( ANDROID_LOG_INFO, "wine", "init_window: %p %ux%u\n",
+                              data.surface.hwnd, width, height );
+    }
+    data.type = SURFACE_CHANGED;
+    send_event( desktop_thread, &data );
+}
+
+void desktop_changed( JNIEnv *env, jobject obj, jint width, jint height )
+{
+    union event_data data;
+
+    memset( &data, 0, sizeof(data) );
+    data.type = DESKTOP_CHANGED;
+    data.desktop.width = width;
+    data.desktop.height = height;
+    p__android_log_print( ANDROID_LOG_INFO, "wine", "desktop_changed: %ux%u\n", width, height );
+    send_event( desktop_thread, &data );
+}
+
+void config_changed( JNIEnv *env, jobject obj, jint dpi, jboolean force )
+{
+    union event_data data;
+
+    data.type = CONFIG_CHANGED;
+    data.cfg.dpi = dpi;
+    data.cfg.force = force;
+    send_event( desktop_thread, &data );
+    p__android_log_print( ANDROID_LOG_INFO, "wine", "config_changed dpi=%d force=%d\n",
+                          data.cfg.dpi, data.cfg.force );
+    return;
+}
+
+
+/* pull events from the event pipe and add them to the queue */
+static void pull_events(void)
+{
+    struct android_thread_data *thread_data = android_init_thread_data();
+    struct java_event *event;
+    int res;
+
+    for (;;)
+    {
+        if (!(event = HeapAlloc( GetProcessHeap(), 0, sizeof(*event) ))) break;
+
+        res = read( thread_data->event_pipe[0], &event->data, sizeof(event->data) );
+        if (res != sizeof(event->data)) break;
+        list_add_tail( &thread_data->event_queue, &event->entry );
+    }
+    HeapFree( GetProcessHeap(), 0, event );
+}
+
+static int process_events( DWORD mask )
+{
+    struct android_thread_data *thread_data = android_init_thread_data();
+    struct java_event *event, *next;
+    union event_data *previous;
+    unsigned int count = 0;
+
+    previous = thread_data->current_event;
+
+    LIST_FOR_EACH_ENTRY_SAFE( event, next, &thread_data->event_queue, struct java_event, entry )
+    {
+        switch (event->data.type)
+        {
+        case HARDWARE_INPUT:
+            if (event->data.hw.input.type == INPUT_KEYBOARD)
+            {
+                if (mask & QS_KEY) break;
+            }
+            else if (event->data.hw.input.u.mi.dwFlags & (MOUSEEVENTF_LEFTDOWN|MOUSEEVENTF_RIGHTDOWN|
+                                                          MOUSEEVENTF_MIDDLEDOWN|MOUSEEVENTF_LEFTUP|
+                                                          MOUSEEVENTF_RIGHTUP|MOUSEEVENTF_MIDDLEUP))
+            {
+                if (mask & QS_MOUSEBUTTON) break;
+            }
+            else if (mask & QS_MOUSEMOVE) break;
+            continue;  /* skip it */
+        case SURFACE_CHANGED:
+            break;  /* always process it to unblock other threads */
+        default:
+            if (mask & QS_SENDMESSAGE) break;
+            continue;  /* skip it */
+        }
+
+        /* remove it first, in case we process events recursively */
+        list_remove( &event->entry );
+        thread_data->current_event = &event->data;
+
+        switch (event->data.type)
+        {
+        case HARDWARE_INPUT:
+            if (event->data.hw.input.type == INPUT_KEYBOARD)
+            {
+                if (event->data.hw.input.u.ki.dwFlags & KEYEVENTF_KEYUP)
+                    TRACE("KEYUP hwnd %p vkey %x '%c' scancode %x\n", event->data.hw.hwnd,
+                          event->data.hw.input.u.ki.wVk, event->data.hw.input.u.ki.wVk,
+                          event->data.hw.input.u.ki.wScan );
+                else
+                    TRACE("KEYDOWN hwnd %p vkey %x '%c' scancode %x\n", event->data.hw.hwnd,
+                          event->data.hw.input.u.ki.wVk, event->data.hw.input.u.ki.wVk,
+                          event->data.hw.input.u.ki.wScan );
+                update_keyboard_lock_state( event->data.hw.input.u.ki.wVk,
+                                            event->data.hw.input.u.ki.dwExtraInfo );
+                event->data.hw.input.u.ki.dwExtraInfo = 0;
+                __wine_send_input( 0, &event->data.hw.input );
+            }
+            else
+            {
+                HWND capture = get_capture_window();
+
+                if (event->data.hw.input.u.mi.dwFlags & (MOUSEEVENTF_LEFTDOWN|MOUSEEVENTF_RIGHTDOWN|MOUSEEVENTF_MIDDLEDOWN))
+                    TRACE( "BUTTONDOWN pos %d,%d hwnd %p flags %x\n",
+                           event->data.hw.input.u.mi.dx, event->data.hw.input.u.mi.dy,
+                           event->data.hw.hwnd, event->data.hw.input.u.mi.dwFlags );
+                else if (event->data.hw.input.u.mi.dwFlags & (MOUSEEVENTF_LEFTUP|MOUSEEVENTF_RIGHTUP|MOUSEEVENTF_MIDDLEUP))
+                    TRACE( "BUTTONUP pos %d,%d hwnd %p flags %x\n",
+                           event->data.hw.input.u.mi.dx, event->data.hw.input.u.mi.dy,
+                           event->data.hw.hwnd, event->data.hw.input.u.mi.dwFlags );
+                else
+                    TRACE( "MOUSEMOVE pos %d,%d hwnd %p flags %x\n",
+                           event->data.hw.input.u.mi.dx, event->data.hw.input.u.mi.dy,
+                           event->data.hw.hwnd, event->data.hw.input.u.mi.dwFlags );
+                if (!capture && (event->data.hw.input.u.mi.dwFlags & MOUSEEVENTF_ABSOLUTE))
+                {
+                    RECT rect;
+                    SetRect( &rect, event->data.hw.input.u.mi.dx, event->data.hw.input.u.mi.dy,
+                             event->data.hw.input.u.mi.dx + 1, event->data.hw.input.u.mi.dy + 1 );
+                    MapWindowPoints( 0, event->data.hw.hwnd, (POINT *)&rect, 2 );
+
+                    SERVER_START_REQ( update_window_zorder )
+                    {
+                        req->window      = wine_server_user_handle( event->data.hw.hwnd );
+                        req->rect.left   = rect.left;
+                        req->rect.top    = rect.top;
+                        req->rect.right  = rect.right;
+                        req->rect.bottom = rect.bottom;
+                        wine_server_call( req );
+                    }
+                    SERVER_END_REQ;
+                }
+                __wine_send_input( capture ? capture : event->data.hw.hwnd, &event->data.hw.input );
+            }
+            break;
+
+        case SURFACE_CHANGED:
+            TRACE("SURFACE_CHANGED %p %p size %ux%u\n", event->data.surface.hwnd,
+                  event->data.surface.window, event->data.surface.width, event->data.surface.height );
+
+            register_native_window( event->data.surface.hwnd, event->data.surface.window );
+            break;
+
+        case CONFIG_CHANGED:
+            TRACE("CONFIG_CHANGED dpi %u\n", event->data.cfg.dpi );
+            set_screen_dpi( event->data.cfg.dpi, event->data.cfg.force );
+            break;
+
+        case CLIPBOARD_CHANGED:
+            TRACE("CLIPBOARD_CHANGED\n");
+            handle_clipboard_changed();
+            break;
+
+        case IMPORT_CLIPBOARD_DATA:
+            TRACE("IMPORT_CLIPBOARD_DATA %i\n", event->data.clipdata.android_format);
+            handle_import_clipboard_data( event->data.clipdata.android_format,
+                event->data.clipdata.data, event->data.clipdata.len );
+            break;
+
+        case CLIPBOARD_REQUEST:
+            TRACE("CLIPBOARD_REQUEST %i\n", event->data.clipdata.android_format);
+            handle_clipboard_request( event->data.clipdata.android_format );
+            break;
+
+        case DESKTOP_CHANGED:
+            TRACE("DESKTOP_CHANGED %ux%u\n", event->data.desktop.width, event->data.desktop.height );
+            screen_width = event->data.desktop.width;
+            screen_height = event->data.desktop.height;
+            init_monitors( screen_width, screen_height );
+            SetWindowPos( GetDesktopWindow(), 0, 0, 0, screen_width, screen_height,
+                          SWP_NOZORDER | SWP_NOACTIVATE | SWP_NOREDRAW );
+            break;
+
+        case IME_TEXT:
+            ERR( "IME_TEXT target %u, length %u\n", event->data.ime_text.target , event->data.ime_text.length );
+            handle_IME_TEXT( event->data.ime_text.target, event->data.ime_text.length);
+            break;
+
+        case IME_FINISH:
+            TRACE( "IME_FINISH target %u, length %u\n", event->data.ime_finish.target, event->data.ime_text.length );
+            handle_IME_FINISH( event->data.ime_finish.target, event->data.ime_finish.length );
+            break;
+
+        case IME_CANCEL:
+            TRACE( "IME_CANCEL\n" );
+            handle_IME_CANCEL();
+            break;
+
+        case IME_START:
+            TRACE( "IME_START\n" );
+            handle_IME_START();
+            break;
+
+        case RUN_CMDLINE:
+            handle_run_cmdline( event->data.runcmd.cmdline, event->data.runcmd.env );
+            free( event->data.runcmd.cmdline );
+            if (event->data.runcmd.env)
+            {
+                LPWSTR *strs = event->data.runcmd.env;
+                while (*strs) free( *strs++ );
+                free( event->data.runcmd.env );
+            }
+            break;
+        case CLEAR_META:
+            TRACE( "CLEAR_META" );
+            handle_clear_meta_key_states( event->data.clearmeta.states );
+            break;
+        default:
+            FIXME( "got event %u\n", event->data.type );
+        }
+        HeapFree( GetProcessHeap(), 0, event );
+        count++;
+    }
+    thread_data->current_event = previous;
+    return count;
+}
+
+static int wait_events( int timeout )
+{
+    struct android_thread_data *thread_data = android_init_thread_data();
+
+    if (thread_data->event_pipe[0] == -1) return -1;
+
+    for (;;)
+    {
+        struct pollfd pollfd;
+        int ret;
+
+        pollfd.fd = thread_data->event_pipe[0];
+        pollfd.events = POLLIN | POLLHUP;
+        ret = poll( &pollfd, 1, timeout );
+        if (ret == -1 && errno == EINTR) continue;
+        if (ret && (pollfd.revents & (POLLHUP | POLLERR))) ret = -1;
+        if (ret > 0) pull_events();
+        return ret;
+    }
+}
+
+/* store the palette or color mask data in the bitmap info structure */
+static void set_color_info( BITMAPINFO *info, BOOL has_alpha )
+{
+    DWORD *colors = (DWORD *)info->bmiColors;
+
+    info->bmiHeader.biSize = sizeof(info->bmiHeader);
+    info->bmiHeader.biClrUsed = 0;
+    info->bmiHeader.biBitCount = 32;
+    if (has_alpha)
+    {
+        info->bmiHeader.biCompression = BI_RGB;
+        return;
+    }
+    info->bmiHeader.biCompression = BI_BITFIELDS;
+    colors[0] = 0xff0000;
+    colors[1] = 0x00ff00;
+    colors[2] = 0x0000ff;
+}
+
+
+/* Window surface support */
+
+struct android_window_surface
+{
+    struct window_surface header;
+    HWND                  hwnd;
+    ANativeWindow        *window;
+    RECT                  bounds;
+    BOOL                  byteswap;
+    RGNDATA              *win_region;
+    HRGN                  region;
+    COLORREF              color_key;
+    void                 *bits;
+    CRITICAL_SECTION      crit;
+    BITMAPINFO            info;   /* variable size, must be last */
+};
+
+static struct android_window_surface *get_android_surface( struct window_surface *surface )
+{
+    return (struct android_window_surface *)surface;
+}
+
+/***********************************************************************
+ *           android_surface_lock
+ */
+static void android_surface_lock( struct window_surface *window_surface )
+{
+    struct android_window_surface *surface = get_android_surface( window_surface );
+
+    EnterCriticalSection( &surface->crit );
+}
+
+/***********************************************************************
+ *           android_surface_unlock
+ */
+static void android_surface_unlock( struct window_surface *window_surface )
+{
+    struct android_window_surface *surface = get_android_surface( window_surface );
+
+    LeaveCriticalSection( &surface->crit );
+}
+
+/***********************************************************************
+ *           android_surface_get_bitmap_info
+ */
+static void *android_surface_get_bitmap_info( struct window_surface *window_surface, BITMAPINFO *info )
+{
+    struct android_window_surface *surface = get_android_surface( window_surface );
+
+    memcpy( info, &surface->info, get_dib_info_size( &surface->info, DIB_RGB_COLORS ));
+    return surface->bits;
+}
+
+/***********************************************************************
+ *           android_surface_get_bounds
+ */
+static RECT *android_surface_get_bounds( struct window_surface *window_surface )
+{
+    struct android_window_surface *surface = get_android_surface( window_surface );
+
+    return &surface->bounds;
+}
+
+/***********************************************************************
+ *           android_surface_set_region
+ */
+static void android_surface_set_region( struct window_surface *window_surface, HRGN region )
+{
+    struct android_window_surface *surface = get_android_surface( window_surface );
+
+    TRACE( "updating surface %p with %p\n", surface, region );
+
+    window_surface->funcs->lock( window_surface );
+    if (!region)
+    {
+        if (surface->region) DeleteObject( surface->region );
+        surface->region = 0;
+    }
+    else
+    {
+        if (!surface->region) surface->region = CreateRectRgn( 0, 0, 0, 0 );
+        CombineRgn( surface->region, region, 0, RGN_COPY );
+    }
+    window_surface->funcs->unlock( window_surface );
+}
+
+/***********************************************************************
+ *           android_surface_flush
+ */
+static void android_surface_flush( struct window_surface *window_surface )
+{
+    struct android_window_surface *surface = get_android_surface( window_surface );
+    ANativeWindow_Buffer buffer;
+    ARect rc;
+    RECT rect;
+    BOOL needs_flush;
+
+    window_surface->funcs->lock( window_surface );
+    SetRect( &rect, 0, 0, surface->header.rect.right - surface->header.rect.left,
+             surface->header.rect.bottom - surface->header.rect.top );
+    needs_flush = IntersectRect( &rect, &rect, &surface->bounds );
+    reset_bounds( &surface->bounds );
+    window_surface->funcs->unlock( window_surface );
+    if (!needs_flush) return;
+
+    TRACE( "flushing %p hwnd %p surface %s rect %s win %p bits %p key %08x\n",
+           surface, surface->hwnd, wine_dbgstr_rect( &surface->header.rect ), wine_dbgstr_rect( &rect ),
+           main_window, surface->bits, surface->color_key );
+
+    rc.left   = rect.left;
+    rc.top    = rect.top;
+    rc.right  = rect.right;
+    rc.bottom = rect.bottom;
+
+    if (!surface->window->perform( surface->window, NATIVE_WINDOW_LOCK, &buffer, &rc ))
+    {
+        const RECT *rgn_rect = NULL, *end = NULL;
+        unsigned int *src, *dst;
+        int x, y, width;
+
+        rect.left   = rc.left;
+        rect.top    = rc.top;
+        rect.right  = rc.right;
+        rect.bottom = rc.bottom;
+        IntersectRect( &rect, &rect, &surface->header.rect );
+
+        if (surface->win_region)
+        {
+            rgn_rect = (RECT *)surface->win_region->Buffer;
+            end = rgn_rect + surface->win_region->rdh.nCount;
+        }
+        src = (unsigned int *)surface->bits
+            + (rect.top - surface->header.rect.top) * surface->info.bmiHeader.biWidth
+            + (rect.left - surface->header.rect.left);
+        dst = (unsigned int *)buffer.bits + rect.top * buffer.stride + rect.left;
+        width = min( rect.right - rect.left, buffer.stride );
+        for (y = rect.top; y < min( buffer.height, rect.bottom); y++)
+        {
+            if (surface->info.bmiHeader.biCompression == BI_RGB)
+                memcpy( dst, src, width * sizeof(*dst) );
+            else
+                for (x = 0; x < width; x++) dst[x] = src[x] | 0xff000000;
+
+            if (surface->color_key != CLR_INVALID)
+                for (x = 0; x < width; x++) if ((src[x] & 0xffffff) == surface->color_key) dst[x] = 0;
+
+            if (rgn_rect)
+            {
+                while (rgn_rect < end && rgn_rect->bottom <= y) rgn_rect++;
+                apply_line_region( dst, width, rect.left, y, rgn_rect, end );
+            }
+
+            src += surface->info.bmiHeader.biWidth;
+            dst += buffer.stride;
+        }
+        surface->window->perform( surface->window, NATIVE_WINDOW_UNLOCK_AND_POST );
+    }
+    else TRACE( "Unable to lock surface %p window %p buffer %p\n",
+                surface, surface->hwnd, surface->window );
+}
+
+/***********************************************************************
+ *           android_surface_destroy
+ */
+static void android_surface_destroy( struct window_surface *window_surface )
+{
+    struct android_window_surface *surface = get_android_surface( window_surface );
+
+    TRACE( "freeing %p bits %p\n", surface, surface->bits );
+
+    surface->crit.DebugInfo->Spare[0] = 0;
+    DeleteCriticalSection( &surface->crit );
+    HeapFree( GetProcessHeap(), 0, surface->win_region );
+    if (surface->region) DeleteObject( surface->region );
+    release_ioctl_window( surface->window );
+    HeapFree( GetProcessHeap(), 0, surface->bits );
+    HeapFree( GetProcessHeap(), 0, surface );
+}
+
+static const struct window_surface_funcs android_surface_funcs =
+{
+    android_surface_lock,
+    android_surface_unlock,
+    android_surface_get_bitmap_info,
+    android_surface_get_bounds,
+    android_surface_set_region,
+    android_surface_flush,
+    android_surface_destroy
+};
+
+static BOOL is_argb_surface( struct window_surface *surface )
+{
+    return surface && surface->funcs == &android_surface_funcs &&
+        get_android_surface( surface )->info.bmiHeader.biCompression == BI_RGB;
+}
+
+/***********************************************************************
+ *           set_color_key
+ */
+static void set_color_key( struct android_window_surface *surface, COLORREF key )
+{
+    if (key == CLR_INVALID)
+        surface->color_key = CLR_INVALID;
+    else if (surface->info.bmiHeader.biBitCount <= 8)
+        surface->color_key = CLR_INVALID;
+    else if (key & (1 << 24))  /* PALETTEINDEX */
+        surface->color_key = 0;
+    else if (key >> 16 == 0x10ff)  /* DIBINDEX */
+        surface->color_key = 0;
+    else if (surface->info.bmiHeader.biBitCount == 24)
+        surface->color_key = key;
+    else
+        surface->color_key = (GetRValue(key) << 16) | (GetGValue(key) << 8) | GetBValue(key);
+}
+
+/***********************************************************************
+ *           set_surface_region
+ */
+static void set_surface_region( struct window_surface *window_surface, HRGN win_region )
+{
+    struct android_window_surface *surface = get_android_surface( window_surface );
+    struct android_win_data *win_data;
+    HRGN region = win_region;
+    RGNDATA *data = NULL;
+    DWORD size;
+    int offset_x, offset_y;
+
+    if (window_surface->funcs != &android_surface_funcs) return;  /* we may get the null surface */
+
+    if (!(win_data = get_win_data( surface->hwnd ))) return;
+    offset_x = win_data->window_rect.left - win_data->whole_rect.left;
+    offset_y = win_data->window_rect.top - win_data->whole_rect.top;
+    release_win_data( win_data );
+
+    if (win_region == (HRGN)1)  /* hack: win_region == 1 means retrieve region from server */
+    {
+        region = CreateRectRgn( 0, 0, 0, 0 );
+        if (GetWindowRgn( surface->hwnd, region ) == ERROR) goto done;
+    }
+
+    OffsetRgn( region, offset_x, offset_y );
+
+    if (!(size = GetRegionData( region, 0, NULL ))) goto done;
+    if (!(data = HeapAlloc( GetProcessHeap(), 0, size ))) goto done;
+
+    if (!GetRegionData( region, size, data ))
+    {
+        HeapFree( GetProcessHeap(), 0, data );
+        data = NULL;
+    }
+
+done:
+    window_surface->funcs->lock( window_surface );
+    HeapFree( GetProcessHeap(), 0, surface->win_region );
+    surface->win_region = data;
+    *window_surface->funcs->get_bounds( window_surface ) = surface->header.rect;
+    window_surface->funcs->unlock( window_surface );
+    if (region != win_region) DeleteObject( region );
+}
+
+/***********************************************************************
+ *           create_surface
+ */
+static struct window_surface *create_surface( HWND hwnd, const RECT *rect,
+                                              COLORREF color_key, BOOL use_alpha )
+{
+    struct android_window_surface *surface;
+    int width = rect->right - rect->left, height = rect->bottom - rect->top;
+
+    surface = HeapAlloc( GetProcessHeap(), HEAP_ZERO_MEMORY,
+                         FIELD_OFFSET( struct android_window_surface, info.bmiColors[3] ));
+    if (!surface) return NULL;
+    set_color_info( &surface->info, use_alpha );
+    surface->info.bmiHeader.biWidth       = width;
+    surface->info.bmiHeader.biHeight      = -height; /* top-down */
+    surface->info.bmiHeader.biPlanes      = 1;
+    surface->info.bmiHeader.biSizeImage   = get_dib_image_size( &surface->info );
+
+    InitializeCriticalSection( &surface->crit );
+    surface->crit.DebugInfo->Spare[0] = (DWORD_PTR)(__FILE__ ": surface");
+
+    surface->header.funcs = &android_surface_funcs;
+    surface->header.rect  = *rect;
+    surface->header.ref   = 1;
+    surface->hwnd         = hwnd;
+    surface->window       = get_ioctl_window( hwnd );
+    set_color_key( surface, color_key );
+    set_surface_region( &surface->header, (HRGN)1 );
+    reset_bounds( &surface->bounds );
+
+    if (!(surface->bits = HeapAlloc( GetProcessHeap(), 0, surface->info.bmiHeader.biSizeImage )))
+        goto failed;
+
+    TRACE( "created %p %s bits %p-%p\n", surface, wine_dbgstr_rect(rect),
+           surface->bits, (char *)surface->bits + surface->info.bmiHeader.biSizeImage );
+
+    ioctl_set_surface_alpha( hwnd, use_alpha || surface->color_key != CLR_INVALID );
+    return &surface->header;
+
+failed:
+    android_surface_destroy( &surface->header );
+    return NULL;
+}
+
+/***********************************************************************
+ *           set_surface_color_key
+ */
+static void set_surface_color_key( struct window_surface *window_surface, COLORREF color_key )
+{
+    struct android_window_surface *surface = get_android_surface( window_surface );
+    COLORREF prev;
+
+    if (window_surface->funcs != &android_surface_funcs) return;  /* we may get the null surface */
+
+    window_surface->funcs->lock( window_surface );
+    prev = surface->color_key;
+    set_color_key( surface, color_key );
+    if (surface->color_key != prev)  /* refresh */
+        *window_surface->funcs->get_bounds( window_surface ) = surface->header.rect;
+    ioctl_set_surface_alpha( surface->hwnd, (surface->info.bmiHeader.biCompression == BI_RGB ||
+                                             surface->color_key != CLR_INVALID) );
+    window_surface->funcs->unlock( window_surface );
+}
+
+/***********************************************************************
+ *              get_bitmap_argb
+ *
+ * Return the bitmap bits in ARGB format. Helper for setting icon hints.
+ */
+static unsigned int *get_bitmap_argb( HDC hdc, HBITMAP color, HBITMAP mask, unsigned int *width,
+                                      unsigned int *height )
+{
+    char buffer[FIELD_OFFSET( BITMAPINFO, bmiColors[256] )];
+    BITMAPINFO *info = (BITMAPINFO *)buffer;
+    BITMAP bm;
+    unsigned int *ptr, *bits = NULL;
+    unsigned char *mask_bits = NULL;
+    int i, j;
+    BOOL has_alpha = FALSE;
+
+    if (!GetObjectW( color, sizeof(bm), &bm )) return NULL;
+    info->bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
+    info->bmiHeader.biWidth = bm.bmWidth;
+    info->bmiHeader.biHeight = -bm.bmHeight;
+    info->bmiHeader.biPlanes = 1;
+    info->bmiHeader.biBitCount = 32;
+    info->bmiHeader.biCompression = BI_RGB;
+    info->bmiHeader.biSizeImage = bm.bmWidth * bm.bmHeight * 4;
+    info->bmiHeader.biXPelsPerMeter = 0;
+    info->bmiHeader.biYPelsPerMeter = 0;
+    info->bmiHeader.biClrUsed = 0;
+    info->bmiHeader.biClrImportant = 0;
+    if (!(bits = HeapAlloc( GetProcessHeap(), 0, bm.bmWidth * bm.bmHeight * sizeof(unsigned int) )))
+        goto failed;
+    if (!GetDIBits( hdc, color, 0, bm.bmHeight, bits, info, DIB_RGB_COLORS )) goto failed;
+
+    *width = bm.bmWidth;
+    *height = bm.bmHeight;
+
+    for (i = 0; i < bm.bmWidth * bm.bmHeight; i++)
+        if ((has_alpha = (bits[i] & 0xff000000) != 0)) break;
+
+    if (!has_alpha)
+    {
+        unsigned int width_bytes = (bm.bmWidth + 31) / 32 * 4;
+        /* generate alpha channel from the mask */
+        info->bmiHeader.biBitCount = 1;
+        info->bmiHeader.biSizeImage = width_bytes * bm.bmHeight;
+        if (!(mask_bits = HeapAlloc( GetProcessHeap(), 0, info->bmiHeader.biSizeImage ))) goto failed;
+        if (!GetDIBits( hdc, mask, 0, bm.bmHeight, mask_bits, info, DIB_RGB_COLORS )) goto failed;
+        ptr = bits;
+        for (i = 0; i < bm.bmHeight; i++)
+            for (j = 0; j < bm.bmWidth; j++, ptr++)
+                if (!((mask_bits[i * width_bytes + j / 8] << (j % 8)) & 0x80)) *ptr |= 0xff000000;
+        HeapFree( GetProcessHeap(), 0, mask_bits );
+    }
+
+    return bits;
+
+failed:
+    HeapFree( GetProcessHeap(), 0, bits );
+    HeapFree( GetProcessHeap(), 0, mask_bits );
+    *width = *height = 0;
+    return NULL;
+}
+
+
+/***********************************************************************
+ *              fetch_window_icon
+ */
+static void fetch_window_icon( HWND hwnd, HICON icon )
+{
+    ICONINFO ii;
+    unsigned int width = 0, height = 0, *bits = NULL;
+
+    if (!icon) icon = (HICON)SendMessageW( hwnd, WM_GETICON, ICON_BIG, 0 );
+    if (!icon) icon = (HICON)GetClassLongPtrW( hwnd, GCLP_HICON );
+
+    if (GetIconInfo( icon, &ii ))
+    {
+        HDC hdc = CreateCompatibleDC( 0 );
+        bits = get_bitmap_argb( hdc, ii.hbmColor, ii.hbmMask, &width, &height );
+        DeleteDC( hdc );
+        DeleteObject( ii.hbmColor );
+        DeleteObject( ii.hbmMask );
+    }
+
+    ioctl_set_window_icon( hwnd, width, height, bits );
+    HeapFree( GetProcessHeap(), 0, bits );
+}
+
+
+/***********************************************************************
+ *           MsgWaitForMultipleObjectsEx
+ */
+DWORD CDECL ANDROID_MsgWaitForMultipleObjectsEx( DWORD count, const HANDLE *handles,
+                                                 DWORD timeout, DWORD mask, DWORD flags )
+{
+    struct android_thread_data *thread_data = android_init_thread_data();
+
+    /* don't process nested events */
+    if (thread_data->current_event) mask = 0;
+
+    pull_events();
+    if (process_events( mask )) return count - 1;
+
+    return WaitForMultipleObjectsEx( count, handles, flags & MWMO_WAITALL,
+                                     timeout, flags & MWMO_ALERTABLE );
+}
+
+/*****************************************************************
+ *		SetFocus
+ */
+void CDECL ANDROID_SetFocus( HWND hwnd )
+{
+    IME_UpdateAssociation(hwnd);
+    ioctl_set_window_focus( GetAncestor( hwnd, GA_ROOT ));
+}
+
+
+/**********************************************************************
+ *		CreateDesktopWindow   (ANDROID.@)
+ */
+BOOL CDECL ANDROID_CreateDesktopWindow( HWND hwnd )
+{
+    android_init_thread_data();
+    return TRUE;
+}
+
+
+/**********************************************************************
+ *		CreateWindow   (ANDROID.@)
+ */
+BOOL CDECL ANDROID_CreateWindow( HWND hwnd )
+{
+    TRACE( "%p\n", hwnd );
+
+    android_init_thread_data();
+
+    if (hwnd == GetDesktopWindow())
+    {
+        struct android_win_data *data;
+
+        desktop_thread = android_thread_data();
+
+        start_android_device();
+
+        if (!(data = alloc_win_data( hwnd ))) return FALSE;
+        release_win_data( data );
+    }
+    return TRUE;
+}
+
+
+/***********************************************************************
+ *		DestroyWindow   (ANDROID.@)
+ */
+void CDECL ANDROID_DestroyWindow( HWND hwnd )
+{
+    struct android_win_data *data;
+
+    if (!(data = get_win_data( hwnd ))) return;
+
+    if (data->surface) window_surface_release( data->surface );
+    data->surface = NULL;
+    free_win_data( data );
+    destroy_gl_drawable( hwnd );
+}
+
+
+/***********************************************************************
+ *		ANDROID_create_win_data
+ *
+ * Create an X11 data window structure for an existing window.
+ */
+static struct android_win_data *ANDROID_create_win_data( HWND hwnd, const RECT *window_rect,
+                                                         const RECT *client_rect )
+{
+    struct android_win_data *data;
+    HWND parent;
+
+    if (!(parent = GetAncestor( hwnd, GA_PARENT ))) return NULL;  /* desktop */
+
+    /* don't create win data for HWND_MESSAGE windows */
+    if (parent != GetDesktopWindow() && !GetAncestor( parent, GA_PARENT )) return NULL;
+
+    /* don't create win data for children */
+    if (parent != GetDesktopWindow()) return NULL;
+
+    if (GetWindowThreadProcessId( hwnd, NULL ) != GetCurrentThreadId()) return NULL;
+
+    if (!(data = alloc_win_data( hwnd ))) return NULL;
+
+    data->whole_rect = data->window_rect = *window_rect;
+    data->client_rect = *client_rect;
+    return data;
+}
+
+
+static inline RECT get_surface_rect( const RECT *visible_rect )
+{
+    RECT rect;
+
+    IntersectRect( &rect, visible_rect, &virtual_screen_rect );
+    OffsetRect( &rect, -visible_rect->left, -visible_rect->top );
+    rect.left &= ~31;
+    rect.top  &= ~31;
+    rect.right  = max( rect.left + 32, (rect.right + 31) & ~31 );
+    rect.bottom = max( rect.top + 32, (rect.bottom + 31) & ~31 );
+    return rect;
+}
+
+
+static WNDPROC desktop_orig_wndproc;
+
+static LRESULT CALLBACK desktop_wndproc_wrapper( HWND hwnd, UINT msg, WPARAM wp, LPARAM lp )
+{
+    switch (msg)
+    {
+    case WM_PARENTNOTIFY:
+        if (LOWORD(wp) == WM_DESTROY) destroy_ioctl_window( (HWND)lp );
+        break;
+    }
+    return desktop_orig_wndproc( hwnd, msg, wp, lp );
+}
+
+
+/***********************************************************************
+ *		WindowPosChanging   (ANDROID.@)
+ */
+void CDECL ANDROID_WindowPosChanging( HWND hwnd, HWND insert_after, UINT swp_flags,
+                                     const RECT *window_rect, const RECT *client_rect, RECT *visible_rect,
+                                     struct window_surface **surface )
+{
+    struct android_win_data *data = get_win_data( hwnd );
+    RECT surface_rect;
+    DWORD flags;
+    COLORREF key;
+    BOOL layered = GetWindowLongW( hwnd, GWL_EXSTYLE ) & WS_EX_LAYERED;
+
+    TRACE( "win %p window %s client %s style %08x flags %08x\n",
+           hwnd, wine_dbgstr_rect(window_rect), wine_dbgstr_rect(client_rect),
+           GetWindowLongW( hwnd, GWL_STYLE ), swp_flags );
+
+    if (!data)
+    {
+        WCHAR text[1024];
+
+        if (!(data = ANDROID_create_win_data( hwnd, window_rect, client_rect ))) return;
+        if (InternalGetWindowText( hwnd, text, sizeof(text)/sizeof(WCHAR) ))
+            ioctl_set_window_text( hwnd, text );
+    }
+
+    *visible_rect = *window_rect;
+
+    /* create the window surface if necessary */
+
+    if (swp_flags & SWP_HIDEWINDOW) goto done;
+    if (is_argb_surface( data->surface )) goto done;
+
+    if (*surface) window_surface_release( *surface );
+    *surface = NULL;  /* indicate that we want to draw directly to the window */
+
+    surface_rect = get_surface_rect( visible_rect );
+    if (data->surface)
+    {
+        if (!memcmp( &data->surface->rect, &surface_rect, sizeof(surface_rect) ))
+        {
+            /* existing surface is good enough */
+            window_surface_add_ref( data->surface );
+            *surface = data->surface;
+            goto done;
+        }
+    }
+    else if (!(swp_flags & SWP_SHOWWINDOW) && !(GetWindowLongW( hwnd, GWL_STYLE ) & WS_VISIBLE)) goto done;
+
+    if (!layered || !GetLayeredWindowAttributes( hwnd, &key, NULL, &flags ) || !(flags & LWA_COLORKEY))
+        key = CLR_INVALID;
+
+    *surface = create_surface( data->hwnd, &surface_rect, key, FALSE );
+
+done:
+    release_win_data( data );
+}
+
+
+/***********************************************************************
+ *		WindowPosChanged   (ANDROID.@)
+ */
+void CDECL ANDROID_WindowPosChanged( HWND hwnd, HWND insert_after, UINT swp_flags,
+                                    const RECT *rectWindow, const RECT *rectClient,
+                                    const RECT *visible_rect, const RECT *valid_rects,
+                                    struct window_surface *surface )
+{
+    struct android_win_data *data;
+    DWORD new_style = GetWindowLongW( hwnd, GWL_STYLE );
+
+    if (!(data = get_win_data( hwnd ))) return;
+
+    data->window_rect = *rectWindow;
+    data->whole_rect  = *visible_rect;
+    data->client_rect = *rectClient;
+
+    if (!is_argb_surface( data->surface ))
+    {
+        if (surface) window_surface_add_ref( surface );
+        if (data->surface) window_surface_release( data->surface );
+        data->surface = surface;
+    }
+
+    TRACE( "win %p window %s client %s style %08x flags %08x\n",
+           hwnd, wine_dbgstr_rect(rectWindow), wine_dbgstr_rect(rectClient), new_style, swp_flags );
+
+    release_win_data( data );
+
+    if ((swp_flags & SWP_SHOWWINDOW) && !desktop_orig_wndproc && hwnd == GetDesktopWindow())
+        desktop_orig_wndproc = (WNDPROC)SetWindowLongPtrW( GetDesktopWindow(), GWLP_WNDPROC,
+                                                           (LONG_PTR)desktop_wndproc_wrapper );
+
+    if ((swp_flags & (SWP_SHOWWINDOW|SWP_NOZORDER)) == (SWP_SHOWWINDOW|SWP_NOZORDER))
+    {
+        /* If this is the topmost visible window, bring the view to the top when showing it. */
+        HWND prev = GetWindow( hwnd, GW_HWNDPREV );
+        while (prev && !(GetWindowLongW( prev, GWL_STYLE ) & WS_VISIBLE))
+            prev = GetWindow( prev, GW_HWNDPREV );
+        if (!prev)
+        {
+            swp_flags &= ~SWP_NOZORDER;
+            insert_after = HWND_TOP;
+        }
+    }
+
+    ioctl_window_pos_changed( hwnd, visible_rect, new_style, swp_flags,
+                              insert_after, GetWindow( hwnd, GW_OWNER ));
+    if (swp_flags & SWP_SHOWWINDOW) fetch_window_icon( hwnd, 0 );
+}
+
+
+/***********************************************************************
+ *           ANDROID_ShowWindow
+ */
+UINT CDECL ANDROID_ShowWindow( HWND hwnd, INT cmd, RECT *rect, UINT swp )
+{
+    static const WCHAR trayW[] = {'S','h','e','l','l','_','T','r','a','y','W','n','d',0};
+
+    if (IsRectEmpty( rect )) return swp;
+    if (!IsIconic( hwnd )) return swp;
+    /* hide icons when the taskbar is active */
+    if (!IsWindowVisible( FindWindowW( trayW, NULL ))) return swp;
+    if (rect->left != -32000 || rect->top != -32000)
+    {
+        OffsetRect( rect, -32000 - rect->left, -32000 - rect->top );
+        swp &= ~(SWP_NOMOVE | SWP_NOCLIENTMOVE);
+    }
+    return swp;
+}
+
+
+/*****************************************************************
+ *		ANDROID_SetParent
+ */
+void CDECL ANDROID_SetParent( HWND hwnd, HWND parent, HWND old_parent )
+{
+    struct android_win_data *data;
+
+    if (parent == old_parent) return;
+    if (!(data = get_win_data( hwnd ))) return;
+
+    TRACE( "win %p parent %p -> %p\n", hwnd, old_parent, parent );
+
+    if (parent != GetDesktopWindow() && old_parent == GetDesktopWindow())
+    {
+        /* destroy the old window */
+        free_win_data( data );
+        return;
+    }
+
+    release_win_data( data );
+}
+
+
+/***********************************************************************
+ *		ANDROID_SetWindowStyle
+ */
+void CDECL ANDROID_SetWindowStyle( HWND hwnd, INT offset, STYLESTRUCT *style )
+{
+    struct android_win_data *data;
+    DWORD changed = style->styleNew ^ style->styleOld;
+
+    if (hwnd == GetDesktopWindow()) return;
+    if (!(data = get_win_data( hwnd ))) return;
+
+    if (offset == GWL_EXSTYLE && (changed & WS_EX_LAYERED)) /* changing WS_EX_LAYERED resets attributes */
+    {
+        if (is_argb_surface( data->surface ))
+        {
+            if (data->surface) window_surface_release( data->surface );
+            data->surface = NULL;
+        }
+        else ioctl_set_window_layered( hwnd, CLR_INVALID, 255 );
+    }
+
+    release_win_data( data );
+}
+
+
+/*****************************************************************
+ *		ANDROID_SetWindowIcon
+ */
+void CDECL ANDROID_SetWindowIcon( HWND hwnd, UINT type, HICON icon )
+{
+    if (type != ICON_BIG) return;  /* small icons not supported */
+    fetch_window_icon( hwnd, icon );
+}
+
+
+/*****************************************************************
+ *		ANDROID_SetWindowText
+ */
+void CDECL ANDROID_SetWindowText( HWND hwnd, WCHAR *text /* technically const */ )
+{
+    ioctl_set_window_text( hwnd, text );
+}
+
+
+/***********************************************************************
+ *		ANDROID_SetWindowRgn
+ */
+void CDECL ANDROID_SetWindowRgn( HWND hwnd, HRGN hrgn, BOOL redraw )
+{
+    struct android_win_data *data;
+
+    if ((data = get_win_data( hwnd )))
+    {
+        if (data->surface) set_surface_region( data->surface, hrgn );
+        release_win_data( data );
+    }
+    else FIXME( "not supported on other process window %p\n", hwnd );
+
+    ioctl_set_window_rgn( hwnd, hrgn );
+}
+
+
+/***********************************************************************
+ *		ANDROID_SetCapture
+ */
+void CDECL ANDROID_SetCapture( HWND hwnd, UINT flags )
+{
+    if (!(flags & (GUI_INMOVESIZE | GUI_INMENUMODE))) return;
+    ioctl_set_capture( hwnd );
+}
+
+
+/***********************************************************************
+ *		ANDROID_SetLayeredWindowAttributes
+ */
+void CDECL ANDROID_SetLayeredWindowAttributes( HWND hwnd, COLORREF key, BYTE alpha, DWORD flags )
+{
+    struct android_win_data *data;
+
+    if (!(flags & LWA_ALPHA)) alpha = 255;
+    if (!(flags & LWA_COLORKEY)) key = CLR_INVALID;
+
+    if ((data = get_win_data( hwnd )))
+    {
+        if (data->surface) set_surface_color_key( data->surface, key );
+        release_win_data( data );
+    }
+    ioctl_set_window_layered( hwnd, key, alpha );
+}
+
+
+/*****************************************************************************
+ *              ANDROID_UpdateLayeredWindow
+ */
+BOOL CDECL ANDROID_UpdateLayeredWindow( HWND hwnd, const UPDATELAYEREDWINDOWINFO *info,
+                                        const RECT *window_rect )
+{
+    struct window_surface *surface;
+    struct android_win_data *data;
+    BLENDFUNCTION blend = { AC_SRC_OVER, 0, 255, 0 };
+    COLORREF color_key = (info->dwFlags & ULW_COLORKEY) ? info->crKey : CLR_INVALID;
+    char buffer[FIELD_OFFSET( BITMAPINFO, bmiColors[256] )];
+    BITMAPINFO *bmi = (BITMAPINFO *)buffer;
+    void *src_bits, *dst_bits;
+    RECT rect;
+    HDC hdc = 0;
+    HBITMAP dib;
+    BOOL ret = FALSE;
+
+    if (!(data = get_win_data( hwnd ))) return FALSE;
+
+    rect = *window_rect;
+    OffsetRect( &rect, -window_rect->left, -window_rect->top );
+
+    surface = data->surface;
+    if (!is_argb_surface( surface ))
+    {
+        if (surface) window_surface_release( surface );
+        surface = NULL;
+    }
+
+    if (!surface || memcmp( &surface->rect, &rect, sizeof(RECT) ))
+    {
+        data->surface = create_surface( data->hwnd, &rect, color_key, TRUE );
+        if (surface) window_surface_release( surface );
+        surface = data->surface;
+    }
+    else set_surface_color_key( surface, color_key );
+
+    if (surface) window_surface_add_ref( surface );
+    release_win_data( data );
+
+    if (!surface) return FALSE;
+    if (!info->hdcSrc)
+    {
+        window_surface_release( surface );
+        return TRUE;
+    }
+
+    dst_bits = surface->funcs->get_info( surface, bmi );
+
+    if (!(dib = CreateDIBSection( info->hdcDst, bmi, DIB_RGB_COLORS, &src_bits, NULL, 0 ))) goto done;
+    if (!(hdc = CreateCompatibleDC( 0 ))) goto done;
+
+    SelectObject( hdc, dib );
+
+    surface->funcs->lock( surface );
+
+    if (info->prcDirty)
+    {
+        IntersectRect( &rect, &rect, info->prcDirty );
+        memcpy( src_bits, dst_bits, bmi->bmiHeader.biSizeImage );
+        PatBlt( hdc, rect.left, rect.top, rect.right - rect.left, rect.bottom - rect.top, BLACKNESS );
+    }
+    ret = GdiAlphaBlend( hdc, rect.left, rect.top, rect.right - rect.left, rect.bottom - rect.top,
+                         info->hdcSrc,
+                         rect.left + (info->pptSrc ? info->pptSrc->x : 0),
+                         rect.top + (info->pptSrc ? info->pptSrc->y : 0),
+                         rect.right - rect.left, rect.bottom - rect.top,
+                         (info->dwFlags & ULW_ALPHA) ? *info->pblend : blend );
+    if (ret)
+    {
+        memcpy( dst_bits, src_bits, bmi->bmiHeader.biSizeImage );
+        add_bounds_rect( surface->funcs->get_bounds( surface ), &rect );
+    }
+
+    surface->funcs->unlock( surface );
+    surface->funcs->flush( surface );
+
+done:
+    window_surface_release( surface );
+    if (hdc) DeleteDC( hdc );
+    if (dib) DeleteObject( dib );
+    return ret;
+}
+
+
+/**********************************************************************
+ *           ANDROID_WindowMessage
+ */
+LRESULT CDECL ANDROID_WindowMessage( HWND hwnd, UINT msg, WPARAM wp, LPARAM lp )
+{
+    struct android_win_data *data;
+
+    switch (msg)
+    {
+    case WM_ANDROID_REFRESH:
+        if ((data = get_win_data( hwnd )))
+        {
+            struct window_surface *surface = data->surface;
+            if (surface)
+            {
+                surface->funcs->lock( surface );
+                *surface->funcs->get_bounds( surface ) = surface->rect;
+                surface->funcs->unlock( surface );
+            }
+            release_win_data( data );
+        }
+        return 0;
+    case WM_ANDROID_IME_CONTROL:
+        return Ime_Control(hwnd, msg, wp, lp);
+    case WM_ANDROID_RENDERFORMAT:
+        ioctl_render_clipboard_data( (int)wp );
+        return 0;
+    case WM_ANDROID_CLIPBOARD_REQUEST:
+        handle_clipboard_request( (int)wp );
+        return 0;
+    default:
+        FIXME( "got window msg %x hwnd %p wp %lx lp %lx\n", msg, hwnd, wp, lp );
+        return 0;
+    }
+}
+
+
+/***********************************************************************
+ *		ANDROID_create_desktop
+ */
+BOOL CDECL ANDROID_create_desktop( UINT width, UINT height )
+{
+    /* wait until we receive the surface changed event */
+    while (!screen_width)
+    {
+        if (wait_events( 2000 ) != 1)
+        {
+            ERR( "wait timed out\n" );
+            break;
+        }
+        process_events( QS_ALLINPUT );
+    }
+    return TRUE;
+}
diff -Naur wine-2.0a/dlls/wineandroid.drv/wineandroid.drv.spec wine-2.0b/dlls/wineandroid.drv/wineandroid.drv.spec
--- wine-2.0a/dlls/wineandroid.drv/wineandroid.drv.spec	1970-01-01 01:00:00.000000000 +0100
+++ wine-2.0b/dlls/wineandroid.drv/wineandroid.drv.spec	2017-07-11 20:37:51.000000000 +0100
@@ -0,0 +1,98 @@
+# GDI driver
+
+@ cdecl wine_get_gdi_driver(long) ANDROID_get_gdi_driver
+
+# USER driver
+
+## @ cdecl ActivateKeyboardLayout(long long) ANDROID_ActivateKeyboardLayout
+## @ cdecl Beep() ANDROID_Beep
+@ cdecl GetKeyNameText(long ptr long) ANDROID_GetKeyNameText
+@ cdecl GetKeyboardLayout(long) ANDROID_GetKeyboardLayout
+## @ cdecl GetKeyboardLayoutName(ptr) ANDROID_GetKeyboardLayoutName
+## @ cdecl LoadKeyboardLayout(wstr long) ANDROID_LoadKeyboardLayout
+@ cdecl MapVirtualKeyEx(long long long) ANDROID_MapVirtualKeyEx
+@ cdecl ToUnicodeEx(long long ptr ptr long long long) ANDROID_ToUnicodeEx
+## @ cdecl UnloadKeyboardLayout(long) ANDROID_UnloadKeyboardLayout
+@ cdecl VkKeyScanEx(long long) ANDROID_VkKeyScanEx
+## @ cdecl DestroyCursorIcon(long) ANDROID_DestroyCursorIcon
+## @ cdecl SetCursor(long) ANDROID_SetCursor
+## @ cdecl GetCursorPos(ptr) ANDROID_GetCursorPos
+## @ cdecl SetCursorPos(long long) ANDROID_SetCursorPos
+## @ cdecl ClipCursor(ptr) ANDROID_ClipCursor
+@ cdecl ChangeDisplaySettingsEx(ptr ptr long long long) ANDROID_ChangeDisplaySettingsEx
+@ cdecl EnumDisplayMonitors(long ptr ptr long) ANDROID_EnumDisplayMonitors
+@ cdecl EnumDisplaySettingsEx(ptr long ptr long) ANDROID_EnumDisplaySettingsEx
+@ cdecl GetMonitorInfo(long ptr) ANDROID_GetMonitorInfo
+## @ cdecl AcquireClipboard(long) ANDROID_AcquireClipboard
+@ cdecl CountClipboardFormats() ANDROID_CountClipboardFormats
+@ cdecl CreateDesktopWindow(long) ANDROID_CreateDesktopWindow
+@ cdecl CreateWindow(long) ANDROID_CreateWindow
+@ cdecl DestroyWindow(long) ANDROID_DestroyWindow
+@ cdecl EmptyClipboard(long) ANDROID_EmptyClipboard
+@ cdecl EndClipboardUpdate() ANDROID_EndClipboardUpdate
+@ cdecl EnumClipboardFormats(long) ANDROID_EnumClipboardFormats
+@ cdecl GetClipboardData(long) ANDROID_GetClipboardData
+## @ cdecl GetDC(long long long ptr ptr long) ANDROID_GetDC
+@ cdecl IsClipboardFormatAvailable(long) ANDROID_IsClipboardFormatAvailable
+@ cdecl MsgWaitForMultipleObjectsEx(long ptr long long long) ANDROID_MsgWaitForMultipleObjectsEx
+## @ cdecl ReleaseDC(long long) ANDROID_ReleaseDC
+## @ cdecl ScrollDC(long long long ptr ptr long ptr) ANDROID_ScrollDC
+@ cdecl SetClipboardData(long long long) ANDROID_SetClipboardData
+@ cdecl SetCapture(long long) ANDROID_SetCapture
+@ cdecl SetFocus(long) ANDROID_SetFocus
+@ cdecl SetLayeredWindowAttributes(long long long long) ANDROID_SetLayeredWindowAttributes
+@ cdecl SetParent(long long long) ANDROID_SetParent
+@ cdecl SetWindowIcon(long long long) ANDROID_SetWindowIcon
+@ cdecl SetWindowRgn(long long long) ANDROID_SetWindowRgn
+@ cdecl SetWindowStyle(ptr long ptr) ANDROID_SetWindowStyle
+@ cdecl SetWindowText(long wstr) ANDROID_SetWindowText
+@ cdecl ShowWindow(long long ptr long) ANDROID_ShowWindow
+## @ cdecl SysCommand(long long long) ANDROID_SysCommand
+@ cdecl UpdateLayeredWindow(long ptr ptr) ANDROID_UpdateLayeredWindow
+@ cdecl WindowMessage(long long long long) ANDROID_WindowMessage
+@ cdecl WindowPosChanging(long long long ptr ptr ptr ptr) ANDROID_WindowPosChanging
+@ cdecl WindowPosChanged(long long long ptr ptr ptr ptr ptr) ANDROID_WindowPosChanged
+## @ cdecl SystemParametersInfo(long long ptr long) ANDROID_SystemParametersInfo
+
+# WinTab32
+## @ cdecl AttachEventQueueToTablet(long) ANDROID_AttachEventQueueToTablet
+## @ cdecl GetCurrentPacket(ptr) ANDROID_GetCurrentPacket
+## @ cdecl LoadTabletInfo(long) ANDROID_LoadTabletInfo
+## @ cdecl WTInfoW(long long ptr) ANDROID_WTInfoW
+
+# Desktop
+@ cdecl wine_create_desktop(long long) ANDROID_create_desktop
+
+# System tray
+## @ cdecl wine_notify_icon(long ptr)
+
+#IME Interface
+@ stdcall ImeInquire(ptr ptr wstr)
+@ stdcall ImeConfigure(long long long ptr)
+@ stdcall ImeDestroy(long)
+@ stdcall ImeEscape(long long ptr)
+@ stdcall ImeSelect(long long)
+@ stdcall ImeSetActiveContext(long long)
+@ stdcall ImeToAsciiEx(long long ptr ptr long long)
+@ stdcall NotifyIME(long long long long)
+@ stdcall ImeRegisterWord(wstr long wstr)
+@ stdcall ImeUnregisterWord(wstr long wstr)
+@ stdcall ImeEnumRegisterWord(ptr wstr long wstr ptr)
+@ stdcall ImeSetCompositionString(long long ptr long ptr long)
+@ stdcall ImeConversionList(long wstr ptr long long)
+@ stdcall ImeProcessKey(long long long ptr)
+@ stdcall ImeGetRegisterWordStyle(long ptr)
+@ stdcall ImeGetImeMenuItems(long long long ptr ptr long)
+
+# MMDevAPI driver functions
+@ stdcall -private GetPriority() AUDDRV_GetPriority
+@ stdcall -private GetEndpointIDs(long ptr ptr ptr ptr) AUDDRV_GetEndpointIDs
+@ stdcall -private GetAudioEndpoint(ptr ptr ptr) AUDDRV_GetAudioEndpoint
+@ stdcall -private GetAudioSessionManager(ptr ptr) AUDDRV_GetAudioSessionManager
+
+# dinput driver functions
+@ stdcall -private GamePadCount()
+@ stdcall -private GamePadName(long ptr long)
+@ stdcall -private GamePadElementCount(long ptr ptr ptr ptr)
+@ stdcall -private GamePadElementProps(long long ptr ptr)
+@ stdcall -private GamePadPollValues(long ptr)
diff -Naur wine-2.0a/dlls/wineandroid.drv/WineDriver.java wine-2.0b/dlls/wineandroid.drv/WineDriver.java
--- wine-2.0a/dlls/wineandroid.drv/WineDriver.java	1970-01-01 01:00:00.000000000 +0100
+++ wine-2.0b/dlls/wineandroid.drv/WineDriver.java	2017-07-11 20:37:51.000000000 +0100
@@ -0,0 +1,1369 @@
+/*
+ * WineDriver class
+ *
+ * Copyright 2013 Alexandre Julliard
+ */
+
+package org.winehq.wine;
+
+import android.app.Activity;
+import android.app.ProgressDialog;
+import android.content.ClipboardManager;
+import android.content.ClipData;
+import android.content.ClipDescription;
+import android.content.ContentProvider;
+import android.content.res.Configuration;
+import android.graphics.Bitmap;
+import android.graphics.drawable.BitmapDrawable;
+import android.graphics.Rect;
+import android.graphics.SurfaceTexture;
+import android.net.Uri;
+import android.os.Build;
+import android.os.Bundle;
+import android.os.Environment;
+import android.text.TextUtils;
+import android.util.AttributeSet;
+import android.util.Log;
+import android.view.InputDevice;
+import android.view.KeyEvent;
+import android.view.Menu;
+import android.view.MenuInflater;
+import android.view.MenuItem;
+import android.view.MotionEvent;
+import android.view.Surface;
+import android.view.TextureView;
+import android.view.View;
+import android.view.ViewGroup;
+import android.view.WindowManager;
+import android.widget.AdapterView;
+import android.widget.TextView;
+import android.widget.Toast;
+import java.lang.ClassNotFoundException;
+import java.io.ByteArrayOutputStream;
+import java.io.File;
+import java.io.IOException;
+import java.io.OutputStream;
+import java.io.PipedInputStream;
+import java.io.PipedOutputStream;
+import java.nio.charset.Charset;
+import java.nio.ByteBuffer;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.LinkedList;
+import java.util.Map;
+import java.util.Map.Entry;
+
+import android.view.inputmethod.EditorInfo;
+import android.view.inputmethod.InputConnection;
+import android.view.inputmethod.BaseInputConnection;
+import android.view.inputmethod.CompletionInfo;
+import android.view.inputmethod.CorrectionInfo;
+import android.text.Spannable;
+import android.text.Editable;
+import android.view.inputmethod.ExtractedTextRequest;
+import android.view.inputmethod.ExtractedText;
+import android.text.InputType;
+import android.view.KeyCharacterMap;
+
+public class WineDriver extends Object
+{
+    private native String wine_init( String[] cmdline, String[] env );
+
+    private Activity activity;
+    private ProgressDialog progDlg;
+    private TextView progressStatusText;
+    private int startupDpi;
+    private boolean firstRun;
+
+    private String providerAuthority;
+    private static WineDriver clipboard_driver;
+
+    public WineDriver( Activity act )
+    {
+        activity = act;
+        clipboard_driver = this;
+    }
+
+    private Activity getActivity()
+    {
+        return activity;
+    }
+
+    private void runOnUiThread( Runnable r )
+    {
+        activity.runOnUiThread( r );
+    }
+
+    private final void runWine( String libwine, HashMap<String,String> wineEnv, String[] cmdline )
+    {
+        System.load( libwine );
+
+        File prefix = new File( wineEnv.get( "WINEPREFIX" ) );
+        prefix.mkdirs();
+
+        String[] env = new String[wineEnv.size() * 2];
+        int j = 0;
+        for (Map.Entry<String,String> entry : wineEnv.entrySet())
+        {
+            env[j++] = entry.getKey();
+            env[j++] = entry.getValue();
+        }
+
+        runOnUiThread( new Runnable() { public void run() { initProgDlg(); } } );
+
+        String[] cmd = new String[3 + cmdline.length];
+        cmd[0] = wineEnv.get( "WINELOADER" );
+        cmd[1] = "explorer.exe";
+        cmd[2] = "/desktop=" + get_desktop_name() + ",,android";
+        System.arraycopy( cmdline, 0, cmd, 3, cmdline.length );
+
+        String cmd_str = "";
+        for (String s : cmd) cmd_str += " " + s;
+        Log.i( "wine", "Running startup program:" + cmd_str );
+
+        String err = wine_init( cmd, env );
+        Log.e( "wine", err );
+    }
+
+    private void initProgDlg()
+    {
+        progDlg = new ProgressDialog( activity );
+        progDlg.setTitle( "Initialization in progress" );
+        progDlg.setMessage( "Setting up virtual Windows environment" );
+        progDlg.setMax( 1 );
+        progDlg.show();
+    }
+
+    public void setStartupDpi( int dpi )
+    {
+        startupDpi = dpi;
+    }
+
+    public void loadWine( final String libwine, final HashMap<String,String> wineEnv, final String[] cmdline )
+    {
+        firstRun = !(new File ( wineEnv.get( "WINEPREFIX" ) ).exists());
+        String existing = firstRun ? "new" : "existing";
+        Log.i( "wine", "Initializing wine in " + existing + " prefix " + wineEnv.get( "WINEPREFIX" ) );
+        Runnable main_thread = new Runnable() { public void run() { runWine( libwine, wineEnv, cmdline ); } };
+        new Thread( main_thread ).start();
+    }
+
+    public void runCmdline( final String cmdline, HashMap<String,String> envMap )
+    {
+        String[] env = null;
+        Log.i( "wine", "Running command line: " + cmdline );
+        if (cmdline == null) return;
+
+        if (envMap != null)
+        {
+            int j = 0;
+            env = new String[envMap.size() * 2];
+            for (Map.Entry<String,String> entry : envMap.entrySet())
+            {
+                env[j++] = entry.getKey();
+                env[j++] = entry.getValue();
+            }
+        }
+
+        wine_run_commandline( cmdline, env );
+    }
+
+    public void setProviderAuthority( final String authority )
+    {
+        this.providerAuthority = authority;
+    }
+
+    protected String get_desktop_name()
+    {
+        return "shell";
+    }
+
+    public native void wine_send_gamepad_count(int count);
+    public native void wine_send_gamepad_data(int index, int id, String name);
+    public native void wine_send_gamepad_axis(int device, float[] axis);
+    public native void wine_send_gamepad_button(int device, int button, int value);
+
+    public native void wine_ime_start();
+    public native void wine_ime_settext( String text, int length, int cursor );
+    public native void wine_ime_finishtext();
+    public native void wine_ime_canceltext();
+
+    protected class WineInputConnection extends BaseInputConnection
+    {
+        KeyCharacterMap mKeyCharacterMap;
+
+        public WineInputConnection( WineView targetView )
+        {
+            super( targetView, true);
+        }
+
+        public boolean beginBatchEdit()
+        {
+            Log.i("wine", "beginBatchEdit");
+            return true;
+        }
+
+        public boolean clearMetaKeyStates (int states)
+        {
+            Log.i("wine", "clearMetaKeyStates");
+            wine_clear_meta_key_states( states );
+            return super.clearMetaKeyStates (states);
+        }
+
+        public boolean commitCompletion (CompletionInfo text)
+        {
+            Log.i("wine", "commitCompletion");
+            return super.commitCompletion (text);
+        }
+
+        public boolean commitCorrection (CorrectionInfo correctionInfo)
+        {
+            Log.i("wine", "commitCorrection");
+            return super.commitCorrection (correctionInfo);
+        }
+
+        public boolean commitText (CharSequence text, int newCursorPosition)
+        {
+            Log.i("wine", "commitText: '"+text.toString()+"'");
+
+            super.commitText (text, newCursorPosition);
+
+            /* This code based on BaseInputConnection in order to generate
+                keystroke events for single character mappable input */
+            Editable content = getEditable();
+            if (content != null)
+            {
+                final int N = content.length();
+                if (N == 1)
+                {
+                    // If it's 1 character, we have a chance of being
+                    // able to generate normal key events...
+                    if (mKeyCharacterMap == null)
+                    {
+                        mKeyCharacterMap = KeyCharacterMap.load(
+                                KeyCharacterMap.BUILT_IN_KEYBOARD);
+                    }
+                    char[] chars = new char[1];
+                    content.getChars(0, 1, chars, 0);
+                    KeyEvent[] events = mKeyCharacterMap.getEvents(chars);
+                    if (events != null)
+                    {
+                        wine_ime_canceltext();
+                        for (int i=0; i<events.length; i++)
+                        {
+                            sendKeyEvent(events[i]);
+                        }
+                        content.clear();
+                        return true;
+                    }
+                }
+
+                wine_ime_start();
+                wine_ime_settext( content.toString(), content.length(), newCursorPosition );
+                wine_ime_finishtext();
+                content.clear();
+            }
+            return true;
+        }
+
+        public boolean deleteSurroundingText (int beforeLength, int afterLength)
+        {
+            Log.i("wine", "deleteSurroundingText :"+beforeLength+","+afterLength);
+            super.deleteSurroundingText (beforeLength, afterLength);
+            return true;
+        }
+
+        public boolean endBatchEdit ()
+        {
+            Log.i("wine", "endBatchEdit");
+            return true;
+        }
+
+        public boolean finishComposingText ()
+        {
+            Log.i("wine", "finishComposingText");
+            wine_ime_finishtext();
+            Editable content = getEditable();
+            if (content != null)
+                content.clear();
+            return super.finishComposingText ();
+        }
+
+        public int getCursorCapsMode (int reqModes)
+        {
+            Log.i("wine", "getCursorCapsMode");
+            return super.getCursorCapsMode (reqModes);
+        }
+
+        public Editable getEditable ()
+        {
+            Log.i("wine", "getEditable");
+            return super.getEditable ();
+        }
+
+        public ExtractedText getExtractedText (ExtractedTextRequest request, int flags)
+        {
+            Log.i("wine", "getExtractedText");
+            super.getExtractedText (request, flags);
+            return null;
+        }
+
+        public CharSequence getSelectedText (int flags)
+        {
+            Log.i("wine", "getSelectedText");
+            super.getSelectedText (flags);
+            return null;
+        }
+
+        public CharSequence getTextAfterCursor (int length, int flags)
+        {
+            Log.i("wine", "getTextAfterCursor");
+            return super.getTextAfterCursor (length, flags);
+        }
+
+        public CharSequence getTextBeforeCursor (int length, int flags)
+        {
+            Log.i("wine", "getTextBeforeCursor");
+            return super.getTextBeforeCursor (length, flags);
+        }
+
+        public boolean performContextMenuAction (int id)
+        {
+            Log.i("wine", "performContextMenuAction");
+            return super.performContextMenuAction (id);
+        }
+
+        public boolean performEditorAction (int actionCode)
+        {
+            Log.i("wine", "performEditorAction");
+            return super.performEditorAction (actionCode);
+        }
+
+        public boolean performPrivateCommand (String action, Bundle data)
+        {
+            Log.i("wine", "performPrivateCommand");
+            return super.performPrivateCommand (action, data);
+        }
+
+        public boolean reportFullscreenMode (boolean enabled)
+        {
+            Log.i("wine", "reportFullscreenMode");
+            return super.reportFullscreenMode (enabled);
+        }
+
+        public boolean sendKeyEvent (KeyEvent event)
+        {
+            Log.i("wine", "sendKeyEvent");
+            return super.sendKeyEvent (event);
+        }
+
+        public boolean setComposingRegion (int start, int end)
+        {
+            Log.i("wine", "setComposingRegion");
+            return super.setComposingRegion (start, end);
+        }
+
+        public boolean setComposingText (CharSequence text, int newCursorPosition)
+        {
+            Log.i("wine", "setComposingText");
+            Log.i("wine", "composeText: "+text.toString());
+            wine_ime_start();
+            wine_ime_settext( text.toString(), text.length(), newCursorPosition );
+            return super.setComposingText (text, newCursorPosition);
+        }
+
+        public boolean setSelection (int start, int end)
+        {
+            Log.i("wine", "setSelection");
+            return super.setSelection (start, end);
+        }
+    }
+
+    public native boolean wine_keyboard_event( int hwnd, int action, int keycode, int scancode, int state );
+    public native boolean wine_motion_event( int hwnd, int action, int x, int y, int state, int vscroll );
+    public native void wine_surface_changed( int hwnd, Surface surface );
+    public native void wine_desktop_changed( int width, int height );
+    public native void wine_config_changed( int dpi, boolean force );
+    public native void wine_clipboard_changed( boolean[] formats_present );
+    public native void wine_import_clipboard_data( int index, byte[] data );
+    public native void wine_clipboard_request( int index );
+    private native void wine_run_commandline( String cmdline, String[] wineEnv );
+    public native void wine_clear_meta_key_states( int states );
+
+    //
+    // Generic Wine window class
+    //
+
+    private HashMap<Integer,WineWindow> win_map = new HashMap<Integer,WineWindow>();
+    private ArrayList<WineWindow> win_list = new ArrayList<WineWindow>();
+
+    protected class WineWindow extends Object
+    {
+        static protected final int CLR_INVALID = 0xffffffff;
+        static protected final int HWND_TOP = 0;
+        static protected final int HWND_TOPMOST = 0xffffffff;
+        static protected final int SWP_NOZORDER = 0x04;
+        static protected final int SWP_SHOWWINDOW = 0x40;
+        static protected final int SWP_HIDEWINDOW = 0x80;
+
+        protected int hwnd;
+        protected int owner;
+        protected int region;
+        protected int color_key;
+        protected int alpha;
+        protected boolean visible;
+        protected boolean has_alpha;
+        protected boolean use_gl;
+        protected Rect rect;
+        protected String text;
+        protected BitmapDrawable icon;
+        protected Surface surface;
+
+        public WineWindow( int w )
+        {
+            Log.i( "wine", String.format( "create hwnd %08x", w ));
+            hwnd = w;
+            owner = 0;
+            region = 0;
+            color_key = CLR_INVALID;
+            alpha = 0;
+            visible = false;
+            has_alpha = false;
+            use_gl = false;
+            rect = new Rect( 0, 0, 0, 0 );
+            win_map.put( w, this );
+        }
+
+        public void destroy()
+        {
+            Log.i( "wine", String.format( "destroy hwnd %08x", hwnd ));
+            if (visible)
+            {
+                visible = false;
+                win_list.remove( this );
+            }
+            win_map.remove( this );
+        }
+
+        public void pos_changed( int flags, int insert_after, int new_owner, int style,
+                                 int left, int top, int right, int bottom )
+        {
+            rect = new Rect( left, top, right, bottom );
+            owner = new_owner;
+            Log.i( "wine", String.format( "pos changed hwnd %08x after %08x owner %08x style %08x rect %s flags %08x",
+                                          hwnd, insert_after, owner, style, rect, flags ));
+            if (!visible && ((flags & SWP_SHOWWINDOW) != 0))
+            {
+                visible = true;
+                win_list.add( this );
+            }
+            else if (visible && ((flags & SWP_HIDEWINDOW) != 0))
+            {
+                visible = false;
+                win_list.remove( this );
+            }
+        }
+
+        public void focus()
+        {
+            Log.i( "wine", String.format( "focus hwnd %08x", hwnd ));
+        }
+
+        public void set_text( String str )
+        {
+            Log.i( "wine", String.format( "set text hwnd %08x '%s'", hwnd, str ));
+            text = str;
+        }
+
+        public void set_icon( BitmapDrawable bmp )
+        {
+            Log.i( "wine", String.format( "set icon hwnd %08x", hwnd ));
+            icon = bmp;
+        }
+
+        public void set_region( int rgn )
+        {
+            Log.i( "wine", String.format( "set region hwnd %08x rgn %08x", hwnd, rgn ));
+            region = rgn;
+        }
+
+        public void set_layered( int key, int a )
+        {
+            Log.i( "wine", String.format( "set layered hwnd %08x key %08x alpha %d", hwnd, key, a ));
+            color_key = key;
+            alpha = a;
+        }
+
+        public void set_alpha( boolean a )
+        {
+            Log.i( "wine", String.format( "set alpha hwnd %08x %b", hwnd, a ));
+            has_alpha = a;
+        }
+
+        public void set_surface( SurfaceTexture surftex )
+        {
+            if (surftex == null) surface = null;
+            else if (surface == null) surface = new Surface( surftex );
+            Log.i( "wine", String.format( "set surface hwnd %08x %s", hwnd, surface ));
+            wine_surface_changed( hwnd, surface );
+        }
+
+        public void start_opengl()
+        {
+            Log.i( "wine", String.format( "start opengl hwnd %08x", hwnd ));
+            use_gl = true;
+        }
+
+        public boolean is_opaque()
+        {
+            return !has_alpha && region == 0 && color_key == CLR_INVALID;
+        }
+
+        public void get_event_pos( MotionEvent event, int[] pos )
+        {
+            pos[0] = Math.round( event.getRawX() );
+            pos[1] = Math.round( event.getRawY() );
+        }
+    }
+
+    //
+    // Wine window implementation using a simple view for each window
+    //
+
+    protected class WineWindowView extends WineWindow
+    {
+        protected WineView view;
+
+        public WineWindowView( Activity activity, int w )
+        {
+            super( w );
+            view = new WineView( activity, this );
+            if (top_view != null) top_view.addView( view );
+        }
+
+        public WineView get_view()
+        {
+            return view;
+        }
+
+        public void destroy()
+        {
+            top_view.removeView( view );
+            view = null;
+            super.destroy();
+        }
+
+        public void pos_changed( int flags, int insert_after, int new_owner, int style,
+                                 int left, int top, int right, int bottom )
+        {
+            boolean show = !visible && ((flags & SWP_SHOWWINDOW) != 0);
+            boolean hide = visible && ((flags & SWP_HIDEWINDOW) != 0);
+
+            if (!show && (!visible || hide))
+            {
+                /* move it off-screen, except that if the texture still needs to be created
+                 * we put one pixel on-screen */
+                if (surface == null)
+                    view.layout( left - right + 1, top - bottom + 1, 1, 1 );
+                else
+                    view.layout( left - right, top - bottom, 0, 0 );
+            }
+            else view.layout( left, top, right, bottom );
+
+            if (show)
+            {
+                view.setFocusable( true );
+                view.setFocusableInTouchMode( true );
+            }
+            else if (hide)
+            {
+                view.setFocusable( false );
+                view.setFocusableInTouchMode( false );
+            }
+
+            if ((flags & SWP_NOZORDER) == 0 &&
+                (insert_after == HWND_TOP || insert_after == HWND_TOPMOST))
+                view.bringToFront();
+
+            super.pos_changed( flags, insert_after, new_owner, style, left, top, right, bottom );
+            top_view.update_action_bar();
+        }
+
+        public void focus()
+        {
+            super.focus();
+            view.setFocusable( true );
+            view.setFocusableInTouchMode( true );
+            view.bringToFront();
+            view.updateGamepads();
+            top_view.update_action_bar();
+        }
+
+        public void set_text( String str )
+        {
+            super.set_text( str );
+            top_view.update_action_bar();
+        }
+
+        public void set_icon( BitmapDrawable bmp )
+        {
+            super.set_icon( bmp );
+            top_view.update_action_bar();
+        }
+
+        public void set_region( int rgn )
+        {
+            super.set_region( rgn );
+            view.setOpaque( is_opaque() );
+        }
+
+        public void set_layered( int key, int a )
+        {
+            super.set_layered( key, a );
+            view.setAlpha( a / 255.0f );
+            view.setOpaque( is_opaque() );
+        }
+
+        public void set_alpha( boolean a )
+        {
+            super.set_alpha( a );
+            view.setOpaque( is_opaque() );
+        }
+
+        public void set_surface( SurfaceTexture surftex )
+        {
+            // move it off-screen if we got a surface while not visible
+            if (!visible && surface == null && surftex != null)
+            {
+                Log.i("wine",String.format("hwnd %08x not visible, moving offscreen", hwnd));
+                view.layout( rect.left - rect.right, rect.top - rect.bottom, 0, 0 );
+            }
+            super.set_surface( surftex );
+        }
+
+        public void get_event_pos( MotionEvent event, int[] pos )
+        {
+            pos[0] = Math.round( event.getX() + view.getLeft() );
+            pos[1] = Math.round( event.getY() + view.getTop() );
+        }
+    }
+
+    protected class WineView extends TextureView implements TextureView.SurfaceTextureListener
+    {
+        static final int CLR_INVALID = 0xffffffff;
+
+        private WineWindow window;
+
+        public WineView( Activity act, WineWindow win )
+        {
+            super( act );
+            window = win;
+            setSurfaceTextureListener( this );
+            setVisibility( View.VISIBLE );
+        }
+
+        public WineView( AttributeSet attrs )
+        {
+            super( getActivity(), attrs );
+        }
+
+        private final void updateGamepads()
+        {
+            ArrayList<Integer> gameControllerDeviceIds = new ArrayList<Integer>();
+            ArrayList<String> gameControllerDeviceNames = new ArrayList<String>();
+            int[] deviceIds = InputDevice.getDeviceIds();
+
+            for (int deviceId : deviceIds)
+            {
+                InputDevice dev = InputDevice.getDevice(deviceId);
+                int sources = dev.getSources();
+
+                if (((sources & InputDevice.SOURCE_GAMEPAD) == InputDevice.SOURCE_GAMEPAD)
+                || ((sources & InputDevice.SOURCE_JOYSTICK)
+                == InputDevice.SOURCE_JOYSTICK))
+                {
+                    if (!gameControllerDeviceIds.contains(deviceId))
+                    {
+                        gameControllerDeviceIds.add(deviceId);
+                        gameControllerDeviceNames.add(dev.getDescriptor());
+                    }
+                }
+            }
+
+            if (gameControllerDeviceIds.size() > 0)
+            {
+                int count = gameControllerDeviceIds.size();
+                int i;
+
+                wine_send_gamepad_count( count );
+                for (i = 0; i < count; i++)
+                {
+                    int id = gameControllerDeviceIds.get(i);
+                    String name = gameControllerDeviceNames.get(i);
+                    wine_send_gamepad_data(i, id, name);
+                }
+            }
+        }
+
+        private float getCenteredAxis(MotionEvent event, InputDevice device, int axis)
+        {
+            final InputDevice.MotionRange range =
+                device.getMotionRange(axis, event.getSource());
+
+            if (range != null)
+            {
+                final float flat = range.getFlat();
+                final float value = event.getAxisValue(axis);
+
+                if (Math.abs(value) > flat)
+                {
+                    return value;
+                }
+            }
+            return 0;
+        }
+
+        public boolean onGenericMotionEvent(MotionEvent event)
+        {
+            Log.i("wine", "view generic motion event");
+            if ((event.getSource() & InputDevice.SOURCE_JOYSTICK) ==
+                InputDevice.SOURCE_JOYSTICK &&
+                event.getAction() == MotionEvent.ACTION_MOVE)
+                {
+                    Log.i("wine", "Joystick Motion");
+                    InputDevice mDevice = event.getDevice();
+                    float[] axis;
+
+                    axis = new float[10];
+                    axis[0] = getCenteredAxis(event, mDevice,  MotionEvent.AXIS_X);
+                    axis[1] = getCenteredAxis(event, mDevice,  MotionEvent.AXIS_Y);
+                    axis[2] = getCenteredAxis(event, mDevice,  MotionEvent.AXIS_Z);
+                    axis[3] = getCenteredAxis(event, mDevice,  MotionEvent.AXIS_RX);
+                    axis[4] = getCenteredAxis(event, mDevice,  MotionEvent.AXIS_RY);
+                    axis[5] = getCenteredAxis(event, mDevice,  MotionEvent.AXIS_RZ);
+                    axis[6] = getCenteredAxis(event, mDevice,  MotionEvent.AXIS_LTRIGGER);
+                    if (axis[6] == 0)
+                        axis[6] = getCenteredAxis(event, mDevice,  MotionEvent.AXIS_BRAKE);
+                    axis[7] = getCenteredAxis(event, mDevice,  MotionEvent.AXIS_RTRIGGER);
+                    if (axis[7] == 0)
+                        axis[7] = getCenteredAxis(event, mDevice,  MotionEvent.AXIS_GAS);
+                    axis[8] = getCenteredAxis(event, mDevice,  MotionEvent.AXIS_HAT_X);
+                    axis[9] = getCenteredAxis(event, mDevice,  MotionEvent.AXIS_HAT_Y);
+
+                    wine_send_gamepad_axis(event.getDeviceId(), axis);
+                    return true;
+                }
+            if ((event.getSource() & InputDevice.SOURCE_CLASS_POINTER) != 0)
+            {
+                int[] pos = new int[2];
+                window.get_event_pos( event, pos );
+                Log.i("wine", String.format( "view motion event win %08x action %d pos %d,%d buttons %04x view %d,%d",
+                                             window.hwnd, event.getAction(), pos[0], pos[1], event.getButtonState(), getLeft(), getTop() ));
+                return wine_motion_event( window.hwnd, event.getAction(), pos[0], pos[1], event.getButtonState(),
+                                          (int)event.getAxisValue(MotionEvent.AXIS_VSCROLL)  );
+            }
+            return super.onGenericMotionEvent(event);
+        }
+
+        public boolean onKeyDown(int keyCode, KeyEvent event)
+        {
+            Log.i("wine", "Keydown");
+            if ((event.getSource() & InputDevice.SOURCE_GAMEPAD)
+                == InputDevice.SOURCE_GAMEPAD)
+            {
+                    Log.i("wine", "Is Gamepad "+keyCode);
+                    wine_send_gamepad_button(event.getDeviceId(), keyCode, 0xff);
+                    return true;
+            }
+            return super.onKeyDown(keyCode, event);
+        }
+
+        public boolean onKeyUp(int keyCode, KeyEvent event)
+        {
+            Log.i("wine", "KeyUp");
+            if ((event.getSource() & InputDevice.SOURCE_GAMEPAD)
+                == InputDevice.SOURCE_GAMEPAD)
+            {
+                    Log.i("wine", "Is Gamepad: "+keyCode);
+                    wine_send_gamepad_button(event.getDeviceId(), keyCode, 0x0);
+                    return true;
+            }
+            return super.onKeyDown(keyCode, event);
+        }
+
+        public boolean onTouchEvent( MotionEvent event )
+        {
+            int[] pos = new int[2];
+            window.get_event_pos( event, pos );
+            Log.i("wine", String.format( "view touch event win %08x action %d pos %d,%d buttons %04x view %d,%d",
+                                         window.hwnd, event.getAction(), pos[0], pos[1], event.getButtonState(), getLeft(), getTop() ));
+            return wine_motion_event( window.hwnd, event.getAction(), pos[0], pos[1], event.getButtonState(), 0 );
+        }
+
+        public boolean dispatchKeyEvent(KeyEvent event)
+        {
+            Log.i("wine", String.format( "view dispatchKeyEvent win %08x action %d keycode %d (%s)",
+                                         window.hwnd, event.getAction(), event.getKeyCode(), event.keyCodeToString( event.getKeyCode() )));;
+            boolean ret = wine_keyboard_event( window.hwnd, event.getAction(), event.getKeyCode(),
+                                               event.getScanCode(), event.getMetaState() );
+            if (!ret) ret = super.dispatchKeyEvent(event);
+            return ret;
+        }
+
+        public void onSurfaceTextureAvailable(SurfaceTexture surftex, int width, int height)
+        {
+            Log.i("wine", String.format( "onSurfaceTextureAvailable win %08x %dx%d", window.hwnd, width, height ));
+            window.set_surface( surftex );
+        }
+
+        public void onSurfaceTextureSizeChanged(SurfaceTexture surftex, int width, int height)
+        {
+            Log.i("wine", String.format( "onSurfaceTextureSizeChanged win %08x %dx%d", window.hwnd, width, height ));
+            window.set_surface( surftex );
+        }
+
+        public boolean onSurfaceTextureDestroyed(SurfaceTexture surftex)
+        {
+            Log.i("wine", String.format( "onSurfaceTextureDestroyed win %08x", window.hwnd ));
+            window.set_surface( null );
+            return true;
+        }
+
+        public void onSurfaceTextureUpdated(SurfaceTexture surftex)
+        {
+        }
+
+        public boolean onCheckIsTextEditor()
+        {
+            Log.i("wine", "onCheckIsTextEditor");
+            return true;
+        }
+
+        public InputConnection onCreateInputConnection( EditorInfo outAttrs )
+        {
+            Log.i("wine", "onCreateInputConnection");
+            outAttrs.inputType = InputType.TYPE_NULL;
+            outAttrs.imeOptions = EditorInfo.IME_NULL;
+            /* Disable voice for now. It double inputs until we can
+               Support deletion of text in the document */
+            outAttrs.privateImeOptions = "nm";
+            return new WineInputConnection( this );
+        }
+    }
+
+    protected class TopView extends ViewGroup implements ClipboardManager.OnPrimaryClipChangedListener
+    {
+        protected WineWindow desktop_win;
+        protected WineView desktop_view;
+        private ClipboardManager clipboard_manager;
+
+        public TopView( int hwnd )
+        {
+            super( getActivity() );
+            desktop_win = new WineWindow( hwnd );
+            desktop_view = new WineView( getActivity(), desktop_win );
+            desktop_win.visible = true;
+            addView( desktop_view );
+
+            clipboard_manager = (ClipboardManager)getActivity().getSystemService( Activity.CLIPBOARD_SERVICE );
+            clipboard_manager.addPrimaryClipChangedListener( this );
+            onPrimaryClipChanged();
+        }
+
+        @Override
+        protected void onSizeChanged( int width, int height, int old_width, int old_height )
+        {
+            Log.i("wine", "desktop size " + width + "x" + height );
+            desktop_view.layout( 0, 0, width, height );
+            wine_desktop_changed( width, height );
+        }
+
+        @Override
+        protected void onLayout( boolean changed, int left, int top, int right, int bottom )
+        {
+            /* nothing to do */
+        }
+
+        @Override
+        public boolean dispatchKeyEvent( KeyEvent event )
+        {
+            return desktop_view.dispatchKeyEvent( event );
+        }
+
+        private void update_action_bar()
+        {
+            for (int i = getChildCount() - 1; i >= 0; i--)
+            {
+                View v = getChildAt( i );
+                if (v instanceof WineView)
+                {
+                    WineView view = (WineView)v;
+                    Log.i( "wine", String.format( "%d: %08x %s", i, view.window.hwnd, view.window.text ));
+                    if (view.window.owner != 0) continue;
+                    if (!view.window.visible) continue;
+                    if (view == desktop_view) continue;
+                    if (view.window.text == null) continue;
+                    getActivity().setTitle( view.window.text );
+                    if (getActivity().getActionBar() != null)
+                    {
+                        if (view.window.icon != null)
+                            getActivity().getActionBar().setIcon( view.window.icon );
+                        else
+                            getActivity().getActionBar().setIcon( R.drawable.wine_launcher );
+                    }
+                    return;
+                }
+            }
+            getActivity().setTitle( R.string.org_winehq_wine_app_name);
+            if (getActivity().getActionBar() != null)
+                getActivity().getActionBar().setIcon( R.drawable.wine_launcher );
+        }
+
+        private String[] format_mimetypes = { "text/plain" };
+
+        // HashMap of mimetype to either:
+        //  * An Integer identifying a mimetype, if Wine has copied data that we don't have yet.
+        //  * A LinkedList of ParcelFileDescriptor objects to which we need to write the data.
+        //  * A byte[] containing the data for this format.
+        private HashMap<String, Object> copying = new HashMap<String, Object>();
+
+        private String[] copying_mimetypes = null;
+
+        private Uri get_clipboard_uri()
+        {
+            String authority = providerAuthority;
+            if (authority == null)
+            {
+                return null;
+            }
+            else
+            {
+                return Uri.parse("content://" + authority + "/copying");
+            }
+        }
+
+        public void onPrimaryClipChanged()
+        {
+            boolean[] formats_present = new boolean[format_mimetypes.length];
+
+            ClipData clipdata = clipboard_manager.getPrimaryClip();
+            ClipDescription clipdesc = null;
+
+            if (clipdata != null)
+            {
+                clipdesc = clipdata.getDescription();
+
+                if (clipdata.getItemCount() >= 1)
+                {
+                    ClipData.Item item = clipdata.getItemAt( 0 );
+
+                    Uri uri = item.getUri();
+                    if (uri != null && uri.equals(get_clipboard_uri()))
+                        /* Wine holds the clipboard, ignore change. */
+                        return;
+                }
+            }
+
+            if (clipdesc != null)
+            {
+                for (int i=0; i < formats_present.length; i++)
+                {
+                    if (format_mimetypes[i] == "text/plain")
+                        /* Android textboxes will try to paste anything, so let's match that. */
+                        formats_present[i] = true;
+                    else
+                        formats_present[i] = clipdesc.hasMimeType( format_mimetypes[i] );
+                }
+            }
+
+            wine_clipboard_changed( formats_present );
+        }
+
+        public void render_clipboard_data( int index )
+        {
+            String mimetype = format_mimetypes[index];
+            byte[] data;
+
+            Log.i( "wine", "render_clipboard_data " + index + " " + mimetype );
+
+            ClipData clipdata = clipboard_manager.getPrimaryClip();
+
+            if (clipdata == null)
+            {
+                data = new byte[0];
+            }
+            else if (mimetype == "text/plain")
+            {
+                Object[] str_list = new Object[clipdata.getItemCount()];
+
+                for (int i=0; i < str_list.length; i++)
+                {
+                    str_list[i] = clipdata.getItemAt( i ).coerceToText( getActivity() );
+                }
+
+                String str_data = TextUtils.join( "\r\n", str_list );
+                data = Charset.forName( "UTF-16LE" ).encode( str_data ).array();
+            }
+            else
+            {
+                data = new byte[0];
+                /* FIXME: Use ContentResolver.openTypedAssetFileDescriptor ? */
+            }
+
+            wine_import_clipboard_data( index, data );
+        }
+
+        void really_acquire_clipboard( String[] mime_types ) throws IOException
+        {
+            // read any text before calling setPrimaryClip
+            PipedInputStream in;
+            PipedOutputStream out;
+
+            in = new PipedInputStream();
+            out = new PipedOutputStream(in);
+
+            serveClipboardData( "text/plain", out );
+
+            ByteArrayOutputStream bs = new ByteArrayOutputStream();
+            byte[] buffer = new byte[4096];
+            int bytesread;
+
+            do
+            {
+                bytesread = in.read(buffer);
+                if (bytesread > 0)
+                {
+                    bs.write( buffer, 0, bytesread );
+                }
+            } while (bytesread > 0);
+
+            CharSequence string = Charset.forName( "UTF-8" ).decode( ByteBuffer.wrap( bs.toByteArray() ) );
+
+            Uri clipboard_uri = get_clipboard_uri();
+
+            if (clipboard_uri == null)
+            {
+                Log.e( "wine", "can't export clipboard because WineDriver.setProviderAuthority wasn't called" );
+                return;
+            }
+
+            ClipData.Item item = new ClipData.Item( string, null, clipboard_uri );
+
+            final ClipData clipdata = new ClipData( "Wine", mime_types, item );
+
+            runOnUiThread( new Runnable() { public void run() {
+                clipboard_manager.setPrimaryClip( clipdata );
+            }} );
+        }
+
+        void acquire_clipboard( boolean[] formats )
+        {
+            Log.i( "wine", "acquire_clipboard" );
+
+            for (Object v : copying.values())
+            {
+                if (v instanceof LinkedList)
+                {
+                    LinkedList<OutputStream> ll = (LinkedList<OutputStream>)v;
+                    for (OutputStream s : ll)
+                    {
+                        try { s.close(); } catch (IOException e) { }
+                    }
+                }
+            }
+            copying.clear();
+
+            HashSet<String> mime_types = new HashSet<String>( formats.length );
+
+            for (int i=0; i<formats.length; i++)
+            {
+                if (formats[i])
+                {
+                    Log.i( "wine", "adding mimetype "+format_mimetypes[i] );
+                    mime_types.add( format_mimetypes[i] );
+                    copying.put( format_mimetypes[i], (Integer)i );
+                }
+            }
+
+            final String[] mime_type_array = mime_types.toArray( new String[0] );
+
+            // Delaying the setPrimaryClip call in an ugly way so we don't deadlock.
+            new Thread( new Runnable() { public void run() {
+                try { really_acquire_clipboard( mime_type_array ); } catch (IOException e) { }
+            }} ).start();
+        }
+
+        void send_clipboard_data( final OutputStream stream, final byte[] data )
+        {
+            new Thread( new Runnable() { public void run() {
+                try { stream.write( data, 0, data.length ); } catch (IOException e) { }
+                try { stream.close(); } catch (IOException e) { }
+            }} ).start();
+        }
+
+        void export_clipboard_data( int index, byte[] data )
+        {
+            Log.i( "wine", "export_clipboard_data "+index );
+            Object v = copying.put( format_mimetypes[index], data );
+            if (v instanceof LinkedList)
+            {
+                LinkedList<OutputStream> ll = (LinkedList<OutputStream>)v;
+                for (OutputStream s : ll)
+                {
+                    send_clipboard_data( s, data );
+                }
+            }
+        }
+
+        void serve_clipboard_data( String mimeType, OutputStream stream )
+        {
+            Object v = copying.get( mimeType );
+            if (v instanceof byte[])
+            {
+                send_clipboard_data( stream, (byte[])v );
+            }
+            else if (v instanceof Integer)
+            {
+                LinkedList<OutputStream> ll = new LinkedList<OutputStream>();
+                ll.add( stream );
+                copying.put( mimeType, ll );
+                wine_clipboard_request( ((Integer)v).intValue() );
+            }
+            else if (v instanceof LinkedList)
+            {
+                LinkedList<OutputStream> ll = (LinkedList<OutputStream>)v;
+                ll.add( stream );
+            }
+            else
+            {
+                /* probably null */
+                try { stream.close(); } catch (IOException e) { }
+            }
+        }
+    }
+
+    protected static TopView top_view;
+
+    protected WineWindow get_window( int hwnd )
+    {
+        return win_map.get( hwnd );
+    }
+
+    public void create_desktop_window( int hwnd )
+    {
+        if (progDlg != null) progDlg.dismiss();
+        Log.i( "wine", "create desktop view " + String.format("%08x",hwnd));
+        top_view = new TopView( hwnd );
+        if (startupDpi == 0)
+            startupDpi = activity.getResources().getConfiguration().densityDpi;
+        wine_config_changed( startupDpi, firstRun );
+    }
+
+    public void create_window( int hwnd, String wingroup )
+    {
+        if (get_window( hwnd ) != null) return;  /* already exists */
+        WineWindowView win = new WineWindowView( activity, hwnd );
+    }
+
+    public void destroy_window( int hwnd )
+    {
+        WineWindow win = get_window( hwnd );
+        if (win != null) win.destroy();
+    }
+
+    public void focus_window( int hwnd )
+    {
+        WineWindow win = get_window( hwnd );
+        if (win != null) win.focus();
+    }
+
+    public void set_window_icon( int hwnd, int width, int height, int icon[] )
+    {
+        WineWindow win = get_window( hwnd );
+        if (win == null) return;
+        BitmapDrawable new_icon = null;
+        if (icon != null) new_icon = new BitmapDrawable( activity.getResources(),
+                                                         Bitmap.createBitmap( icon, width, height, Bitmap.Config.ARGB_8888 ) );
+        win.set_icon( new_icon );
+    }
+
+    public void set_window_text( int hwnd, String text )
+    {
+        WineWindow win = get_window( hwnd );
+        if (win != null) win.set_text( text );
+    }
+
+    public void window_pos_changed( int hwnd, int flags, int insert_after, int owner, int style,
+                                    int left, int top, int right, int bottom )
+    {
+        WineWindow win = get_window( hwnd );
+        if (win != null) win.pos_changed( flags, insert_after, owner, style, left, top, right, bottom );
+    }
+
+    public void set_window_region( int hwnd, int rgn )
+    {
+        WineWindow win = get_window( hwnd );
+        if (win != null) win.set_region( rgn );
+    }
+
+    public void set_window_layered( int hwnd, int key, int alpha )
+    {
+        WineWindow win = get_window( hwnd );
+        if (win != null) win.set_layered( key, alpha );
+    }
+
+    public void set_window_surface( int hwnd, boolean has_alpha )
+    {
+        WineWindow win = get_window( hwnd );
+        if (win != null) win.set_alpha( has_alpha );
+    }
+
+    public void start_window_opengl( int hwnd )
+    {
+        WineWindow win = get_window( hwnd );
+        if (win != null) win.start_opengl();
+    }
+
+    public void render_clipboard_data( int index )
+    {
+        top_view.render_clipboard_data( index );
+    }
+
+    public void acquire_clipboard( boolean[] formats )
+    {
+        top_view.acquire_clipboard( formats );
+    }
+
+    public void export_clipboard_data( int index, byte[] data )
+    {
+        top_view.export_clipboard_data( index, data );
+    }
+
+
+    public void createDesktopWindow( final int hwnd )
+    {
+        runOnUiThread( new Runnable() { public void run() { create_desktop_window( hwnd ); }} );
+    }
+
+    public void createWindow( final int hwnd, final String wingroup )
+    {
+        runOnUiThread( new Runnable() { public void run() { create_window( hwnd, wingroup ); }} );
+    }
+
+    public void destroyWindow( final int hwnd )
+    {
+        runOnUiThread( new Runnable() { public void run() { destroy_window( hwnd ); }} );
+    }
+
+    public void startOpenGL( final int hwnd )
+    {
+        runOnUiThread( new Runnable() { public void run() { start_window_opengl( hwnd ); }} );
+    }
+
+    public void setFocus( final int hwnd )
+    {
+        runOnUiThread( new Runnable() { public void run() { focus_window( hwnd ); }} );
+    }
+
+    public void setWindowIcon( final int hwnd, final int width, final int height, final int icon[] )
+    {
+        runOnUiThread( new Runnable() { public void run() { set_window_icon( hwnd, width, height, icon ); }} );
+    }
+
+    public void setWindowText( final int hwnd, final String text )
+    {
+        runOnUiThread( new Runnable() { public void run() { set_window_text( hwnd, text ); }} );
+    }
+
+    public void windowPosChanged( final int hwnd, final int flags, final int insert_after,
+                                  final int owner, final int style,
+                                  final int left, final int top, final int right, final int bottom )
+    {
+        runOnUiThread( new Runnable() {
+            public void run() { window_pos_changed( hwnd, flags, insert_after, owner, style,
+                                                    left, top, right, bottom ); }} );
+    }
+
+    public void setWindowRgn( final int hwnd, final int region )
+    {
+        runOnUiThread( new Runnable() { public void run() { set_window_region( hwnd, region ); }} );
+    }
+
+    public void setWindowLayered( final int hwnd, final int key, final int alpha )
+    {
+        runOnUiThread( new Runnable() { public void run() { set_window_layered( hwnd, key, alpha ); }} );
+    }
+
+    public void setWindowSurface( final int hwnd, final boolean has_alpha )
+    {
+        runOnUiThread( new Runnable() { public void run() { set_window_surface( hwnd, has_alpha ); }} );
+    }
+
+    public void renderClipboardData( final int index )
+    {
+        new Thread( new Runnable() { public void run() { render_clipboard_data( index ); }} ).start();
+    }
+
+    public void acquireClipboard( final boolean[] formats )
+    {
+        runOnUiThread( new Runnable() { public void run() { acquire_clipboard( formats ); }} );
+    }
+
+    public void exportClipboardData( final int index, final byte[] data )
+    {
+        runOnUiThread( new Runnable() { public void run() { export_clipboard_data( index, data ); }} );
+    }
+
+    public static String[] getCopyingTypes( final String mimeTypeFilter )
+    {
+        String[] copying_mimetypes = null;
+
+        if (clipboard_driver != null && clipboard_driver.top_view != null)
+            copying_mimetypes = clipboard_driver.top_view.copying_mimetypes;
+        if (copying_mimetypes == null)
+            copying_mimetypes = new String[] { "text/plain" };
+        else
+            copying_mimetypes = copying_mimetypes.clone();
+
+        int i=0, length=copying_mimetypes.length;
+        while (i < length)
+        {
+            if (ClipDescription.compareMimeTypes( copying_mimetypes[i], mimeTypeFilter ))
+            {
+                i++;
+            }
+            else
+            {
+                copying_mimetypes[i] = copying_mimetypes[length-1];
+                length--;
+            }
+        }
+
+        if (length == 0)
+            return null;
+        else if (length == copying_mimetypes.length)
+            return copying_mimetypes;
+        else
+            return Arrays.copyOf( copying_mimetypes, length );
+    }
+
+    public static void serveClipboardData( String mimeTypeFilter, final OutputStream stream )
+    {
+        String[] mimeTypes = getCopyingTypes( mimeTypeFilter );
+        if (mimeTypes != null && clipboard_driver != null)
+        {
+            final String mimeType = mimeTypes[0];
+            final TopView top_view = clipboard_driver.top_view;
+            if (top_view != null)
+            {
+                clipboard_driver.runOnUiThread( new Runnable() { public void run() { top_view.serve_clipboard_data( mimeType, stream ); }} );
+            }
+        }
+        else
+        {
+            try { stream.close(); } catch (IOException e) { }
+        }
+    }
+}
diff -Naur wine-2.0a/dlls/wineandroid.drv/wine_launcher_hdpi.png wine-2.0b/dlls/wineandroid.drv/wine_launcher_hdpi.png
--- wine-2.0a/dlls/wineandroid.drv/wine_launcher_hdpi.png	1970-01-01 01:00:00.000000000 +0100
+++ wine-2.0b/dlls/wineandroid.drv/wine_launcher_hdpi.png	2017-07-11 20:37:51.000000000 +0100
@@ -0,0 +1,6 @@
+PNG
+
+   IHDR   0   0   Wù   gAMA  ±üa    cHRM  z&    ú   è  u0  ê`  :  pºQ<   bKGD ÿ ÿ ÿ ½§   	oFFs       þ ¾«   tIMEß7Äá    	vpAg  p   @ Hþôy  	IDAThÞíkl\ÅÇÿgæ¾v÷îË`;Æo	ÅP J(mHiS¨*!úêJFU"¡Yå¡Ð"|pÕ>D+T²HR"JpÄØµó´¯íµ½ñ®÷qw÷ÎéÛÔÒkÇjt´;sþ?ÍÌ×þo×h¡03½ôÒKßu]÷ÇDô%f.à ¹Ç @¢ÌÜ+¥|¹¥¥åM"âË°mÛ6a  ú¹[Jy\)5HDã &ç-fæe V2s#&"j Åb­­­©B5h0ãfI)eæ)å~xò¿yñÅR×Ñ½J©_B¡ ì¸, D¾öÚkõõõßø~4]¶cÇ×qh.»  =÷¨Ç²¬°i¥¶m²²²huuu¢··7ÞÓÓZ0sýàààSkÖ¬qËËËoPÍÌåDT@0sADf`æ!×uOçr¹®'Oz¨þ² ¸izzú·Dô3K 'hÀ9 §öìÙxõÕWÕÎ;]¿ß¯1³`f@ë×¯7W¯^}+ï-D(´`{{»@­âã¹¿ÊæóÉ¤Ü½{7mØ°ÁÝµkîñxüB¿Ò/¥H)ý]]]VQQQëçêZÚpçF =7ntÙP J¥´ÑÑQkß¾}RJi0MÓÔ5Mo SSS<33ãcæSLæ @)õ"úh.¹ e³YH$X,fuvvJ"²MÓ4¥ºBRÊù.DDjllL³m{nZr !Äõ öÏ%+\×étZO¥RÆää¤>44daêºn!Ðr¾Ï=KMMMÉ|>ßT°B2óuDô1 ¸®[Ëåd&ÑÉ¤122à5MÓBØaØ¦iÚ¦iúçÝ0$ÑÁ`®_RÖÖV@½a' Àqª|>/s¹N§ÍÁÁARú>Ë²lÃ0üaø5MèºîÕÂá0Q]{{»^ºP h 0ÔÜÜ ¹¹ÜÊééàÈ¡cÇ´×_¯¿mlÌ4F¤)MË(MsHJ×±¬©¶=~ÁïtÊ9CÌ<å8NK ¨pò>à~h9¾wïÍªÁAW?wNT9#kÌ®è ì¹Y"W1ZÆ²Îðñãç&RÕK@DSÝÝ«J?¬Â®(*BvdDf\WfLB Ï³NÄ¬YS r bétyèPeêæ3ñÒÒB´ú*qFGWV ¨--®iPs9&Lf MÔuHÃ ù|`¯®¦¡Äu1Hhq!ìéÙÕêÒ 0³/Ï§/ #B@ û|Ë£è¾û¨©·¼fe%´²2`J!yèb#ÒÓè±cÈ)ÇçSJ){)[ÀTRªâø8T2ñß³ ]h R Ó Ý,ZL3Ç®[Ðr¢Ð10å-- PÄÐéÓq }B`~zR° sn\ä:fwA5UUÈd³yiãh)h ¢ÃÅÖ|ºó7>ÉóBÐ Ø Jæ¼tÎÍyéEyWßqDYàSîK`æ?Û*+ÏÀGo½ !¯åÁàg×66B«¬T®¦å-Ëz»-²BjÝºu(¾úêúÁýûË4 cG¢²¶F>65  ðß  ? Ïëz
+ïD"IÖõ_¶´´t.  ÜrË-áð¯ÏçHXF¬»¥ ''áùDø¼Ï§ý'@×ÌL>ªi½çgª:xî¹ç®$àÃÄ£»»87<3³ç*»À¢dëVtÁÇ¢ºi~¹¥¥e´P>Ú¾}{¹ÊçßEoïeýývþÔ)ðð0¼À¿V¯ÕÜ÷ÔÏ7äÝ¶iÓ¦ó¿`  hoo¦vá8ëËûú¬+ffïïÎ%­]H(2|VÊ¿{677O/4ö¢ ÌÛóÏ?ÿÌ+Ë£QTÃÐ¼^DIµ,¤¤TÊ0~ðÈ#üy±b.*  <óÌÓ·»®Ú·,Xd8é42É¬®É57?öþbÆ+xGöy¶yócRéÔþcýpÁqÐÝwSéä;-Xø¹Ð4¯ßó?XíõzýRJTU_D¿¾±½ ÀgÙüBétîÀ`ãÆt2J!Nú[[[³_  PÌ§3idsY°R=*Î% Àær9ÏçA$ú¾ <îºyÇuóÖú Ä1¥ÜR
+D¸p©Â\²1ÀÌ¤-ú9oRq[[[¹¢ü:nðU W2À¬+¥XH'3«1fR¾GJîÞ²eËðehkkóò¿R¿EùòCW­¬>SUU=mÛ¶yêÔÉ½oïYËÌøÖ=÷vWÄÉ$¢QsxxÈ?0Ð_qÒÐ7mÙ²%Q¨Eù?ÕT×jß¼{íö¾¾¾ø#G2¯½¶k¦··×ñxÌ³M76Ý0|ëf:%ËW­ZUóõ»îÆº³óÐÁ¿ øö03µm{ú®ºÚW^xáÓO>ùä°a¦ÂÔuÝÐ4-^W_wÑÕÕ'"yøðá¨2&èôÑG#>øà=W03z_¼ .ôØÖ-­¨XyÝ×ßÐ+¥îLE"d$ÉNOO#^RRâÃ¾ÊÊÊâêêê²ººº«\×ÅÛûöæí~¿íWÏ>Ù£¢¥°mûýä?/+»â¡@ ÂÑ¢pq&¦e¶Ï¶4MÓ³¹,)×ñxÇ££b<õNL[ÈØÎßÿîå?¦R©cøôJvé æ¬6_±fÍ×V­¨(¿1
+4éRH©63rÕëæ¹\n"9r~x¸ëÝw÷÷Äb±4^ ßÔ/æû¹@9fÝè"7s@Àf¿¡øß¶D!äÿë¤   %tEXtdate:create 2015-01-23T16:55:11-06:00(â$   %tEXtdate:modify 2015-01-23T16:55:11-06:00YÀZ    IEND®B`
\ No newline at end of file
diff -Naur wine-2.0a/dlls/wineandroid.drv/wine_launcher_ldpi.png wine-2.0b/dlls/wineandroid.drv/wine_launcher_ldpi.png
--- wine-2.0a/dlls/wineandroid.drv/wine_launcher_ldpi.png	1970-01-01 01:00:00.000000000 +0100
+++ wine-2.0b/dlls/wineandroid.drv/wine_launcher_ldpi.png	2017-07-11 20:37:51.000000000 +0100
@@ -0,0 +1,9 @@
+PNG
+
+   IHDR           szzô   gAMA  ±üa    cHRM  z&    ú   è  u0  ê`  :  pºQ<   bKGD ÿ ÿ ÿ ½§   	oFFs   °    Bû=â   tIMEß7
+³æ¨   	vpAg  p   @ Hþôy  IDATXÃ½[lUÿ½÷\ÎSz®=mA©-H[l¡ØÐA
+VLÁ[omA}1>Ì	¡	O 	&\T4(ÒµÚCJÐªméå\z:gfÎÌ,¬ÆðÒé%®dgæaÍ¿¿ù×=X@èº®èº®,DùM<zôhPq1ÖLDI nlÑcì"cìË.÷ ¸
+à"º@D;Ãµ¶¶²ÖÖVæy^T¤çè"×è¿ºßDÎyIqqñx:nfUjög{{{1Æ DÇYÆ9_Åî§ÓéÄ¢@×u%NîÛ·ïILÓ:#»®ûO+0EÎçówÎ9³7JÅt]·ÅX,ÖHD·4M;HDeYþÍ4Í[µµµ?+®ëªªª]»vEêëë <Ç7èX "ÚJDßQ@Ø²,ÑÛÛH§ÓUUsµ¦¦&tóæM
+¡êêê~ OûðÛM ®Xîº®Ôzzz ËrTUÕx"(ZbFäÞ½{¡`0#¢&?Â³°À÷ãT¡d2@__Ð4-ªiZÌuÝ¦i`0Åãqb5Î<»°;vlbª­­mtÏ=+ÓÓ¡®®ÚÔåË¡°Ä¹êªªí*3]T41©ª Ùííí î.s¾Â³í__>ýáÔ©'Ë/Wyw·hºsGØ6äÎ-1§èÊiQS!IªZ0 ÒìíÛëÖ á0
+ÐlªmC  !L²,P$ùL"Q¶àpÎK3©<°©P& CQà45A©¬¶l¤Pv6÷öLçclá Dd(EEß¢¾ÁA,­ªBÿØº:;!wvB  Üë¦íÛÁ9·Èõ}àçXu5cáÚÙ³(
+`ÅÅÈs@ð*IÂÚ­[auÏ&.fK¸téÒÐÍ®®ÐØÀJ*/Éçþ]	 k^|édÒ¢¿íÀwì cxý±Ý»©zõj²ûúðçH°@ÅÌZ·m47£ÇuMxÕ»þç'O>ëXÖ'7BÁAþ~ ±hå{÷b°¦?é±«­­íËE ãÇ¯A>N5¦]9cÉhá0¦Ö­CO.GY¢»Y~áàÁ·üjÎ	  t]çÈsÜr¢p pÍ¼ç©òùlvz·®ëÞ\ôæ  'NPGÇï¡b3çÒ+û÷ï/ÌUË÷Hößhii±ÂáÈòòR*+/£H,òñ|67  ëvær¹iå§<¢ëóÕñ=>Ñ-Ë¶<Ïó ~¯Î¼p]%ò8	Æ(ó¿H%"	Ä¹35_9}Z-/+²²MUd²( D£±1ÊÛÖàü£·ß|ÛwIfýüï¾wXG£6>±©vÃúPeeÕ?p{	c;{Þnhh,[µrÕ&+oî_¿áqéë¯®~ãËI¿ ç¾¹eóS)Û²S½½}¹\.'KBVÇåçÎOÙ¶-oÞ¼9þì3;B'Þx¾ òèèýÓß½R_W_\WWÇ,Ëò<ÏÀD0,.))'''½Ï/}êÞ;¿ûkÖSq.=P±å©-ëëëw&7Åâ±RUçd92:2:>>Ññcw÷g×®^ë ðÑùÅÀR á{à È ÁßïøÊ]ÌcU{r   %tEXtdate:create 2015-01-23T16:55:10-06:00êé   %tEXtdate:modify 2015-01-23T16:55:10-06:00ÿ·Q,    IEND®B`
\ No newline at end of file
diff -Naur wine-2.0a/dlls/wineandroid.drv/wine_launcher_mdpi.png wine-2.0b/dlls/wineandroid.drv/wine_launcher_mdpi.png
--- wine-2.0a/dlls/wineandroid.drv/wine_launcher_mdpi.png	1970-01-01 01:00:00.000000000 +0100
+++ wine-2.0b/dlls/wineandroid.drv/wine_launcher_mdpi.png	2017-07-11 20:37:51.000000000 +0100
@@ -0,0 +1,7 @@
+PNG
+
+   IHDR   0   0   Wù   gAMA  ±üa    cHRM  z&    ú   è  u0  ê`  :  pºQ<   bKGD ÿ ÿ ÿ ½§   	oFFs       þ ¾«   tIMEß7
+³æ¨   	vpAg  p   @ Hþôy  	IDAThÞíkl\ÅÇÿgæ¾v÷îË`;Æo	ÅP J(mHiS¨*!úêJFU"¡Yå¡Ð"|pÕ>D+T²HR"JpÄØµó´¯íµ½ñ®÷qw÷ÎéÛÔÒkÇjt´;sþ?ÍÌ×þo×h¡03½ôÒKßu]÷ÇDô%f.à ¹Ç @¢ÌÜ+¥|¹¥¥åM"âË°mÛ6a  ú¹[Jy\)5HDã &ç-fæe V2s#&"j Åb­­­©B5h0ãfI)eæ)å~xò¿yñÅR×Ñ½J©_B¡ ì¸, D¾öÚkõõõßø~4]¶cÇ×qh.»  =÷¨Ç²¬°i¥¶m²²²huuu¢··7ÞÓÓZ0sýàààSkÖ¬qËËËoPÍÌåDT@0sADf`æ!×uOçr¹®'Oz¨þ² ¸izzú·Dô3K 'hÀ9 §öìÙxõÕWÕÎ;]¿ß¯1³`f@ë×¯7W¯^}+ï-D(´`{{»@­âã¹¿ÊæóÉ¤Ü½{7mØ°ÁÝµkîñxüB¿Ò/¥H)ý]]]VQQQëçêZÚpçF =7ntÙP J¥´ÑÑQkß¾}RJi0MÓÔ5Mo SSS<33ãcæSLæ @)õ"úh.¹ e³YH$X,fuvvJ"²MÓ4¥ºBRÊù.DDjllL³m{nZr !Äõ öÏ%+\×étZO¥RÆää¤>44daêºn!Ðr¾Ï=KMMMÉ|>ßT°B2óuDô1 ¸®[Ëåd&ÑÉ¤122à5MÓBØaØ¦iÚ¦iúçÝ0$ÑÁ`®_RÖÖV@½a' Àqª|>/s¹N§ÍÁÁARú>Ë²lÃ0üaø5MèºîÕÂá0Q]{{»^ºP h 0ÔÜÜ ¹¹ÜÊééàÈ¡cÇ´×_¯¿mlÌ4F¤)MË(MsHJ×±¬©¶=~ÁïtÊ9CÌ<å8NK ¨pò>à~h9¾wïÍªÁAW?wNT9#kÌ®è ì¹Y"W1ZÆ²Îðñãç&RÕK@DSÝÝ«J?¬Â®(*BvdDf\WfLB Ï³NÄ¬YS r bétyèPeêæ3ñÒÒB´ú*qFGWV ¨--®iPs9&Lf MÔuHÃ ù|`¯®¦¡Äu1Hhq!ìéÙÕêÒ 0³/Ï§/ #B@ û|Ë£è¾û¨©·¼fe%´²2`J!yèb#ÒÓè±cÈ)ÇçSJ){)[ÀTRªâø8T2ñß³ ]h R Ó Ý,ZL3Ç®[Ðr¢Ð10å-- PÄÐéÓq }B`~zR° sn\ä:fwA5UUÈd³yiãh)h ¢ÃÅÖ|ºó7>ÉóBÐ Ø Jæ¼tÎÍyéEyWßqDYàSîK`æ?Û*+ÏÀGo½ !¯åÁàg×66B«¬T®¦å-Ëz»-²BjÝºu(¾úêúÁýûË4 cG¢²¶F>65  ðß  ? Ïëz
+ïD"IÖõ_¶´´t.  ÜrË-áð¯ÏçHXF¬»¥ ''áùDø¼Ï§ý'@×ÌL>ªi½çgª:xî¹ç®$àÃÄ£»»87<3³ç*»À¢dëVtÁÇ¢ºi~¹¥¥e´P>Ú¾}{¹ÊçßEoïeýývþÔ)ðð0¼À¿V¯ÕÜ÷ÔÏ7äÝ¶iÓ¦ó¿`  hoo¦vá8ëËûú¬+ffïïÎ%­]H(2|VÊ¿{677O/4ö¢ ÌÛóÏ?ÿÌ+Ë£QTÃÐ¼^DIµ,¤¤TÊ0~ðÈ#üy±b.*  <óÌÓ·»®Ú·,Xd8é42É¬®É57?öþbÆ+xGöy¶yócRéÔþcýpÁqÐÝwSéä;-Xø¹Ð4¯ßó?XíõzýRJTU_D¿¾±½ ÀgÙüBétîÀ`ãÆt2J!Nú[[[³_  PÌ§3idsY°R=*Î% Àær9ÏçA$ú¾ <îºyÇuóÖú Ä1¥ÜR
+D¸p©Â\²1ÀÌ¤-ú9oRq[[[¹¢ü:nðU W2À¬+¥XH'3«1fR¾GJîÞ²eËðehkkóò¿R¿EùòCW­¬>SUU=mÛ¶yêÔÉ½oïYËÌøÖ=÷vWÄÉ$¢QsxxÈ?0Ð_qÒÐ7mÙ²%Q¨Eù?ÕT×jß¼{íö¾¾¾ø#G2¯½¶k¦··×ñxÌ³M76Ý0|ëf:%ËW­ZUóõ»îÆº³óÐÁ¿ øö03µm{ú®ºÚW^xáÓO>ùä°a¦ÂÔuÝÐ4-^W_wÑÕÕ'"yøðá¨2&èôÑG#>øà=W03z_¼ .ôØÖ-­¨XyÝ×ßÐ+¥îLE"d$ÉNOO#^RRâÃ¾ÊÊÊâêêê²ººº«\×ÅÛûöæí~¿íWÏ>Ù£¢¥°mûýä?/+»â¡@ ÂÑ¢pq&¦e¶Ï¶4MÓ³¹,)×ñxÇ££b<õNL[ÈØÎßÿîå?¦R©cøôJvé æ¬6_±fÍ×V­¨(¿1
+4éRH©63rÕëæ¹\n"9r~x¸ëÝw÷÷Äb±4^ ßÔ/æû¹@9fÝè"7s@Àf¿¡øß¶D!äÿë¤   %tEXtdate:create 2015-01-23T16:55:10-06:00êé   %tEXtdate:modify 2015-01-23T16:55:10-06:00ÿ·Q,    IEND®B`
\ No newline at end of file
diff -Naur wine-2.0a/dlls/wineandroid.drv/wine_launcher.svg wine-2.0b/dlls/wineandroid.drv/wine_launcher.svg
--- wine-2.0a/dlls/wineandroid.drv/wine_launcher.svg	1970-01-01 01:00:00.000000000 +0100
+++ wine-2.0b/dlls/wineandroid.drv/wine_launcher.svg	2017-07-11 20:37:51.000000000 +0100
@@ -0,0 +1,204 @@
+<?xml version="1.0" encoding="UTF-8" standalone="no"?>
+<!-- Created with Inkscape (http://www.inkscape.org/) -->
+<svg id="svg2" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns="http://www.w3.org/2000/svg" height="64" width="368" version="1.1" xmlns:cc="http://creativecommons.org/ns#" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:dc="http://purl.org/dc/elements/1.1/">
+ <metadata id="metadata303">
+  <rdf:RDF>
+   <cc:Work rdf:about="">
+    <dc:format>image/svg+xml</dc:format>
+    <dc:type rdf:resource="http://purl.org/dc/dcmitype/StillImage"/>
+   </cc:Work>
+  </rdf:RDF>
+ </metadata>
+ <defs id="defs4">
+  <linearGradient id="linearGradient3933">
+   <stop id="stop3935" stop-color="#000" stop-opacity="0.302" offset="0"/>
+   <stop id="stop3941" stop-color="#000" stop-opacity="0.2" offset="0.88501"/>
+   <stop id="stop3937" stop-color="#000" stop-opacity="0" offset="1"/>
+  </linearGradient>
+  <filter id="filter3391" height="1.336" width="1.1344" color-interpolation-filters="sRGB" y="-0.168" x="-0.067199998">
+   <feGaussianBlur id="feGaussianBlur3393" stdDeviation="0.14"/>
+  </filter>
+  <linearGradient id="linearGradient3198">
+   <stop id="stop3200" stop-color="#FFF" offset="0"/>
+   <stop id="stop3202" stop-color="#FFF" stop-opacity="0" offset="1"/>
+  </linearGradient>
+  <filter id="filter3391-9" height="1.336" width="1.1344" color-interpolation-filters="sRGB" y="-0.168" x="-0.067199998">
+   <feGaussianBlur id="feGaussianBlur3393-0" stdDeviation="0.14"/>
+  </filter>
+  <linearGradient id="linearGradient3052" y2="25.5" gradientUnits="userSpaceOnUse" x2="20.5" gradientTransform="translate(-8.0000004,15.967633)" y1="27.5" x1="16">
+   <stop id="stop3375" stop-color="#000" offset="0"/>
+   <stop id="stop3377" stop-color="#373737" stop-opacity="0" offset="1"/>
+  </linearGradient>
+  <linearGradient id="linearGradient3054" y2="27" gradientUnits="userSpaceOnUse" x2="21.5" gradientTransform="translate(-8.0000004,15.967633)" y1="27" x1="16">
+   <stop id="stop3444" stop-color="#000" offset="0"/>
+   <stop id="stop3446" stop-color="#000" stop-opacity="0" offset="1"/>
+  </linearGradient>
+  <radialGradient id="radialGradient3319" gradientUnits="userSpaceOnUse" cy="14.19" cx="18" gradientTransform="matrix(0.5171097,0,0,0.09372595,295.71991,44.846526)" r="5.5055">
+   <stop id="stop3454-5" stop-color="#FFF" offset="0"/>
+   <stop id="stop3456-4" stop-color="#FFF" stop-opacity="0" offset="1"/>
+  </radialGradient>
+  <linearGradient id="linearGradient3324" y2="18.312" xlink:href="#linearGradient3198" gradientUnits="userSpaceOnUse" x2="23" gradientTransform="matrix(0.5171097,0,0,0.509783,292.0317,35.706174)" y1="18.312" x1="17.605"/>
+  <linearGradient id="linearGradient3327" y2="19" xlink:href="#linearGradient3198" gradientUnits="userSpaceOnUse" x2="22" gradientTransform="matrix(0.51465215,0,0,0.51427415,291.66575,36.071594)" y1="25.27" x1="30.376"/>
+  <radialGradient id="radialGradient3330" gradientUnits="userSpaceOnUse" cy="13.192" cx="25.017" gradientTransform="matrix(0.6409233,0,0,0.23260484,289.25876,43.172933)" r="9.7513">
+   <stop id="stop3173-2" stop-color="#fd0000" offset="0"/>
+   <stop id="stop3175-4" stop-color="#6a0000" offset="1"/>
+  </radialGradient>
+  <linearGradient id="linearGradient3332" y2="7.1352" gradientUnits="userSpaceOnUse" x2="22.036" gradientTransform="matrix(0.6409233,0,0,0.4699064,289.25876,40.562616)" y1="15.984" x1="27.217">
+   <stop id="stop4404-2" stop-color="#e80000" offset="0"/>
+   <stop id="stop4406-1" stop-color="#490000" offset="1"/>
+  </linearGradient>
+  <radialGradient id="radialGradient3335" gradientUnits="userSpaceOnUse" cy="26.577" cx="26.625" gradientTransform="matrix(0.4905733,-0.1612076,0.0594676,0.1758752,290.71541,48.376273)" r="12.5">
+   <stop id="stop3191-6" stop-color="#e40000" offset="0"/>
+   <stop id="stop3193-5" stop-color="#490000" offset="1"/>
+  </radialGradient>
+  <linearGradient id="linearGradient3338" y2="27" gradientUnits="userSpaceOnUse" x2="19" gradientTransform="matrix(0.5171097,0,0,0.5097831,291.58937,36.045709)" y1="33" x1="29">
+   <stop id="stop3222-8" stop-color="#373737" offset="0"/>
+   <stop id="stop3224-5" stop-color="#FFF" offset="1"/>
+  </linearGradient>
+  <linearGradient id="linearGradient3341" y2="5.0354" xlink:href="#linearGradient3198" gradientUnits="userSpaceOnUse" x2="17.799" gradientTransform="matrix(0.7042341,0,0,0.4625263,287.80262,49.412231)" y1="12.038" x1="25.269"/>
+  <linearGradient id="linearGradient3344" y2="9.277" gradientUnits="userSpaceOnUse" x2="21.44" gradientTransform="matrix(0.6372376,0,0,0.5144393,289.34354,48.841188)" y1="14.243" x1="27.681">
+   <stop id="stop3230-47" stop-color="#373737" offset="0"/>
+   <stop id="stop3232-9" stop-color="#cfcfcf" stop-opacity="0.67826086" offset="1"/>
+  </linearGradient>
+  <radialGradient id="radialGradient3347" gradientUnits="userSpaceOnUse" cy="22.614" cx="27.5" gradientTransform="matrix(0.7955532,-0.039214,0.04965997,0.9791288,282.80915,27.21674)" r="6.5">
+   <stop id="stop3348-2" stop-color="#737373" offset="0"/>
+   <stop id="stop3350-2" stop-color="#000" stop-opacity="0" offset="1"/>
+  </radialGradient>
+  <radialGradient id="radialGradient3350" gradientUnits="userSpaceOnUse" cy="33.188" cx="37.375" gradientTransform="matrix(0.2103491,0,0,0.05208649,295.79979,45.30668)" r="14.625">
+   <stop id="stop4335-63" stop-color="#000" offset="0"/>
+   <stop id="stop4337-0" stop-color="#000" stop-opacity="0" offset="1"/>
+  </radialGradient>
+  <radialGradient id="radialGradient3115" gradientUnits="userSpaceOnUse" cy="14.19" cx="18" gradientTransform="matrix(1.0342194,0,0,0.1874519,175.43981,33.693031)" r="5.5055">
+   <stop id="stop3454-4" stop-color="#FFF" offset="0"/>
+   <stop id="stop3456-9" stop-color="#FFF" stop-opacity="0" offset="1"/>
+  </radialGradient>
+  <linearGradient id="linearGradient3120" y2="18.312" xlink:href="#linearGradient3198" gradientUnits="userSpaceOnUse" x2="23" gradientTransform="matrix(1.0342194,0,0,1.019566,168.0634,15.412329)" y1="18.312" x1="17.605"/>
+  <linearGradient id="linearGradient3123" y2="19" xlink:href="#linearGradient3198" gradientUnits="userSpaceOnUse" x2="22" gradientTransform="matrix(1.0293043,0,0,1.0285483,167.3315,16.143168)" y1="25.27" x1="30.376"/>
+  <radialGradient id="radialGradient3126" gradientUnits="userSpaceOnUse" cy="13.192" cx="25.017" gradientTransform="matrix(1.2818465,0,0,0.46520969,162.51753,30.345846)" r="9.7513">
+   <stop id="stop3173-5" stop-color="#fd0000" offset="0"/>
+   <stop id="stop3175-8" stop-color="#6a0000" offset="1"/>
+  </radialGradient>
+  <linearGradient id="linearGradient3128" y2="7.1352" gradientUnits="userSpaceOnUse" x2="22.036" gradientTransform="matrix(1.2818465,0,0,0.9398128,162.51753,25.125212)" y1="15.984" x1="27.217">
+   <stop id="stop4404-1" stop-color="#e80000" offset="0"/>
+   <stop id="stop4406-5" stop-color="#490000" offset="1"/>
+  </linearGradient>
+  <radialGradient id="radialGradient3132" gradientUnits="userSpaceOnUse" cy="26.577" cx="26.625" gradientTransform="matrix(0.9811466,-0.3224151,0.1189352,0.3517503,165.43081,40.752527)" r="12.5">
+   <stop id="stop3191-9" stop-color="#e40000" offset="0"/>
+   <stop id="stop3193-7" stop-color="#490000" offset="1"/>
+  </radialGradient>
+  <linearGradient id="linearGradient3135" y2="27" gradientUnits="userSpaceOnUse" x2="19" gradientTransform="matrix(1.0342194,0,0,1.0195661,167.17874,16.091399)" y1="33" x1="29">
+   <stop id="stop3222-6" stop-color="#373737" offset="0"/>
+   <stop id="stop3224-3" stop-color="#FFF" offset="1"/>
+  </linearGradient>
+  <linearGradient id="linearGradient3138" y2="5.0354" xlink:href="#linearGradient3198" gradientUnits="userSpaceOnUse" x2="17.799" gradientTransform="matrix(1.2818465,0,0,0.9398128,162.51753,42.162079)" y1="12.038" x1="25.269"/>
+  <linearGradient id="linearGradient3141" y2="9.277" gradientUnits="userSpaceOnUse" x2="21.44" gradientTransform="matrix(1.2744752,0,0,1.0288787,162.68707,41.182354)" y1="14.243" x1="27.681">
+   <stop id="stop3230-4" stop-color="#373737" offset="0"/>
+   <stop id="stop3232-6" stop-color="#cfcfcf" stop-opacity="0.67826086" offset="1"/>
+  </linearGradient>
+  <radialGradient id="radialGradient3144" gradientUnits="userSpaceOnUse" cy="22.614" cx="27.5" gradientTransform="matrix(1.5911065,-0.078428,0.09931994,1.9582576,149.61831,-1.566539)" r="6.5">
+   <stop id="stop3348-7" stop-color="#737373" offset="0"/>
+   <stop id="stop3350-0" stop-color="#000" stop-opacity="0" offset="1"/>
+  </radialGradient>
+  <radialGradient id="radialGradient3148" gradientUnits="userSpaceOnUse" cy="33.188" cx="37.375" gradientTransform="matrix(0.4206982,0,0,0.10417298,175.59958,34.613341)" r="14.625">
+   <stop id="stop4335-6" stop-color="#000" offset="0"/>
+   <stop id="stop4337-5" stop-color="#000" stop-opacity="0" offset="1"/>
+  </radialGradient>
+  <radialGradient id="radialGradient3926" gradientUnits="userSpaceOnUse" cy="14.19" cx="18" gradientTransform="matrix(1.551329,0,0,0.2811779,7.1597166,22.539516)" r="5.5055">
+   <stop id="stop3454" stop-color="#FFF" offset="0"/>
+   <stop id="stop3456" stop-color="#FFF" stop-opacity="0" offset="1"/>
+  </radialGradient>
+  <linearGradient id="linearGradient3930" y2="18.312" xlink:href="#linearGradient3198" gradientUnits="userSpaceOnUse" x2="23" gradientTransform="matrix(1.551329,0,0,1.5293489,-3.904902,-4.881536)" y1="18.312" x1="17.605"/>
+  <linearGradient id="linearGradient3934" y2="19" xlink:href="#linearGradient3198" gradientUnits="userSpaceOnUse" x2="22" gradientTransform="matrix(1.5439563,0,0,1.5428223,-5.002754,-3.785278)" y1="25.27" x1="30.376"/>
+  <radialGradient id="radialGradient3937" gradientUnits="userSpaceOnUse" cy="13.192" cx="25.017" gradientTransform="matrix(1.9227697,0,0,0.69781448,-12.223704,17.518739)" r="9.7513">
+   <stop id="stop3173" stop-color="#fd0000" offset="0"/>
+   <stop id="stop3175" stop-color="#6a0000" offset="1"/>
+  </radialGradient>
+  <linearGradient id="linearGradient3939" y2="7.1352" gradientUnits="userSpaceOnUse" x2="22.036" gradientTransform="matrix(1.9227697,0,0,1.4097191,-12.223704,9.6877877)" y1="15.984" x1="27.217">
+   <stop id="stop4404" stop-color="#e80000" offset="0"/>
+   <stop id="stop4406" stop-color="#490000" offset="1"/>
+  </linearGradient>
+  <radialGradient id="radialGradient3942" gradientUnits="userSpaceOnUse" cy="26.577" cx="26.625" gradientTransform="matrix(1.4717199,-0.4836227,0.1784028,0.5276254,-7.853782,33.128759)" r="12.5">
+   <stop id="stop3191" stop-color="#e40000" offset="0"/>
+   <stop id="stop3193" stop-color="#490000" offset="1"/>
+  </radialGradient>
+  <linearGradient id="linearGradient3945" y2="27" gradientUnits="userSpaceOnUse" x2="19" gradientTransform="matrix(1.551329,0,0,1.529349,-5.231894,-3.862931)" y1="33" x1="29">
+   <stop id="stop3222" stop-color="#373737" offset="0"/>
+   <stop id="stop3224" stop-color="#FFF" offset="1"/>
+  </linearGradient>
+  <linearGradient id="linearGradient3948" y2="5.0354" xlink:href="#linearGradient3198" gradientUnits="userSpaceOnUse" x2="17.799" gradientTransform="matrix(1.9227697,0,0,1.4097191,-12.223704,34.901493)" y1="12.038" x1="25.269"/>
+  <linearGradient id="linearGradient3951" y2="9.277" gradientUnits="userSpaceOnUse" x2="21.44" gradientTransform="matrix(1.9227697,0,0,1.4097191,-12.223704,34.922047)" y1="19.122" x1="29.455">
+   <stop id="stop3230" stop-color="#373737" offset="0"/>
+   <stop id="stop3232" stop-color="#373737" stop-opacity="0" offset="1"/>
+  </linearGradient>
+  <radialGradient id="radialGradient3955" gradientUnits="userSpaceOnUse" cy="22.614" cx="27.5" gradientTransform="matrix(2.3866597,-0.117642,0.1489799,2.9373862,-31.572536,-30.349836)" r="6.5">
+   <stop id="stop3348" stop-color="#737373" offset="0"/>
+   <stop id="stop3350" stop-color="#000" stop-opacity="0" offset="1"/>
+  </radialGradient>
+  <radialGradient id="radialGradient3958" xlink:href="#linearGradient3933" gradientUnits="userSpaceOnUse" cy="55.076" cx="31.071" gradientTransform="matrix(1.1299037,0.00293243,-0.00104388,0.40221964,-2.8919247,29.673628)" r="8.5533"/>
+  <radialGradient id="radialGradient3961" gradientUnits="userSpaceOnUse" cy="33.188" cx="37.375" gradientTransform="matrix(0.6310473,0,0,0.15625948,7.3993769,23.919982)" r="14.625">
+   <stop id="stop4335" stop-color="#000" offset="0"/>
+   <stop id="stop4337" stop-color="#000" stop-opacity="0" offset="1"/>
+  </radialGradient>
+  <radialGradient id="radialGradient3965" xlink:href="#linearGradient3933" gradientUnits="userSpaceOnUse" cy="55.076" cx="31.071" gradientTransform="matrix(0.76667705,0.00198975,-7.0830713e-4,0.27291933,168.20209,38.465153)" r="8.5533"/>
+ </defs>
+ <image id="icon:48-8" xlink:href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAMAAABg3Am1AAAAAXNSR0IArs4c6QAAAv1QTFRFdwAA SwAASQQAUAIAVwABUAIDXwAAawACZQMAbQEAdAABfgABZwcKggAAGxwaYAoMegQAiQACjAAAhAMA jQEAlAABjgIGlwAAmAAAjgMAngAAoAABoQAChggJbQ8PkAYIpAEArAABJCYktQAAaRUUuAAAuQAA sAMAuAAIsAMDwQAAwwAAKiwpxgIAzgAAzQAD0QAAxwQJ2QAB0gMAvQkMjxYW3wUFoxYUjR8iiCMm iiQizRQWqR4kxBgS4hEThS8t2xgXky0uljAwbjs65xserCwu2Scm4yYrtDQ05SglxDI2fEdFU1RS iEZJhUpKqEFDiE1Ng09Se1NRXF5bn01LeFhZzkRFjFhavUtLYmRhZWZkqFVS3EhHyU9SgGVk50pH kmJibW9smWNl1VNTq19ekmhmomRjcHJvjGtslGxvmnBuq2xriHZ40WRk2GNhknd2gIJ/tnV14Gxu p3x6lIGDhIaDrXx8hoiF03RzmIWHmoWCiIqHpYKDioyJy3t5i42KkoyLjI6Lk42MtoSEoIuIjpCN 5nh8j5GOmo6OoI2PkJKPqIyLlpGP2ICBkpSRzYSGmJOS2oODlZeUqJKPso+QlpiVxYuNmZiQmJqX 0oqL54aEmpuYz42MoZuam52ZnJ6bo52cnZ+c5YyMnqCdn6GeoKKfpqGgoqSh74+SqKOiu5+epKaj 7ZOUpaekvqGgp6mmxaGiqauoqqypyKSl1aGgrK6q3KGjra+s5aGfrrCtwauosLKusbOv7qOjt7Kx srSxs7WyubSz8aantbe0tri1t7q2ubu48q2su726vL67z7m2vb+84bW4yby8v8G+w8XC3cC+xcfE xsjF6r7B+Ly98769yMrHycvIyszJy87Kzc/LztDMz9HO0NLP0dPQ09XS1NbT1dfU1tjV3NfV2NrW 2dvX2tzZ293a3N7b3d/c3uDd4OLe4uTh5Obj5efk5+nm6Orn6evo6uzp6+7q7e/r7vDt7/Hu8PLv 8vTx8/Xy9Pfz9vj0+Pr3+fv4/P/72Xgt7AAAAAF0Uk5TAEDm2GYAAAABYktHRACIBR1IAAAACXBI WXMAAA3XAAAN1wFCKJt4AAAAB3RJTUUH2QsVCR0IF5SuWgAAAsRJREFUSMdjYBgIMHv21L729r6p s2cTpbxr4aYD5249fXrr3IFNC7uIUH/4/qv3X8Dg/av7hwnqmH3+07X9axcvXb52+dL1B25/O0/I WbNv//jz9+8/EPj798/PL9cJanj95dfvn9+/vX/96ikIPCCkYdKXL7+BGt69fHL/9u1bt24/IWjD ly9/fn9//+L+rWuXzgPBPcIavv358fH17Wvnz504duzosYsENMy+/uX776/vn146d+zIgT27d+8+ thu/jtlPv3wHWnDv9JH9WzdtXL9+/c4TBDR8/PL1O9CCI7s3rV29dOmSpcsv9RHwwoevnx+f7U7w 8w1Pza+cMHs2gZibvStgw4bmbAtBUXFRMTExEXmndXg1zC7h4T6zrTfXREtbV9/AwEBfWzWiBZ+O 2UHc5pd3TMwz1Dc2MrNzcfF0dwsrxqshlMPywpaZFWFFK45fuXqoLdlL0xW/DXGMrKc2NIcIS4rL SImLCPMKsNtPxuuJEkbGKetqAhkZGZlZ2DjYuQQEojvxhtJcRkbvdTUJrEDVnFzcvIIiInN68Aer MyNjVk2SHNBsXmDQSsl4bJ6EPzFNYGLlT0uz5BYWEZdRUFTX2NFBKLXmqLBzOZpKiisoqqpp6y7q 3kgwU2dYyQJNV1TV1jVwWDNlGRGlUqa/DdB4bQOj+L1lc4kqx5pSYr1srWNmTWvaR2TR11CZXddf WNVAfGFZvaCjo6echNJ1Unp5QdQkUsrjvtldrSQV4PXrF9eTpGHSwkl9pNURk0hzEQNDez2JGhqr aa2hnhQNs4GgvLS2kbhKEaj49ruvTxrrTzb6BCemE9Qze8/nH18/vr1foMSn41N+7PURQjra3397 9/rFk3tLIucfOXZk//3vBCuUta+/f3j36sntW/cevHj7+9NGwm6avvzErSev3r9/9fD60dlE+xsK BqTlAgDUYl8el7kojwAAAABJRU5ErkJggg== " height="48" width="48" y="8" x="64"/>
+ <image id="icon:48-4" xlink:href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwBAMAAAClLOS0AAAAAXNSR0IArs4c6QAAACpQTFRFAAB/ AAAAfwAAfwB/AH9/wMDAf39//wAAAP8A//8AAAD//wD/AP//////NG9NSgAAAAF0Uk5TAEDm2GYA AAABYktHRACIBR1IAAAACXBIWXMAAA3XAAAN1wFCKJt4AAAAB3RJTUUH2QscCScNP1/LJgAAANdJ REFUOMvNkzsOwyAMhj2xd+kBkEJOZG9IKBLeukSqOCndcpca0gkb9TH1G/n4BfID4HccC8k4zyiQ NjkeQiUVOLBTkxInExHrNBEtURtmIgqjuL0CSFq0ANaHFnGSqNSKxaPImTbfGITbFvJF2ENSYm2i GMIviN5bojMI2MLr8QATwYNgz+Z3wfnQxaKqe94vehpYjtdyZz0+Eim7MT4gj+/E1ii22s5mNH0n QDXprXDp/8RsOTkflI1qOdlNulwzGvtRkWU7k5Hoa6tb24+tTvHkVx/zBD4ahxXA9YrvAAAAAElF TkSuQmCC " height="48" width="48" y="8" x="120"/>
+ <image id="icon:32-8" xlink:href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAAAAXNSR0IArs4c6QAAAvdQTFRFvb68 SQAAVgAATAUFTQUFYAAAYwAAZAAAVwQEZgAAZwAAagAAbAAAcQAAeAAAfgAAggAAgQEBigAAiwAA lwAAmwAAnQEBoQAAowEBjwcHqQAAqgAAsgAAehAQtgAAlQoKnwgIwQAAeRQUpwoKzQAAmw4OxAMD mRER1QEBiRcXYSIimBQUlxUV3AYGrxUV2AoK3goK3QwMOjo61BERPT48eD4+fj4+szIyqTY2b0hI vzk5WVlYrkREi05OlVRUe15ejFpa2EhI0ExMqV5e0FZWj2hozVtblWtrkm1tlmxspGpqd3h1iHV1 0mNji3d3fHx8lXh4wG5uu3Jy1mtrgYOAgoN/goOCuHV10m9v229v2HBwhYeEmoKChoiElYSEvXp6 l4WF23NziIqFnYWFiYuGkomJi4uLs4GBm4iIjI2JjY6LnIqKt4ODloyMjY+LjY+Mj5CNj5CO7Xd3 kpCQkJGOk5CQkZGRlZGRkpKSkZONl5GRlpKSkpSRlJSUmJOTk5WQlZWVl5WVlZaUlpaTmZWVlpaW lpeVqJKSmJiYmZiYmZmZmpqamZuXm5ubs5WV1oyMo5ubyZGRnZ2do5ycnZ6cnp6en5+ftpmZn6Cc oKCgx5aWoKGezpaWoqKioqOfo6ShpKSgpKSkzZmZo6WipKWjpaWlpaejqaampqelp6enqKenzp2d 35mZqKioqamoyqKiq6ur1aCgqqyorK2qrq6ura+sr6+vr7CtsLCwsLKvs7OztLS0tra2t7e3uLi4 ubm5urq6vLy8vb29vr6+vr+9wMDAv8G/wMK/wsLCwsPCxMTExcXFxsbGx8nGycnIycnJysrKy8vL zc3N1MzMzc7Nzs7Oz8/P0tLS09PT1NTT1NTU1dXU1dXV19fX2NjY29vb3Nzc3d3d3d7d3t7e39/f 4ODf4OHg4eHg4eHh4uLi5OTk5eXl5ubm6Ojo6enp6urq6+rq6+vr7Ozs7e3t7u7u7+/v8PDw8fHx 8vLy9PT09fX19/f3+Pj4yPz4CQAAAAF0Uk5TAEDm2GYAAAABYktHRACIBR1IAAAACXBIWXMAAA3X AAAN1wFCKJt4AAAAB3RJTUUH2QsVCSMuhFww2gAAAYtJREFUOMtjYCAFTGqoKCuraJ2ES75s28UH nz7ev7CtDLv8tL1dK3fs37dlYce+aVgVtP768/Pb509fv//81oBVwdovv399e3n/1vUb95ZiVXDo y58fr25cPH36xPkd2OS3XPv2+/3dUwf37d51YM8WLApmPvz+4+WFfTs2rFy64fBULApqP376cLnd wzUgoWXSqVosCnpt09eH64hJKKiqa8d3YpH3E+xfE6ymoqFrYKjvlNyLqcCebdaiQHOXyCg3Kz2b GCwKfBg9pzswsbJzcnHzOmdgKmAoZtbqc+dg5eETEJLfWI7FkassWcy8ZPmFRcSlI3KWYwupRlMl TUlRKTlFx9V12KOz2s5CWUbRuGhiFa4EMTkuyDdxTvYE3ElqRW5paeoSfIkuJMw/FG+q3DmlaTv+ dNtWSCBh1+QTUFCSRUBBXiY+2d6t81KSZhSs68UhXX/24fNYEyPrtGjsKirvvbt+arZ399yXL/Ow m9B85dXrZy++/nnU04vLDZsXLF42f1MvSTkeAADgnlTqwm9mAAAAAElFTkSuQmCC " height="32" width="32" y="24" x="216"/>
+ <image id="icon:32-4" xlink:href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgBAMAAACBVGfHAAAAAXNSR0IArs4c6QAAAC1QTFRFf38A AAAAfwAAAAB/fwB/AH9/wMDAf39//wAAAP8A//8AAAD//wD/AP//////Q4IZrgAAAAF0Uk5TAEDm 2GYAAAABYktHRACIBR1IAAAACXBIWXMAAA3XAAAN1wFCKJt4AAAAB3RJTUUH2QsVCzUCqZg9gAAA AJVJREFUKM+tkaESAyEMRM+h+wsrmvuuiuAYBnG4E6f4Us7xDQ2qS6ZT1XV5s4Rl2bbvqiaeg46h mcDZVdPNYJgcSCmuoHcCYRqUtoZp0M6gW44jU6wIQD7RyvPVWruEwHSAgDgQUG2+6BaIzQsA9h30 3DJPCPdR0CQvDQHZd+hKDfn/wH9UTfdjIYd1qHFxqGr9tYP0BoPkRWo1rTHhAAAAAElFTkSuQmCC " height="32" width="32" y="24" x="256"/>
+ <image id="icon:16-8" xlink:href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAAAXNSR0IArs4c6QAAASBQTFRFyMjG agICggAAlgAAoAICvAEBkA0NsQYGvwMDtAgImhERnxoaYzIxmzAwgTg4jjs6rTg4ol5ek2Rkyl9d s21sloWBuXx8mIiEi42JjI6KkJGNlZGNkZKPmJGNn5CQkpSQmpSPlZaTzIeHmJaSl5iVnJeUmJmU nJmVmJqXmZqXmpqWmpuXoJqXn5uboaGeoqOgrqKipKWipqekpqikp6ilqKmmqamoqaunrK2qra6s rq6ur6+ssLCvsLGvsbKvsrKwsbOwsrOwtLWztbWztLaztre0uLm3ubq3vr+9xMXDxsbGxsfFx8fH y8vL0tLR0tLS0tPS1NTU2NjY2dnZ2drZ29vb4ODf4ODg4+Pi5ePj5OTk5ubm6Ojo7e3t7u7u9vb2 BMiXUQAAAAF0Uk5TAEDm2GYAAAABYktHRACIBR1IAAAACXBIWXMAAA3XAAAN1wFCKJt4AAAAB3RJ TUUH2QsVCScZWI1Q0QAAAIZJREFUGNNjYAADFSkpRQYkIGMVFGwjjyRgHerrE2iBJOAdH+7vZYvg u4ZEGsjpmjnDBdQFldhZOQVU4QJafGJs3Fy8ynABFx4hRiZmEUeEIdL8LBzCssgO0REVV2BAAZIS qHwGTTU0AVNjFK67iYa2oROCb+4c7ekRa6mPEHEzsnPQswczAaZ0D867PNMnAAAAAElFTkSuQmCC " height="16" width="16" y="40" x="320"/>
+ <image id="icon:16-4" xlink:href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQBAMAAADt3eJSAAAAAXNSR0IArs4c6QAAADBQTFRFAAAA fwAAAH8Af38AAAB/fwB/AH9/wMDAf39//wAAAP8A//8AAAD//wD/AP//////HPn1FAAAAAF0Uk5T AEDm2GYAAAABYktHRACIBR1IAAAACXBIWXMAAA3XAAAN1wFCKJt4AAAAB3RJTUUH2QsVCy4SHRnm fgAAAEZJREFUCNdjYGBg6OhgAAOO8vIGNMZ/KKP9e0cFmNHYKCiBxhCUhDA4BCdCFDM0QgSAQg3o DPYCqEB7BczkeojJHB0dQBEA7MAUcDV+I9sAAAAASUVORK5CYII= " height="16" width="16" y="40" x="344"/>
+ <g id="g3985">
+  <path id="path4331" opacity="0.07000002" fill="url(#radialGradient3961)" d="m40.214,29.106a9.2291,2.2853,0,0,1,-18.458,0,9.2291,2.2853,0,1,1,18.458,0z"/>
+  <path id="path3420" fill="url(#radialGradient3958)" d="m42.261,52a10.426,3.4403,0,0,1,-20.852,0,10.426,3.4403,0,1,1,20.852,0z"/>
+  <path id="path3159" fill-rule="evenodd" fill="url(#radialGradient3955)" d="m39.757,12.195c-0.77566-1.5293-14.738-1.5293-15.513,0,0,2.294-2.327,9.1761-2.327,15.293,0,6.1174,7.7566,9.9408,10.084,9.9408,2.327,0,10.084-3.8234,10.084-9.9408s-2.327-12.999-2.327-15.293z"/>
+  <path id="path2385" stroke-linejoin="round" style="stroke-dasharray:none;" d="m39.757,12.216a7.7566,1.5499,0,0,1,-15.513,0,7.7566,1.5499,0,1,1,15.513,0z" stroke="#919191" stroke-linecap="round" stroke-miterlimit="0" stroke-width="1.01098025" fill="none"/>
+  <path id="path3157" stroke-linejoin="round" style="stroke-dasharray:none;" d="m40.532,50.429a8.5323,3.0793,0,0,1,-17.065,0,8.5323,3.0793,0,1,1,17.065,0z" stroke="#888a85" stroke-linecap="round" stroke-miterlimit="0" stroke-width="1.01098025" fill="url(#linearGradient3951)"/>
+  <path id="path3236" stroke-linejoin="round" style="stroke-dasharray:none;" d="m39.5,50.408a7.5,1.9084,0,0,1,-15,0,7.5,1.9084,0,1,1,15,0z" stroke="url(#linearGradient3948)" stroke-linecap="round" stroke-miterlimit="0" stroke-width="1.01098025" fill="none"/>
+  <path id="path3163" stroke-linejoin="miter" d="m28.122,35.9c1.5513,1.5293,3.1027,3.8234,3.1027,12.235,0,1.5293,0.20982,2.294,0.77566,2.294,0.56585,0,0.77566-0.76467,0.77566-2.294,0-8.4114,1.5513-10.705,3.1027-12.235" fill-rule="evenodd" stroke="#888a85" stroke-linecap="round" stroke-width="1px" fill="url(#linearGradient3945)"/>
+  <path id="path3179" fill-rule="evenodd" fill="url(#radialGradient3942)" d="m22,25c0,9,7.673,12.429,10,12.429s10-3.429,10-12.429"/>
+  <path id="path5788" stroke-linejoin="round" style="stroke-dasharray:none;" d="m41.5,25.195a9.5,2.294,0,0,1,-19,0,9.5,2.294,0,1,1,19,0z" stroke="url(#linearGradient3939)" stroke-linecap="round" stroke-miterlimit="0" stroke-width="1.01098025" fill="url(#radialGradient3937)"/>
+  <path id="path3196" stroke-linejoin="miter" d="m23,25.5c-1.5,6.5,6.5,11,9,11s11-4.5,9-12c-0.5-4-1-6-2-9.5" stroke="url(#linearGradient3934)" stroke-linecap="round" stroke-width="1px" fill="none"/>
+  <path id="path3266" fill-rule="evenodd" fill="url(#linearGradient3930)" d="M26.346,15,31,15s-2.327,9.1761-2.327,12.999c0,2.294,1.5513,3.8234,0.77566,4.588-0.77566,0.76468-4.654-2.2183-4.654-6.1174,0-1.5293,0.77566-6.1174,1.5513-11.47z"/>
+  <path id="path3358" stroke-linejoin="round" d="M39.5,13.5c-0.5,0.5-3.462,1.05-7.743,1.05-4.282,0-6.757-0.55-7.257-1.05" stroke="#FFF" stroke-linecap="round" stroke-miterlimit="0" stroke-width="1.01098013" fill="none"/>
+  <path id="path3450" stroke-linejoin="round" d="m41,24.5c0,0.85555-3.5,2-9.019,2.0499-5.519,0.05-8.981-1.194-8.981-2.05" stroke="url(#radialGradient3926)" stroke-linecap="round" stroke-miterlimit="0" stroke-width="1.01098013" fill="none"/>
+  <path id="path3395" opacity="0.35" stroke-linejoin="round" d="m30,38s0.5,1,2,0.95884c1.5-0.041,2-0.959,2-0.959" stroke="#000" stroke-linecap="round" stroke-width="1px" fill="none"/>
+  <path id="path3363" stroke-linejoin="round" d="m8,43.468,2.5-1,2.4688,0.125-4.9687,0.875z" fill-rule="evenodd" transform="matrix(1.551329,0,0,1.5293489,19.589369,-16.477177)" filter="url(#filter3391)" stroke="url(#linearGradient3054)" stroke-linecap="round" stroke-width="0.64922434px" fill="url(#linearGradient3052)"/>
+  <path id="path3354" stroke-linejoin="miter" d="m39.757,12.195c-0.77566-2.294-14.738-2.294-15.513,0,0,2.294-2.327,9.1761-2.327,15.293,0,6.1174,7.7566,9.9408,10.084,9.9408,2.327,0,10.084-3.8234,10.084-9.9408s-2.327-12.999-2.327-15.293z" stroke="#919191" stroke-linecap="round" stroke-width="1px" fill="none"/>
+ </g>
+ <rect id="icon:48-32" height="48" width="48" y="8" x="8" fill="none"/>
+ <g id="g3967">
+  <path id="path4331-5" opacity="0.07000002" fill="url(#radialGradient3148)" d="m197.48,38.071a6.1527,1.5235,0,0,1,-12.305,0,6.1527,1.5235,0,1,1,12.305,0z"/>
+  <path id="path3159-0" fill-rule="evenodd" fill="url(#radialGradient3144)" d="m197.17,26.797c-0.51711-1.0196-9.8251-1.0196-10.342,0,0,1.5293-1.5513,6.1174-1.5513,10.196,0,4.0783,5.1711,6.6272,6.7224,6.6272s6.7224-2.5489,6.7224-6.6272-1.5513-8.6663-1.5513-10.196z"/>
+  <path id="path3963" fill="url(#radialGradient3965)" d="m198.84,53.614a7.0742,2.3344,0,0,1,-14.148,0,7.0742,2.3344,0,1,1,14.148,0z"/>
+  <path id="path3157-8" stroke-linejoin="round" style="stroke-dasharray:none;" d="m197.48,52.5a5.4784,1.9784,0,0,1,-10.957,0,5.4784,1.9784,0,1,1,10.957,0z" stroke="#888a85" stroke-linecap="round" stroke-miterlimit="0" stroke-width="1.04329979" fill="url(#linearGradient3141)"/>
+  <path id="path3236-7" stroke-linejoin="round" style="stroke-dasharray:none;" d="m196.5,52.5a4.5,1.2723,0,1,1,-9,0,4.5,1.2723,0,1,1,9,0z" stroke="url(#linearGradient3138)" stroke-linecap="round" stroke-miterlimit="0" stroke-width="1" fill="none"/>
+  <path id="path3163-6" stroke-linejoin="miter" d="m189.41,42.6c1.0342,1.0196,2.0684,2.5489,2.0684,8.1565,0,1.0196,0.13988,1.5293,0.51711,1.5293s0.51711-0.50978,0.51711-1.5293c0-5.6076,1.0342-7.137,2.0684-8.1565" fill-rule="evenodd" stroke="#888a85" stroke-linecap="round" stroke-width="1" fill="url(#linearGradient3135)"/>
+  <path id="path3179-3" fill-rule="evenodd" fill="url(#radialGradient3132)" d="m185,35.5c0,6,5.4487,8.1197,7,8.1197s7-2.1197,7-8.1197"/>
+  <path id="path5788-5" stroke-linejoin="round" style="stroke-dasharray:none;" d="m198.33,35.463a6.3333,1.5293,0,0,1,-12.667,0,6.3333,1.5293,0,1,1,12.667,0z" stroke="url(#linearGradient3128)" stroke-linecap="round" stroke-miterlimit="0" stroke-width="0.67398685" fill="url(#radialGradient3126)"/>
+  <path id="path10032" stroke-linejoin="miter" d="m196.59,28.813-10.5,6.9062c-0.47185,2.1071,0.57612,3.8839,1.9688,5.1562,0.69977,0.63931,1.4778,1.1545,2.1875,1.5,0.70965,0.3455,1.3655,0.53125,1.75,0.53125,0.38459,0,1.0458-0.20765,1.7812-0.5625,0.73541-0.35485,1.5613-0.85244,2.2812-1.5312,1.4399-1.3576,2.4993-3.3228,1.8438-5.7812-0.001-0.01036-0.001-0.02089,0-0.03125-0.32628-2.6102-0.67143-3.938-1.3125-6.1875z" stroke="url(#linearGradient3123)" stroke-linecap="round" stroke-width="1" fill="none"/>
+  <path id="path3266-0" fill-rule="evenodd" fill="url(#linearGradient3120)" d="m188.23,28.667,3.1026,0s-1.5513,6.1174-1.5513,8.6663c0,1.5293,1.0342,2.5489,0.51711,3.0587-0.51711,0.50978-3.1026-1.4789-3.1026-4.0783,0-1.0196,0.51711-4.0783,1.0342-7.6467z"/>
+  <path id="path2385-8" stroke-linejoin="round" style="stroke-dasharray:none;" d="m197.18,26.727a5.1841,1.2399,0,1,1,-0.00079,-0.02154" stroke="#919191" stroke-linecap="round" stroke-miterlimit="0" stroke-width="0.97392541" fill="none"/>
+  <path id="path3358-0" stroke-linejoin="round" d="m197,27.965c-0.33333,0.33333-2.3078,0.69994-5.1622,0.69994s-4.5044-0.3666-4.8378-0.69994" stroke="#FFF" stroke-linecap="round" stroke-miterlimit="0" stroke-width="0.67398679" fill="none"/>
+  <path id="path3450-4" stroke-linejoin="round" d="m198,35c0,0.57036-2.3333,1.3333-6.0127,1.3666-3.68,0.033-5.99-0.797-5.99-1.367" stroke="url(#radialGradient3115)" stroke-linecap="round" stroke-miterlimit="0" stroke-width="0.67398679" fill="none"/>
+  <path id="path3395-1" opacity="0.35" stroke-linejoin="round" d="m190.67,44s0.33333,0.66667,1.3333,0.63923c1-0.02744,1.3333-0.63923,1.3333-0.63923" stroke="#000" stroke-linecap="round" stroke-width="0.66666669px" fill="none"/>
+  <path id="path3363-1" stroke-linejoin="round" d="m8,43.468,2.5-1,2.4688,0.125-4.9687,0.875z" fill-rule="evenodd" transform="matrix(1.0342194,0,0,1.019566,183.72625,7.681901)" filter="url(#filter3391-9)" stroke="url(#linearGradient3054)" stroke-linecap="round" stroke-width="0.64922434px" fill="url(#linearGradient3052)"/>
+  <path id="path3354-3" stroke-linejoin="miter" d="m197.17,26.797c-0.6711-1.7968-9.6711-1.7968-10.342,0,0,1.5293-1.8289,6.1249-1.8289,10.203,0,4.0783,5.4487,6.6197,7,6.6197s7-2.5414,7-6.6197-1.8289-8.6738-1.8289-10.203z" stroke="#919191" stroke-linecap="round" stroke-width="1" fill="none"/>
+ </g>
+ <rect id="icon:32-32" height="32" width="32" y="24" x="176" fill="none"/>
+ <g id="g3353">
+  <path id="path4331-0" opacity="0.07000002" fill="url(#radialGradient3350)" d="m306.74,47.035a3.0764,0.76176,0,0,1,-6.1527,0,3.0764,0.76176,0,1,1,6.1527,0z"/>
+  <path id="path3159-3" fill-rule="evenodd" fill="url(#radialGradient3347)" d="m306.59,41.398c-0.25856-0.50978-4.9125-0.50978-5.1711,0,0,0.76468-0.77566,3.0587-0.77566,5.0978s2.5856,3.3136,3.3612,3.3136c0.77566,0,3.3612-1.2745,3.3612-3.3136s-0.77566-4.3332-0.77566-5.0978z"/>
+  <path id="path3157-4" stroke-linejoin="round" style="stroke-dasharray:none;" d="m307.5,54.5a3.5,1,0,1,1,-7,0,3.5,1,0,1,1,7,0z" stroke="#888a85" stroke-linecap="round" stroke-miterlimit="0" stroke-width="0.75" fill="url(#linearGradient3344)"/>
+  <path id="path3236-6" stroke-linejoin="round" style="stroke-dasharray:none;" d="m306.47,54.5a2.4723,0.62614,0,1,1,-4.9445,0,2.4723,0.62614,0,1,1,4.9445,0z" stroke="url(#linearGradient3341)" stroke-linecap="round" stroke-miterlimit="0" stroke-width="0.51998168" fill="none"/>
+  <path id="path3163-60" stroke-linejoin="miter" d="M302.71,49.3c0.51,0.51,1.29,1.396,1.29,4.2,0,0.50978-0.18862,1,0,1s0-0.49022,0-1c0-2.8038,0.77566-3.6902,1.2928-4.2" fill-rule="evenodd" stroke="#888a85" stroke-linecap="round" stroke-width="1" fill="url(#linearGradient3338)"/>
+  <path id="path3179-2" fill-rule="evenodd" fill="url(#radialGradient3335)" d="m300.67,45.667c0,3,2.5577,4.1432,3.3333,4.1432,0.77566,0,3.3333-1.1432,3.3333-4.1432"/>
+  <path id="path5788-58" stroke-linejoin="round" style="stroke-dasharray:none;" d="m307.17,45.732a3.1667,0.76467,0,0,1,-6.3333,0,3.1667,0.76467,0,1,1,6.3333,0z" stroke="url(#linearGradient3332)" stroke-linecap="round" stroke-miterlimit="0" stroke-width="0.33699343" fill="url(#radialGradient3330)"/>
+  <path id="path10032-9" stroke-linejoin="miter" d="m306.33,42.359-5.3125,3.4844c-0.24,1.0703,0.29739,1.9831,1,2.625,0.35297,0.32247,0.73566,0.57566,1.0938,0.75,0.3581,0.17434,0.68682,0.26562,0.89063,0.26562,0.20383,0,0.53517-0.08657,0.90625-0.26562s0.77734-0.45434,1.1406-0.79688c0.72658-0.68506,1.2693-1.6777,0.9375-2.9219-0.16485-1.3189-0.32971-1.9963-0.65625-3.1406z" stroke="url(#linearGradient3327)" stroke-linecap="round" stroke-width="0.5" fill="none"/>
+  <path id="path3266-5" fill-rule="evenodd" fill="url(#linearGradient3324)" d="m302.12,42.333,1.5513,0s-0.77567,3.0587-0.77567,4.3332c0,0.76468,0.51711,1.2745,0.25856,1.5293-0.25856,0.25489-1.5513-0.73944-1.5513-2.0391,0-0.50978,0.25855-2.0391,0.51711-3.8234z"/>
+  <path id="path2385-0" stroke-linejoin="round" style="stroke-dasharray:none;" d="m306.5,41.363a2.5,0.86345,0,1,1,-0.00038,-0.01501" stroke="#919191" stroke-linecap="round" stroke-miterlimit="0" stroke-width="0.75" fill="none"/>
+  <path id="path3358-6" stroke-linejoin="round" d="m306.5,42.608c-0.16667,0.16667-1.1539,0.56872-2.5811,0.56872s-2.2835-0.46455-2.4501-0.63122" stroke-opacity="0.49803922" stroke="#FFF" stroke-linecap="round" stroke-miterlimit="0" stroke-width="1" fill="none"/>
+  <path id="path3450-0" stroke-linejoin="round" d="m307,45.5c0,0.28518-1.1667,0.66667-3.0063,0.6833-1.84,0.017-2.99-0.398-2.99-0.683" stroke="url(#radialGradient3319)" stroke-linecap="round" stroke-miterlimit="0" stroke-width="0.3369934" fill="none"/>
+  <path id="path3354-8" stroke-linejoin="miter" d="m306.5,41.5c0.14844-1.4062-5.2188-1.2578-5,0,0,0.76467-1,2.9609-1,5s2.7243,3.3098,3.5,3.3098c0.77566,0,3.5-1.2707,3.5-3.3098s-1-4.2353-1-5z" stroke="#888a85" stroke-linecap="round" stroke-width="0.75" fill="none"/>
+ </g>
+ <rect id="icon:16-32" height="16" width="16" y="40" x="296" fill="none"/>
+</svg>
diff -Naur wine-2.0a/dlls/wineandroid.drv/wine_launcher_xhdpi.png wine-2.0b/dlls/wineandroid.drv/wine_launcher_xhdpi.png
--- wine-2.0a/dlls/wineandroid.drv/wine_launcher_xhdpi.png	1970-01-01 01:00:00.000000000 +0100
+++ wine-2.0b/dlls/wineandroid.drv/wine_launcher_xhdpi.png	2017-07-11 20:37:51.000000000 +0100
@@ -0,0 +1,6 @@
+PNG
+
+   IHDR   0   0   Wù   gAMA  ±üa    cHRM  z&    ú   è  u0  ê`  :  pºQ<   bKGD ÿ ÿ ÿ ½§   	oFFs       þ ¾«   tIMEß7Äá    	vpAg  p   @ Hþôy  	IDAThÞíkl\ÅÇÿgæ¾v÷îË`;Æo	ÅP J(mHiS¨*!úêJFU"¡Yå¡Ð"|pÕ>D+T²HR"JpÄØµó´¯íµ½ñ®÷qw÷ÎéÛÔÒkÇjt´;sþ?ÍÌ×þo×h¡03½ôÒKßu]÷ÇDô%f.à ¹Ç @¢ÌÜ+¥|¹¥¥åM"âË°mÛ6a  ú¹[Jy\)5HDã &ç-fæe V2s#&"j Åb­­­©B5h0ãfI)eæ)å~xò¿yñÅR×Ñ½J©_B¡ ì¸, D¾öÚkõõõßø~4]¶cÇ×qh.»  =÷¨Ç²¬°i¥¶m²²²huuu¢··7ÞÓÓZ0sýàààSkÖ¬qËËËoPÍÌåDT@0sADf`æ!×uOçr¹®'Oz¨þ² ¸izzú·Dô3K 'hÀ9 §öìÙxõÕWÕÎ;]¿ß¯1³`f@ë×¯7W¯^}+ï-D(´`{{»@­âã¹¿ÊæóÉ¤Ü½{7mØ°ÁÝµkîñxüB¿Ò/¥H)ý]]]VQQQëçêZÚpçF =7ntÙP J¥´ÑÑQkß¾}RJi0MÓÔ5Mo SSS<33ãcæSLæ @)õ"úh.¹ e³YH$X,fuvvJ"²MÓ4¥ºBRÊù.DDjllL³m{nZr !Äõ öÏ%+\×étZO¥RÆää¤>44daêºn!Ðr¾Ï=KMMMÉ|>ßT°B2óuDô1 ¸®[Ëåd&ÑÉ¤122à5MÓBØaØ¦iÚ¦iúçÝ0$ÑÁ`®_RÖÖV@½a' Àqª|>/s¹N§ÍÁÁARú>Ë²lÃ0üaø5MèºîÕÂá0Q]{{»^ºP h 0ÔÜÜ ¹¹ÜÊééàÈ¡cÇ´×_¯¿mlÌ4F¤)MË(MsHJ×±¬©¶=~ÁïtÊ9CÌ<å8NK ¨pò>à~h9¾wïÍªÁAW?wNT9#kÌ®è ì¹Y"W1ZÆ²Îðñãç&RÕK@DSÝÝ«J?¬Â®(*BvdDf\WfLB Ï³NÄ¬YS r bétyèPeêæ3ñÒÒB´ú*qFGWV ¨--®iPs9&Lf MÔuHÃ ù|`¯®¦¡Äu1Hhq!ìéÙÕêÒ 0³/Ï§/ #B@ û|Ë£è¾û¨©·¼fe%´²2`J!yèb#ÒÓè±cÈ)ÇçSJ){)[ÀTRªâø8T2ñß³ ]h R Ó Ý,ZL3Ç®[Ðr¢Ð10å-- PÄÐéÓq }B`~zR° sn\ä:fwA5UUÈd³yiãh)h ¢ÃÅÖ|ºó7>ÉóBÐ Ø Jæ¼tÎÍyéEyWßqDYàSîK`æ?Û*+ÏÀGo½ !¯åÁàg×66B«¬T®¦å-Ëz»-²BjÝºu(¾úêúÁýûË4 cG¢²¶F>65  ðß  ? Ïëz
+ïD"IÖõ_¶´´t.  ÜrË-áð¯ÏçHXF¬»¥ ''áùDø¼Ï§ý'@×ÌL>ªi½çgª:xî¹ç®$àÃÄ£»»87<3³ç*»À¢dëVtÁÇ¢ºi~¹¥¥e´P>Ú¾}{¹ÊçßEoïeýývþÔ)ðð0¼À¿V¯ÕÜ÷ÔÏ7äÝ¶iÓ¦ó¿`  hoo¦vá8ëËûú¬+ffïïÎ%­]H(2|VÊ¿{677O/4ö¢ ÌÛóÏ?ÿÌ+Ë£QTÃÐ¼^DIµ,¤¤TÊ0~ðÈ#üy±b.*  <óÌÓ·»®Ú·,Xd8é42É¬®É57?öþbÆ+xGöy¶yócRéÔþcýpÁqÐÝwSéä;-Xø¹Ð4¯ßó?XíõzýRJTU_D¿¾±½ ÀgÙüBétîÀ`ãÆt2J!Nú[[[³_  PÌ§3idsY°R=*Î% Àær9ÏçA$ú¾ <îºyÇuóÖú Ä1¥ÜR
+D¸p©Â\²1ÀÌ¤-ú9oRq[[[¹¢ü:nðU W2À¬+¥XH'3«1fR¾GJîÞ²eËðehkkóò¿R¿EùòCW­¬>SUU=mÛ¶yêÔÉ½oïYËÌøÖ=÷vWÄÉ$¢QsxxÈ?0Ð_qÒÐ7mÙ²%Q¨Eù?ÕT×jß¼{íö¾¾¾ø#G2¯½¶k¦··×ñxÌ³M76Ý0|ëf:%ËW­ZUóõ»îÆº³óÐÁ¿ øö03µm{ú®ºÚW^xáÓO>ùä°a¦ÂÔuÝÐ4-^W_wÑÕÕ'"yøðá¨2&èôÑG#>øà=W03z_¼ .ôØÖ-­¨XyÝ×ßÐ+¥îLE"d$ÉNOO#^RRâÃ¾ÊÊÊâêêê²ººº«\×ÅÛûöæí~¿íWÏ>Ù£¢¥°mûýä?/+»â¡@ ÂÑ¢pq&¦e¶Ï¶4MÓ³¹,)×ñxÇ££b<õNL[ÈØÎßÿîå?¦R©cøôJvé æ¬6_±fÍ×V­¨(¿1
+4éRH©63rÕëæ¹\n"9r~x¸ëÝw÷÷Äb±4^ ßÔ/æû¹@9fÝè"7s@Àf¿¡øß¶D!äÿë¤   %tEXtdate:create 2015-01-23T16:55:11-06:00(â$   %tEXtdate:modify 2015-01-23T16:55:11-06:00YÀZ    IEND®B`
\ No newline at end of file
diff -Naur wine-2.0a/dlls/wineandroid.drv/WineProvider.java wine-2.0b/dlls/wineandroid.drv/WineProvider.java
--- wine-2.0a/dlls/wineandroid.drv/WineProvider.java	1970-01-01 01:00:00.000000000 +0100
+++ wine-2.0b/dlls/wineandroid.drv/WineProvider.java	2017-07-11 20:37:51.000000000 +0100
@@ -0,0 +1,109 @@
+/*
+ * WineProvider class
+ *
+ * Copyright 2016 Vincent Povirk for CodeWeavers
+ */
+
+package org.winehq.wine;
+
+import android.content.ContentProvider;
+import android.content.ContentValues;
+import android.content.UriMatcher;
+import android.content.res.AssetFileDescriptor;
+import android.database.Cursor;
+import android.net.Uri;
+import android.os.Bundle;
+import android.os.ParcelFileDescriptor;
+import android.util.Log;
+import java.io.IOException;
+import java.io.FileOutputStream;
+import org.winehq.wine.WineDriver;
+
+public class WineProvider extends ContentProvider {
+    private static final int COPYING = 1;
+
+    private static final UriMatcher uri_matcher = new UriMatcher( UriMatcher.NO_MATCH );
+
+    static
+    {
+        uri_matcher.addURI( "*", "copying", 1 );
+    }
+
+    @Override
+    public Cursor query( Uri uri, String[] projection, String selection,
+            String[] selectionArgs, String sortOrder ) {
+        Log.i( "Wine", "WineProvider.query "+uri.toString() );
+        return null;
+    }
+
+    @Override
+    public Uri insert( Uri uri, ContentValues values ) {
+        return null;
+    }
+
+    @Override
+    public int update( Uri uri, ContentValues values, String selection, String[] selectionArgs ) {
+        return 0;
+    }
+
+    @Override
+    public int delete( Uri uri, String selection, String[] selectionArgs ) {
+        return 0;
+    }
+
+    @Override
+    public String getType( Uri uri ) {
+        Log.i( "wine", "WineProvider.getType "+uri.toString() );
+        return null;
+    }
+
+    @Override
+    public boolean onCreate() {
+        return true;
+    }
+
+    @Override
+    public String[] getStreamTypes( Uri uri, String mimeTypeFilter )
+    {
+        Log.i( "wine", "getStreamTypes "+uri.toString()+" "+mimeTypeFilter );
+        switch (uri_matcher.match( uri ))
+        {
+        case COPYING:
+            return WineDriver.getCopyingTypes( mimeTypeFilter );
+        default:
+            return null;
+        }
+    }
+
+    @Override
+    public AssetFileDescriptor openTypedAssetFile( Uri uri, String mimeTypeFilter, Bundle opts )
+    {
+        Log.i( "wine", "openTypedAssetFile "+uri.toString()+" "+mimeTypeFilter );
+        switch (uri_matcher.match( uri ))
+        {
+        case COPYING:
+        {
+            ParcelFileDescriptor[] fd;
+
+            try
+            {
+                fd = ParcelFileDescriptor.createPipe();
+            }
+            catch (IOException e)
+            {
+                Log.i( "wine", "createPipe failed" );
+                return null;
+            }
+
+            ParcelFileDescriptor r = fd[0];
+            FileOutputStream w = new ParcelFileDescriptor.AutoCloseOutputStream( fd[1] );
+
+            WineDriver.serveClipboardData( mimeTypeFilter, w );
+
+            return new AssetFileDescriptor( r, 0, AssetFileDescriptor.UNKNOWN_LENGTH );
+        }
+        default:
+            return null;
+        }
+    }
+}
diff -Naur wine-2.0a/dlls/winecoreaudio.drv/midi.c wine-2.0b/dlls/winecoreaudio.drv/midi.c
--- wine-2.0a/dlls/winecoreaudio.drv/midi.c	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/winecoreaudio.drv/midi.c	2017-07-11 20:37:51.000000000 +0100
@@ -96,13 +96,42 @@
 extern int SynthUnit_Close(AUGraph graph);
 
 
+/* CodeWeavers HACK - bug 5193: Allow disabling of MIDI during bottle
+ * creation and installs. */
+static BOOL MIDI_IsEnabled(void)
+{
+    static BOOL inited;
+    static BOOL enabled = TRUE;
+
+    if (!inited)
+    {
+        if (getenv("CX_DISABLE_COREAUDIO_MIDI"))
+        {
+            TRACE("MIDI support disabled by environment variable.\n");
+            enabled = FALSE;
+        }
+        inited = TRUE;
+    }
+
+    return enabled;
+}
+
+
 LONG CoreAudio_MIDIInit(void)
 {
     int i;
     CHAR szPname[MAXPNAMELEN] = {0};
 
-    int numDest = MIDIGetNumberOfDestinations();
-    CFStringRef name = CFStringCreateWithFormat(kCFAllocatorDefault, NULL, CFSTR("wineMIDIClient.%d"), getpid());
+    int numDest;
+    CFStringRef name;
+
+    /* CodeWeavers HACK - bug 5193: Allow disabling of MIDI during bottle
+     * creation and installs. */
+    if (!MIDI_IsEnabled())
+        return DRV_SUCCESS;
+
+    numDest = MIDIGetNumberOfDestinations();
+    name = CFStringCreateWithFormat(kCFAllocatorDefault, NULL, CFSTR("wineMIDIClient.%d"), getpid());
 
     wineMIDIClient = CoreMIDI_CreateClient( name );
     if (wineMIDIClient == NULL)
@@ -199,6 +228,11 @@
 
 LONG CoreAudio_MIDIRelease(void)
 {
+    /* CodeWeavers HACK - bug 5193: Allow disabling of MIDI during bottle
+     * creation and installs. */
+    if (!MIDI_IsEnabled())
+        return DRV_SUCCESS;
+
     TRACE("\n");
     if (MIDIIn_NumDevs > 0)
     {
@@ -948,6 +982,11 @@
 */
 DWORD WINAPI CoreAudio_modMessage(UINT wDevID, UINT wMsg, DWORD dwUser, DWORD dwParam1, DWORD dwParam2)
 {
+    /* CodeWeavers HACK - bug 5193: Allow disabling of MIDI during bottle
+     * creation and installs. */
+    if (!MIDI_IsEnabled())
+        return MMSYSERR_NOTENABLED;
+
     TRACE("%d %08x %08x %08x %08x\n", wDevID, wMsg, dwUser, dwParam1, dwParam2);
 
     switch (wMsg) {
@@ -989,6 +1028,11 @@
 */
 DWORD WINAPI CoreAudio_midMessage(UINT wDevID, UINT wMsg, DWORD dwUser, DWORD dwParam1, DWORD dwParam2)
 {
+    /* CodeWeavers HACK - bug 5193: Allow disabling of MIDI during bottle
+     * creation and installs. */
+    if (!MIDI_IsEnabled())
+        return MMSYSERR_NOTENABLED;
+
     TRACE("%d %08x %08x %08x %08x\n", wDevID, wMsg, dwUser, dwParam1, dwParam2);
     switch (wMsg) {
         case DRVM_INIT:
diff -Naur wine-2.0a/dlls/wined3d/arb_program_shader.c wine-2.0b/dlls/wined3d/arb_program_shader.c
--- wine-2.0a/dlls/wined3d/arb_program_shader.c	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/wined3d/arb_program_shader.c	2017-07-11 20:37:51.000000000 +0100
@@ -148,6 +148,7 @@
     } no;
     struct wined3d_shader_loop_control loop_control;
     BOOL                            had_else;
+    char                            src_param[256]; /* For the broken ARA quirk */
 };
 
 struct arb_ps_np2fixup_info
@@ -2841,8 +2842,12 @@
     struct shader_arb_ctx_priv *priv = ins->ctx->backend_data;
     const char *one = arb_get_helper_value(ins->ctx->reg_maps->shader_version.type, ARB_ONE);
 
-    /* POW operates on the absolute value of the input */
-    src0_copy.modifiers = abs_modifier(src0_copy.modifiers, &need_abs);
+    /* POW operates on the absolute value of the input. */
+    /* CrossOver hack: This was added for a DCT test, and it breaks Half Life
+     * 2 Episode two because the TA blasts the 32 register limit on gf7 cards.
+     * Allow disabling it for HL2. */
+    if (!cxgames_hacks.no_pow_abs)
+        src0_copy.modifiers = abs_modifier(src0_copy.modifiers, &need_abs);
 
     shader_arb_get_dst_param(ins, &ins->dst[0], dst);
     shader_arb_get_src_param(ins, &src0_copy, 0, src0);
@@ -2874,11 +2879,33 @@
     }
 }
 
+static void loop_helper_component(unsigned int depth, char *counter, char *aL)
+{
+    if(depth == 0)
+    {
+        *counter = 'x';
+        *aL = 'y';
+        return;
+    }
+    if(depth == 1)
+    {
+        *counter = 'z';
+        *aL = 'w';
+        return;
+    }
+
+    FIXME("Unsupported loop depth for broken ARA quirk: %u\n", depth);
+    *counter = '?';
+    *aL = '?';
+}
+
 static void shader_hw_loop(const struct wined3d_shader_instruction *ins)
 {
     struct wined3d_string_buffer *buffer = ins->ctx->buffer;
     char src_name[50];
     BOOL vshader = shader_is_vshader_version(ins->ctx->reg_maps->shader_version.type);
+    const struct wined3d_device *device = ins->ctx->shader->device;
+    const struct wined3d_gl_info *gl_info = &device->adapter->gl_info;
 
     /* src0 is aL */
     shader_arb_get_src_param(ins, &ins->src[1], 0, src_name);
@@ -2888,12 +2915,30 @@
         struct shader_arb_ctx_priv *priv = ins->ctx->backend_data;
         struct list *e = list_head(&priv->control_frames);
         struct control_frame *control_frame = LIST_ENTRY(e, struct control_frame, entry);
+        char counter, aL;
 
         if(priv->loop_depth > 1) shader_addline(buffer, "PUSHA aL;\n");
-        /* The constant loader makes sure to load -1 into iX.w */
-        shader_addline(buffer, "ARLC aL, %s.xywz;\n", src_name);
-        shader_addline(buffer, "BRA loop_%u_end (LE.x);\n", control_frame->no.loop);
+
+        if (gl_info->quirks & WINED3D_CX_QUIRK_BROKEN_ARA)
+        {
+            loop_helper_component(priv->loop_depth, &counter, &aL);
+            shader_addline(buffer, "MOVC loop_helper.%c%c, %s.xyxy;\n", counter, aL, src_name);
+            strcpy(control_frame->src_param, src_name);
+        }
+        else
+        {
+            /* The constant loader makes sure to load -1 into iX.w */
+            shader_addline(buffer, "ARLC aL, %s.xywz;\n", src_name);
+            counter = 'x';
+            aL = 'y';
+        }
+        shader_addline(buffer, "BRA loop_%u_end (LE.%c);\n", control_frame->no.loop, counter);
         shader_addline(buffer, "loop_%u_start:\n", control_frame->no.loop);
+
+        if (gl_info->quirks & WINED3D_CX_QUIRK_BROKEN_ARA)
+        {
+            shader_addline(buffer, "ARL aL.y, loop_helper.%c;\n", aL);
+        }
     }
     else
     {
@@ -2901,11 +2946,24 @@
     }
 }
 
+static char rep_helper_component(unsigned int depth)
+{
+    if(depth == 0) return 'x';
+    if(depth == 1) return 'y';
+    if(depth == 2) return 'z';
+    if(depth == 3) return 'w';
+
+    FIXME("Unsupported rep depth for broken ARA quirk: %u\n", depth);
+        return 'w';
+}
+
 static void shader_hw_rep(const struct wined3d_shader_instruction *ins)
 {
     struct wined3d_string_buffer *buffer = ins->ctx->buffer;
     char src_name[50];
     BOOL vshader = shader_is_vshader_version(ins->ctx->reg_maps->shader_version.type);
+    const struct wined3d_device *device = ins->ctx->shader->device;
+    const struct wined3d_gl_info *gl_info = &device->adapter->gl_info;
 
     shader_arb_get_src_param(ins, &ins->src[0], 0, src_name);
 
@@ -2915,11 +2973,21 @@
         struct shader_arb_ctx_priv *priv = ins->ctx->backend_data;
         struct list *e = list_head(&priv->control_frames);
         struct control_frame *control_frame = LIST_ENTRY(e, struct control_frame, entry);
+        char component;
 
-        if(priv->loop_depth > 1) shader_addline(buffer, "PUSHA aL;\n");
-
-        shader_addline(buffer, "ARLC aL, %s.xywz;\n", src_name);
-        shader_addline(buffer, "BRA loop_%u_end (LE.x);\n", control_frame->no.loop);
+        if (gl_info->quirks & WINED3D_CX_QUIRK_BROKEN_ARA)
+        {
+            component = rep_helper_component(priv->loop_depth);
+            shader_addline(buffer, "MOVC rep_helper.%c, %s.x;\n", component, src_name);
+            strcpy(control_frame->src_param, src_name);
+        }
+        else
+        {
+            component = 'x';
+            if(priv->loop_depth > 1) shader_addline(buffer, "PUSHA aL;\n");
+            shader_addline(buffer, "ARLC aL, %s.xywz;\n", src_name);
+        }
+        shader_addline(buffer, "BRA loop_%u_end (LE.%c);\n", control_frame->no.loop, component);
         shader_addline(buffer, "loop_%u_start:\n", control_frame->no.loop);
     }
     else
@@ -2932,15 +3000,29 @@
 {
     struct wined3d_string_buffer *buffer = ins->ctx->buffer;
     BOOL vshader = shader_is_vshader_version(ins->ctx->reg_maps->shader_version.type);
+    const struct wined3d_device *device = ins->ctx->shader->device;
+    const struct wined3d_gl_info *gl_info = &device->adapter->gl_info;
 
     if(vshader)
     {
         struct shader_arb_ctx_priv *priv = ins->ctx->backend_data;
         struct list *e = list_head(&priv->control_frames);
         struct control_frame *control_frame = LIST_ENTRY(e, struct control_frame, entry);
+        char counter, aL;
 
-        shader_addline(buffer, "ARAC aL.xy, aL;\n");
-        shader_addline(buffer, "BRA loop_%u_start (GT.x);\n", control_frame->no.loop);
+        if (gl_info->quirks & WINED3D_CX_QUIRK_BROKEN_ARA)
+        {
+            loop_helper_component(priv->loop_depth, &counter, &aL);
+            shader_addline(buffer, "ADDC loop_helper.%c%c, loop_helper.%c%c%c%c, %s.wzwz;\n",
+                          counter, aL, counter, aL, counter, aL, control_frame->src_param);
+        }
+        else
+        {
+            shader_addline(buffer, "ARAC aL.xy, aL;\n");
+            counter = 'x';
+            aL = 'y';
+        }
+        shader_addline(buffer, "BRA loop_%u_start (GT.%c);\n", control_frame->no.loop, counter);
         shader_addline(buffer, "loop_%u_end:\n", control_frame->no.loop);
 
         if(priv->loop_depth > 1) shader_addline(buffer, "POPA aL;\n");
@@ -2955,18 +3037,34 @@
 {
     struct wined3d_string_buffer *buffer = ins->ctx->buffer;
     BOOL vshader = shader_is_vshader_version(ins->ctx->reg_maps->shader_version.type);
+    const struct wined3d_device *device = ins->ctx->shader->device;
+    const struct wined3d_gl_info *gl_info = &device->adapter->gl_info;
 
     if(vshader)
     {
         struct shader_arb_ctx_priv *priv = ins->ctx->backend_data;
         struct list *e = list_head(&priv->control_frames);
         struct control_frame *control_frame = LIST_ENTRY(e, struct control_frame, entry);
+        char component;
 
-        shader_addline(buffer, "ARAC aL.xy, aL;\n");
-        shader_addline(buffer, "BRA loop_%u_start (GT.x);\n", control_frame->no.loop);
+        if (gl_info->quirks & WINED3D_CX_QUIRK_BROKEN_ARA)
+        {
+            component = rep_helper_component(priv->loop_depth);
+            shader_addline(buffer, "ADDC rep_helper.%c, rep_helper.%c, %s.w;\n", component,
+                           component, control_frame->src_param);
+        }
+        else
+        {
+            component = 'x';
+            shader_addline(buffer, "ARAC aL.xy, aL;\n");
+        }
+        shader_addline(buffer, "BRA loop_%u_start (GT.%c);\n", control_frame->no.loop, component);
         shader_addline(buffer, "loop_%u_end:\n", control_frame->no.loop);
 
-        if(priv->loop_depth > 1) shader_addline(buffer, "POPA aL;\n");
+        if (!(gl_info->quirks & WINED3D_CX_QUIRK_BROKEN_ARA))
+        {
+            if(priv->loop_depth > 1) shader_addline(buffer, "POPA aL;\n");
+        }
     }
     else
     {
@@ -3635,6 +3733,7 @@
     BOOL dcl_td = FALSE;
     BOOL want_nv_prog = FALSE;
     struct arb_pshader_private *shader_priv = shader->backend_data;
+    BOOL varying_limit_ok = TRUE;
     DWORD map;
     BOOL custom_linear_fog = FALSE;
 
@@ -3731,7 +3830,22 @@
         shader_addline(buffer, "OPTION ARB_draw_buffers;\n");
     }
 
-    if (reg_maps->shader_version.major < 3)
+    if (gl_info->quirks & WINED3D_CX_QUIRK_TEXCOORD_FOG)
+    {
+        unsigned int cnt = 0;
+        for(i = 0; i < MAX_REG_TEXCRD; i++)
+        {
+            if (reg_maps->texcoord & (1 << i)) ++cnt;
+        }
+        if(shader_priv->clipplane_emulation) cnt++;
+        if(cnt >= 8)
+        {
+            WARN("Disabling fog because 8 texcoords are used\n");
+            varying_limit_ok = FALSE;
+        }
+    }
+
+    if (reg_maps->shader_version.major < 3 && varying_limit_ok)
     {
         switch (args->super.fog)
         {
@@ -3921,7 +4035,7 @@
         }
     }
 
-    if (shader_priv->clipplane_emulation != ~0U && args->clip)
+    if (shader_priv->clipplane_emulation != ~0U && args->super.clip)
     {
         shader_addline(buffer, "KIL fragment.texcoord[%u];\n", shader_priv->clipplane_emulation);
     }
@@ -4253,6 +4367,11 @@
         shader_addline(buffer, "OPTION NV_vertex_program3;\n");
         priv_ctx.target_version = NV3;
         shader_addline(buffer, "ADDRESS aL;\n");
+        if (gl_info->quirks & WINED3D_CX_QUIRK_BROKEN_ARA)
+        {
+            shader_addline(buffer, "TEMP rep_helper;\n");
+            shader_addline(buffer, "TEMP loop_helper;\n");
+        }
     }
     else if (gl_info->supported[NV_VERTEX_PROGRAM2_OPTION])
     {
@@ -4549,7 +4668,6 @@
         struct arb_ps_compile_args *args)
 {
     const struct wined3d_gl_info *gl_info = context->gl_info;
-    const struct wined3d_d3d_info *d3d_info = context->d3d_info;
     int i;
     WORD int_skip;
 
@@ -4564,17 +4682,6 @@
             args->bools |= ( 1u << i);
     }
 
-    /* Only enable the clip plane emulation KIL if at least one clipplane is enabled. The KIL instruction
-     * is quite expensive because it forces the driver to disable early Z discards. It is cheaper to
-     * duplicate the shader than have a no-op KIL instruction in every shader
-     */
-    if (!d3d_info->vs_clipping && use_vs(state)
-            && state->render_states[WINED3D_RS_CLIPPING]
-            && state->render_states[WINED3D_RS_CLIPPLANEENABLE])
-        args->clip = 1;
-    else
-        args->clip = 0;
-
     /* Skip if unused or local, or supported natively */
     int_skip = ~shader->reg_maps.integer_constants | shader->reg_maps.local_int_consts;
     if (int_skip == 0xffff || gl_info->supported[NV_FRAGMENT_PROGRAM_OPTION])
@@ -5097,6 +5204,11 @@
         }
         caps->vs_version = min(wined3d_settings.max_sm_vs, vs_version);
         caps->vs_uniform_count = min(WINED3D_MAX_VS_CONSTS_F, vs_consts);
+        if (cxgames_hacks.safe_vs_consts)
+        {
+            /* One for the posFixup, one for the helper const, and the clipplanes. */
+            caps->vs_uniform_count -= 2 + gl_info->limits.user_clip_distances;
+        }
     }
     else
     {
@@ -8010,8 +8122,11 @@
     /* Leave the opengl state valid for blitting */
     arbfp_blit_unset(context->gl_info);
 
-    if (wined3d_settings.strict_draw_ordering
-            || (dst_texture->swapchain && (dst_texture->swapchain->front_buffer == dst_texture)))
+    if (wined3d_use_csmt(device))
+        context->gl_info->gl_ops.gl.p_glFinish();
+    else if (wined3d_settings.strict_draw_ordering
+            || (dst_texture->swapchain
+            && (dst_texture->swapchain->front_buffer == dst_texture)))
         context->gl_info->gl_ops.gl.p_glFlush(); /* Flush to ensure ordering across contexts. */
 
     context_release(context);
diff -Naur wine-2.0a/dlls/wined3d/buffer.c wine-2.0b/dlls/wined3d/buffer.c
--- wine-2.0a/dlls/wined3d/buffer.c	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/wined3d/buffer.c	2017-07-11 20:37:51.000000000 +0100
@@ -29,21 +29,23 @@
 
 WINE_DEFAULT_DEBUG_CHANNEL(d3d);
 
-#define WINED3D_BUFFER_HASDESC      0x01    /* A vertex description has been found. */
-#define WINED3D_BUFFER_USE_BO       0x02    /* Use a buffer object for this buffer. */
-#define WINED3D_BUFFER_DOUBLEBUFFER 0x04    /* Keep both a buffer object and a system memory copy for this buffer. */
-#define WINED3D_BUFFER_DISCARD      0x08    /* A DISCARD lock has occurred since the last preload. */
-#define WINED3D_BUFFER_SYNC         0x10    /* There has been at least one synchronized map since the last preload. */
-#define WINED3D_BUFFER_MAP          0x20    /* There has been at least one map since the last preload. */
-#define WINED3D_BUFFER_APPLESYNC    0x40    /* Using sync as in GL_APPLE_flush_buffer_range. */
-
 #define VB_MAXDECLCHANGES     100     /* After that number of decl changes we stop converting */
 #define VB_RESETDECLCHANGE    1000    /* Reset the decl changecount after that number of draws */
 #define VB_MAXFULLCONVERSIONS 5       /* Number of full conversions before we stop converting */
 #define VB_RESETFULLCONVS     20      /* Reset full conversion counts after that number of draws */
 
-static void buffer_invalidate_bo_range(struct wined3d_buffer *buffer, unsigned int offset, unsigned int size)
+void buffer_invalidate_bo_range(struct wined3d_buffer *buffer, unsigned int offset, unsigned int size)
 {
+    if (wined3d_use_csmt(buffer->resource.device))
+    {
+        buffer->locations &= ~WINED3D_LOCATION_BUFFER;
+
+        TRACE("New locations flags are %s.\n", wined3d_debug_location(buffer->locations));
+
+        if (!buffer->locations)
+            ERR("Buffer %p does not have any up to date location.\n", buffer);
+    }
+
     if (!offset && (!size || size == buffer->resource.size))
         goto invalidate_all;
 
@@ -113,14 +115,17 @@
             buffer, wined3d_debug_location(location), offset, size);
 
     if (location & WINED3D_LOCATION_BUFFER)
-        buffer_invalidate_bo_range(buffer, offset, size);
+        wined3d_cs_emit_buffer_invalidate_bo_range(buffer->resource.device->cs, buffer, offset, size);
 
-    buffer->locations &= ~location;
+    if (!wined3d_use_csmt(buffer->resource.device) || !(location & WINED3D_LOCATION_BUFFER))
+    {
+        buffer->locations &= ~location;
 
-    TRACE("New locations flags are %s.\n", wined3d_debug_location(buffer->locations));
+        TRACE("New locations flags are %s.\n", wined3d_debug_location(buffer->locations));
 
-    if (!buffer->locations)
-        ERR("Buffer %p does not have any up to date location.\n", buffer);
+        if (!buffer->locations)
+            ERR("Buffer %p does not have any up to date location.\n", buffer);
+    }
 }
 
 void wined3d_buffer_invalidate_location(struct wined3d_buffer *buffer, DWORD location)
@@ -183,7 +188,7 @@
 }
 
 /* Context activation is done by the caller. */
-static BOOL buffer_create_buffer_object(struct wined3d_buffer *buffer, struct wined3d_context *context)
+BOOL buffer_create_buffer_object(struct wined3d_buffer *buffer, struct wined3d_context *context)
 {
     const struct wined3d_gl_info *gl_info = context->gl_info;
     GLenum gl_usage = GL_STATIC_DRAW;
@@ -226,7 +231,12 @@
         TRACE("Buffer has WINED3DUSAGE_DYNAMIC set.\n");
         gl_usage = GL_STREAM_DRAW_ARB;
 
-        if (gl_info->supported[APPLE_FLUSH_BUFFER_RANGE])
+        if (cxgames_hacks.allow_glmapbuffer == WINED3D_MAPBUF_NEVER
+                || cxgames_hacks.allow_glmapbuffer == WINED3D_MAPBUF_STATIC)
+        {
+            buffer->flags |= WINED3D_BUFFER_DOUBLEBUFFER;
+        }
+        else if (gl_info->supported[APPLE_FLUSH_BUFFER_RANGE])
         {
             GL_EXTCALL(glBufferParameteriAPPLE(buffer->buffer_type_hint, GL_BUFFER_FLUSHING_UNMAP_APPLE, GL_FALSE));
             GL_EXTCALL(glBufferParameteriAPPLE(buffer->buffer_type_hint, GL_BUFFER_SERIALIZED_MODIFY_APPLE, GL_FALSE));
@@ -235,6 +245,10 @@
         }
         /* No setup is needed here for GL_ARB_map_buffer_range. */
     }
+    else if (cxgames_hacks.allow_glmapbuffer == WINED3D_MAPBUF_NEVER)
+    {
+        buffer->flags |= WINED3D_BUFFER_DOUBLEBUFFER;
+    }
 
     /* Reserve memory for the buffer. The amount of data won't change
      * so we are safe with calling glBufferData once and
@@ -253,13 +267,14 @@
 
     if (buffer->flags & WINED3D_BUFFER_DOUBLEBUFFER)
     {
-        buffer_invalidate_bo_range(buffer, 0, 0);
+        wined3d_cs_emit_buffer_invalidate_bo_range(buffer->resource.device->cs, buffer, 0, 0);
     }
     else
     {
         wined3d_resource_free_sysmem(&buffer->resource);
         wined3d_buffer_validate_location(buffer, WINED3D_LOCATION_BUFFER);
         wined3d_buffer_invalidate_location(buffer, WINED3D_LOCATION_SYSMEM);
+        buffer->resource.map_heap_memory = NULL;
     }
 
     return TRUE;
@@ -548,6 +563,7 @@
                 ERR("Failed to allocate system memory.\n");
                 return FALSE;
             }
+            buffer->resource.heap_memory = buffer->resource.map_heap_memory;
             return TRUE;
 
         case WINED3D_LOCATION_BUFFER:
@@ -810,40 +826,29 @@
 static void buffer_direct_upload(struct wined3d_buffer *This, struct wined3d_context *context, DWORD flags)
 {
     const struct wined3d_gl_info *gl_info = context->gl_info;
-    unsigned int start, len;
-    BYTE *map;
+    unsigned int start = 0, len = 0;
 
     buffer_bind(This, context);
-    if (gl_info->supported[ARB_MAP_BUFFER_RANGE])
-    {
-        GLbitfield mapflags;
-        mapflags = GL_MAP_WRITE_BIT | GL_MAP_FLUSH_EXPLICIT_BIT;
-        if (flags & WINED3D_BUFFER_DISCARD)
-            mapflags |= GL_MAP_INVALIDATE_BUFFER_BIT;
-        else if (flags & WINED3D_BUFFER_MAP && !(flags & WINED3D_BUFFER_SYNC))
-            mapflags |= GL_MAP_UNSYNCHRONIZED_BIT;
-        map = GL_EXTCALL(glMapBufferRange(This->buffer_type_hint, 0,
-                This->resource.size, mapflags));
-        checkGLcall("glMapBufferRange");
-    }
-    else
+
+    if (flags & WINED3D_BUFFER_DISCARD)
     {
-        if (This->flags & WINED3D_BUFFER_APPLESYNC)
-        {
-            DWORD syncflags = 0;
-            if (flags & WINED3D_BUFFER_DISCARD)
-                syncflags |= WINED3D_MAP_DISCARD;
-            else if (flags & WINED3D_BUFFER_MAP && !(flags & WINED3D_BUFFER_SYNC))
-                syncflags |= WINED3D_MAP_NOOVERWRITE;
-            buffer_sync_apple(This, syncflags, gl_info);
-        }
-        map = GL_EXTCALL(glMapBuffer(This->buffer_type_hint, GL_WRITE_ONLY));
-        checkGLcall("glMapBuffer");
+        GL_EXTCALL(glBufferData(This->buffer_type_hint, This->resource.size, NULL, GL_STREAM_DRAW));
+        checkGLcall("glBufferData");
     }
-    if (!map)
+    else if (flags & WINED3D_BUFFER_SYNC && This->flags & WINED3D_BUFFER_APPLESYNC)
     {
-        ERR("Failed to map OpenGL buffer.\n");
-        return;
+        /* OS X doesn't do non-blocking asynchonous glBufferSubData() like
+         * Linux drivers do, so we want to set
+         * GL_BUFFER_SERIALIZED_MODIFY_APPLE to GL_FALSE. Unfortunately
+         * ARB_sync and APPLE_fence are pretty slow on OS X. Putting the
+         * buffer back into synchronised mode for future maps is a lot faster.
+         * (GeForce 650M, Mavericks). The difference between ARB_sync and
+         * normal buffer operation is small in the glMapBuffer() codepath
+         * without CSMT. */
+        glFinish();
+        GL_EXTCALL(glBufferParameteriAPPLE(This->buffer_type_hint, GL_BUFFER_SERIALIZED_MODIFY_APPLE, GL_TRUE));
+        checkGLcall("glBufferParameteriAPPLE(This->buffer_type_hint, GL_BUFFER_SERIALIZED_MODIFY_APPLE, GL_TRUE)");
+        This->flags &= ~WINED3D_BUFFER_APPLESYNC;
     }
 
     while (This->modified_areas)
@@ -852,21 +857,9 @@
         start = This->maps[This->modified_areas].offset;
         len = This->maps[This->modified_areas].size;
 
-        memcpy(map + start, (BYTE *)This->resource.heap_memory + start, len);
-
-        if (gl_info->supported[ARB_MAP_BUFFER_RANGE])
-        {
-            GL_EXTCALL(glFlushMappedBufferRange(This->buffer_type_hint, start, len));
-            checkGLcall("glFlushMappedBufferRange");
-        }
-        else if (This->flags & WINED3D_BUFFER_APPLESYNC)
-        {
-            GL_EXTCALL(glFlushMappedBufferRangeAPPLE(This->buffer_type_hint, start, len));
-            checkGLcall("glFlushMappedBufferRangeAPPLE");
-        }
+        GL_EXTCALL(glBufferSubData(This->buffer_type_hint, start, len, (BYTE *)This->resource.heap_memory + start));
+        checkGLcall("glBufferSubData");
     }
-    GL_EXTCALL(glUnmapBuffer(This->buffer_type_hint));
-    checkGLcall("glUnmapBuffer");
 
     wined3d_buffer_validate_location(This, WINED3D_LOCATION_BUFFER);
 }
@@ -929,7 +922,7 @@
     wined3d_buffer_validate_location(buffer, WINED3D_LOCATION_BUFFER);
 }
 
-void buffer_mark_used(struct wined3d_buffer *buffer)
+static void buffer_mark_used(struct wined3d_buffer *buffer)
 {
     buffer->flags &= ~(WINED3D_BUFFER_MAP | WINED3D_BUFFER_SYNC | WINED3D_BUFFER_DISCARD);
 }
@@ -944,12 +937,6 @@
 
     TRACE("buffer %p.\n", buffer);
 
-    if (buffer->resource.map_count)
-    {
-        WARN("Buffer is mapped, skipping preload.\n");
-        return;
-    }
-
     buffer_mark_used(buffer);
 
     /* TODO: Make converting independent from VBOs */
@@ -1008,7 +995,7 @@
 
         /* The declaration changed, reload the whole buffer. */
         WARN("Reloading buffer because of a vertex declaration change.\n");
-        buffer_invalidate_bo_range(buffer, 0, 0);
+        wined3d_cs_emit_buffer_invalidate_bo_range(buffer->resource.device->cs, buffer, 0, 0);
 
         /* Avoid unfenced updates, we might overwrite more areas of the buffer than the application
          * cleared for unsynchronized updates.
@@ -1078,13 +1065,31 @@
 
     TRACE("buffer %p, offset %u, size %u, data %p, flags %#x.\n", buffer, offset, size, data, flags);
 
+    /* FIXME: There is a race condition with the same code in
+     * buffer_internal_preload() and buffer_get_memory().
+     *
+     * This deals with a race condition concerning buffer creation and buffer
+     * maps. If a VBO is created by the worker thread while the buffer is
+     * mapped, outdated data may be uploaded, and the BO range is not properly
+     * invalidated. Keep in mind that a broken application might draw from a
+     * buffer before mapping it.
+     *
+     * Don't try to solve this by going back to always invalidating changed
+     * areas. This won't work if we ever want to support glMapBufferRange()
+     * mapping with GL_ARB_buffer_storage in the CS.
+     *
+     * Also keep in mind that UnLoad can destroy the VBO, so simply creating
+     * it on buffer creation won't work either. */
+    if (!buffer->buffer_object && (buffer->flags & WINED3D_BUFFER_USE_BO))
+        wined3d_cs_emit_create_vbo(device->cs, buffer);
+
     /* Filter redundant WINED3D_MAP_DISCARD maps. The 3DMark2001 multitexture
      * fill rate test seems to depend on this. When we map a buffer with
      * GL_MAP_INVALIDATE_BUFFER_BIT, the driver is free to discard the
      * previous contents of the buffer. The r600g driver only does this when
      * the buffer is currently in use, while the proprietary NVIDIA driver
      * appears to do this unconditionally. */
-    if (buffer->flags & WINED3D_BUFFER_DISCARD)
+    if (buffer->ignore_discard)
         flags &= ~WINED3D_MAP_DISCARD;
     count = ++buffer->resource.map_count;
 
@@ -1113,16 +1118,36 @@
 
             if (!(flags & WINED3D_MAP_READONLY))
                 wined3d_buffer_invalidate_range(buffer, WINED3D_LOCATION_BUFFER, dirty_offset, dirty_size);
+
+            if (!wined3d_use_csmt(buffer->resource.device))
+            {
+                buffer->flags |= WINED3D_BUFFER_MAP;
+                if (flags & WINED3D_MAP_DISCARD)
+                {
+                    buffer->flags |= WINED3D_BUFFER_DISCARD;
+                    buffer->ignore_discard = TRUE;
+                }
+                else if (!(flags & WINED3D_MAP_NOOVERWRITE))
+                    buffer->flags |= WINED3D_BUFFER_SYNC;
+            }
         }
         else
         {
             if (!(flags & WINED3D_MAP_READONLY))
-                buffer_invalidate_bo_range(buffer, dirty_offset, dirty_size);
+                wined3d_cs_emit_buffer_invalidate_bo_range(buffer->resource.device->cs,
+                        buffer, dirty_offset, dirty_size);
 
             if (count == 1)
             {
                 const struct wined3d_gl_info *gl_info;
 
+                if (wined3d_use_csmt(buffer->resource.device))
+                {
+                    FIXME("waiting for cs\n");
+                    wined3d_cs_emit_glfinish(device->cs);
+                    device->cs->ops->finish(device->cs);
+                }
+
                 context = context_acquire(device, NULL);
                 gl_info = context->gl_info;
 
@@ -1167,20 +1192,34 @@
                         wined3d_buffer_load_location(buffer, context, WINED3D_LOCATION_SYSMEM);
                     }
                     TRACE("New pointer is %p.\n", buffer->resource.heap_memory);
-                    buffer->map_ptr = NULL;
                 }
                 context_release(context);
             }
         }
+    }
 
-        buffer->flags |= WINED3D_BUFFER_MAP;
-        if (flags & WINED3D_MAP_DISCARD)
-            buffer->flags |= WINED3D_BUFFER_DISCARD;
-        else if (!(flags & WINED3D_MAP_NOOVERWRITE))
+    if (wined3d_use_csmt(buffer->resource.device) && count == 1)
+    {
+        BOOL swvp = device->create_parms.flags & WINED3DCREATE_SOFTWARE_VERTEXPROCESSING;
+        if (flags & WINED3D_MAP_DISCARD && !swvp)
+        {
+            if (!wined3d_resource_is_idle(&buffer->resource))
+            {
+                buffer->ignore_discard = TRUE;
+                wined3d_resource_allocate_sysmem(&buffer->resource);
+                wined3d_cs_emit_buffer_swap_mem(device->cs, buffer, buffer->resource.map_heap_memory);
+            }
+        }
+        else if(!(flags & (WINED3D_MAP_NOOVERWRITE | WINED3D_MAP_READONLY)) && !buffer->ignore_discard)
+        {
+            wined3d_resource_wait_idle(&buffer->resource);
+            /* Writing to the (otherwise worker thread controlled) flags field
+             * is ok here since we made sure the buffer is idle. */
             buffer->flags |= WINED3D_BUFFER_SYNC;
+        }
     }
 
-    base = buffer->map_ptr ? buffer->map_ptr : buffer->resource.heap_memory;
+    base = buffer->map_ptr ? buffer->map_ptr : buffer->resource.map_heap_memory;
     *data = base + offset;
 
     TRACE("Returning memory at %p (base %p, offset %u).\n", *data, base, offset);
@@ -1243,17 +1282,15 @@
         }
 
         GL_EXTCALL(glUnmapBuffer(buffer->buffer_type_hint));
-        if (wined3d_settings.strict_draw_ordering)
+        if (wined3d_use_csmt(buffer->resource.device))
+            gl_info->gl_ops.gl.p_glFinish();
+        else if (wined3d_settings.strict_draw_ordering)
             gl_info->gl_ops.gl.p_glFlush(); /* Flush to ensure ordering across contexts. */
         context_release(context);
 
         buffer_clear_dirty_areas(buffer);
         buffer->map_ptr = NULL;
     }
-    else if (buffer->flags & WINED3D_BUFFER_HASDESC)
-    {
-        wined3d_resource_preload(&buffer->resource);
-    }
 }
 
 HRESULT wined3d_buffer_copy(struct wined3d_buffer *dst_buffer, unsigned int dst_offset,
@@ -1472,6 +1509,7 @@
     buffer->buffer_type_hint = buffer_type_hint_from_bind_flags(bind_flags);
     buffer->bind_flags = bind_flags;
     buffer->locations = WINED3D_LOCATION_SYSMEM;
+    buffer->ignore_discard = TRUE;
 
     TRACE("buffer %p, size %#x, usage %#x, format %s, memory @ %p.\n",
             buffer, buffer->resource.size, buffer->resource.usage,
@@ -1508,6 +1546,9 @@
         buffer->flags |= WINED3D_BUFFER_USE_BO;
     }
 
+    if (wined3d_use_csmt(device))
+        buffer->flags |= WINED3D_BUFFER_DOUBLEBUFFER;
+
     if (!(buffer->maps = HeapAlloc(GetProcessHeap(), 0, sizeof(*buffer->maps))))
     {
         ERR("Out of memory.\n");
@@ -1629,3 +1670,10 @@
 
     return WINED3D_OK;
 }
+
+void buffer_swap_mem(struct wined3d_buffer *buffer, BYTE *mem)
+{
+    wined3d_resource_free_sysmem(&buffer->resource);
+    buffer->resource.heap_memory = mem;
+    buffer->flags |= WINED3D_BUFFER_DISCARD;
+}
diff -Naur wine-2.0a/dlls/wined3d/context.c wine-2.0b/dlls/wined3d/context.c
--- wine-2.0a/dlls/wined3d/context.c	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/wined3d/context.c	2017-07-11 20:37:51.000000000 +0100
@@ -1420,19 +1420,27 @@
 }
 
 /* This function takes care of wined3d pixel format selection. */
-static int context_choose_pixel_format(const struct wined3d_device *device, HDC hdc,
-        const struct wined3d_format *color_format, const struct wined3d_format *ds_format,
+static int context_choose_pixel_format(const struct wined3d_device *device, const struct wined3d_swapchain *swapchain,
+        HDC hdc, const struct wined3d_format *color_format, const struct wined3d_format *ds_format,
         BOOL auxBuffers, BOOL findCompatible)
 {
+    const struct wined3d_gl_info *gl_info = &device->adapter->gl_info;
     int iPixelFormat=0;
     unsigned int current_value;
     unsigned int cfg_count = device->adapter->cfg_count;
+    BOOL double_buffer = TRUE;
     unsigned int i;
 
     TRACE("device %p, dc %p, color_format %s, ds_format %s, aux_buffers %#x, find_compatible %#x.\n",
             device, hdc, debug_d3dformat(color_format->id), debug_d3dformat(ds_format->id),
             auxBuffers, findCompatible);
 
+    /* CrossOver hack for bug 9330. */
+    if ((gl_info->quirks & WINED3D_CX_QUIRK_APPLE_DOUBLE_BUFFER)
+            && wined3d_settings.offscreen_rendering_mode == ORM_FBO
+            && !swapchain->desc.backbuffer_count)
+        double_buffer = FALSE;
+
     current_value = 0;
     for (i = 0; i < cfg_count; ++i)
     {
@@ -1444,7 +1452,7 @@
         if (cfg->iPixelType != WGL_TYPE_RGBA_ARB)
             continue;
         /* In window mode we need a window drawable format and double buffering. */
-        if (!(cfg->windowDrawable && cfg->doubleBuffer))
+        if (!cfg->windowDrawable || (double_buffer && !cfg->doubleBuffer))
             continue;
         if (cfg->redSize < color_format->red_size)
             continue;
@@ -1467,17 +1475,19 @@
          * depth it is no problem to emulate 16-bit using e.g. 24-bit, so accept that. */
         if (cfg->depthSize == ds_format->depth_size)
             value += 1;
-        if (cfg->stencilSize == ds_format->stencil_size)
+        if (!cfg->doubleBuffer == !double_buffer)
             value += 2;
-        if (cfg->alphaSize == color_format->alpha_size)
+        if (cfg->stencilSize == ds_format->stencil_size)
             value += 4;
+        if (cfg->alphaSize == color_format->alpha_size)
+            value += 8;
         /* We like to have aux buffers in backbuffer mode */
         if (auxBuffers && cfg->auxBuffers)
-            value += 8;
+            value += 16;
         if (cfg->redSize == color_format->red_size
                 && cfg->greenSize == color_format->green_size
                 && cfg->blueSize == color_format->blue_size)
-            value += 16;
+            value += 32;
 
         if (value > current_value)
         {
@@ -1498,7 +1508,9 @@
         ZeroMemory(&pfd, sizeof(pfd));
         pfd.nSize      = sizeof(pfd);
         pfd.nVersion   = 1;
-        pfd.dwFlags    = PFD_SUPPORT_OPENGL | PFD_DOUBLEBUFFER | PFD_DRAW_TO_WINDOW;/*PFD_GENERIC_ACCELERATED*/
+        pfd.dwFlags    = PFD_SUPPORT_OPENGL | PFD_DRAW_TO_WINDOW;/*PFD_GENERIC_ACCELERATED*/
+        if (double_buffer)
+            pfd.dwFlags |= PFD_DOUBLEBUFFER;
         pfd.iPixelType = PFD_TYPE_RGBA;
         pfd.cAlphaBits = color_format->alpha_size;
         pfd.cColorBits = color_format->red_size + color_format->green_size
@@ -1768,13 +1780,13 @@
     }
 
     /* Try to find a pixel format which matches our requirements. */
-    pixel_format = context_choose_pixel_format(device, hdc, color_format, ds_format, auxBuffers, FALSE);
+    pixel_format = context_choose_pixel_format(device, swapchain, hdc, color_format, ds_format, auxBuffers, FALSE);
 
     /* Try to locate a compatible format if we weren't able to find anything. */
     if (!pixel_format)
     {
         TRACE("Trying to locate a compatible pixel format because an exact match failed.\n");
-        pixel_format = context_choose_pixel_format(device, hdc, color_format, ds_format, auxBuffers, TRUE);
+        pixel_format = context_choose_pixel_format(device, swapchain, hdc, color_format, ds_format, auxBuffers, TRUE);
     }
 
     /* If we still don't have a pixel format, something is very wrong as ChoosePixelFormat barely fails */
@@ -3499,8 +3511,12 @@
         for (i = 0, map = context->stream_info.use_map; map; map >>= 1, ++i)
         {
             if (map & 1)
-                buffer_mark_used(state->streams[context->stream_info.elements[i].stream_idx].buffer);
+                wined3d_buffer_load(state->streams[context->stream_info.elements[i].stream_idx].buffer,
+                        context, state);
         }
+        /* PreLoad may kick buffers out of vram. */
+        if (isStateDirty(context, STATE_STREAMSRC))
+            context_update_stream_info(context, state);
     }
     if (state->index_buffer)
     {
@@ -3625,6 +3641,9 @@
 
     TRACE("device %p, target %p.\n", device, target);
 
+    if (wined3d_use_csmt(device) && device->cs->thread_id != GetCurrentThreadId())
+        FIXME("Acquiring a GL context from outside the CS thread.\n");
+
     if (current_context && current_context->destroyed)
         current_context = NULL;
 
diff -Naur wine-2.0a/dlls/wined3d/cs.c wine-2.0b/dlls/wined3d/cs.c
--- wine-2.0a/dlls/wined3d/cs.c	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/wined3d/cs.c	2017-07-11 20:37:51.000000000 +0100
@@ -26,6 +26,8 @@
 
 enum wined3d_cs_op
 {
+    WINED3D_CS_OP_NOP,
+    WINED3D_CS_OP_FENCE,
     WINED3D_CS_OP_PRESENT,
     WINED3D_CS_OP_CLEAR,
     WINED3D_CS_OP_DRAW,
@@ -53,6 +55,7 @@
     WINED3D_CS_OP_SET_CLIP_PLANE,
     WINED3D_CS_OP_SET_COLOR_KEY,
     WINED3D_CS_OP_SET_MATERIAL,
+    WINED3D_CS_OP_PUSH_CONSTANTS,
     WINED3D_CS_OP_RESET_STATE,
     WINED3D_CS_OP_DESTROY_OBJECT,
     WINED3D_CS_OP_QUERY_ISSUE,
@@ -60,6 +63,48 @@
     WINED3D_CS_OP_UNLOAD_RESOURCE,
     WINED3D_CS_OP_MAP,
     WINED3D_CS_OP_UNMAP,
+    WINED3D_CS_OP_SET_PRIMITIVE_TYPE,
+    WINED3D_CS_OP_SET_LIGHT,
+    WINED3D_CS_OP_SET_LIGHT_ENABLE,
+    WINED3D_CS_OP_GLFINISH,
+    WINED3D_CS_OP_BLT,
+    WINED3D_CS_OP_CLEAR_RTV,
+    WINED3D_CS_OP_TEXTURE_CHANGED,
+    WINED3D_CS_OP_BUFFER_SWAP_MEM,
+    WINED3D_CS_OP_BUFFER_INVALIDATE_RANGE,
+    WINED3D_CS_OP_UPDATE_TEXTURE,
+    WINED3D_CS_OP_UPDATE_SUB_RESOURCE,
+    WINED3D_CS_OP_CREATE_VBO,
+    WINED3D_CS_OP_SAMPLER_INIT,
+    WINED3D_CS_OP_GET_DC,
+    WINED3D_CS_OP_RELEASE_DC,
+    WINED3D_CS_OP_CREATE_DUMMY_TEXTURES,
+    WINED3D_CS_OP_CREATE_SWAPCHAIN_CONTEXT,
+    WINED3D_CS_OP_DELETE_GL_CONTEXTS,
+    WINED3D_CS_OP_UPDATE_SWAP_INTERVAL,
+    WINED3D_CS_OP_STOP,
+};
+
+struct wined3d_cs_packet
+{
+    unsigned int size;
+    BYTE data[1];
+};
+
+struct wined3d_cs_stop
+{
+    enum wined3d_cs_op opcode;
+};
+
+struct wined3d_cs_nop
+{
+    enum wined3d_cs_op opcode;
+};
+
+struct wined3d_cs_fence
+{
+    enum wined3d_cs_op opcode;
+    BOOL *signalled;
 };
 
 struct wined3d_cs_present
@@ -268,6 +313,15 @@
     struct wined3d_material material;
 };
 
+struct wined3d_cs_push_constants
+{
+    enum wined3d_cs_op opcode;
+    enum wined3d_push_constants type;
+    unsigned int start_idx;
+    unsigned int count;
+    BYTE constants[1];
+};
+
 struct wined3d_cs_reset_state
 {
     enum wined3d_cs_op opcode;
@@ -318,6 +372,171 @@
     HRESULT *hr;
 };
 
+struct wined3d_cs_set_primitive_type
+{
+    enum wined3d_cs_op opcode;
+    GLenum gl_primitive_type;
+};
+
+struct wined3d_cs_set_light
+{
+    enum wined3d_cs_op opcode;
+    struct wined3d_light_info light;
+};
+
+struct wined3d_cs_set_light_enable
+{
+    enum wined3d_cs_op opcode;
+    UINT idx;
+    BOOL enable;
+};
+
+struct wined3d_cs_finish
+{
+    enum wined3d_cs_op opcode;
+};
+
+struct wined3d_cs_blt
+{
+    enum wined3d_cs_op opcode;
+    struct wined3d_surface *dst_surface;
+    RECT dst_rect;
+    struct wined3d_surface *src_surface;
+    RECT src_rect;
+    DWORD flags;
+    struct wined3d_blt_fx fx;
+    enum wined3d_texture_filter_type filter;
+};
+
+struct wined3d_cs_clear_rtv
+{
+    enum wined3d_cs_op opcode;
+    struct wined3d_rendertarget_view *view;
+    RECT rect;
+    DWORD flags;
+    struct wined3d_color color;
+    float depth;
+    DWORD stencil;
+    const struct blit_shader *blitter;
+};
+
+struct wined3d_cs_texture_changed
+{
+    enum wined3d_cs_op opcode;
+    struct wined3d_texture *texture;
+    unsigned int sub_resource_idx;
+    struct wined3d_gl_bo *swap_buffer;
+    void *swap_heap_memory;
+};
+
+struct wined3d_cs_buffer_swap_mem
+{
+    enum wined3d_cs_op opcode;
+    struct wined3d_buffer *buffer;
+    BYTE *mem;
+};
+
+struct wined3d_cs_buffer_invalidate_bo_range
+{
+    enum wined3d_cs_op opcode;
+    struct wined3d_buffer *buffer;
+    unsigned int offset, size;
+};
+
+struct wined3d_cs_update_texture
+{
+    enum wined3d_cs_op opcode;
+    struct wined3d_texture *src, *dst;
+};
+
+struct wined3d_cs_update_sub_resource
+{
+    enum wined3d_cs_op opcode;
+    struct wined3d_resource *resource;
+    unsigned int sub_resource_idx;
+    struct wined3d_box box;
+    struct wined3d_sub_resource_data data;
+};
+
+struct wined3d_cs_create_vbo
+{
+    enum wined3d_cs_op opcode;
+    struct wined3d_buffer *buffer;
+};
+
+struct wined3d_cs_sampler_init
+{
+    enum wined3d_cs_op opcode;
+    struct wined3d_sampler *sampler;
+};
+
+struct wined3d_cs_get_release_dc
+{
+    enum wined3d_cs_op opcode;
+    struct wined3d_texture *texture;
+    unsigned int sub_resource_idx;
+};
+
+struct wined3d_cs_create_dummy_textures
+{
+    enum wined3d_cs_op opcode;
+};
+
+struct wined3d_cs_create_swapchain_context
+{
+    enum wined3d_cs_op opcode;
+    struct wined3d_swapchain *swapchain;
+    HRESULT *ret;
+};
+
+struct wined3d_cs_delete_gl_contexts
+{
+    enum wined3d_cs_op opcode;
+    struct wined3d_swapchain *swapchain;
+};
+
+struct wined3d_cs_update_swap_interval
+{
+    enum wined3d_cs_op opcode;
+    struct wined3d_swapchain *swapchain;
+};
+
+static void wined3d_cs_exec_nop(struct wined3d_cs *cs, const void *data)
+{
+}
+
+static void wined3d_cs_exec_fence(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_fence *op = data;
+
+    InterlockedExchange(op->signalled, TRUE);
+}
+
+static void wined3d_cs_emit_fence(struct wined3d_cs *cs, BOOL *signalled)
+{
+    struct wined3d_cs_fence *op;
+
+    *signalled = FALSE;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_FENCE;
+    op->signalled = signalled;
+    cs->ops->submit(cs);
+}
+
+static void wined3d_cs_emit_fence_prio(struct wined3d_cs *cs, BOOL *signalled)
+{
+    struct wined3d_cs_fence *op;
+
+    *signalled = FALSE;
+
+    op = cs->ops->require_space_prio(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_FENCE;
+    op->signalled = signalled;
+
+    cs->ops->submit_prio(cs);
+}
+
 static void wined3d_cs_exec_present(struct wined3d_cs *cs, const void *data)
 {
     const struct wined3d_cs_present *op = data;
@@ -334,6 +553,8 @@
     {
         wined3d_resource_release(&swapchain->back_buffers[i]->resource);
     }
+
+    InterlockedDecrement(&cs->pending_presents);
 }
 
 void wined3d_cs_emit_present(struct wined3d_cs *cs, struct wined3d_swapchain *swapchain,
@@ -341,6 +562,7 @@
 {
     struct wined3d_cs_present *op;
     unsigned int i;
+    LONG pending;
 
     op = cs->ops->require_space(cs, sizeof(*op));
     op->opcode = WINED3D_CS_OP_PRESENT;
@@ -350,6 +572,8 @@
     op->dst_rect = *dst_rect;
     op->flags = flags;
 
+    pending = InterlockedIncrement(&cs->pending_presents);
+
     wined3d_resource_acquire(&swapchain->front_buffer->resource);
     for (i = 0; i < swapchain->desc.backbuffer_count; ++i)
     {
@@ -357,21 +581,34 @@
     }
 
     cs->ops->submit(cs);
+
+    /* D3D10 documentation suggests that Windows allows the game to run
+     * 3 frames ahead of the GPU. Increasing this above 1 causes uneven
+     * animation in some games, most notably StarCraft II. The framerates
+     * don't show this problem. The issue is more noticable with vsync
+     * on, but also happens with vsync off.
+     *
+     * In Counter-Strike: Source a frame difference of 3 causes noticable
+     * input delay that makes the game unplayable. */
+    while (pending > 1)
+    {
+        wined3d_pause();
+        pending = InterlockedCompareExchange(&cs->pending_presents, 0, 0);
+    }
 }
 
 static void wined3d_cs_exec_clear(struct wined3d_cs *cs, const void *data)
 {
+    const struct wined3d_state *state = &cs->state;
     const struct wined3d_cs_clear *op = data;
-    const struct wined3d_state *state;
     struct wined3d_device *device;
     unsigned int i;
     RECT draw_rect;
 
     device = cs->device;
-    state = &device->state;
     wined3d_get_draw_rect(state, &draw_rect);
     device_clear_render_targets(device, device->adapter->gl_info.limits.buffers,
-            &device->fb, op->rect_count, op->rects, &draw_rect, op->flags,
+            &cs->fb, op->rect_count, op->rects, &draw_rect, op->flags,
             &op->color, op->depth, op->stencil);
 
     if (op->flags & WINED3DCLEAR_TARGET)
@@ -416,16 +653,41 @@
     cs->ops->submit(cs);
 }
 
+static BOOL wined3d_cs_colorwrite_enabled(const struct wined3d_state *state, unsigned int i)
+{
+    switch (i)
+    {
+        case 0:
+            return !!state->render_states[WINED3D_RS_COLORWRITEENABLE];
+        case 1:
+            return !!state->render_states[WINED3D_RS_COLORWRITEENABLE1];
+        case 2:
+            return !!state->render_states[WINED3D_RS_COLORWRITEENABLE2];
+        case 3:
+            return !!state->render_states[WINED3D_RS_COLORWRITEENABLE3];
+        default:
+            ERR("Unexpected color target %u.\n", i);
+            return TRUE;
+    }
+}
+
+static BOOL wined3d_cs_depth_stencil_enabled(const struct wined3d_state *state)
+{
+    return state->render_states[WINED3D_RS_ZENABLE]
+            || state->render_states[WINED3D_RS_STENCILENABLE];
+}
+
 static void wined3d_cs_exec_draw(struct wined3d_cs *cs, const void *data)
 {
-    struct wined3d_state *state = &cs->device->state;
+    const struct wined3d_gl_info *gl_info = &cs->device->adapter->gl_info;
     struct wined3d_shader_sampler_map_entry *entry;
     struct wined3d_shader_resource_view *view;
+    struct wined3d_state *state = &cs->state;
     const struct wined3d_cs_draw *op = data;
     struct wined3d_shader *shader;
     unsigned int i, j;
 
-    if (!cs->device->adapter->gl_info.supported[ARB_DRAW_ELEMENTS_BASE_VERTEX]
+    if (!gl_info->supported[ARB_DRAW_ELEMENTS_BASE_VERTEX]
             && state->load_base_vertex_index != op->base_vertex_idx)
     {
         state->load_base_vertex_index = op->base_vertex_idx;
@@ -447,12 +709,12 @@
         if (state->textures[i])
             wined3d_resource_release(&state->textures[i]->resource);
     }
-    for (i = 0; i < cs->device->adapter->gl_info.limits.buffers; ++i)
+    for (i = 0; i < gl_info->limits.buffers; ++i)
     {
-        if (state->fb->render_targets[i])
+        if (state->fb->render_targets[i] && wined3d_cs_colorwrite_enabled(state, i))
             wined3d_resource_release(state->fb->render_targets[i]->resource);
     }
-    if (state->fb->depth_stencil)
+    if (state->fb->depth_stencil && wined3d_cs_depth_stencil_enabled(state))
         wined3d_resource_release(state->fb->depth_stencil->resource);
     for (i = 0; i < WINED3D_SHADER_TYPE_COUNT; ++i)
     {
@@ -497,11 +759,17 @@
     op->indexed = indexed;
 
     if (indexed)
+    {
         wined3d_resource_acquire(&state->index_buffer->resource);
+        state->index_buffer->ignore_discard = FALSE;
+    }
     for (i = 0; i < ARRAY_SIZE(state->streams); ++i)
     {
         if (state->streams[i].buffer)
+        {
             wined3d_resource_acquire(&state->streams[i].buffer->resource);
+            state->streams[i].buffer->ignore_discard = FALSE;
+        }
     }
     for (i = 0; i < ARRAY_SIZE(state->textures); ++i)
     {
@@ -510,10 +778,10 @@
     }
     for (i = 0; i < cs->device->adapter->gl_info.limits.buffers; ++i)
     {
-        if (state->fb->render_targets[i])
+        if (state->fb->render_targets[i] && wined3d_cs_colorwrite_enabled(state, i))
             wined3d_resource_acquire(state->fb->render_targets[i]->resource);
     }
-    if (state->fb->depth_stencil)
+    if (state->fb->depth_stencil && wined3d_cs_depth_stencil_enabled(state))
         wined3d_resource_acquire(state->fb->depth_stencil->resource);
     for (i = 0; i < WINED3D_SHADER_TYPE_COUNT; ++i)
     {
@@ -633,10 +901,10 @@
                 || prev_surface->container->flags & WINED3D_TEXTURE_DISCARD))
         {
             surface_modify_ds_location(prev_surface, WINED3D_LOCATION_DISCARDED, prev->width, prev->height);
-            if (prev_surface == device->onscreen_depth_stencil)
+            if (prev_surface == cs->onscreen_depth_stencil)
             {
-                wined3d_texture_decref(device->onscreen_depth_stencil->container);
-                device->onscreen_depth_stencil = NULL;
+                wined3d_texture_decref(cs->onscreen_depth_stencil->container);
+                cs->onscreen_depth_stencil = NULL;
             }
         }
     }
@@ -1256,6 +1524,73 @@
     cs->ops->submit(cs);
 }
 
+static const struct
+{
+    unsigned int offset;
+    unsigned int size;
+    DWORD mask;
+}
+wined3d_cs_push_constant_info[] =
+{
+    /* WINED3D_PUSH_CONSTANTS_VS_F */
+    {FIELD_OFFSET(struct wined3d_state, vs_consts_f), sizeof(struct wined3d_vec4),  WINED3D_SHADER_CONST_VS_F},
+    /* WINED3D_PUSH_CONSTANTS_PS_F */
+    {FIELD_OFFSET(struct wined3d_state, ps_consts_f), sizeof(struct wined3d_vec4),  WINED3D_SHADER_CONST_PS_F},
+    /* WINED3D_PUSH_CONSTANTS_VS_I */
+    {FIELD_OFFSET(struct wined3d_state, vs_consts_i), sizeof(struct wined3d_ivec4), WINED3D_SHADER_CONST_VS_I},
+    /* WINED3D_PUSH_CONSTANTS_PS_I */
+    {FIELD_OFFSET(struct wined3d_state, ps_consts_i), sizeof(struct wined3d_ivec4), WINED3D_SHADER_CONST_PS_I},
+    /* WINED3D_PUSH_CONSTANTS_VS_B */
+    {FIELD_OFFSET(struct wined3d_state, vs_consts_b), sizeof(BOOL),                 WINED3D_SHADER_CONST_VS_B},
+    /* WINED3D_PUSH_CONSTANTS_PS_B */
+    {FIELD_OFFSET(struct wined3d_state, ps_consts_b), sizeof(BOOL),                 WINED3D_SHADER_CONST_PS_B},
+};
+
+static void wined3d_cs_st_push_constants(struct wined3d_cs *cs, enum wined3d_push_constants p,
+        unsigned int start_idx, unsigned int count, const void *constants)
+{
+    struct wined3d_device *device = cs->device;
+    unsigned int context_count;
+    unsigned int i;
+    unsigned int offset;
+
+    if (p == WINED3D_PUSH_CONSTANTS_VS_F)
+        device->shader_backend->shader_update_float_vertex_constants(device, start_idx, count);
+    else if (p == WINED3D_PUSH_CONSTANTS_PS_F)
+        device->shader_backend->shader_update_float_pixel_constants(device, start_idx, count);
+
+    offset = wined3d_cs_push_constant_info[p].offset + start_idx * wined3d_cs_push_constant_info[p].size;
+    memcpy((BYTE *)&cs->state + offset, constants, count * wined3d_cs_push_constant_info[p].size);
+    for (i = 0, context_count = device->context_count; i < context_count; ++i)
+    {
+        device->contexts[i]->constant_update_mask |= wined3d_cs_push_constant_info[p].mask;
+    }
+}
+
+static void wined3d_cs_exec_push_constants(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_push_constants *op = data;
+
+    wined3d_cs_st_push_constants(cs, op->type, op->start_idx, op->count, op->constants);
+}
+
+static void wined3d_cs_mt_push_constants(struct wined3d_cs *cs, enum wined3d_push_constants p,
+        unsigned int start_idx, unsigned int count, const void *constants)
+{
+    struct wined3d_cs_push_constants *op;
+    unsigned int size;
+
+    size = count * wined3d_cs_push_constant_info[p].size;
+    op = cs->ops->require_space(cs, FIELD_OFFSET(struct wined3d_cs_push_constants, constants[size]));
+    op->opcode = WINED3D_CS_OP_PUSH_CONSTANTS;
+    op->type = p;
+    op->start_idx = start_idx;
+    op->count = count;
+    memcpy(op->constants, constants, size);
+
+    cs->ops->submit(cs);
+}
+
 static void wined3d_cs_exec_reset_state(struct wined3d_cs *cs, const void *data)
 {
     struct wined3d_adapter *adapter = cs->device->adapter;
@@ -1299,8 +1634,42 @@
 {
     const struct wined3d_cs_query_issue *op = data;
     struct wined3d_query *query = op->query;
+    BOOL poll;
+
+    poll = query->query_ops->query_issue(query, op->flags);
 
-    query->query_ops->query_issue(query, op->flags);
+    if (wined3d_use_csmt(query->device))
+    {
+        if (poll && list_empty(&query->poll_list_entry))
+        {
+            list_add_tail(&cs->query_poll_list, &query->poll_list_entry);
+        }
+        else if (!poll && !list_empty(&query->poll_list_entry))
+        {
+            /* Can happen if occlusion queries are restarted. This discards the old
+             * result, polling it could result in a GL error */
+            list_remove(&query->poll_list_entry);
+            list_init(&query->poll_list_entry);
+            InterlockedIncrement(&query->counter_retrieved);
+            /* If this is an END called on a running query we need to increase
+             * the counter again to match the "redundant" increment of the
+             * second END. */
+            if (op->flags & WINED3DISSUE_END)
+                InterlockedIncrement(&query->counter_retrieved);
+        }
+        else if (op->flags & WINED3DISSUE_END)
+        {
+            /* Can happen when an occlusion query is ended without being started,
+             * in which case we don't want to poll, but still have to counter-balance
+             * the increment of the main counter (!poll && list_empty).
+             *
+             * This can also happen if an event query is re-issued before the first
+             * fence was reached (poll && !list_empty). In this case the query is
+             * already in the list and the poll function will check the new fence.
+             * We have to counter-balance the discarded increment. */
+            InterlockedIncrement(&query->counter_retrieved);
+        }
+    }
 }
 
 void wined3d_cs_emit_query_issue(struct wined3d_cs *cs, struct wined3d_query *query, DWORD flags)
@@ -1374,7 +1743,7 @@
     struct wined3d_cs_map *op;
     HRESULT hr;
 
-    op = cs->ops->require_space(cs, sizeof(*op));
+    op = cs->ops->require_space_prio(cs, sizeof(*op));
     op->opcode = WINED3D_CS_OP_MAP;
     op->resource = resource;
     op->sub_resource_idx = sub_resource_idx;
@@ -1383,7 +1752,8 @@
     op->flags = flags;
     op->hr = &hr;
 
-    cs->ops->submit(cs);
+    cs->ops->submit_prio(cs);
+    cs->ops->finish_prio(cs);
 
     return hr;
 }
@@ -1401,19 +1771,605 @@
     struct wined3d_cs_unmap *op;
     HRESULT hr;
 
-    op = cs->ops->require_space(cs, sizeof(*op));
+    op = cs->ops->require_space_prio(cs, sizeof(*op));
     op->opcode = WINED3D_CS_OP_UNMAP;
     op->resource = resource;
     op->sub_resource_idx = sub_resource_idx;
     op->hr = &hr;
 
-    cs->ops->submit(cs);
+    cs->ops->submit_prio(cs);
+    cs->ops->finish_prio(cs);
 
     return hr;
 }
 
+static void wined3d_cs_exec_set_primitive_type(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_set_primitive_type *op = data;
+    GLenum prev;
+
+    prev = cs->state.gl_primitive_type;
+
+    if (op->gl_primitive_type == GL_POINTS || prev == GL_POINTS)
+        device_invalidate_state(cs->device, STATE_POINT_ENABLE);
+
+    cs->state.gl_primitive_type = op->gl_primitive_type;
+}
+
+void wined3d_cs_emit_set_primitive_type(struct wined3d_cs *cs, GLenum primitive_type)
+{
+    struct wined3d_cs_set_primitive_type *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_SET_PRIMITIVE_TYPE;
+    op->gl_primitive_type = primitive_type;
+
+    cs->ops->submit(cs);
+}
+
+static void wined3d_cs_exec_set_light(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_set_light *op = data;
+
+    UINT light_idx = op->light.OriginalIndex;
+    UINT hash_idx = LIGHTMAP_HASHFUNC(op->light.OriginalIndex);
+    struct wined3d_light_info *object = NULL;
+    struct list *e;
+
+    LIST_FOR_EACH(e, &cs->state.light_map[hash_idx])
+    {
+        object = LIST_ENTRY(e, struct wined3d_light_info, entry);
+        if (object->OriginalIndex == light_idx)
+            break;
+        object = NULL;
+    }
+
+    if (!object)
+    {
+        TRACE("Adding new light.\n");
+        if (!(object = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(*object))))
+        {
+            ERR("Failed to allocate light info.\n");
+            return;
+        }
+
+        list_add_head(&cs->state.light_map[hash_idx], &object->entry);
+        object->glIndex = -1;
+        object->OriginalIndex = light_idx;
+    }
+
+    /* Update the live definitions if the light is currently assigned a glIndex. */
+    if (object->glIndex != -1)
+    {
+        if (object->OriginalParms.type != op->light.OriginalParms.type)
+            device_invalidate_state(cs->device, STATE_LIGHT_TYPE);
+        device_invalidate_state(cs->device, STATE_ACTIVELIGHT(object->glIndex));
+    }
+
+    object->OriginalParms = op->light.OriginalParms;
+    object->position = op->light.position;
+    object->direction = op->light.direction;
+    object->exponent = op->light.exponent;
+    object->cutoff = op->light.cutoff;
+}
+
+void wined3d_cs_emit_set_light(struct wined3d_cs *cs, const struct wined3d_light_info *light)
+{
+    struct wined3d_cs_set_light *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_SET_LIGHT;
+    op->light = *light;
+
+    cs->ops->submit(cs);
+}
+
+static void wined3d_cs_exec_set_light_enable(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_set_light_enable *op = data;
+    UINT hash_idx = LIGHTMAP_HASHFUNC(op->idx);
+    struct wined3d_light_info *light_info = NULL;
+    struct list *e;
+    struct wined3d_device *device = cs->device;
+
+    LIST_FOR_EACH(e, &cs->state.light_map[hash_idx])
+    {
+        light_info = LIST_ENTRY(e, struct wined3d_light_info, entry);
+        if (light_info->OriginalIndex == op->idx)
+            break;
+        light_info = NULL;
+    }
+    TRACE("Found light %p.\n", light_info);
+
+    /* Should be handled by the device by emitting a set_light op */
+    if (!light_info)
+    {
+        ERR("Trying to enable an undefined light.\n");
+        return;
+    }
+
+    if (!op->enable)
+    {
+        if (light_info->glIndex != -1)
+        {
+            device_invalidate_state(device, STATE_LIGHT_TYPE);
+            device_invalidate_state(device, STATE_ACTIVELIGHT(light_info->glIndex));
+            cs->state.lights[light_info->glIndex] = NULL;
+            light_info->glIndex = -1;
+        }
+        else
+        {
+            TRACE("Light already disabled, nothing to do.\n");
+        }
+        light_info->enabled = FALSE;
+    }
+    else
+    {
+        light_info->enabled = TRUE;
+        if (light_info->glIndex != -1)
+        {
+            TRACE("Nothing to do as light was enabled.\n");
+        }
+        else
+        {
+            unsigned int i;
+            const struct wined3d_gl_info *gl_info = &device->adapter->gl_info;
+            /* Find a free GL light. */
+            for (i = 0; i < gl_info->limits.lights; ++i)
+            {
+                if (!cs->state.lights[i])
+                {
+                    cs->state.lights[i] = light_info;
+                    light_info->glIndex = i;
+                    break;
+                }
+            }
+            if (light_info->glIndex == -1)
+            {
+                /* Should be caught by the device before emitting
+                 * the light_enable op. */
+                ERR("Too many concurrently active lights.\n");
+                return;
+            }
+
+            /* i == light_info->glIndex */
+            device_invalidate_state(device, STATE_LIGHT_TYPE);
+            device_invalidate_state(device, STATE_ACTIVELIGHT(i));
+        }
+    }
+}
+
+void wined3d_cs_emit_set_light_enable(struct wined3d_cs *cs, unsigned int idx, BOOL enable)
+{
+    struct wined3d_cs_set_light_enable *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_SET_LIGHT_ENABLE;
+    op->idx = idx;
+    op->enable = enable;
+
+    cs->ops->submit(cs);
+}
+
+static void wined3d_cs_exec_glfinish(struct wined3d_cs *cs, const void *data)
+{
+    struct wined3d_device *device = cs->device;
+    struct wined3d_context *context;
+
+    if (!device->d3d_initialized)
+        return;
+
+    context = context_acquire(device, NULL);
+    context->gl_info->gl_ops.gl.p_glFinish();
+    context_release(context);
+}
+
+void wined3d_cs_emit_glfinish(struct wined3d_cs *cs)
+{
+    struct wined3d_cs_finish *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_GLFINISH;
+
+    cs->ops->submit(cs);
+}
+
+static void wined3d_cs_exec_blt(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_blt *op = data;
+
+    surface_blt_ugly(op->dst_surface, &op->dst_rect, op->src_surface,
+            &op->src_rect, op->flags, &op->fx, op->filter);
+
+    wined3d_resource_release(&op->dst_surface->container->resource);
+    if (op->src_surface && op->src_surface != op->dst_surface)
+        wined3d_resource_release(&op->src_surface->container->resource);
+}
+
+void wined3d_cs_emit_blt(struct wined3d_cs *cs, struct wined3d_surface *dst_surface,
+        const RECT *dst_rect, struct wined3d_surface *src_surface,
+        const RECT *src_rect, DWORD flags, const struct wined3d_blt_fx *fx,
+        enum wined3d_texture_filter_type filter)
+{
+    struct wined3d_cs_blt *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_BLT;
+    op->dst_surface = dst_surface;
+    op->dst_rect = *dst_rect;
+    op->src_surface = src_surface;
+    op->src_rect = *src_rect;
+    op->flags = flags;
+    op->filter = filter;
+    if (fx)
+        op->fx = *fx;
+
+    wined3d_resource_acquire(&dst_surface->container->resource);
+    if (src_surface && src_surface != dst_surface)
+        wined3d_resource_acquire(&src_surface->container->resource);
+
+    cs->ops->submit(cs);
+}
+
+static void wined3d_cs_exec_clear_rtv(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_clear_rtv *op = data;
+    struct wined3d_device *device = cs->device;
+
+    if (op->flags & WINED3DCLEAR_TARGET)
+        op->blitter->color_fill(device, op->view, &op->rect, &op->color);
+    else
+        op->blitter->depth_fill(device, op->view, &op->rect, op->flags, op->depth, op->stencil);
+
+    wined3d_resource_release(op->view->resource);
+}
+
+void wined3d_cs_emit_clear_rtv(struct wined3d_cs *cs, struct wined3d_rendertarget_view *view,
+        const RECT *rect, DWORD flags, const struct wined3d_color *color, float depth, DWORD stencil,
+        const struct blit_shader *blitter)
+{
+    struct wined3d_cs_clear_rtv *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_CLEAR_RTV;
+    op->view = view;
+    op->rect = *rect;
+    op->flags = flags;
+    if (flags & WINED3DCLEAR_TARGET)
+        op->color = *color;
+    op->depth = depth;
+    op->stencil = stencil;
+    op->blitter = blitter;
+
+    wined3d_resource_acquire(view->resource);
+
+    cs->ops->submit(cs);
+}
+
+static void wined3d_cs_exec_texture_changed(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_texture_changed *op = data;
+
+    wined3d_texture_changed(op->texture, op->sub_resource_idx, op->swap_buffer, op->swap_heap_memory);
+}
+
+void wined3d_cs_emit_texture_changed(struct wined3d_cs *cs, struct wined3d_texture *texture,
+        unsigned int sub_resource_idx, struct wined3d_gl_bo *swap_buffer, void *swap_heap_memory)
+{
+    struct wined3d_cs_texture_changed *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_TEXTURE_CHANGED;
+    op->texture = texture;
+    op->sub_resource_idx = sub_resource_idx;
+    op->swap_buffer = swap_buffer;
+    op->swap_heap_memory = swap_heap_memory;
+
+    cs->ops->submit(cs);
+}
+
+static void wined3d_cs_exec_buffer_swap_mem(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_buffer_swap_mem *op = data;
+    struct wined3d_buffer *buffer = op->buffer;
+
+    buffer_swap_mem(buffer, op->mem);
+
+    if (!buffer->buffer_object && buffer->resource.bind_count)
+    {
+        device_invalidate_state(cs->device, STATE_STREAMSRC);
+        device_invalidate_state(cs->device, STATE_INDEXBUFFER);
+    }
+}
+
+void wined3d_cs_emit_buffer_swap_mem(struct wined3d_cs *cs, struct wined3d_buffer *buffer, BYTE *mem)
+{
+    struct wined3d_cs_buffer_swap_mem *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_BUFFER_SWAP_MEM;
+    op->buffer = buffer;
+    op->mem = mem;
+
+    cs->ops->submit(cs);
+}
+
+static void wined3d_cs_exec_buffer_invalidate_bo_range(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_buffer_invalidate_bo_range *op = data;
+
+    buffer_invalidate_bo_range(op->buffer, op->offset, op->size);
+}
+
+void wined3d_cs_emit_buffer_invalidate_bo_range(struct wined3d_cs *cs,
+        struct wined3d_buffer *buffer, unsigned int offset, unsigned int size)
+{
+    struct wined3d_cs_buffer_invalidate_bo_range *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_BUFFER_INVALIDATE_RANGE;
+    op->buffer = buffer;
+    op->offset = offset;
+    op->size = size;
+
+    cs->ops->submit(cs);
+}
+
+static void wined3d_cs_exec_update_texture(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_update_texture *op = data;
+    struct wined3d_context *context;
+
+    context = context_acquire(cs->device, NULL);
+    device_exec_update_texture(context, op->src, op->dst);
+    context_release(context);
+
+    wined3d_resource_release(&op->src->resource);
+    wined3d_resource_release(&op->dst->resource);
+}
+
+void wined3d_cs_emit_update_texture(struct wined3d_cs *cs, struct wined3d_texture *src,
+        struct wined3d_texture *dst)
+{
+    struct wined3d_cs_update_texture *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_UPDATE_TEXTURE;
+    op->src = src;
+    op->dst = dst;
+
+    wined3d_resource_acquire(&op->src->resource);
+    wined3d_resource_acquire(&op->dst->resource);
+
+    cs->ops->submit(cs);
+}
+
+static void wined3d_cs_exec_update_sub_resource(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_update_sub_resource *op = data;
+    const struct wined3d_box *box = &op->box;
+    unsigned int width, height, depth, level;
+    struct wined3d_const_bo_address addr;
+    struct wined3d_context *context;
+    struct wined3d_texture *texture;
+
+    texture = wined3d_texture_from_resource(op->resource);
+
+    level = op->sub_resource_idx % texture->level_count;
+    width = wined3d_texture_get_level_width(texture, level);
+    height = wined3d_texture_get_level_height(texture, level);
+    depth = wined3d_texture_get_level_depth(texture, level);
+
+    addr.buffer_object = 0;
+    addr.addr = op->data.data;
+
+    context = context_acquire(op->resource->device, NULL);
+
+    /* Only load the sub-resource for partial updates. */
+    if (!box->left && !box->top && !box->front
+            && box->right == width && box->bottom == height && box->back == depth)
+        wined3d_texture_prepare_texture(texture, context, FALSE);
+    else
+        wined3d_texture_load_location(texture, op->sub_resource_idx, context, WINED3D_LOCATION_TEXTURE_RGB);
+    wined3d_texture_bind_and_dirtify(texture, context, FALSE);
+
+    wined3d_texture_upload_data(texture, op->sub_resource_idx, context,
+            box, &addr, op->data.row_pitch, op->data.slice_pitch);
+
+    context_release(context);
+
+    wined3d_texture_validate_location(texture, op->sub_resource_idx, WINED3D_LOCATION_TEXTURE_RGB);
+    wined3d_texture_invalidate_location(texture, op->sub_resource_idx, ~WINED3D_LOCATION_TEXTURE_RGB);
+}
+
+void wined3d_cs_emit_update_sub_resource(struct wined3d_cs *cs, struct wined3d_resource *resource,
+        unsigned int sub_resource_idx, const struct wined3d_box *box, const void *data, unsigned int row_pitch,
+        unsigned int slice_pitch)
+{
+    struct wined3d_cs_update_sub_resource *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_UPDATE_SUB_RESOURCE;
+    op->resource = resource;
+    op->sub_resource_idx = sub_resource_idx;
+    op->box = *box;
+    op->data.row_pitch = row_pitch;
+    op->data.slice_pitch = slice_pitch;
+    op->data.data = data;
+
+    cs->ops->submit(cs);
+    /* The data pointer may go away, need to wait until the data is read.
+     * Copying the data may be faster if it's small. */
+    cs->ops->finish(cs);
+}
+
+static void wined3d_cs_exec_create_vbo(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_create_vbo *op = data;
+    struct wined3d_context *context = context_acquire(cs->device, NULL);
+
+    buffer_create_buffer_object(op->buffer, context);
+
+    context_release(context);
+}
+
+void wined3d_cs_emit_create_vbo(struct wined3d_cs *cs, struct wined3d_buffer *buffer)
+{
+    struct wined3d_cs_create_vbo *op;
+
+    op = cs->ops->require_space_prio(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_CREATE_VBO;
+    op->buffer = buffer;
+
+    cs->ops->submit_prio(cs);
+    cs->ops->finish_prio(cs);
+}
+
+static void wined3d_cs_exec_sampler_init(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_sampler_init *op = data;
+
+    wined3d_sampler_init(op->sampler);
+}
+
+void wined3d_cs_emit_sampler_init(struct wined3d_cs *cs, struct wined3d_sampler *sampler)
+{
+    struct wined3d_cs_sampler_init *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_SAMPLER_INIT;
+    op->sampler = sampler;
+
+    cs->ops->submit(cs);
+}
+
+static void wined3d_cs_exec_get_dc(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_get_release_dc *op = data;
+
+    wined3d_texture_get_dc_cs(op->texture, op->sub_resource_idx);
+}
+
+void wined3d_cs_emit_get_dc(struct wined3d_cs *cs, struct wined3d_texture *texture,
+        unsigned int sub_resource_idx)
+{
+    struct wined3d_cs_get_release_dc *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_GET_DC;
+    op->texture = texture;
+    op->sub_resource_idx = sub_resource_idx;
+
+    cs->ops->submit(cs);
+    cs->ops->finish(cs);
+}
+
+static void wined3d_cs_exec_release_dc(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_get_release_dc *op = data;
+
+    wined3d_texture_release_dc_cs(op->texture, op->sub_resource_idx);
+}
+
+void wined3d_cs_emit_release_dc(struct wined3d_cs *cs, struct wined3d_texture *texture,
+        unsigned int sub_resource_idx)
+{
+    struct wined3d_cs_get_release_dc *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_RELEASE_DC;
+    op->texture = texture;
+    op->sub_resource_idx = sub_resource_idx;
+
+    cs->ops->submit(cs);
+    cs->ops->finish(cs);
+}
+
+static void wined3d_cs_exec_create_dummy_textures(struct wined3d_cs *cs, const void *data)
+{
+    struct wined3d_context *context;
+
+    context = context_acquire(cs->device, NULL);
+    device_create_dummy_textures(cs->device, context);
+    context_release(context);
+}
+
+void wined3d_cs_emit_create_dummy_textures(struct wined3d_cs *cs)
+{
+    struct wined3d_cs_create_dummy_textures *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_CREATE_DUMMY_TEXTURES;
+
+    cs->ops->submit(cs);
+    cs->ops->finish(cs);
+}
+
+static void wined3d_cs_exec_create_swapchain_context(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_create_swapchain_context *op = data;
+
+    *op->ret = swapchain_create_context_cs(cs->device, op->swapchain);
+}
+
+HRESULT wined3d_cs_emit_create_swapchain_context(struct wined3d_cs *cs, struct wined3d_swapchain *swapchain)
+{
+    HRESULT ret;
+    struct wined3d_cs_create_swapchain_context *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_CREATE_SWAPCHAIN_CONTEXT;
+    op->swapchain = swapchain;
+    op->ret = &ret;
+
+    cs->ops->submit(cs);
+    cs->ops->finish(cs);
+
+    return ret;
+}
+
+static void wined3d_cs_exec_delete_gl_contexts(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_delete_gl_contexts *op = data;
+
+    device_delete_opengl_contexts_cs(cs->device, op->swapchain);
+}
+
+void wined3d_cs_emit_delete_opengl_contexts(struct wined3d_cs *cs, struct wined3d_swapchain *swapchain)
+{
+    struct wined3d_cs_delete_gl_contexts *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_DELETE_GL_CONTEXTS;
+    op->swapchain = swapchain;
+
+    cs->ops->submit(cs);
+    cs->ops->finish(cs);
+}
+
+static void wined3d_cs_exec_update_swap_interval(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_update_swap_interval *op = data;
+
+    swapchain_update_swap_interval(op->swapchain);
+}
+
+void wined3d_cs_emit_update_swap_interval(struct wined3d_cs *cs, struct wined3d_swapchain *swapchain)
+{
+    struct wined3d_cs_update_swap_interval *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_UPDATE_SWAP_INTERVAL;
+    op->swapchain = swapchain;
+
+    cs->ops->submit(cs);
+    cs->ops->finish(cs);
+}
+
 static void (* const wined3d_cs_op_handlers[])(struct wined3d_cs *cs, const void *data) =
 {
+    /* WINED3D_CS_OP_NOP                        */ wined3d_cs_exec_nop,
+    /* WINED3D_CS_OP_FENCE                      */ wined3d_cs_exec_fence,
     /* WINED3D_CS_OP_PRESENT                    */ wined3d_cs_exec_present,
     /* WINED3D_CS_OP_CLEAR                      */ wined3d_cs_exec_clear,
     /* WINED3D_CS_OP_DRAW                       */ wined3d_cs_exec_draw,
@@ -1441,6 +2397,7 @@
     /* WINED3D_CS_OP_SET_CLIP_PLANE             */ wined3d_cs_exec_set_clip_plane,
     /* WINED3D_CS_OP_SET_COLOR_KEY              */ wined3d_cs_exec_set_color_key,
     /* WINED3D_CS_OP_SET_MATERIAL               */ wined3d_cs_exec_set_material,
+    /* WINED3D_CS_OP_PUSH_CONSTANTS             */ wined3d_cs_exec_push_constants,
     /* WINED3D_CS_OP_RESET_STATE                */ wined3d_cs_exec_reset_state,
     /* WINED3D_CS_OP_DESTROY_OBJECT             */ wined3d_cs_exec_destroy_object,
     /* WINED3D_CS_OP_QUERY_ISSUE                */ wined3d_cs_exec_query_issue,
@@ -1448,82 +2405,360 @@
     /* WINED3D_CS_OP_UNLOAD_RESOURCE            */ wined3d_cs_exec_unload_resource,
     /* WINED3D_CS_OP_MAP                        */ wined3d_cs_exec_map,
     /* WINED3D_CS_OP_UNMAP                      */ wined3d_cs_exec_unmap,
+    /* WINED3D_CS_OP_SET_PRIMITIVE_TYPE         */ wined3d_cs_exec_set_primitive_type,
+    /* WINED3D_CS_OP_SET_LIGHT                  */ wined3d_cs_exec_set_light,
+    /* WINED3D_CS_OP_SET_LIGHT_ENABLE           */ wined3d_cs_exec_set_light_enable,
+    /* WINED3D_CS_OP_GLFINISH                   */ wined3d_cs_exec_glfinish,
+    /* WINED3D_CS_OP_BLT                        */ wined3d_cs_exec_blt,
+    /* WINED3D_CS_OP_CLEAR_RTV                  */ wined3d_cs_exec_clear_rtv,
+    /* WINED3D_CS_OP_TEXTURE_CHANGED            */ wined3d_cs_exec_texture_changed,
+    /* WINED3D_CS_OP_BUFFER_SWAP_MEM            */ wined3d_cs_exec_buffer_swap_mem,
+    /* WINED3D_CS_OP_BUFFER_INVALIDATE_RANGE    */ wined3d_cs_exec_buffer_invalidate_bo_range,
+    /* WINED3D_CS_OP_UPDATE_TEXTURE             */ wined3d_cs_exec_update_texture,
+    /* WINED3D_CS_OP_UPDATE_SUB_RESOURCE        */ wined3d_cs_exec_update_sub_resource,
+    /* WINED3D_CS_OP_CREATE_VBO                 */ wined3d_cs_exec_create_vbo,
+    /* WINED3D_CS_OP_SAMPLER_INIT               */ wined3d_cs_exec_sampler_init,
+    /* WINED3D_CS_OP_GET_DC                     */ wined3d_cs_exec_get_dc,
+    /* WINED3D_CS_OP_RELEASE_DC                 */ wined3d_cs_exec_release_dc,
+    /* WINED3D_CS_OP_CREATE_DUMMY_TEXTURES      */ wined3d_cs_exec_create_dummy_textures,
+    /* WINED3D_CS_OP_CREATE_SWAPCHAIN_CONTEXT   */ wined3d_cs_exec_create_swapchain_context,
+    /* WINED3D_CS_OP_DELETE_GL_CONTEXTS         */ wined3d_cs_exec_delete_gl_contexts,
+    /* WINED3D_CS_OP_UPDATE_SWAP_INTERVAL       */ wined3d_cs_exec_update_swap_interval,
 };
 
-static void *wined3d_cs_st_require_space(struct wined3d_cs *cs, size_t size)
+static void *wined3d_cs_st_require_space(struct wined3d_cs *cs, unsigned int size)
 {
-    if (size > cs->data_size)
+    if (size > (cs->data_size - cs->end))
     {
+        unsigned int new_size;
         void *new_data;
 
-        size = max( size, cs->data_size * 2 );
-        if (!(new_data = HeapReAlloc(GetProcessHeap(), 0, cs->data, size)))
+        assert(!cs->end);
+
+        new_size = max( size, cs->data_size * 2 );
+        if (!(new_data = HeapReAlloc(GetProcessHeap(), 0, cs->data, new_size)))
             return NULL;
 
-        cs->data_size = size;
+        cs->data_size = new_size;
         cs->data = new_data;
     }
 
-    return cs->data;
+    cs->end += size;
+
+    return (BYTE *)cs->data + cs->start;
 }
 
 static void wined3d_cs_st_submit(struct wined3d_cs *cs)
 {
-    enum wined3d_cs_op opcode = *(const enum wined3d_cs_op *)cs->data;
+    enum wined3d_cs_op opcode = *(const enum wined3d_cs_op *)((BYTE *)cs->data + cs->start);
+    unsigned int start;
 
-    wined3d_cs_op_handlers[opcode](cs, cs->data);
+    if (opcode >= WINED3D_CS_OP_STOP)
+    {
+        ERR("Invalid opcode %#x.\n", opcode);
+        return;
+    }
+
+    start = cs->start;
+    cs->start = cs->end;
+    wined3d_cs_op_handlers[opcode](cs, (BYTE *)cs->data + start);
+    if (!start)
+        cs->start = cs->end = 0;
 }
 
-static void wined3d_cs_st_push_constants(struct wined3d_cs *cs, enum wined3d_push_constants p,
-        unsigned int start_idx, unsigned int count, const void *constants)
+static void wined3d_cs_st_finish(struct wined3d_cs *cs)
 {
-    struct wined3d_device *device = cs->device;
-    unsigned int context_count;
-    unsigned int i;
-    size_t offset;
+}
+
+static const struct wined3d_cs_ops wined3d_cs_st_ops =
+{
+    wined3d_cs_st_require_space,
+    wined3d_cs_st_require_space,
+    wined3d_cs_st_submit,
+    wined3d_cs_st_submit,
+    wined3d_cs_st_push_constants,
+    wined3d_cs_st_finish,
+    wined3d_cs_st_finish,
+};
+
+static void wined3d_cs_queue_submit(struct wined3d_cs_queue *queue, struct wined3d_cs *cs)
+{
+    struct wined3d_cs_packet *packet;
 
-    static const struct
+    if (cs->thread_id == GetCurrentThreadId())
+        return wined3d_cs_st_submit(cs);
+
+    /* There is only one thread writing to queue.head, InterlockedExchange
+     * is used for the memory barrier. */
+    packet = (struct wined3d_cs_packet *)&queue->data[queue->head];
+    InterlockedExchange(&queue->head, (queue->head + FIELD_OFFSET(struct wined3d_cs_packet, data[packet->size]))
+            & (WINED3D_CS_QUEUE_SIZE - 1));
+
+    if (InterlockedCompareExchange(&cs->waiting_for_event, FALSE, TRUE))
+        SetEvent(cs->event);
+}
+
+static void wined3d_cs_mt_submit(struct wined3d_cs *cs)
+{
+    wined3d_cs_queue_submit(&cs->queue, cs);
+}
+
+static void wined3d_cs_mt_submit_prio(struct wined3d_cs *cs)
+{
+    wined3d_cs_queue_submit(&cs->prio_queue, cs);
+}
+
+static void *wined3d_cs_queue_require_space(struct wined3d_cs_queue *queue, unsigned int size, struct wined3d_cs *cs)
+{
+    unsigned int queue_size = sizeof(queue->data) / sizeof(*queue->data);
+    struct wined3d_cs_packet *packet;
+    unsigned int packet_size;
+    unsigned int remaining;
+
+    if (cs->thread_id == GetCurrentThreadId())
+        return wined3d_cs_st_require_space(cs, size);
+
+    size = (size + FIELD_OFFSET(struct wined3d_cs_packet, data[0]) - 1)
+            & ~(FIELD_OFFSET(struct wined3d_cs_packet, data[0]) - 1);
+    packet_size = FIELD_OFFSET(struct wined3d_cs_packet, data[size]);
+    remaining = queue_size - queue->head;
+    if (remaining < packet_size)
     {
-        size_t offset;
-        size_t size;
-        DWORD mask;
-    }
-    push_constant_info[] =
-    {
-        /* WINED3D_PUSH_CONSTANTS_VS_F */
-        {FIELD_OFFSET(struct wined3d_state, vs_consts_f), sizeof(struct wined3d_vec4),  WINED3D_SHADER_CONST_VS_F},
-        /* WINED3D_PUSH_CONSTANTS_PS_F */
-        {FIELD_OFFSET(struct wined3d_state, ps_consts_f), sizeof(struct wined3d_vec4),  WINED3D_SHADER_CONST_PS_F},
-        /* WINED3D_PUSH_CONSTANTS_VS_I */
-        {FIELD_OFFSET(struct wined3d_state, vs_consts_i), sizeof(struct wined3d_ivec4), WINED3D_SHADER_CONST_VS_I},
-        /* WINED3D_PUSH_CONSTANTS_PS_I */
-        {FIELD_OFFSET(struct wined3d_state, ps_consts_i), sizeof(struct wined3d_ivec4), WINED3D_SHADER_CONST_PS_I},
-        /* WINED3D_PUSH_CONSTANTS_VS_B */
-        {FIELD_OFFSET(struct wined3d_state, vs_consts_b), sizeof(BOOL),                 WINED3D_SHADER_CONST_VS_B},
-        /* WINED3D_PUSH_CONSTANTS_PS_B */
-        {FIELD_OFFSET(struct wined3d_state, ps_consts_b), sizeof(BOOL),                 WINED3D_SHADER_CONST_PS_B},
-    };
+        unsigned int nop_size = remaining - FIELD_OFFSET(struct wined3d_cs_packet, data[0]);
+        struct wined3d_cs_nop *nop;
 
-    if (p == WINED3D_PUSH_CONSTANTS_VS_F)
-        device->shader_backend->shader_update_float_vertex_constants(device, start_idx, count);
-    else if (p == WINED3D_PUSH_CONSTANTS_PS_F)
-        device->shader_backend->shader_update_float_pixel_constants(device, start_idx, count);
+        TRACE("No room at the end of the buffer for a packet large %u bytes, inserting a NOP for %u + %u bytes.\n",
+                packet_size, remaining - nop_size, nop_size);
+        nop = wined3d_cs_queue_require_space(queue, nop_size, cs);
+        if (nop_size)
+            nop->opcode = WINED3D_CS_OP_NOP;
 
-    offset = push_constant_info[p].offset + start_idx * push_constant_info[p].size;
-    memcpy((BYTE *)&cs->state + offset, constants, count * push_constant_info[p].size);
-    for (i = 0, context_count = device->context_count; i < context_count; ++i)
+        wined3d_cs_queue_submit(queue, cs);
+
+        assert(!queue->head);
+    }
+
+    for (;;)
     {
-        device->contexts[i]->constant_update_mask |= push_constant_info[p].mask;
+        LONG head = queue->head;
+        LONG tail = *((volatile LONG *)&queue->tail);
+        LONG new_pos;
+        /* Empty */
+        if (head == tail)
+            break;
+        new_pos = (head + packet_size) & (WINED3D_CS_QUEUE_SIZE - 1);
+        /* Head ahead of tail. We checked the remaining size above, so we only
+         * need to make sure we don't make head equal to tail. */
+        if (head > tail && (new_pos != tail))
+            break;
+        /* Tail ahead of head. Make sure the new head is before the tail as
+         * well. Note that new_pos is 0 when it's at the end of the queue. */
+        if (new_pos < tail && new_pos)
+            break;
+
+        TRACE("Waiting for free space. Head %u, tail %u, want %u.\n", head, tail, packet_size);
     }
+
+    packet = (struct wined3d_cs_packet *)&queue->data[queue->head];
+    packet->size = size;
+    return packet->data;
 }
 
-static const struct wined3d_cs_ops wined3d_cs_st_ops =
+static void *wined3d_cs_mt_require_space(struct wined3d_cs *cs, unsigned int size)
 {
-    wined3d_cs_st_require_space,
-    wined3d_cs_st_submit,
-    wined3d_cs_st_push_constants,
+    return wined3d_cs_queue_require_space(&cs->queue, size, cs);
+}
+
+static void *wined3d_cs_mt_require_space_prio(struct wined3d_cs *cs, unsigned int size)
+{
+    return wined3d_cs_queue_require_space(&cs->prio_queue, size, cs);
+}
+
+static void wined3d_cs_mt_finish(struct wined3d_cs *cs)
+{
+    BOOL fence;
+
+    if (cs->thread_id == GetCurrentThreadId())
+        return;
+
+    wined3d_cs_emit_fence(cs, &fence);
+
+    /* A busy wait should be fine, we're not supposed to have to wait very
+     * long. */
+    while (!InterlockedCompareExchange(&fence, TRUE, TRUE))
+        wined3d_pause();
+}
+
+static void wined3d_cs_mt_finish_prio(struct wined3d_cs *cs)
+{
+    BOOL fence;
+
+    if (cs->thread_id == GetCurrentThreadId())
+        return;
+
+    wined3d_cs_emit_fence_prio(cs, &fence);
+
+    /* A busy wait should be fine, we're not supposed to have to wait very
+     * long. */
+    while (!InterlockedCompareExchange(&fence, TRUE, TRUE))
+        wined3d_pause();
+}
+
+static const struct wined3d_cs_ops wined3d_cs_mt_ops =
+{
+    wined3d_cs_mt_require_space,
+    wined3d_cs_mt_require_space_prio,
+    wined3d_cs_mt_submit,
+    wined3d_cs_mt_submit_prio,
+    wined3d_cs_mt_push_constants,
+    wined3d_cs_mt_finish,
+    wined3d_cs_mt_finish_prio,
 };
 
+/* FIXME: wined3d_device_uninit_3d() should either flush and wait, or be an
+ * OP itself. */
+static void wined3d_cs_emit_stop(struct wined3d_cs *cs)
+{
+    struct wined3d_cs_stop *op;
+
+    op = wined3d_cs_mt_require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_STOP;
+
+    wined3d_cs_mt_submit(cs);
+}
+
+static void poll_queries(struct wined3d_cs *cs)
+{
+    struct wined3d_query *query, *cursor;
+
+    LIST_FOR_EACH_ENTRY_SAFE(query, cursor, &cs->query_poll_list, struct wined3d_query, poll_list_entry)
+    {
+        if (!query->query_ops->query_poll(query, query->flags))
+            continue;
+
+        list_remove(&query->poll_list_entry);
+        list_init(&query->poll_list_entry);
+        InterlockedIncrement(&query->counter_retrieved);
+    }
+}
+
+void wined3d_cs_switch_onscreen_ds(struct wined3d_cs *cs,
+        struct wined3d_context *context, struct wined3d_surface *depth_stencil)
+{
+    if (cs->onscreen_depth_stencil)
+    {
+        struct wined3d_texture *texture = cs->onscreen_depth_stencil->container;
+
+        wined3d_texture_load_location(texture,
+                surface_get_sub_resource_idx(cs->onscreen_depth_stencil),
+                context, WINED3D_LOCATION_TEXTURE_RGB);
+
+        surface_modify_ds_location(cs->onscreen_depth_stencil, WINED3D_LOCATION_TEXTURE_RGB,
+                cs->onscreen_depth_stencil->ds_current_size.cx,
+                cs->onscreen_depth_stencil->ds_current_size.cy);
+        wined3d_texture_decref(texture);
+    }
+    cs->onscreen_depth_stencil = depth_stencil;
+    wined3d_texture_incref(cs->onscreen_depth_stencil->container);
+}
+
+static BOOL wined3d_cs_queue_is_empty(const struct wined3d_cs_queue *queue)
+{
+    return *((volatile LONG *)&queue->head) == queue->tail;
+}
+
+static void wined3d_cs_wait_event(struct wined3d_cs *cs)
+{
+    InterlockedExchange(&cs->waiting_for_event, TRUE);
+
+    /* The main thread might enqueue a finish command and block on it
+     * after the worker thread decided to enter wined3d_cs_wait_event
+     * and before waiting_for_event was set to TRUE. Check again if
+     * the queues are empty */
+    if (!wined3d_cs_queue_is_empty(&cs->prio_queue) || !wined3d_cs_queue_is_empty(&cs->queue))
+    {
+        /* The main thread might have signalled the event, or be in the process
+         * of doing so. Wait for the event to reset it. ResetEvent is not good
+         * because the main thread might be beween the waiting_for_event reset
+         * and SignalEvent call. */
+        if (!InterlockedCompareExchange(&cs->waiting_for_event, FALSE, TRUE))
+            WaitForSingleObject(cs->event, INFINITE);
+    }
+    else
+    {
+        WaitForSingleObject(cs->event, INFINITE);
+    }
+}
+
+static DWORD WINAPI wined3d_cs_run(void *thread_param)
+{
+    struct wined3d_cs *cs = thread_param;
+    struct wined3d_cs_packet *packet;
+    struct wined3d_cs_queue *queue;
+    unsigned int spin_count = 0;
+    enum wined3d_cs_op opcode;
+    char poll = 0;
+    LONG tail;
+
+    TRACE("Started.\n");
+
+    queue = &cs->queue;
+    list_init(&cs->query_poll_list);
+    cs->thread_id = GetCurrentThreadId();
+    for (;;)
+    {
+        if (poll == 10)
+        {
+            poll = 0;
+            poll_queries(cs);
+        }
+        else
+            ++poll;
+
+        if (!wined3d_cs_queue_is_empty(&cs->prio_queue))
+        {
+            queue = &cs->prio_queue;
+        }
+        else if (!wined3d_cs_queue_is_empty(&cs->queue))
+        {
+            queue = &cs->queue;
+        }
+        else
+        {
+            if (++spin_count >= WINED3D_CS_SPIN_COUNT && list_empty(&cs->query_poll_list))
+                wined3d_cs_wait_event(cs);
+            continue;
+        }
+
+        spin_count = 0;
+
+        tail = queue->tail;
+        packet = (struct wined3d_cs_packet *)&queue->data[tail];
+        if (packet->size)
+        {
+            opcode = *(const enum wined3d_cs_op *)packet->data;
+
+            if (opcode >= WINED3D_CS_OP_STOP)
+            {
+                if (opcode > WINED3D_CS_OP_STOP)
+                    ERR("Invalid opcode %#x.\n", opcode);
+                goto done;
+            }
+
+            /* FIXME: We could do some kind of packet size validation here. */
+            wined3d_cs_op_handlers[opcode](cs, packet->data);
+        }
+
+        tail += FIELD_OFFSET(struct wined3d_cs_packet, data[packet->size]);
+        tail &= (WINED3D_CS_QUEUE_SIZE - 1);
+        InterlockedExchange(&queue->tail, tail);
+    }
+
+done:
+    TRACE("Stopped.\n");
+    return 0;
+}
+
 struct wined3d_cs *wined3d_cs_create(struct wined3d_device *device)
 {
     const struct wined3d_gl_info *gl_info = &device->adapter->gl_info;
@@ -1532,6 +2767,9 @@
     if (!(cs = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(*cs))))
         return NULL;
 
+    cs->ops = &wined3d_cs_st_ops;
+    cs->device = device;
+
     if (!(cs->fb.render_targets = wined3d_calloc(gl_info->limits.buffers, sizeof(*cs->fb.render_targets))))
     {
         HeapFree(GetProcessHeap(), 0, cs);
@@ -1541,9 +2779,6 @@
     state_init(&cs->state, &cs->fb, gl_info, &device->adapter->d3d_info,
             WINED3D_STATE_NO_REF | WINED3D_STATE_INIT_DEFAULT);
 
-    cs->ops = &wined3d_cs_st_ops;
-    cs->device = device;
-
     cs->data_size = WINED3D_INITIAL_CS_SIZE;
     if (!(cs->data = HeapAlloc(GetProcessHeap(), 0, cs->data_size)))
     {
@@ -1553,13 +2788,45 @@
         return NULL;
     }
 
+    if (wined3d_use_csmt(device))
+    {
+        cs->ops = &wined3d_cs_mt_ops;
+
+        cs->event = CreateEventW(NULL, FALSE, FALSE, NULL);
+
+        if (!(cs->thread = CreateThread(NULL, 0, wined3d_cs_run, cs, 0, NULL)))
+        {
+            ERR("Failed to create wined3d command stream thread.\n");
+            HeapFree(GetProcessHeap(), 0, cs->data);
+            state_cleanup(&cs->state);
+            HeapFree(GetProcessHeap(), 0, cs->fb.render_targets);
+            HeapFree(GetProcessHeap(), 0, cs);
+            return NULL;
+        }
+    }
+
     return cs;
 }
 
 void wined3d_cs_destroy(struct wined3d_cs *cs)
 {
+    DWORD ret;
+
     state_cleanup(&cs->state);
     HeapFree(GetProcessHeap(), 0, cs->fb.render_targets);
     HeapFree(GetProcessHeap(), 0, cs->data);
+
+    if (wined3d_use_csmt(cs->device))
+    {
+        wined3d_cs_emit_stop(cs);
+
+        ret = WaitForSingleObject(cs->thread, INFINITE);
+        CloseHandle(cs->thread);
+        if (ret != WAIT_OBJECT_0)
+            ERR("Wait failed (%#x).\n", ret);
+        if (!CloseHandle(cs->event))
+            ERR("Closing event failed.\n");
+    }
+
     HeapFree(GetProcessHeap(), 0, cs);
 }
diff -Naur wine-2.0a/dlls/wined3d/device.c wine-2.0b/dlls/wined3d/device.c
--- wine-2.0a/dlls/wined3d/device.c	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/wined3d/device.c	2017-07-11 20:37:51.000000000 +0100
@@ -198,22 +198,6 @@
     device->contexts = new_array;
 }
 
-void device_switch_onscreen_ds(struct wined3d_device *device,
-        struct wined3d_context *context, struct wined3d_surface *depth_stencil)
-{
-    if (device->onscreen_depth_stencil)
-    {
-        surface_load_location(device->onscreen_depth_stencil, context, WINED3D_LOCATION_TEXTURE_RGB);
-
-        surface_modify_ds_location(device->onscreen_depth_stencil, WINED3D_LOCATION_TEXTURE_RGB,
-                device->onscreen_depth_stencil->ds_current_size.cx,
-                device->onscreen_depth_stencil->ds_current_size.cy);
-        wined3d_texture_decref(device->onscreen_depth_stencil->container);
-    }
-    device->onscreen_depth_stencil = depth_stencil;
-    wined3d_texture_incref(device->onscreen_depth_stencil->container);
-}
-
 static BOOL is_full_clear(const struct wined3d_surface *target, const RECT *draw_rect, const RECT *clear_rect)
 {
     unsigned int height = wined3d_texture_get_level_height(target->container, target->texture_level);
@@ -283,7 +267,7 @@
     }
 
     /* Full load. */
-    surface_load_location(ds, context, location);
+    wined3d_texture_load_location(ds->container, surface_get_sub_resource_idx(ds), context, location);
     SetRect(out_rect, 0, 0, ds->ds_current_size.cx, ds->ds_current_size.cy);
 }
 
@@ -295,7 +279,7 @@
     struct wined3d_surface *target = rtv ? wined3d_rendertarget_view_get_surface(rtv) : NULL;
     struct wined3d_rendertarget_view *dsv = fb->depth_stencil;
     struct wined3d_surface *depth_stencil = dsv ? wined3d_rendertarget_view_get_surface(dsv) : NULL;
-    const struct wined3d_state *state = &device->state;
+    const struct wined3d_state *state = &device->cs->state;
     const struct wined3d_gl_info *gl_info;
     UINT drawable_width, drawable_height;
     struct wined3d_color corrected_color;
@@ -359,8 +343,8 @@
     {
         DWORD location = render_offscreen ? dsv->resource->draw_binding : WINED3D_LOCATION_DRAWABLE;
 
-        if (!render_offscreen && depth_stencil != device->onscreen_depth_stencil)
-            device_switch_onscreen_ds(device, context, depth_stencil);
+        if (!render_offscreen && depth_stencil != device->cs->onscreen_depth_stencil)
+            wined3d_cs_switch_onscreen_ds(device->cs, context, depth_stencil);
         prepare_ds_clear(depth_stencil, context, location,
                 draw_rect, rect_count, clear_rect, &ds_rect);
     }
@@ -680,8 +664,38 @@
     if (hbm) DeleteObject(hbm);
 }
 
+static void create_default_samplers(struct wined3d_device *device, struct wined3d_context *context)
+{
+    const struct wined3d_gl_info *gl_info = context->gl_info;
+
+    if (!gl_info->supported[ARB_SAMPLER_OBJECTS])
+    {
+        device->default_sampler = 0;
+        device->null_sampler = 0;
+        return;
+    }
+
+    /* In shader model 4+ resources and samplers are separate. Some shader
+     * instructions allow access to resources without using samplers. In GLSL,
+     * resources are always accessed through sampler or image variables. The
+     * default sampler object is used to emulate direct resource access when
+     * there is no sampler state to use. */
+    GL_EXTCALL(glGenSamplers(1, &device->default_sampler));
+    GL_EXTCALL(glSamplerParameteri(device->default_sampler, GL_TEXTURE_MAG_FILTER, GL_NEAREST));
+    GL_EXTCALL(glSamplerParameteri(device->default_sampler, GL_TEXTURE_MIN_FILTER, GL_NEAREST));
+    checkGLcall("Create default sampler");
+
+    /* In d3d10 and later, a NULL sampler maps to the default sampler state. */
+    GL_EXTCALL(glGenSamplers(1, &device->null_sampler));
+    GL_EXTCALL(glSamplerParameteri(device->null_sampler, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR));
+    GL_EXTCALL(glSamplerParameteri(device->null_sampler, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE));
+    GL_EXTCALL(glSamplerParameteri(device->null_sampler, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE));
+    GL_EXTCALL(glSamplerParameteri(device->null_sampler, GL_TEXTURE_WRAP_R, GL_CLAMP_TO_EDGE));
+    checkGLcall("Create null sampler");
+}
+
 /* Context activation is done by the caller. */
-static void create_dummy_textures(struct wined3d_device *device, struct wined3d_context *context)
+void device_create_dummy_textures(struct wined3d_device *device, struct wined3d_context *context)
 {
     const struct wined3d_d3d_info *d3d_info = &device->adapter->d3d_info;
     const struct wined3d_gl_info *gl_info = &device->adapter->gl_info;
@@ -770,6 +784,7 @@
     }
 
     context_bind_dummy_textures(device, context);
+    create_default_samplers(device, context);
 }
 
 /* Context activation is done by the caller. */
@@ -797,39 +812,6 @@
 }
 
 /* Context activation is done by the caller. */
-static void create_default_samplers(struct wined3d_device *device, struct wined3d_context *context)
-{
-    const struct wined3d_gl_info *gl_info = context->gl_info;
-
-    if (gl_info->supported[ARB_SAMPLER_OBJECTS])
-    {
-        /* In SM4+ shaders there is a separation between resources and samplers. Some shader
-         * instructions allow access to resources without using samplers.
-         * In GLSL, resources are always accessed through sampler or image variables. The default
-         * sampler object is used to emulate the direct resource access when there is no sampler state
-         * to use.
-         */
-        GL_EXTCALL(glGenSamplers(1, &device->default_sampler));
-        GL_EXTCALL(glSamplerParameteri(device->default_sampler, GL_TEXTURE_MAG_FILTER, GL_NEAREST));
-        GL_EXTCALL(glSamplerParameteri(device->default_sampler, GL_TEXTURE_MIN_FILTER, GL_NEAREST));
-        checkGLcall("Create default sampler");
-
-        /* In D3D10+, a NULL sampler maps to the default sampler state. */
-        GL_EXTCALL(glGenSamplers(1, &device->null_sampler));
-        GL_EXTCALL(glSamplerParameteri(device->null_sampler, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR));
-        GL_EXTCALL(glSamplerParameteri(device->null_sampler, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE));
-        GL_EXTCALL(glSamplerParameteri(device->null_sampler, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE));
-        GL_EXTCALL(glSamplerParameteri(device->null_sampler, GL_TEXTURE_WRAP_R, GL_CLAMP_TO_EDGE));
-        checkGLcall("Create null sampler");
-    }
-    else
-    {
-        device->default_sampler = 0;
-        device->null_sampler = 0;
-    }
-}
-
-/* Context activation is done by the caller. */
 static void destroy_default_samplers(struct wined3d_device *device, struct wined3d_context *context)
 {
     const struct wined3d_gl_info *gl_info = context->gl_info;
@@ -996,7 +978,6 @@
     static const struct wined3d_color black = {0.0f, 0.0f, 0.0f, 0.0f};
     const struct wined3d_gl_info *gl_info = &device->adapter->gl_info;
     struct wined3d_swapchain *swapchain = NULL;
-    struct wined3d_context *context;
     DWORD clear_flags = 0;
     HRESULT hr;
 
@@ -1060,17 +1041,12 @@
     device->swapchains[0] = swapchain;
     device_init_swapchain_state(device, swapchain);
 
-    context = context_acquire(device, NULL);
-
-    create_dummy_textures(device, context);
-    create_default_samplers(device, context);
+    wined3d_cs_emit_create_dummy_textures(device->cs);
 
     device->contexts[0]->last_was_rhw = 0;
 
     TRACE("All defaults now set up, leaving 3D init.\n");
 
-    context_release(context);
-
     /* Clear the screen */
     if (swapchain->back_buffers && swapchain->back_buffers[0])
         clear_flags |= WINED3DCLEAR_TARGET;
@@ -1143,8 +1119,6 @@
 HRESULT CDECL wined3d_device_uninit_3d(struct wined3d_device *device)
 {
     struct wined3d_resource *resource, *cursor;
-    const struct wined3d_gl_info *gl_info;
-    struct wined3d_context *context;
     struct wined3d_surface *surface;
     UINT i;
 
@@ -1153,11 +1127,8 @@
     if (!device->d3d_initialized)
         return WINED3DERR_INVALIDCALL;
 
-    /* I don't think that the interface guarantees that the device is destroyed from the same thread
-     * it was created. Thus make sure a context is active for the glDelete* calls
-     */
-    context = context_acquire(device, NULL);
-    gl_info = context->gl_info;
+    if (wined3d_use_csmt(device))
+        device->cs->ops->finish(device->cs);
 
     if (device->logo_texture)
         wined3d_texture_decref(device->logo_texture);
@@ -1175,28 +1146,15 @@
 
     wine_rb_clear(&device->samplers, device_free_sampler, NULL);
 
-    /* Destroy the depth blt resources, they will be invalid after the reset. Also free shader
-     * private data, it might contain opengl pointers
-     */
-    if (device->depth_blt_texture)
-    {
-        gl_info->gl_ops.gl.p_glDeleteTextures(1, &device->depth_blt_texture);
-        device->depth_blt_texture = 0;
-    }
+    /* FIXME: Is this in the right place??? */
+    wined3d_cs_emit_delete_opengl_contexts(device->cs, device->swapchains[0]);
 
-    /* Destroy the shader backend. Note that this has to happen after all shaders are destroyed. */
-    device->blitter->free_private(device);
-    device->shader_backend->shader_free_private(device);
-    destroy_dummy_textures(device, context);
-    destroy_default_samplers(device, context);
-
-    context_release(context);
-
-    /* Release the buffers (with sanity checks) */
-    if (device->onscreen_depth_stencil)
+    /* Release the buffers (with sanity checks). */
+    /* FIXME: Shouldn't the cs take care of onscreen_depth_stencil? */
+    if (device->cs->onscreen_depth_stencil)
     {
-        surface = device->onscreen_depth_stencil;
-        device->onscreen_depth_stencil = NULL;
+        surface = device->cs->onscreen_depth_stencil;
+        device->cs->onscreen_depth_stencil = NULL;
         wined3d_texture_decref(surface->container);
     }
 
@@ -1219,7 +1177,7 @@
             ERR("Something's still holding the auto depth/stencil view (%p).\n", view);
     }
 
-    for (i = 0; i < gl_info->limits.buffers; ++i)
+    for (i = 0; i < device->adapter->gl_info.limits.buffers; ++i)
     {
         wined3d_device_set_rendertarget_view(device, i, NULL, FALSE);
     }
@@ -1605,14 +1563,6 @@
             light->direction.x, light->direction.y, light->direction.z,
             light->range, light->falloff, light->theta, light->phi);
 
-    /* Update the live definitions if the light is currently assigned a glIndex. */
-    if (object->glIndex != -1 && !device->recording)
-    {
-        if (object->OriginalParms.type != light->type)
-            device_invalidate_state(device, STATE_LIGHT_TYPE);
-        device_invalidate_state(device, STATE_ACTIVELIGHT(object->glIndex));
-    }
-
     /* Save away the information. */
     object->OriginalParms = *light;
 
@@ -1692,6 +1642,9 @@
             FIXME("Unrecognized light type %#x.\n", light->type);
     }
 
+    if (!device->recording)
+        wined3d_cs_emit_set_light(device->cs, object);
+
     return WINED3D_OK;
 }
 
@@ -1764,12 +1717,6 @@
     {
         if (light_info->glIndex != -1)
         {
-            if (!device->recording)
-            {
-                device_invalidate_state(device, STATE_LIGHT_TYPE);
-                device_invalidate_state(device, STATE_ACTIVELIGHT(light_info->glIndex));
-            }
-
             device->update_state->lights[light_info->glIndex] = NULL;
             light_info->glIndex = -1;
         }
@@ -1811,16 +1758,12 @@
                 WARN("Too many concurrently active lights\n");
                 return WINED3D_OK;
             }
-
-            /* i == light_info->glIndex */
-            if (!device->recording)
-            {
-                device_invalidate_state(device, STATE_LIGHT_TYPE);
-                device_invalidate_state(device, STATE_ACTIVELIGHT(i));
-            }
         }
     }
 
+    if (!device->recording)
+        wined3d_cs_emit_set_light_enable(device->cs, light_idx, enable);
+
     return WINED3D_OK;
 }
 
@@ -2943,6 +2886,13 @@
     }
     dest_ptr = map_desc.data;
 
+    if (wined3d_use_csmt(device))
+    {
+        FIXME("Waiting for cs.\n");
+        wined3d_cs_emit_glfinish(device->cs);
+        device->cs->ops->finish(device->cs);
+    }
+
     wined3d_device_get_transform(device, WINED3D_TS_VIEW, &view_mat);
     wined3d_device_get_transform(device, WINED3D_TS_PROJECTION, &proj_mat);
     wined3d_device_get_transform(device, WINED3D_TS_WORLD_MATRIX(0), &world_mat);
@@ -3429,8 +3379,6 @@
 
 HRESULT CDECL wined3d_device_end_scene(struct wined3d_device *device)
 {
-    struct wined3d_context *context;
-
     TRACE("device %p.\n", device);
 
     if (!device->inScene)
@@ -3439,13 +3387,6 @@
         return WINED3DERR_INVALIDCALL;
     }
 
-    context = context_acquire(device, NULL);
-    /* We only have to do this if we need to read the, swapbuffers performs a flush for us */
-    context->gl_info->gl_ops.gl.p_glFlush();
-    /* No checkGLcall here to avoid locking the lock just for checking a call that hardly ever
-     * fails. */
-    context_release(context);
-
     device->inScene = FALSE;
     return WINED3D_OK;
 }
@@ -3528,8 +3469,8 @@
     device->update_state->gl_primitive_type = gl_primitive_type;
     if (device->recording)
         device->recording->changed.primitive_type = TRUE;
-    else if (gl_primitive_type != prev && (gl_primitive_type == GL_POINTS || prev == GL_POINTS))
-        device_invalidate_state(device, STATE_POINT_ENABLE);
+    else if (gl_primitive_type != prev)
+        wined3d_cs_emit_set_primitive_type(device->cs, gl_primitive_type);
 }
 
 void CDECL wined3d_device_get_primitive_type(const struct wined3d_device *device,
@@ -3589,34 +3530,17 @@
             start_idx, index_count, start_instance, instance_count, TRUE);
 }
 
-static HRESULT wined3d_device_update_texture_3d(struct wined3d_device *device,
+/* Context activation is done by the caller. */
+static void wined3d_device_update_texture_3d(struct wined3d_context *context,
         struct wined3d_texture *src_texture, unsigned int src_level,
         struct wined3d_texture *dst_texture, unsigned int level_count)
 {
     struct wined3d_const_bo_address data;
-    struct wined3d_context *context;
     struct wined3d_map_desc src;
-    HRESULT hr = WINED3D_OK;
     unsigned int i;
 
-    TRACE("device %p, src_texture %p, src_level %u, dst_texture %p, level_count %u.\n",
-            device, src_texture, src_level, dst_texture, level_count);
-
-    if (src_texture->resource.format != dst_texture->resource.format)
-    {
-        WARN("Source and destination formats do not match.\n");
-        return WINED3DERR_INVALIDCALL;
-    }
-
-    if (wined3d_texture_get_level_width(src_texture, src_level) != dst_texture->resource.width
-            || wined3d_texture_get_level_height(src_texture, src_level) != dst_texture->resource.height
-            || wined3d_texture_get_level_depth(src_texture, src_level) != dst_texture->resource.depth)
-    {
-        WARN("Source and destination dimensions do not match.\n");
-        return WINED3DERR_INVALIDCALL;
-    }
-
-    context = context_acquire(device, NULL);
+    TRACE("context %p, src_texture %p, src_level %u, dst_texture %p, level_count %u.\n",
+            context, src_texture, src_level, dst_texture, level_count);
 
     /* Only a prepare, since we're uploading entire volumes. */
     wined3d_texture_prepare_texture(dst_texture, context, FALSE);
@@ -3624,32 +3548,92 @@
 
     for (i = 0; i < level_count; ++i)
     {
-        if (FAILED(hr = wined3d_resource_map(&src_texture->resource,
+        if (FAILED(wined3d_resource_map(&src_texture->resource,
                 src_level + i, &src, NULL, WINED3D_MAP_READONLY)))
-            goto done;
+            return;
 
         data.buffer_object = 0;
         data.addr = src.data;
         wined3d_texture_upload_data(dst_texture, i, context, NULL, &data, src.row_pitch, src.slice_pitch);
         wined3d_texture_invalidate_location(dst_texture, i, ~WINED3D_LOCATION_TEXTURE_RGB);
 
-        if (FAILED(hr = wined3d_resource_unmap(&src_texture->resource, src_level + i)))
-            goto done;
+        if (FAILED(wined3d_resource_unmap(&src_texture->resource, src_level + i)))
+            return;
     }
+}
 
-done:
-    context_release(context);
-    return hr;
+/* Context activation is done by the caller */
+void device_exec_update_texture(struct wined3d_context *context, struct wined3d_texture *src_texture,
+        struct wined3d_texture *dst_texture)
+{
+    unsigned int src_size, dst_size, src_skip_levels = 0;
+    unsigned int level_count, i, j;
+
+    level_count = min(wined3d_texture_get_level_count(src_texture),
+            wined3d_texture_get_level_count(dst_texture));
+
+    src_size = max(src_texture->resource.width, src_texture->resource.height);
+    dst_size = max(dst_texture->resource.width, dst_texture->resource.height);
+    if (dst_texture->resource.type == WINED3D_RTYPE_TEXTURE_3D)
+    {
+        src_size = max(src_size, src_texture->resource.depth);
+        dst_size = max(dst_size, dst_texture->resource.depth);
+    }
+    while (src_size > dst_size)
+    {
+        src_size >>= 1;
+        ++src_skip_levels;
+    }
+
+    /* Make sure that the destination texture is loaded. */
+    for (i = 0; i < dst_texture->layer_count; ++i)
+        for (j = 0; j < level_count; ++j)
+            wined3d_texture_prepare_location(dst_texture, i * dst_texture->level_count + j, context,
+                    WINED3D_LOCATION_TEXTURE_RGB);
+
+    /* Update every surface level of the texture. */
+    switch (dst_texture->resource.type)
+    {
+        case WINED3D_RTYPE_TEXTURE_2D:
+        {
+            unsigned int src_levels = src_texture->level_count;
+            unsigned int dst_levels = dst_texture->level_count;
+            struct wined3d_surface *src_surface;
+            struct wined3d_surface *dst_surface;
+
+            for (i = 0; i < src_texture->layer_count; ++i)
+            {
+                for (j = 0; j < level_count; ++j)
+                {
+                    HRESULT hr;
+                    src_surface = src_texture->sub_resources[i * src_levels + j + src_skip_levels].u.surface;
+                    dst_surface = dst_texture->sub_resources[i * dst_levels + j].u.surface;
+                    if (FAILED(hr = surface_upload_from_surface(dst_surface, NULL, src_surface, NULL)))
+                    {
+                        WARN("Failed to update surface, hr %#x.\n", hr);
+                        return;
+                    }
+                }
+            }
+            break;
+        }
+
+        case WINED3D_RTYPE_TEXTURE_3D:
+            wined3d_device_update_texture_3d(context,
+                    src_texture, src_skip_levels, dst_texture, level_count);
+            break;
+
+        default:
+            FIXME("Unsupported texture type %#x.\n", dst_texture->resource.type);
+    }
 }
 
 HRESULT CDECL wined3d_device_update_texture(struct wined3d_device *device,
         struct wined3d_texture *src_texture, struct wined3d_texture *dst_texture)
 {
     unsigned int src_size, dst_size, src_skip_levels = 0;
-    unsigned int layer_count, level_count, i, j;
+    unsigned int layer_count;
     enum wined3d_resource_type type;
-    HRESULT hr;
-    struct wined3d_context *context;
 
     TRACE("device %p, src_texture %p, dst_texture %p.\n", device, src_texture, dst_texture);
 
@@ -3686,63 +3670,48 @@
         return WINED3DERR_INVALIDCALL;
     }
 
-    level_count = min(wined3d_texture_get_level_count(src_texture),
-            wined3d_texture_get_level_count(dst_texture));
-
-    src_size = max(src_texture->resource.width, src_texture->resource.height);
-    dst_size = max(dst_texture->resource.width, dst_texture->resource.height);
-    if (type == WINED3D_RTYPE_TEXTURE_3D)
-    {
-        src_size = max(src_size, src_texture->resource.depth);
-        dst_size = max(dst_size, dst_texture->resource.depth);
-    }
-    while (src_size > dst_size)
+    /* FIXME: This isn't necessary for 2D textures, but currently surface_upload_from_surface
+     * rejects mismatching formats, and we can't report the error back after dispatching the
+     * call. */
+    if (src_texture->resource.format != dst_texture->resource.format)
     {
-        src_size >>= 1;
-        ++src_skip_levels;
+        WARN("Source and destination formats do not match.\n");
+        return WINED3DERR_INVALIDCALL;
     }
 
-    /* Make sure that the destination texture is loaded. */
-    context = context_acquire(device, NULL);
-    wined3d_texture_load(dst_texture, context, FALSE);
-    context_release(context);
-
-    /* Update every surface level of the texture. */
     switch (type)
     {
         case WINED3D_RTYPE_TEXTURE_2D:
-        {
-            unsigned int src_levels = src_texture->level_count;
-            unsigned int dst_levels = dst_texture->level_count;
-            struct wined3d_surface *src_surface;
-            struct wined3d_surface *dst_surface;
+            break;
 
-            for (i = 0; i < layer_count; ++i)
+        case WINED3D_RTYPE_TEXTURE_3D:
+            src_size = max(src_texture->resource.width, src_texture->resource.height);
+            src_size = max(src_size, src_texture->resource.depth);
+            dst_size = max(dst_texture->resource.width, dst_texture->resource.height);
+            dst_size = max(dst_size, dst_texture->resource.depth);
+
+            while (src_size > dst_size)
             {
-                for (j = 0; j < level_count; ++j)
-                {
-                    src_surface = src_texture->sub_resources[i * src_levels + j + src_skip_levels].u.surface;
-                    dst_surface = dst_texture->sub_resources[i * dst_levels + j].u.surface;
-                    if (FAILED(hr = surface_upload_from_surface(dst_surface, NULL, src_surface, NULL)))
-                    {
-                        WARN("Failed to update surface, hr %#x.\n", hr);
-                        return hr;
-                    }
-                }
+                src_size >>= 1;
+                ++src_skip_levels;
             }
-            return WINED3D_OK;
-        }
 
-        case WINED3D_RTYPE_TEXTURE_3D:
-            if (FAILED(hr = wined3d_device_update_texture_3d(device,
-                    src_texture, src_skip_levels, dst_texture, level_count)))
-                WARN("Failed to update 3D texture, hr %#x.\n", hr);
-            return hr;
+            if (wined3d_texture_get_level_width(src_texture, src_skip_levels) != dst_texture->resource.width
+                    || wined3d_texture_get_level_height(src_texture, src_skip_levels) != dst_texture->resource.height
+                    || wined3d_texture_get_level_depth(src_texture, src_skip_levels) != dst_texture->resource.depth)
+            {
+                WARN("Source and destination dimensions do not match.\n");
+                return WINED3DERR_INVALIDCALL;
+            }
+            break;
 
         default:
-            FIXME("Unsupported texture type %#x.\n", type);
-            return WINED3DERR_INVALIDCALL;
+            break;
     }
+
+    wined3d_cs_emit_update_texture(device->cs, src_texture, dst_texture);
+
+    return WINED3D_OK;
 }
 
 HRESULT CDECL wined3d_device_validate_device(const struct wined3d_device *device, DWORD *num_passes)
@@ -3980,6 +3949,7 @@
     struct wined3d_texture *dst_texture, *src_texture;
     RECT dst_rect, src_rect;
     HRESULT hr;
+    struct wined3d_box dst_box;
 
     TRACE("device %p, dst_resource %p, dst_sub_resource_idx %u, dst_x %u, dst_y %u, dst_z %u, "
             "src_resource %p, src_sub_resource_idx %u, src_box %s.\n",
@@ -4067,6 +4037,14 @@
 
     if (src_box)
     {
+        if ((src_texture->resource.format_flags & WINED3DFMT_FLAG_BLOCKS)
+                && !wined3d_texture_check_block_align(src_texture,
+                src_sub_resource_idx % src_texture->level_count, src_box))
+        {
+            WARN("Source box not block-aligned.\n");
+            return WINED3DERR_INVALIDCALL;
+        }
+
         SetRect(&src_rect, src_box->left, src_box->top, src_box->right, src_box->bottom);
     }
     else
@@ -4080,6 +4058,23 @@
     SetRect(&dst_rect, dst_x, dst_y, dst_x + (src_rect.right - src_rect.left),
             dst_y + (src_rect.bottom - src_rect.top));
 
+    if (dst_texture->resource.format_flags & WINED3DFMT_FLAG_BLOCKS)
+    {
+        dst_box.left = dst_rect.left;
+        dst_box.top = dst_rect.top;
+        dst_box.front = 0;
+        dst_box.right = dst_rect.right;
+        dst_box.bottom = dst_rect.bottom;
+        dst_box.back = 1;
+
+        if(!wined3d_texture_check_block_align(dst_texture,
+                dst_sub_resource_idx % dst_texture->level_count, &dst_box))
+        {
+            WARN("Destination box not block-aligned.\n");
+            return WINED3DERR_INVALIDCALL;
+        }
+    }
+
     if (FAILED(hr = wined3d_texture_blt(dst_texture, dst_sub_resource_idx, &dst_rect,
             src_texture, src_sub_resource_idx, &src_rect, 0, NULL, WINED3D_TEXF_POINT)))
         WARN("Failed to blit, hr %#x.\n", hr);
@@ -4092,9 +4087,8 @@
         unsigned int depth_pitch)
 {
     unsigned int width, height, depth, level;
-    struct wined3d_const_bo_address addr;
-    struct wined3d_context *context;
     struct wined3d_texture *texture;
+    struct wined3d_box b;
 
     TRACE("device %p, resource %p, sub_resource_idx %u, box %s, data %p, row_pitch %u, depth_pitch %u.\n",
             device, resource, sub_resource_idx, debug_box(box), data, row_pitch, depth_pitch);
@@ -4134,33 +4128,28 @@
     height = wined3d_texture_get_level_height(texture, level);
     depth = wined3d_texture_get_level_depth(texture, level);
 
-    if (box && (box->left >= box->right || box->right > width
-            || box->top >= box->bottom || box->bottom > height
-            || box->front >= box->back || box->back > depth))
+    if (box)
     {
-        WARN("Invalid box %s specified.\n", debug_box(box));
-        return;
+        if (box->left >= box->right || box->right > width
+                || box->top >= box->bottom || box->bottom > height
+                || box->front >= box->back || box->back > depth)
+        {
+            WARN("Invalid box %s specified.\n", debug_box(box));
+            return;
+        }
     }
-
-    addr.buffer_object = 0;
-    addr.addr = data;
-
-    context = context_acquire(resource->device, NULL);
-
-    /* Only load the sub-resource for partial updates. */
-    if (!box || (!box->left && !box->top && !box->front
-            && box->right == width && box->bottom == height && box->back == depth))
-        wined3d_texture_prepare_texture(texture, context, FALSE);
     else
-        wined3d_texture_load_location(texture, sub_resource_idx, context, WINED3D_LOCATION_TEXTURE_RGB);
-    wined3d_texture_bind_and_dirtify(texture, context, FALSE);
-
-    wined3d_texture_upload_data(texture, sub_resource_idx, context, box, &addr, row_pitch, depth_pitch);
-
-    context_release(context);
+    {
+        b.left = 0;
+        b.right = width;
+        b.top = 0;
+        b.bottom = height;
+        b.front = 0;
+        b.back = depth;
+        box = &b;
+    }
 
-    wined3d_texture_validate_location(texture, sub_resource_idx, WINED3D_LOCATION_TEXTURE_RGB);
-    wined3d_texture_invalidate_location(texture, sub_resource_idx, ~WINED3D_LOCATION_TEXTURE_RGB);
+    wined3d_cs_emit_update_sub_resource(device->cs, resource, sub_resource_idx, box, data, row_pitch, depth_pitch);
 }
 
 HRESULT CDECL wined3d_device_clear_rendertarget_view(struct wined3d_device *device,
@@ -4169,8 +4158,8 @@
 {
     const struct blit_shader *blitter;
     struct wined3d_resource *resource;
-    enum wined3d_blit_op blit_op;
     RECT r;
+    enum wined3d_blit_op blit_op;
 
     TRACE("device %p, view %p, rect %s, flags %#x, color %s, depth %.8e, stencil %u.\n",
             device, view, wine_dbgstr_rect(rect), flags, debug_color(color), depth, stencil);
@@ -4209,10 +4198,8 @@
         return WINED3DERR_INVALIDCALL;
     }
 
-    if (blit_op == WINED3D_BLIT_OP_COLOR_FILL)
-        return blitter->color_fill(device, view, rect, color);
-    else
-        return blitter->depth_fill(device, view, rect, flags, depth, stencil);
+    wined3d_cs_emit_clear_rtv(device->cs, view, rect, flags, color, depth, stencil, blitter);
+    return WINED3D_OK;
 }
 
 struct wined3d_rendertarget_view * CDECL wined3d_device_get_rendertarget_view(const struct wined3d_device *device,
@@ -4539,19 +4526,12 @@
     }
 }
 
-static void delete_opengl_contexts(struct wined3d_device *device, struct wined3d_swapchain *swapchain)
+void device_delete_opengl_contexts_cs(struct wined3d_device *device, struct wined3d_swapchain *swapchain)
 {
-    struct wined3d_resource *resource, *cursor;
     const struct wined3d_gl_info *gl_info;
     struct wined3d_context *context;
     struct wined3d_shader *shader;
 
-    LIST_FOR_EACH_ENTRY_SAFE(resource, cursor, &device->resources, struct wined3d_resource, resource_list_entry)
-    {
-        TRACE("Unloading resource %p.\n", resource);
-        wined3d_cs_emit_unload_resource(device->cs, resource);
-    }
-
     LIST_FOR_EACH_ENTRY(shader, &device->shaders, struct wined3d_shader, shader_list_entry)
     {
         device->shader_backend->shader_destroy(shader);
@@ -4583,12 +4563,24 @@
 
     HeapFree(GetProcessHeap(), 0, swapchain->context);
     swapchain->context = NULL;
+    swapchain->num_contexts = 0;
+}
+
+static void delete_opengl_contexts(struct wined3d_device *device, struct wined3d_swapchain *swapchain)
+{
+    struct wined3d_resource *resource, *cursor;
+
+    LIST_FOR_EACH_ENTRY_SAFE(resource, cursor, &device->resources, struct wined3d_resource, resource_list_entry)
+    {
+        TRACE("Unloading resource %p.\n", resource);
+        wined3d_cs_emit_unload_resource(device->cs, resource);
+    }
+
+    wined3d_cs_emit_delete_opengl_contexts(device->cs, swapchain);
 }
 
 static HRESULT create_primary_opengl_context(struct wined3d_device *device, struct wined3d_swapchain *swapchain)
 {
-    struct wined3d_context *context;
-    struct wined3d_texture *target;
     HRESULT hr;
 
     if (FAILED(hr = device->shader_backend->shader_alloc_private(device,
@@ -4605,31 +4597,16 @@
         return hr;
     }
 
-    /* Recreate the primary swapchain's context */
-    swapchain->context = HeapAlloc(GetProcessHeap(), 0, sizeof(*swapchain->context));
-    if (!swapchain->context)
-    {
-        ERR("Failed to allocate memory for swapchain context array.\n");
-        device->blitter->free_private(device);
-        device->shader_backend->shader_free_private(device);
-        return E_OUTOFMEMORY;
-    }
-
-    target = swapchain->back_buffers ? swapchain->back_buffers[0] : swapchain->front_buffer;
-    if (!(context = context_create(swapchain, target, swapchain->ds_format)))
+    hr = wined3d_cs_emit_create_swapchain_context(device->cs, swapchain);
+    if (FAILED(hr))
     {
         WARN("Failed to create context.\n");
         device->blitter->free_private(device);
         device->shader_backend->shader_free_private(device);
-        HeapFree(GetProcessHeap(), 0, swapchain->context);
-        return E_FAIL;
+        return hr;
     }
 
-    swapchain->context[0] = context;
-    swapchain->num_contexts = 1;
-    create_dummy_textures(device, context);
-    create_default_samplers(device, context);
-    context_release(context);
+    wined3d_cs_emit_create_dummy_textures(device->cs);
 
     return WINED3D_OK;
 }
@@ -4648,6 +4625,12 @@
     TRACE("device %p, swapchain_desc %p, mode %p, callback %p, reset_state %#x.\n",
             device, swapchain_desc, mode, callback, reset_state);
 
+    if (wined3d_use_csmt(device))
+    {
+        wined3d_cs_emit_glfinish(device->cs);
+        device->cs->ops->finish(device->cs);
+    }
+
     if (!(swapchain = wined3d_device_get_swapchain(device, 0)))
     {
         ERR("Failed to get the first implicit swapchain.\n");
@@ -4678,10 +4661,10 @@
     }
     wined3d_device_set_depth_stencil_view(device, NULL);
 
-    if (device->onscreen_depth_stencil)
+    if (device->cs->onscreen_depth_stencil)
     {
-        wined3d_texture_decref(device->onscreen_depth_stencil->container);
-        device->onscreen_depth_stencil = NULL;
+        wined3d_texture_decref(device->cs->onscreen_depth_stencil->container);
+        device->cs->onscreen_depth_stencil = NULL;
     }
 
     if (reset_state)
@@ -4878,7 +4861,7 @@
     {
         if (reset_state)
             hr = create_primary_opengl_context(device, swapchain);
-        swapchain_update_swap_interval(swapchain);
+        wined3d_cs_emit_update_swap_interval(device->cs, swapchain);
     }
 
     /* All done. There is no need to reload resources or shaders, this will happen automatically on the
@@ -5186,3 +5169,56 @@
     else
         return CallWindowProcA(proc, window, message, wparam, lparam);
 }
+
+/* Context activation is done by the caller */
+struct wined3d_gl_bo *wined3d_device_get_bo(struct wined3d_device *device, UINT size, GLenum gl_usage,
+        GLenum type_hint, struct wined3d_context *context)
+{
+    struct wined3d_gl_bo *ret;
+    const struct wined3d_gl_info *gl_info;
+
+    TRACE("device %p, size %u, gl_usage %u, type_hint %u\n", device, size, gl_usage,
+            type_hint);
+
+    ret = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(*ret));
+    if(!ret)
+        return NULL;
+    ret->type_hint = type_hint;
+    ret->size = size;
+    ret->usage = gl_usage;
+
+    gl_info = context->gl_info;
+
+    GL_EXTCALL(glGenBuffers(1, &ret->name));
+    if (type_hint == GL_ELEMENT_ARRAY_BUFFER)
+        context_invalidate_state(context, STATE_INDEXBUFFER);
+    GL_EXTCALL(glBindBuffer(type_hint, ret->name));
+    GL_EXTCALL(glBufferData(type_hint, size, NULL, gl_usage));
+    GL_EXTCALL(glBindBuffer(type_hint, 0));
+    checkGLcall("Create buffer object");
+
+    TRACE("Successfully created and set up buffer %u\n", ret->name);
+    return ret;
+}
+
+/* Context activation is done by the caller */
+static void wined3d_device_destroy_bo(struct wined3d_device *device, const struct wined3d_context *context,
+        struct wined3d_gl_bo *bo)
+{
+    const struct wined3d_gl_info *gl_info = context->gl_info;
+    TRACE("device %p, bo %p, GL bo %u\n", device, bo, bo->name);
+
+    GL_EXTCALL(glDeleteBuffers(1, &bo->name));
+    checkGLcall("glDeleteBuffers");
+
+    HeapFree(GetProcessHeap(), 0, bo);
+}
+
+/* Context activation is done by the caller */
+void wined3d_device_release_bo(struct wined3d_device *device, struct wined3d_gl_bo *bo,
+        const struct wined3d_context *context)
+{
+    TRACE("device %p, bo %p, GL bo %u\n", device, bo, bo->name);
+
+    wined3d_device_destroy_bo(device, context, bo);
+}
diff -Naur wine-2.0a/dlls/wined3d/directx.c wine-2.0b/dlls/wined3d/directx.c
--- wine-2.0a/dlls/wined3d/directx.c	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/wined3d/directx.c	2017-07-11 20:37:51.000000000 +0100
@@ -617,6 +617,45 @@
     return TRUE;
 }
 
+static BOOL match_apple_ati(const struct wined3d_gl_info *gl_info, const char *gl_renderer,
+        enum wined3d_gl_vendor gl_vendor, enum wined3d_pci_vendor card_vendor, enum wined3d_pci_device device)
+{
+    return gl_vendor == GL_VENDOR_APPLE && card_vendor == HW_VENDOR_AMD;
+}
+
+static BOOL match_apple_ati_sl(const struct wined3d_gl_info *gl_info, const char *gl_renderer,
+        enum wined3d_gl_vendor gl_vendor, enum wined3d_pci_vendor card_vendor, enum wined3d_pci_device device)
+{
+    /* ATI cards on Snow Leopard support GL_ARB_texture_rg, but not on Leopard, according
+     * to Apple's OpenGL capabilities matrix. Nvidia cards don't support it, but that's ok
+     * for this matcher since its only intended for ATI anyway.
+     */
+    if(!gl_info->supported[ARB_TEXTURE_RG]) return FALSE;
+    return match_apple_ati(gl_info, gl_renderer, gl_vendor, card_vendor, device);
+}
+
+static BOOL match_broken_ara(const struct wined3d_gl_info *gl_info, const char *gl_renderer,
+        enum wined3d_gl_vendor gl_vendor, enum wined3d_pci_vendor card_vendor, enum wined3d_pci_device device)
+{
+    if (!gl_info->supported[NV_VERTEX_PROGRAM2_OPTION]) return FALSE;
+    if (gl_vendor != GL_VENDOR_APPLE) return FALSE;
+
+    switch (device)
+    {
+        /* There are no intel macs with pre-geforce 7 cards. ARA works on pre-gf8 cards */
+        case CARD_NVIDIA_GEFORCE_7400:
+        case CARD_NVIDIA_GEFORCE_7300:
+        case CARD_NVIDIA_GEFORCE_7600:
+        case CARD_NVIDIA_GEFORCE_7800GT:
+            /* ARA works on GF7 cards */
+            return FALSE;
+
+        default:
+            /* Assume ARA is broken */
+            return TRUE;
+    }
+}
+
 static BOOL match_dx10_capable(const struct wined3d_gl_info *gl_info, const char *gl_renderer,
         enum wined3d_gl_vendor gl_vendor, enum wined3d_pci_vendor card_vendor, enum wined3d_pci_device device)
 {
@@ -630,6 +669,45 @@
     return gl_info->limits.glsl_varyings > 44;
 }
 
+static BOOL match_apple_broken_uniforms(const struct wined3d_gl_info *gl_info, const char *gl_renderer,
+                                        enum wined3d_gl_vendor gl_vendor, enum wined3d_pci_vendor card_vendor, enum wined3d_pci_device device)
+{
+    const char *sysrelease;
+    unsigned int major, minor, ret;
+    void (CDECL *my_wine_get_host_version)(const char **sysname, const char **release);
+
+    /* MacOS dx9 GPU drivers more GLSL vertex shader uniforms than supported by the hardware, and if
+     * more are used it falls back to software. While the compiler can detect if the shader uses all
+     * declared uniforms, the optimization fails if the shader uses relative addressing. So any GLSL
+     * shader using relative addressing falls back to software.
+     *
+     * ARB vp gives the correct amount of uniforms, so use it instead of GLSL.
+     *
+     * In addition, AMD Radeon HD GPUs advertise > 256 constants and can support this in HW, but the
+     * driver nevertheless falls back to software if more than 256 are used. This is fixed in MacOS
+     * 10.8.3 */
+
+    /* Non-Apple GL vendors report uniforms correctly */
+    if (!match_apple(gl_info, gl_renderer, gl_vendor, card_vendor, device)) return FALSE;
+    /* All dx9 cards are overreported on OSX */
+    if (!match_dx10_capable(gl_info, gl_renderer, gl_vendor, card_vendor, device)) return TRUE;
+    /* Nvidia and Intel DX10 cards support > 256 uniforms */
+    if (card_vendor != HW_VENDOR_AMD) return FALSE;
+
+    /* On OSX 10.8.3 and later, AMD GPUs support more than 256 constants. This OSX version reports
+     * uname -r "12.3.0" */
+    my_wine_get_host_version = (void *)GetProcAddress(GetModuleHandleA("ntdll.dll"), "wine_get_host_version");
+    if (!my_wine_get_host_version) return FALSE;
+
+    my_wine_get_host_version(NULL, &sysrelease);
+    ret = sscanf(sysrelease, "%u.%u", &major, &minor);
+    if (ret != 2) return FALSE; /* String format changed, assume workaround not needed */
+    if (major > 12) return FALSE;
+    if (major == 12 && minor >= 3) return FALSE;
+
+    return TRUE;
+}
+
 static BOOL match_not_dx10_capable(const struct wined3d_gl_info *gl_info, const char *gl_renderer,
         enum wined3d_gl_vendor gl_vendor, enum wined3d_pci_vendor card_vendor, enum wined3d_pci_device device)
 {
@@ -790,6 +868,109 @@
     return gl_vendor == GL_VENDOR_FGLRX;
 }
 
+static BOOL match_broken_round(const struct wined3d_gl_info *gl_info, const char *gl_renderer,
+        enum wined3d_gl_vendor gl_vendor, enum wined3d_pci_vendor card_vendor, enum wined3d_pci_device device)
+{
+    const char *shader =
+        "#version 120\n"
+        "#extension GL_EXT_gpu_shader4 : enable\n"
+        "void main()\n"
+        "{\n"
+        "    vec4 color;\n"
+        "    vec4 rounded = round(gl_MultiTexCoord0.yxzw);\n"
+        "    /* all(rounded == gl_MultiTexCoord1) fails for some reason */\n"
+        "    if (all(equal(rounded, gl_MultiTexCoord1)))\n"
+        "    {\n"
+        "        color = vec4(0.0, 1.0, 0.0, 0.0);\n"
+        "    }\n"
+        "    else\n"
+        "    {\n"
+        "        color = vec4(1.0, 0.0, 0.0, 0.0);\n"
+        "    }\n"
+        "    gl_FrontColor = color;\n"
+        "    gl_Position = gl_Vertex;\n"
+        "}\n";
+    GLuint tex, fbo;
+    GLuint prog, vs;
+    GLenum status;
+    DWORD check;
+    unsigned char red, green, blue;
+
+    if (!gl_info->supported[EXT_GPU_SHADER4]) return FALSE;
+
+    if (wined3d_settings.offscreen_rendering_mode != ORM_FBO)
+    {
+        WARN("FBOs not available, guessing broken glsl round from driver info\n");
+        return gl_vendor == GL_VENDOR_APPLE && card_vendor == HW_VENDOR_AMD;
+    }
+
+    gl_info->gl_ops.gl.p_glGenTextures(1, &tex);
+    gl_info->gl_ops.gl.p_glBindTexture(GL_TEXTURE_2D, tex);
+    gl_info->gl_ops.gl.p_glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
+    gl_info->gl_ops.gl.p_glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
+    gl_info->gl_ops.gl.p_glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA8, 1, 1, 0, GL_BGRA, GL_UNSIGNED_INT_8_8_8_8_REV, NULL);
+    checkGLcall("glTexImage2D");
+    gl_info->gl_ops.gl.p_glBindTexture(GL_TEXTURE_2D, 0);
+
+    gl_info->fbo_ops.glGenFramebuffers(1, &fbo);
+    gl_info->fbo_ops.glBindFramebuffer(GL_FRAMEBUFFER, fbo);
+    gl_info->fbo_ops.glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, tex, 0);
+    checkGLcall("glFramebufferTexture2D");
+
+    status = gl_info->fbo_ops.glCheckFramebufferStatus(GL_FRAMEBUFFER);
+    if (status != GL_FRAMEBUFFER_COMPLETE) ERR("FBO status %#x\n", status);
+    checkGLcall("glCheckFramebufferStatus");
+
+    vs = GL_EXTCALL(glCreateShaderObjectARB(GL_VERTEX_SHADER));
+    GL_EXTCALL(glShaderSourceARB(vs, 1, &shader, 0));
+    GL_EXTCALL(glCompileShaderARB(vs));
+
+    prog = GL_EXTCALL(glCreateProgramObjectARB());
+    GL_EXTCALL(glAttachObjectARB(prog, vs));
+    GL_EXTCALL(glLinkProgramARB(prog));
+    GL_EXTCALL(glDeleteObjectARB(vs));
+    GL_EXTCALL(glUseProgramObjectARB(prog));
+    checkGLcall("round test shader setup");
+
+    gl_info->gl_ops.gl.p_glBegin(GL_QUADS);
+    GL_EXTCALL(glMultiTexCoord4fARB(0, 1.0, 2.0, 3.0, 4.0));
+    /* Note that the result is swizzled */
+    GL_EXTCALL(glMultiTexCoord4fARB(1, 2.0, 1.0, 3.0, 4.0));
+    gl_info->gl_ops.gl.p_glVertex3f(-1.0, -1.0, -0.5);
+    gl_info->gl_ops.gl.p_glVertex3f(-1.0,  1.0, -0.5);
+    gl_info->gl_ops.gl.p_glVertex3f( 1.0,  1.0, -0.5);
+    gl_info->gl_ops.gl.p_glVertex3f( 1.0, -1.0, -0.5);
+    gl_info->gl_ops.gl.p_glEnd();
+    checkGLcall("round test draw");
+
+    gl_info->gl_ops.gl.p_glBindTexture(GL_TEXTURE_2D, tex);
+    gl_info->gl_ops.gl.p_glGetTexImage(GL_TEXTURE_2D, 0, GL_BGRA, GL_UNSIGNED_INT_8_8_8_8_REV, &check);
+    GL_EXTCALL(glUseProgramObjectARB(0));
+    GL_EXTCALL(glDeleteObjectARB(prog));
+
+    gl_info->fbo_ops.glBindFramebuffer(GL_FRAMEBUFFER, 0);
+    gl_info->fbo_ops.glDeleteFramebuffers(1, &fbo);
+    gl_info->gl_ops.gl.p_glBindTexture(GL_TEXTURE_2D, 0);
+    gl_info->gl_ops.gl.p_glDeleteTextures(1, &tex);
+    checkGLcall("round test teardown");
+
+    TRACE("GLSL round test color: %08x\n", check);
+    red = (check & 0x00ff0000) >> 16;
+    green = (check & 0x0000ff00) >> 8;
+    blue = (check & 0x000000ff);
+    /* If round behaves correctly green is returned. Return FALSE in this
+     * case(don't enable quirk). For any other color return TRUE */
+    return (red > 0x10) || (green < 0xf0) || (blue > 0x10);
+}
+
+static void quirk_arb_constants(struct wined3d_gl_info *gl_info)
+{
+    TRACE("Using ARB vs constant limit(=%u) for GLSL.\n", gl_info->limits.arb_vs_native_constants);
+    gl_info->limits.glsl_vs_float_constants = gl_info->limits.arb_vs_native_constants;
+    TRACE("Using ARB ps constant limit(=%u) for GLSL.\n", gl_info->limits.arb_ps_native_constants);
+    gl_info->limits.glsl_ps_float_constants = gl_info->limits.arb_ps_native_constants;
+}
+
 static BOOL match_r200(const struct wined3d_gl_info *gl_info, const char *gl_renderer,
         enum wined3d_gl_vendor gl_vendor, enum wined3d_pci_vendor card_vendor, enum wined3d_pci_device device)
 {
@@ -893,6 +1074,36 @@
     return data[0] != 0x00ff0000 || data[3] != 0x0000ff00;
 }
 
+static BOOL match_nvidia_multithreading(const struct wined3d_gl_info *gl_info, const char *gl_renderer,
+        enum wined3d_gl_vendor gl_vendor, enum wined3d_pci_vendor card_vendor, enum wined3d_pci_device device)
+{
+    char buffer[2];
+    DWORD ret;
+
+    if (gl_vendor != GL_VENDOR_NVIDIA) return FALSE;
+
+    SetLastError(0);
+    ret = GetEnvironmentVariableA("__GL_THREADED_OPTIMIZATIONS", buffer, sizeof(buffer));
+
+    /* The nvidia driver enables its threaded optimizations when the variable is set
+     * and not "0", "n" or "N". Even a value like "00", "NN" or "" enables it */
+    if (!ret)
+        return !GetLastError();
+    if (ret > 1)
+        return TRUE;
+
+    switch(buffer[0])
+    {
+        case 'n':
+        case 'N':
+        case '0':
+            return FALSE;
+
+        default:
+            return TRUE;
+    }
+}
+
 static void quirk_apple_glsl_constants(struct wined3d_gl_info *gl_info)
 {
     /* MacOS needs uniforms for relative addressing offsets. This can accumulate to quite a few uniforms.
@@ -978,11 +1189,40 @@
     gl_info->quirks |= WINED3D_QUIRK_NV_CLIP_BROKEN;
 }
 
+static void quirk_apple_no_glsl_clip(struct wined3d_gl_info *gl_info)
+{
+    gl_info->quirks |= WINED3D_CX_QUIRK_GLSL_CLIP_BROKEN;
+}
+
+static void texcoord_fog_quirk(struct wined3d_gl_info *gl_info)
+{
+    gl_info->quirks |= WINED3D_CX_QUIRK_TEXCOORD_FOG;
+}
+
+static void broken_ara_quirk(struct wined3d_gl_info *gl_info)
+{
+    gl_info->quirks |= WINED3D_CX_QUIRK_BROKEN_ARA;
+}
+
+static void fbo_blit_quirk(struct wined3d_gl_info *gl_info)
+{
+    gl_info->quirks |= WINED3D_CX_QUIRK_BLIT;
+}
+
 static void quirk_fbo_tex_update(struct wined3d_gl_info *gl_info)
 {
     gl_info->quirks |= WINED3D_QUIRK_FBO_TEX_UPDATE;
 }
 
+static void render_to_fbo_quirk(struct wined3d_gl_info *gl_info)
+{
+    /* Mac OSX 10.6(Snow Leopard) has a bug when glBlitFramebufferEXT
+     * is called to copy from the onscreen backbuffer to a framebuffer.
+     * Render the swapchain to a FBO to avoid from-backbuffer blits.
+     */
+    gl_info->quirks |= WINED3D_CX_QUIRK_RENDER_TO_FBO;
+}
+
 static void quirk_broken_rgba16(struct wined3d_gl_info *gl_info)
 {
     gl_info->quirks |= WINED3D_QUIRK_BROKEN_RGBA16;
@@ -1003,6 +1243,16 @@
     gl_info->quirks |= WINED3D_QUIRK_LIMITED_TEX_FILTERING;
 }
 
+static void broken_round_quirk(struct wined3d_gl_info *gl_info)
+{
+    gl_info->quirks |= WINED3D_CX_QUIRK_BROKEN_ROUND;
+}
+
+static void quirk_apple_double_buffer(struct wined3d_gl_info *gl_info)
+{
+    gl_info->quirks |= WINED3D_CX_QUIRK_APPLE_DOUBLE_BUFFER;
+}
+
 static void quirk_r200_constants(struct wined3d_gl_info *gl_info)
 {
     /* The Mesa r200 driver (and there is no other driver for this GPU Wine would run on)
@@ -1029,6 +1279,14 @@
     const char *description;
 };
 
+static void quirk_mapbuffer(struct wined3d_gl_info *gl_info)
+{
+    if (cxgames_hacks.allow_glmapbuffer == WINED3D_MAPBUF_STATIC_NV)
+        cxgames_hacks.allow_glmapbuffer = WINED3D_MAPBUF_STATIC;
+    else if (cxgames_hacks.allow_glmapbuffer == WINED3D_MAPBUF_NEVER_NV)
+        cxgames_hacks.allow_glmapbuffer = WINED3D_MAPBUF_NEVER;
+}
+
 static const struct driver_quirk quirk_table[] =
 {
     {
@@ -1039,8 +1297,21 @@
     {
         match_apple,
         quirk_apple_glsl_constants,
+        "Reserving 12 GLSL uniforms on OSX"
+    },
+    {
+        match_apple_broken_uniforms,
+        quirk_arb_constants,
         "Apple GLSL uniform override"
     },
+    /* Additionally to matching the apple vendor this code could try to compile a testing NVvp shader
+     * that writes to result.clip[n]. This syntax is broken on osx
+     */
+    {
+        match_apple,
+        quirk_apple_no_glsl_clip,
+        "Disabled vertex shader clipping on Macs"
+    },
     {
         match_geforce5,
         quirk_no_np2,
@@ -1062,6 +1333,17 @@
         "Reserved varying for gl_ClipPos"
     },
     {
+        match_amd_r300_to_500,
+        texcoord_fog_quirk,
+        "Disable fog if 8 texcoords are used"
+    },
+    {
+        /* GL_NV_vertex_program2's ARA instruction is broken on gf8+ cards on OSX. */
+        match_broken_ara,
+        broken_ara_quirk,
+        "Disable broken ARA instruction"
+    },
+    {
         /* GL_EXT_secondary_color does not allow 4 component secondary colors, but most
          * GL implementations accept it. The Mac GL is the only implementation known to
          * reject it.
@@ -1082,6 +1364,11 @@
         "Apple NV_vertex_program clip bug quirk"
     },
     {
+        match_apple_ati,
+        fbo_blit_quirk,
+        "GL_EXT_framebuffer_blit glBlendFunc and glColorMask quirk"
+    },
+    {
         match_fbo_tex_update,
         quirk_fbo_tex_update,
         "FBO rebind for attachment updates"
@@ -1102,6 +1389,21 @@
         "Texture filtering, blending and VTF support is limited"
     },
     {
+        match_apple_ati_sl,
+        render_to_fbo_quirk,
+        "Render to FBO quirk"
+    },
+    {
+        match_broken_round,
+        broken_round_quirk,
+        "Broken GLSL round"
+    },
+    {
+        match_apple,
+        quirk_apple_double_buffer,
+        "Apple double buffered context bug (9330)"
+    },
+    {
         match_r200,
         quirk_r200_constants,
         "r200 vertex shader constants"
@@ -1111,6 +1413,11 @@
         quirk_broken_arb_fog,
         "ARBfp fogstart == fogend workaround"
     },
+    {
+        match_nvidia_multithreading,
+        quirk_mapbuffer,
+        "NVidia multithreading glMapBuffer[Range] quirk"
+    },
 };
 
 /* Certain applications (Steam) complain if we report an outdated driver version. In general,
@@ -1776,7 +2083,8 @@
     return HW_VENDOR_NVIDIA;
 }
 
-static enum wined3d_d3d_level d3d_level_from_caps(const struct shader_caps *shader_caps, const struct fragment_caps *fragment_caps, DWORD glsl_version)
+static enum wined3d_d3d_level d3d_level_from_caps(const struct shader_caps *shader_caps,
+        const struct fragment_caps *fragment_caps, DWORD glsl_version, struct wined3d_gl_info *gl_info)
 {
     if (shader_caps->vs_version >= 5)
         return WINED3D_D3D_LEVEL_11;
@@ -1788,7 +2096,7 @@
          * Mesa drivers. */
         if (glsl_version >= MAKEDWORD_VERSION(4, 30))
             return WINED3D_D3D_LEVEL_11;
-        if (glsl_version >= MAKEDWORD_VERSION(1, 30))
+        if (glsl_version >= MAKEDWORD_VERSION(1, 30) || gl_info->supported[EXT_GPU_SHADER4])
             return WINED3D_D3D_LEVEL_10;
         return WINED3D_D3D_LEVEL_9_SM3;
     }
@@ -2418,7 +2726,8 @@
 
 
 static enum wined3d_pci_device wined3d_guess_card(const struct shader_caps *shader_caps, const struct fragment_caps *fragment_caps,
-        DWORD glsl_version, const char *gl_renderer, enum wined3d_gl_vendor *gl_vendor, enum wined3d_pci_vendor *card_vendor)
+        DWORD glsl_version, const char *gl_renderer, enum wined3d_gl_vendor *gl_vendor,
+        struct wined3d_gl_info *gl_info, enum wined3d_pci_vendor *card_vendor)
 {
     /* A Direct3D device object contains the PCI id (vendor + device) of the
      * videocard which is used for rendering. Various applications use this
@@ -2471,7 +2780,7 @@
      * memory can be overruled using a registry setting. */
 
     unsigned int i;
-    enum wined3d_d3d_level d3d_level = d3d_level_from_caps(shader_caps, fragment_caps, glsl_version);
+    enum wined3d_d3d_level d3d_level = d3d_level_from_caps(shader_caps, fragment_caps, glsl_version, gl_info);
     enum wined3d_pci_device device;
 
     for (i = 0; i < (sizeof(card_vendor_table) / sizeof(*card_vendor_table)); ++i)
@@ -2580,6 +2889,38 @@
     }
 }
 
+static void disable_extensions(struct wined3d_gl_info *gl_info, const char *extensions,
+        const struct wined3d_extension_map *map, UINT entry_count)
+{
+    while (*extensions)
+    {
+        const char *start;
+        size_t len;
+        UINT i;
+
+        while (isspace(*extensions))
+            ++extensions;
+        start = extensions;
+        while (!isspace(*extensions) && *extensions)
+            ++extensions;
+
+        len = extensions - start;
+        if (!len)
+            continue;
+
+        for (i = 0; i < entry_count; ++i)
+        {
+            if (len == strlen(map[i].extension_string)
+                    && !memcmp(start, map[i].extension_string, len))
+            {
+                TRACE(" DISABLING: %s.\n", map[i].extension_string);
+                gl_info->supported[map[i].extension] = FALSE;
+                break;
+            }
+        }
+    }
+}
+
 static void enumerate_gl_extensions(struct wined3d_gl_info *gl_info,
         const struct wined3d_extension_map *map, unsigned int map_entries_count)
 {
@@ -3769,6 +4110,15 @@
         }
     }
 
+    /* CodeWeavers Hack bug 5501 - Allow registry disabling of OpenGL extensions. */
+    if (cxgames_hacks.disabled_extensions)
+    {
+        disable_extensions(gl_info, cxgames_hacks.disabled_extensions, gl_extension_map,
+                sizeof(gl_extension_map) / sizeof(*gl_extension_map));
+        disable_extensions(gl_info, cxgames_hacks.disabled_extensions, wgl_extension_map,
+                sizeof(wgl_extension_map) / sizeof(*wgl_extension_map));
+    }
+
     if (gl_info->supported[EXT_BLEND_MINMAX] || gl_info->supported[EXT_BLEND_SUBTRACT])
         gl_info->supported[WINED3D_GL_BLEND_EQUATION] = TRUE;
 
@@ -4104,7 +4454,7 @@
         TRACE("Guessed vendor PCI ID 0x%04x.\n", vendor);
 
         device = wined3d_guess_card(&shader_caps, &fragment_caps, gl_info->glsl_version,
-                gl_renderer_str, &gl_vendor, &vendor);
+                gl_renderer_str, &gl_vendor, gl_info, &vendor);
         TRACE("Guessed device PCI ID 0x%04x.\n", device);
 
         if (!(gpu_description = get_gpu_description(vendor, device)))
@@ -5662,7 +6012,11 @@
 
     caps->MaxUserClipPlanes                = vertex_caps.max_user_clip_planes;
     caps->MaxActiveLights                  = vertex_caps.max_active_lights;
-    caps->MaxVertexBlendMatrices           = vertex_caps.max_vertex_blend_matrices;
+
+    if (cxgames_hacks.max_vertex_blend_matrices && vertex_caps.max_vertex_blend_matrices <= 1)
+        caps->MaxVertexBlendMatrices = cxgames_hacks.max_vertex_blend_matrices;
+    else
+        caps->MaxVertexBlendMatrices           = vertex_caps.max_vertex_blend_matrices;
     caps->MaxVertexBlendMatrixIndex        = vertex_caps.max_vertex_blend_matrix_index;
     caps->VertexProcessingCaps             = vertex_caps.vertex_processing_caps;
     caps->FVFCaps                          = vertex_caps.fvf_caps;
diff -Naur wine-2.0a/dlls/wined3d/drawprim.c wine-2.0b/dlls/wined3d/drawprim.c
--- wine-2.0a/dlls/wined3d/drawprim.c	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/wined3d/drawprim.c	2017-07-11 20:37:51.000000000 +0100
@@ -468,8 +468,8 @@
         {
             RECT current_rect, draw_rect, r;
 
-            if (!context->render_offscreen && ds != device->onscreen_depth_stencil)
-                device_switch_onscreen_ds(device, context, ds);
+            if (!context->render_offscreen && ds != device->cs->onscreen_depth_stencil)
+                wined3d_cs_switch_onscreen_ds(device->cs, context, ds);
 
             if (surface_get_sub_resource(ds)->locations & location)
                 SetRect(&current_rect, 0, 0, ds->ds_current_size.cx, ds->ds_current_size.cy);
diff -Naur wine-2.0a/dlls/wined3d/glsl_shader.c wine-2.0b/dlls/wined3d/glsl_shader.c
--- wine-2.0a/dlls/wined3d/glsl_shader.c	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/wined3d/glsl_shader.c	2017-07-11 20:37:51.000000000 +0100
@@ -219,6 +219,7 @@
     GLuint id;
     DWORD constant_update_mask;
     UINT constant_version;
+    DWORD clipplanes;
 };
 
 struct glsl_program_key
@@ -226,6 +227,7 @@
     GLuint vs_id;
     GLuint gs_id;
     GLuint ps_id;
+    DWORD clipplanes;
 };
 
 struct shader_glsl_ctx_priv {
@@ -268,6 +270,7 @@
         struct glsl_ps_compiled_shader *ps;
     } gl_shaders;
     UINT num_gl_shaders, shader_array_size;
+    DWORD clipplane_emulation;
 };
 
 struct glsl_ffp_vertex_shader
@@ -464,6 +467,7 @@
 /* Context activation is done by the caller. */
 static void shader_glsl_compile(const struct wined3d_gl_info *gl_info, GLuint shader, const char *src)
 {
+    WORD old_fpu_cw = wined3d_get_fpu_cw();
     const char *ptr, *line;
 
     TRACE("Compiling shader object %u.\n", shader);
@@ -476,8 +480,12 @@
 
     GL_EXTCALL(glShaderSource(shader, 1, &src, NULL));
     checkGLcall("glShaderSource");
+    if (old_fpu_cw != WINED3D_DEFAULT_FPU_CW)
+        wined3d_set_fpu_cw(WINED3D_DEFAULT_FPU_CW);
     GL_EXTCALL(glCompileShader(shader));
     checkGLcall("glCompileShader");
+    if (old_fpu_cw != WINED3D_DEFAULT_FPU_CW)
+        wined3d_set_fpu_cw(old_fpu_cw);
     print_glsl_info_log(gl_info, shader, FALSE);
 }
 
@@ -1397,6 +1405,16 @@
     const struct wined3d_gl_info *gl_info = context->gl_info;
     struct wined3d_vec4 plane;
 
+    /* With macOS clip planes emulation, the generated shader
+     * hardcodes the enabled clip planes. That means the compiler
+     * might optimize away clip_planes[] elements known not to be
+     * used. Trying to upload unused clip plane uniforms is thus a bad
+     * idea, since the computed uniform location will either be
+     * unused, thus invalid, or used by some other uniform, which is
+     * potentially dangerous. */
+    if (!(state->render_states[WINED3D_RS_CLIPPLANEENABLE] & 1 << index))
+        return;
+
     /* Clip planes are affected by the view transform in d3d for FFP draws. */
     if (!use_vs(state))
         multiply_vector_matrix(&plane, &state->clip_planes[index], &state->transforms[WINED3D_TS_VIEW]);
@@ -1404,6 +1422,7 @@
         plane = state->clip_planes[index];
 
     GL_EXTCALL(glUniform4fv(prog->vs.clip_planes_location + index, 1, &plane.x));
+    checkGLcall("glUniform4fv");
 }
 
 /* Context activation is done by the caller (state handler). */
@@ -1941,7 +1960,17 @@
                  * clipplane as well. */
                 max_constantsF = gl_info->limits.glsl_vs_float_constants - 3;
                 if (vs_args->clip_enabled)
-                    max_constantsF -= gl_info->limits.user_clip_distances;
+                {
+                    if (gl_info->quirks & WINED3D_CX_QUIRK_GLSL_CLIP_BROKEN)
+                    {
+                        /* The link program reads at most 4 clipplanes to emulate clipping */
+                        max_constantsF -= 4;
+                    }
+                    else
+                    {
+                        max_constantsF -= gl_info->limits.user_clip_distances;
+                    }
+                }
                 max_constantsF -= wined3d_popcount(reg_maps->integer_constants);
                 /* Strictly speaking a bool only uses one scalar, but the nvidia(Linux) compiler doesn't pack them properly,
                  * so each scalar requires a full vec4. We could work around this by packing the booleans ourselves, but
@@ -3546,7 +3575,8 @@
         const struct wined3d_shader_version *version = &ins->ctx->shader->reg_maps.shader_version;
         unsigned int mask_size = shader_glsl_get_write_mask_size(write_mask);
 
-        if (shader_glsl_get_version(gl_info, version) >= 130 || gl_info->supported[EXT_GPU_SHADER4])
+        if ((shader_glsl_get_version(gl_info, version) >= 130 || gl_info->supported[EXT_GPU_SHADER4])
+                && !(gl_info->quirks & WINED3D_CX_QUIRK_BROKEN_ROUND))
         {
             if (mask_size > 1)
                 shader_addline(buffer, "ivec%d(round(%s)));\n", mask_size, src0_param.param_str);
@@ -5583,6 +5613,24 @@
  * Vertex Shader Specific Code begins here
  ********************************************/
 
+static DWORD find_clipplanes(const struct wined3d_context *context,
+                             const struct wined3d_state *state,
+                             const struct wined3d_gl_info *gl_info,
+                             const struct wined3d_d3d_info *d3d_info )
+{
+    /* If HW clipping is used, no clipplane emulation */
+    if (!(gl_info->quirks & WINED3D_CX_QUIRK_GLSL_CLIP_BROKEN)) return 0;
+    /* If clipping is disabled, no clipplanes are needed */
+    if (!state->render_states[WINED3D_RS_CLIPPING]) return 0;
+    /* With pixelshaders, emulate all enabled clipplanes(disabled per shader
+     * if no free texcoord is found. */
+    if (use_ps(state)) return state->render_states[WINED3D_RS_CLIPPLANEENABLE];
+    /* With FFP, if all texcoords are used, don't emulate clipplanes */
+    if (context->lowest_disabled_stage >= d3d_info->limits.ffp_blend_stages) return 0;
+    /* Otherwise(FFP with highest texcoord free) emulate all enabled planes */
+    return state->render_states[WINED3D_RS_CLIPPLANEENABLE];
+}
+
 static void add_glsl_program_entry(struct shader_glsl_priv *priv, struct glsl_shader_prog_link *entry)
 {
     struct glsl_program_key key;
@@ -5590,6 +5638,7 @@
     key.vs_id = entry->vs.id;
     key.gs_id = entry->gs.id;
     key.ps_id = entry->ps.id;
+    key.clipplanes = entry->clipplanes;
 
     if (wine_rb_put(&priv->program_lookup, &key, &entry->program_lookup_entry) == -1)
     {
@@ -5598,7 +5647,11 @@
 }
 
 static struct glsl_shader_prog_link *get_glsl_program_entry(const struct shader_glsl_priv *priv,
-        GLuint vs_id, GLuint gs_id, GLuint ps_id)
+                                                            GLuint vs_id, GLuint gs_id, GLuint ps_id,
+                                                            const struct wined3d_context *context,
+                                                            const struct wined3d_state *state,
+                                                            const struct wined3d_gl_info *gl_info,
+                                                            const struct wined3d_d3d_info *d3d_info )
 {
     struct wine_rb_entry *entry;
     struct glsl_program_key key;
@@ -5606,6 +5659,7 @@
     key.vs_id = vs_id;
     key.gs_id = gs_id;
     key.ps_id = ps_id;
+    key.clipplanes = find_clipplanes(context, state, gl_info, d3d_info);
 
     entry = wine_rb_get(&priv->program_lookup, &key);
     return entry ? WINE_RB_ENTRY_VALUE(entry, struct glsl_shader_prog_link, program_lookup_entry) : NULL;
@@ -5731,6 +5785,58 @@
     string_buffer_release(&priv->string_buffers, destination);
 }
 
+static void glsl_gen_clipplane_emul(const struct wined3d_shader *ps, struct wined3d_string_buffer *buffer,
+        const struct wined3d_gl_info *gl_info, const struct wined3d_d3d_info *d3d_info,
+        DWORD enabled_clipplanes)
+{
+    BOOL legacy_context = gl_info->supported[WINED3D_GL_LEGACY_CONTEXT];
+    const char *clip_varying = legacy_context ? "gl_TexCoord" : !ps || ps->reg_maps.shader_version.major < 3
+            ? "ffp_varying_texcoord" : "ps_link";
+    DWORD clip_coord = 0;
+
+    /* Generate a clipplane emulation texcoord if native clipplanes are broken */
+    if(ps)
+    {
+        struct glsl_shader_private *shader_priv = ps->backend_data;
+        clip_coord = shader_priv->clipplane_emulation;
+    }
+    else if (gl_info->quirks & WINED3D_CX_QUIRK_GLSL_CLIP_BROKEN)
+    {
+        clip_coord = d3d_info->limits.ffp_blend_stages;
+    }
+
+    if(clip_coord)
+    {
+        unsigned int i, coord = 0;
+        char component;
+
+        shader_addline(buffer, "%s[%u] = vec4(1.0);\n", clip_varying, clip_coord - 1);
+        if(enabled_clipplanes)
+        {
+            shader_addline(buffer, "vec4 ClipCoord = gl_Position;\n");
+            shader_addline(buffer, "ClipCoord.xy += pos_fixup.zw * ClipCoord.ww;\n");
+            for(i = 0; i < gl_info->limits.user_clip_distances; i++)
+            {
+                if(enabled_clipplanes & (1 << i))
+                {
+                    if(coord == 0) component = 'x';
+                    else if(coord == 1) component = 'y';
+                    else if(coord == 2) component = 'z';
+                    else if(coord == 3) component = 'w';
+                    else
+                    {
+                        FIXME("Too many clipplanes used for clipplane emulation\n");
+                        break;
+                    }
+                    shader_addline(buffer, "%s[%u].%c = dot(ClipCoord, clip_planes[%u]);\n",
+                            clip_varying, clip_coord - 1, component, i);
+                    coord++;
+                }
+            }
+        }
+    }
+}
+
 static void shader_glsl_setup_sm4_shader_output(struct shader_glsl_priv *priv,
         unsigned int input_count, const struct wined3d_shader_signature *output_signature,
         const struct wined3d_shader_reg_maps *reg_maps_out, const char *out_array_name)
@@ -5833,7 +5939,8 @@
 /* Context activation is done by the caller. */
 static GLuint shader_glsl_generate_vs3_rasterizer_input_setup(struct shader_glsl_priv *priv,
         const struct wined3d_shader *vs, const struct wined3d_shader *ps,
-        BOOL per_vertex_point_size, BOOL flatshading, const struct wined3d_gl_info *gl_info)
+        BOOL per_vertex_point_size, BOOL flatshading, const struct wined3d_gl_info *gl_info,
+        const struct wined3d_d3d_info *d3d_info, DWORD enabled_clipplanes)
 {
     struct wined3d_string_buffer *buffer = &priv->shader_buffer;
     GLuint ret;
@@ -5869,6 +5976,11 @@
             declare_out_varying(gl_info, buffer, FALSE, "float ffp_varying_fogcoord;\n");
         }
 
+        if (enabled_clipplanes)
+        {
+            shader_addline(buffer, "uniform vec4 clip_planes[%u];\n", gl_info->limits.user_clip_distances);
+            shader_addline(buffer, "uniform vec4 pos_fixup;\n");
+        }
         shader_addline(buffer, "void setup_vs_output(in vec4 shader_out[%u])\n{\n", vs->limits->packed_output);
 
         for (i = 0; i < vs->output_signature.element_count; ++i)
@@ -5954,15 +6066,25 @@
                         legacy_context ? "gl_TexCoord" : "ffp_varying_texcoord", i, reg_mask, reg_mask);
             }
         }
+
+        glsl_gen_clipplane_emul(ps, buffer, gl_info, d3d_info, enabled_clipplanes);
     }
     else
     {
         UINT in_count = min(vec4_varyings(ps_major, gl_info), ps->limits->packed_input);
 
         declare_out_varying(gl_info, buffer, FALSE, "vec4 ps_link[%u];\n", in_count);
+        if (enabled_clipplanes)
+        {
+            shader_addline(buffer, "uniform vec4 clip_planes[%u];\n", gl_info->limits.user_clip_distances);
+            shader_addline(buffer, "uniform vec4 pos_fixup;\n");
+        }
+
         shader_addline(buffer, "void setup_vs_output(in vec4 shader_out[%u])\n{\n", vs->limits->packed_output);
         shader_glsl_setup_sm3_rasterizer_input(priv, gl_info, ps->u.ps.input_reg_map, &ps->input_signature,
                 &ps->reg_maps, 0, &vs->output_signature, &vs->reg_maps, per_vertex_point_size);
+
+        glsl_gen_clipplane_emul(ps, buffer, gl_info, d3d_info, enabled_clipplanes);
     }
 
     shader_addline(buffer, "}\n");
@@ -6084,9 +6206,10 @@
 
 static void shader_glsl_generate_ps_epilogue(const struct wined3d_gl_info *gl_info,
         struct wined3d_string_buffer *buffer, const struct wined3d_shader *shader,
-        const struct ps_compile_args *args)
+        const struct ps_compile_args *args, struct glsl_shader_private *shader_priv )
 {
     const struct wined3d_shader_reg_maps *reg_maps = &shader->reg_maps;
+    BOOL varying_limit_ok = TRUE;
 
     /* Pixel shaders < 2.0 place the resulting color in R0 implicitly. */
     if (reg_maps->shader_version.major < 2)
@@ -6095,8 +6218,23 @@
     if (args->srgb_correction)
         shader_glsl_generate_srgb_write_correction(buffer, gl_info);
 
+    if (gl_info->quirks & WINED3D_CX_QUIRK_TEXCOORD_FOG)
+    {
+        unsigned int cnt = 0, i;
+        for(i = 0; i < MAX_REG_TEXCRD; i++)
+        {
+            if (reg_maps->texcoord & (1 << i)) ++cnt;
+        }
+        if(shader_priv->clipplane_emulation) cnt++;
+        if(cnt >= 8)
+        {
+            WARN("Disabling fog because 8 texcoords are used\n");
+            varying_limit_ok = FALSE;
+        }
+    }
+
     /* SM < 3 does not replace the fog stage. */
-    if (reg_maps->shader_version.major < 3)
+    if (reg_maps->shader_version.major < 3 && varying_limit_ok)
         shader_glsl_generate_fog_code(buffer, gl_info, args->fog);
 
     shader_glsl_generate_alpha_test(buffer, gl_info, args->alpha_test_func + 1);
@@ -6113,6 +6251,7 @@
     const DWORD *function = shader->function;
     struct shader_glsl_ctx_priv priv_ctx;
     BOOL legacy_context = gl_info->supported[WINED3D_GL_LEGACY_CONTEXT];
+    struct glsl_shader_private *shader_priv = shader->backend_data;
 
     /* Create the hw GLSL shader object and assign it as the shader->prgId */
     GLuint shader_id = GL_EXTCALL(glCreateShader(GL_FRAGMENT_SHADER));
@@ -6205,12 +6344,20 @@
     if (reg_maps->shader_version.major >= 3)
         shader_glsl_input_pack(shader, buffer, &shader->input_signature, reg_maps, args, gl_info);
 
+    if(shader_priv->clipplane_emulation && args->clip)
+    {
+        shader_addline(buffer, "vec4 planes_distance = %s[%u];\n",
+                legacy_context ? "gl_TexCoord" : reg_maps->shader_version.major < 3
+                ? "ffp_varying_texcoord" : "ps_link", shader_priv->clipplane_emulation - 1);
+        shader_addline(buffer, "if(any(lessThan(planes_distance, vec4(0.0)))) discard;\n");
+    }
+
     /* Base Shader Body */
     shader_generate_main(shader, buffer, reg_maps, function, &priv_ctx);
 
     /* In SM4+ the shader epilogue is generated by the "ret" instruction. */
     if (reg_maps->shader_version.major < 4)
-        shader_glsl_generate_ps_epilogue(gl_info, buffer, shader, args);
+        shader_glsl_generate_ps_epilogue(gl_info, buffer, shader, args, shader_priv);
 
     shader_addline(buffer, "}\n");
 
@@ -6361,11 +6508,12 @@
     const struct shader_glsl_ctx_priv *priv = ctx->backend_data;
     const struct wined3d_gl_info *gl_info = ctx->gl_info;
     const struct wined3d_shader *shader = ctx->shader;
+    struct glsl_shader_private *shader_priv = shader->backend_data;
 
     switch (shader->reg_maps.shader_version.type)
     {
         case WINED3D_SHADER_TYPE_PIXEL:
-            shader_glsl_generate_ps_epilogue(gl_info, ctx->buffer, shader, priv->cur_ps_args);
+            shader_glsl_generate_ps_epilogue(gl_info, ctx->buffer, shader, priv->cur_ps_args, shader_priv);
             break;
         case WINED3D_SHADER_TYPE_VERTEX:
             shader_glsl_generate_vs_epilogue(gl_info, ctx->buffer, shader, priv->cur_vs_args);
@@ -6392,12 +6540,21 @@
 
     if (!shader->backend_data)
     {
+        const struct wined3d_gl_info *gl_info = &shader->device->adapter->gl_info;
         shader->backend_data = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(*shader_data));
         if (!shader->backend_data)
         {
             ERR("Failed to allocate backend data.\n");
             return 0;
         }
+
+        if (gl_info->quirks & WINED3D_CX_QUIRK_GLSL_CLIP_BROKEN)
+        {
+            unsigned int coord;
+            coord = shader_find_free_input_register(&shader->reg_maps, context->d3d_info->limits.ffp_blend_stages - 1);
+            /* Store off by one, the code checks against zero */
+            ((struct glsl_shader_private *)shader->backend_data)->clipplane_emulation = coord + 1;
+        }
     }
     shader_data = shader->backend_data;
     gl_shaders = shader_data->gl_shaders.ps;
@@ -7486,6 +7643,9 @@
                 shader_addline(buffer, "ffp_texcoord[%u] = vec4(0.0);\n", stage);
         }
     }
+    if (settings->emul_clipplanes)
+        shader_addline(buffer, "ffp_texcoord[7] = %s[7];\n",
+                legacy_context ? "gl_TexCoord" : "ffp_varying_texcoord");
 
     if (legacy_context && settings->fog != WINED3D_FFP_PS_FOG_OFF)
         shader_addline(buffer, "ffp_varying_fogcoord = gl_FogFragCoord;\n");
@@ -7939,6 +8099,7 @@
     GLuint gs_id = 0;
     GLuint ps_id = 0;
     struct list *ps_list, *vs_list;
+    WORD old_fpu_cw;
     WORD attribs_map;
     struct wined3d_string_buffer *tmp_name;
 
@@ -8029,7 +8190,8 @@
         ps_list = &ffp_shader->linked_programs;
     }
 
-    if ((!vs_id && !gs_id && !ps_id) || (entry = get_glsl_program_entry(priv, vs_id, gs_id, ps_id)))
+    if ((!vs_id && !gs_id && !ps_id) || (entry = get_glsl_program_entry(priv, vs_id, gs_id, ps_id,
+                                                                        context, state, gl_info, d3d_info)))
     {
         ctx_data->glsl_program = entry;
         return;
@@ -8047,6 +8209,7 @@
     entry->ps.id = ps_id;
     entry->constant_version = 0;
     entry->ps.np2_fixup_info = np2fixup_info;
+    entry->clipplanes = find_clipplanes(context, state, gl_info, d3d_info);
     /* Add the hash table entry */
     add_glsl_program_entry(priv, entry);
 
@@ -8065,13 +8228,15 @@
 
     if (vshader)
     {
+        DWORD clip = find_clipplanes(context, state, gl_info, d3d_info);
+
         attribs_map = vshader->reg_maps.input_registers;
         if (vshader->reg_maps.shader_version.major < 4)
         {
             reorder_shader_id = shader_glsl_generate_vs3_rasterizer_input_setup(priv, vshader, pshader,
                     state->gl_primitive_type == GL_POINTS && vshader->reg_maps.point_size,
                     d3d_info->emulated_flatshading
-                    && state->render_states[WINED3D_RS_SHADEMODE] == WINED3D_SHADE_FLAT, gl_info);
+                    && state->render_states[WINED3D_RS_SHADEMODE] == WINED3D_SHADE_FLAT, gl_info, d3d_info, clip);
             TRACE("Attaching GLSL shader object %u to program %u.\n", reorder_shader_id, program_id);
             GL_EXTCALL(glAttachShader(program_id, reorder_shader_id));
             checkGLcall("glAttachShader");
@@ -8152,7 +8317,16 @@
 
     /* Link the program */
     TRACE("Linking GLSL shader program %u.\n", program_id);
+
+    old_fpu_cw = wined3d_get_fpu_cw();
+    if (old_fpu_cw != WINED3D_DEFAULT_FPU_CW)
+        wined3d_set_fpu_cw(WINED3D_DEFAULT_FPU_CW);
+
     GL_EXTCALL(glLinkProgram(program_id));
+
+    if (old_fpu_cw != WINED3D_DEFAULT_FPU_CW)
+        wined3d_set_fpu_cw(old_fpu_cw);
+
     shader_glsl_validate_link(gl_info, program_id);
 
     shader_glsl_init_vs_uniform_locations(gl_info, priv, program_id, &entry->vs,
@@ -8684,6 +8858,9 @@
     if (k->ps_id > prog->ps.id) return 1;
     else if (k->ps_id < prog->ps.id) return -1;
 
+    if(k->clipplanes > prog->clipplanes) return 1;
+    else if(k->clipplanes < prog->clipplanes) return -1;
+
     return 0;
 }
 
@@ -8859,6 +9036,8 @@
             && gl_info->supported[ARB_SHADER_BIT_ENCODING] && gl_info->supported[ARB_SAMPLER_OBJECTS]
             && gl_info->supported[ARB_TEXTURE_SWIZZLE])
         shader_model = 4;
+    else if (cxgames_hacks.glsl130_sm4 && gl_info->glsl_version >= MAKEDWORD_VERSION(1, 30))
+        shader_model = 4;
     /* Support for texldd and texldl instructions in pixel shaders is required
      * for SM3. */
     else if (shader_glsl_has_core_grad(gl_info, NULL) || gl_info->supported[ARB_SHADER_TEXTURE_LOD])
@@ -8878,6 +9057,13 @@
     caps->ps_uniform_count = min(WINED3D_MAX_PS_CONSTS_F, gl_info->limits.glsl_ps_float_constants);
     caps->varying_count = gl_info->limits.glsl_varyings;
 
+    if (cxgames_hacks.safe_vs_consts)
+    {
+        /* One for the posFixup, two for compiler constants, and the clipplanes. */
+        caps->vs_uniform_count -= 3 + gl_info->limits.user_clip_distances;
+        caps->vs_uniform_count -= gl_info->reserved_glsl_constants;
+    }
+
     /* FIXME: The following line is card dependent. -8.0 to 8.0 is the
      * Direct3D minimum requirement.
      *
@@ -8900,6 +9086,21 @@
      * shader_glsl_alloc(). */
     caps->wined3d_caps = WINED3D_SHADER_CAP_VS_CLIPPING
             | WINED3D_SHADER_CAP_SRGB_WRITE;
+
+    /* Do not advertise VS clipping if the no vs clipping quirk is set. On a
+     * proper GL driver this should not matter, but on a proper GL driver we
+     * don't need the quirk in the first place.
+     *
+     * ATI cards on OSX clip based on gl_Position if a clipplane is enabled.
+     * This would be almost perfect for our use, except that the Z fixup
+     * makes the clip position invalid. Don't try to make use of this bug
+     * though by disabling the Z fixup, I consider it a bad idea to depend on
+     * a bug, and disabling the Z fixup will break geometry position vs depth
+     * clear position, and it will reduce the Z buffer precision.
+     *
+     * Tracked by crossover hacks bug 5366. */
+    if (gl_info->quirks & WINED3D_CX_QUIRK_GLSL_CLIP_BROKEN)
+        caps->wined3d_caps &= ~WINED3D_SHADER_CAP_VS_CLIPPING;
 }
 
 static BOOL shader_glsl_color_fixup_supported(struct color_fixup_desc fixup)
diff -Naur wine-2.0a/dlls/wined3d/query.c wine-2.0b/dlls/wined3d/query.c
--- wine-2.0a/dlls/wined3d/query.c	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/wined3d/query.c	2017-07-11 20:37:51.000000000 +0100
@@ -37,6 +37,7 @@
     query->data = data;
     query->data_size = data_size;
     query->query_ops = query_ops;
+    list_init(&query->poll_list_entry);
 }
 
 static struct wined3d_event_query *wined3d_event_query_from_query(struct wined3d_query *query)
@@ -267,6 +268,9 @@
 {
     struct wined3d_query *query = object;
 
+    if (!list_empty(&query->poll_list_entry))
+        list_remove(&query->poll_list_entry);
+
     /* Queries are specific to the GL context that created them. Not
      * deleting the query will obviously leak it, but that's still better
      * than potentially deleting a different query with the same id in this
@@ -330,9 +334,24 @@
     }
 
     if (query->state == QUERY_CREATED)
+    {
         WARN("Query wasn't started yet.\n");
-    else if (!query->query_ops->query_poll(query, flags))
-        return S_FALSE;
+    }
+    else if (!wined3d_use_csmt(query->device))
+    {
+        if (!query->query_ops->query_poll(query, flags))
+            return S_FALSE;
+    }
+    else
+    {
+        /* FIXME: Maybe InterlockedOr would be nicer here but it's not
+         * available in current Wine...
+         * Otherwise we could send a packet to the CS to ask for a flush if
+         * flags contains WINED3DGETDATA_FLUSH. */
+        InterlockedExchange((LONG *)&query->flags, flags);
+        if (query->counter_main != query->counter_retrieved)
+            return S_FALSE;
+    }
 
     if (data)
         memcpy(data, query->data, min(data_size, query->data_size));
@@ -351,6 +370,9 @@
 {
     TRACE("query %p, flags %#x.\n", query, flags);
 
+    if (flags & WINED3DISSUE_END)
+        ++query->counter_main;
+
     wined3d_cs_emit_query_issue(query->device->cs, query, flags);
 
     if (flags & WINED3DISSUE_BEGIN)
@@ -454,7 +476,7 @@
     return query->type;
 }
 
-static void wined3d_event_query_ops_issue(struct wined3d_query *query, DWORD flags)
+static BOOL wined3d_event_query_ops_issue(struct wined3d_query *query, DWORD flags)
 {
     TRACE("query %p, flags %#x.\n", query, flags);
 
@@ -463,20 +485,24 @@
         struct wined3d_event_query *event_query = wined3d_event_query_from_query(query);
 
         wined3d_event_query_issue(event_query, query->device);
+        return TRUE;
     }
     else if (flags & WINED3DISSUE_BEGIN)
     {
         /* Started implicitly at query creation. */
         ERR("Event query issued with START flag - what to do?\n");
     }
+
+    return FALSE;
 }
 
-static void wined3d_occlusion_query_ops_issue(struct wined3d_query *query, DWORD flags)
+static BOOL wined3d_occlusion_query_ops_issue(struct wined3d_query *query, DWORD flags)
 {
     struct wined3d_occlusion_query *oq = wined3d_occlusion_query_from_query(query);
     struct wined3d_device *device = query->device;
     const struct wined3d_gl_info *gl_info = &device->adapter->gl_info;
     struct wined3d_context *context;
+    BOOL poll = FALSE;
 
     TRACE("query %p, flags %#x.\n", query, flags);
 
@@ -484,7 +510,7 @@
      * restart. */
     if (flags & WINED3DISSUE_BEGIN)
     {
-        if (query->state == QUERY_BUILDING)
+        if (oq->started)
         {
             if (oq->context->tid != GetCurrentThreadId())
             {
@@ -514,13 +540,14 @@
         checkGLcall("glBeginQuery()");
 
         context_release(context);
+        oq->started = TRUE;
     }
     if (flags & WINED3DISSUE_END)
     {
         /* MSDN says END on a non-building occlusion query returns an error,
          * but our tests show that it returns OK. But OpenGL doesn't like it,
          * so avoid generating an error. */
-        if (query->state == QUERY_BUILDING)
+        if (oq->started)
         {
             if (oq->context->tid != GetCurrentThreadId())
             {
@@ -534,9 +561,13 @@
                 checkGLcall("glEndQuery()");
 
                 context_release(context);
+                poll = TRUE;
             }
         }
+        oq->started = FALSE;
     }
+
+    return poll;
 }
 
 static BOOL wined3d_timestamp_query_ops_poll(struct wined3d_query *query, DWORD flags)
@@ -577,7 +608,7 @@
     return available;
 }
 
-static void wined3d_timestamp_query_ops_issue(struct wined3d_query *query, DWORD flags)
+static BOOL wined3d_timestamp_query_ops_issue(struct wined3d_query *query, DWORD flags)
 {
     struct wined3d_timestamp_query *tq = wined3d_timestamp_query_from_query(query);
     const struct wined3d_gl_info *gl_info;
@@ -599,7 +630,11 @@
         GL_EXTCALL(glQueryCounter(tq->id, GL_TIMESTAMP));
         checkGLcall("glQueryCounter()");
         context_release(context);
+
+        return TRUE;
     }
+
+    return FALSE;
 }
 
 static BOOL wined3d_timestamp_disjoint_query_ops_poll(struct wined3d_query *query, DWORD flags)
@@ -609,9 +644,11 @@
     return TRUE;
 }
 
-static void wined3d_timestamp_disjoint_query_ops_issue(struct wined3d_query *query, DWORD flags)
+static BOOL wined3d_timestamp_disjoint_query_ops_issue(struct wined3d_query *query, DWORD flags)
 {
     TRACE("query %p, flags %#x.\n", query, flags);
+
+    return FALSE;
 }
 
 static const struct wined3d_query_ops event_query_ops =
diff -Naur wine-2.0a/dlls/wined3d/resource.c wine-2.0b/dlls/wined3d/resource.c
--- wine-2.0a/dlls/wined3d/resource.c	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/wined3d/resource.c	2017-07-11 20:37:51.000000000 +0100
@@ -210,6 +210,7 @@
             ERR("Failed to allocate system memory.\n");
             return E_OUTOFMEMORY;
         }
+        resource->heap_memory = resource->map_heap_memory;
     }
     else
     {
@@ -238,6 +239,7 @@
     struct wined3d_resource *resource = object;
 
     wined3d_resource_free_sysmem(resource);
+    resource->map_heap_memory = NULL;
     context_resource_released(resource->device, resource, resource->type);
     wined3d_resource_release(resource);
 }
@@ -351,19 +353,111 @@
             resource, sub_resource_idx, map_desc, debug_box(box), flags);
 
     flags = wined3d_resource_sanitise_map_flags(resource, flags);
+    if (resource->type != WINED3D_RTYPE_BUFFER && (flags & WINED3D_MAP_DISCARD))
+    {
+        switch (resource->map_binding)
+        {
+            case WINED3D_LOCATION_BUFFER:
+            case WINED3D_LOCATION_SYSMEM:
+                break;
+
+            default:
+                FIXME("Implement discard maps with %s map binding.\n",
+                        wined3d_debug_location(resource->map_binding));
+                wined3d_resource_wait_idle(resource);
+        }
+    }
+    else if (resource->type != WINED3D_RTYPE_BUFFER
+            || !(flags & (WINED3D_MAP_NOOVERWRITE | WINED3D_MAP_DISCARD)))
+    {
+        wined3d_resource_wait_idle(resource);
+    }
+
+    if (resource->type == WINED3D_RTYPE_BUFFER)
+    {
+        struct wined3d_buffer *buffer = buffer_from_resource(resource);
+
+        if (buffer->flags & WINED3D_BUFFER_DOUBLEBUFFER)
+            return resource->resource_ops->resource_sub_resource_map(resource,
+                    sub_resource_idx, map_desc, box, flags);
+    }
+    else
+    {
+        struct wined3d_texture *texture = texture_from_resource(resource);
+        struct wined3d_texture_sub_resource *sub_resource =
+                wined3d_texture_get_sub_resource(texture, sub_resource_idx);
+
+        if (!(flags & WINED3D_MAP_READONLY))
+            sub_resource->unmap_dirtify = TRUE;
+
+        if (texture->flags & WINED3D_TEXTURE_PIN_SYSMEM && ((flags & WINED3D_MAP_DISCARD)
+                || (sub_resource->locations & texture->resource.map_binding)))
+            return resource->resource_ops->resource_sub_resource_map(resource,
+                    sub_resource_idx, map_desc, box, flags);
+    }
 
     return wined3d_cs_map(resource->device->cs, resource, sub_resource_idx, map_desc, box, flags);
 }
 
 HRESULT CDECL wined3d_resource_unmap(struct wined3d_resource *resource, unsigned int sub_resource_idx)
 {
+    HRESULT hr;
+
     TRACE("resource %p, sub_resource_idx %u.\n", resource, sub_resource_idx);
 
-    return wined3d_cs_unmap(resource->device->cs, resource, sub_resource_idx);
+    if (resource->type == WINED3D_RTYPE_BUFFER)
+    {
+        struct wined3d_buffer *buffer = buffer_from_resource(resource);
+
+        if (buffer->flags & WINED3D_BUFFER_DOUBLEBUFFER)
+            return resource->resource_ops->resource_sub_resource_unmap(resource, sub_resource_idx);
+    }
+    else
+    {
+        struct wined3d_texture *texture = texture_from_resource(resource);
+        struct wined3d_texture_sub_resource *sub_resource = wined3d_texture_get_sub_resource(texture, sub_resource_idx);
+
+        if (texture->flags & WINED3D_TEXTURE_PIN_SYSMEM)
+        {
+            hr = resource->resource_ops->resource_sub_resource_unmap(resource, sub_resource_idx);
+
+            if (sub_resource->unmap_dirtify)
+            {
+                wined3d_cs_emit_texture_changed(texture->resource.device->cs, texture,
+                        sub_resource_idx, sub_resource->map_buffer, resource->map_heap_memory);
+                sub_resource->unmap_dirtify = FALSE;
+            }
+            return hr;
+        }
+    }
+
+    hr = wined3d_cs_unmap(resource->device->cs, resource, sub_resource_idx);
+
+    if (SUCCEEDED(hr) && resource->type != WINED3D_RTYPE_BUFFER)
+    {
+        struct wined3d_texture *texture = texture_from_resource(resource);
+        struct wined3d_texture_sub_resource *sub_resource =
+                wined3d_texture_get_sub_resource(texture, sub_resource_idx);
+
+        if (sub_resource->unmap_dirtify)
+        {
+            wined3d_cs_emit_texture_changed(texture->resource.device->cs, texture,
+                    sub_resource_idx, sub_resource->map_buffer, resource->map_heap_memory);
+            sub_resource->unmap_dirtify = FALSE;
+        }
+    }
+
+    return hr;
 }
 
 void CDECL wined3d_resource_preload(struct wined3d_resource *resource)
 {
+    if (resource->type == WINED3D_RTYPE_BUFFER && resource->map_count)
+    {
+        WARN("Buffer is mapped, skipping preload.\n");
+        return;
+    }
+
     wined3d_cs_emit_preload_resource(resource->device->cs, resource);
 }
 
@@ -379,7 +473,7 @@
     p = (void **)(((ULONG_PTR)mem + align) & ~(RESOURCE_ALIGNMENT - 1)) - 1;
     *p = mem;
 
-    resource->heap_memory = ++p;
+    resource->map_heap_memory = ++p;
 
     return TRUE;
 }
diff -Naur wine-2.0a/dlls/wined3d/sampler.c wine-2.0b/dlls/wined3d/sampler.c
--- wine-2.0a/dlls/wined3d/sampler.c	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/wined3d/sampler.c	2017-07-11 20:37:51.000000000 +0100
@@ -66,43 +66,37 @@
     return sampler->parent;
 }
 
-static void wined3d_sampler_init(struct wined3d_sampler *sampler, struct wined3d_device *device,
-        const struct wined3d_sampler_desc *desc, void *parent)
+void wined3d_sampler_init(struct wined3d_sampler *sampler)
 {
     const struct wined3d_gl_info *gl_info;
     struct wined3d_context *context;
 
-    sampler->refcount = 1;
-    sampler->device = device;
-    sampler->parent = parent;
-    sampler->desc = *desc;
-
-    context = context_acquire(device, NULL);
+    context = context_acquire(sampler->device, NULL);
     gl_info = context->gl_info;
 
     GL_EXTCALL(glGenSamplers(1, &sampler->name));
     GL_EXTCALL(glSamplerParameteri(sampler->name, GL_TEXTURE_WRAP_S,
-            gl_info->wrap_lookup[desc->address_u - WINED3D_TADDRESS_WRAP]));
+            gl_info->wrap_lookup[sampler->desc.address_u - WINED3D_TADDRESS_WRAP]));
     GL_EXTCALL(glSamplerParameteri(sampler->name, GL_TEXTURE_WRAP_T,
-            gl_info->wrap_lookup[desc->address_v - WINED3D_TADDRESS_WRAP]));
+            gl_info->wrap_lookup[sampler->desc.address_v - WINED3D_TADDRESS_WRAP]));
     GL_EXTCALL(glSamplerParameteri(sampler->name, GL_TEXTURE_WRAP_R,
-            gl_info->wrap_lookup[desc->address_w - WINED3D_TADDRESS_WRAP]));
-    GL_EXTCALL(glSamplerParameterfv(sampler->name, GL_TEXTURE_BORDER_COLOR, &desc->border_color[0]));
+            gl_info->wrap_lookup[sampler->desc.address_w - WINED3D_TADDRESS_WRAP]));
+    GL_EXTCALL(glSamplerParameterfv(sampler->name, GL_TEXTURE_BORDER_COLOR, &sampler->desc.border_color[0]));
     GL_EXTCALL(glSamplerParameteri(sampler->name, GL_TEXTURE_MAG_FILTER,
-            wined3d_gl_mag_filter(desc->mag_filter)));
+            wined3d_gl_mag_filter(sampler->desc.mag_filter)));
     GL_EXTCALL(glSamplerParameteri(sampler->name, GL_TEXTURE_MIN_FILTER,
-            wined3d_gl_min_mip_filter(desc->min_filter, desc->mip_filter)));
-    GL_EXTCALL(glSamplerParameterf(sampler->name, GL_TEXTURE_LOD_BIAS, desc->lod_bias));
-    GL_EXTCALL(glSamplerParameterf(sampler->name, GL_TEXTURE_MIN_LOD, desc->min_lod));
-    GL_EXTCALL(glSamplerParameterf(sampler->name, GL_TEXTURE_MAX_LOD, desc->max_lod));
+            wined3d_gl_min_mip_filter(sampler->desc.min_filter, sampler->desc.mip_filter)));
+    GL_EXTCALL(glSamplerParameterf(sampler->name, GL_TEXTURE_LOD_BIAS, sampler->desc.lod_bias));
+    GL_EXTCALL(glSamplerParameterf(sampler->name, GL_TEXTURE_MIN_LOD, sampler->desc.min_lod));
+    GL_EXTCALL(glSamplerParameterf(sampler->name, GL_TEXTURE_MAX_LOD, sampler->desc.max_lod));
     if (gl_info->supported[EXT_TEXTURE_FILTER_ANISOTROPIC])
-        GL_EXTCALL(glSamplerParameteri(sampler->name, GL_TEXTURE_MAX_ANISOTROPY_EXT, desc->max_anisotropy));
-    if (desc->compare)
+        GL_EXTCALL(glSamplerParameteri(sampler->name, GL_TEXTURE_MAX_ANISOTROPY_EXT, sampler->desc.max_anisotropy));
+    if (sampler->desc.compare)
         GL_EXTCALL(glSamplerParameteri(sampler->name, GL_TEXTURE_COMPARE_MODE, GL_COMPARE_R_TO_TEXTURE));
     GL_EXTCALL(glSamplerParameteri(sampler->name, GL_TEXTURE_COMPARE_FUNC,
-            wined3d_gl_compare_func(desc->comparison_func)));
+            wined3d_gl_compare_func(sampler->desc.comparison_func)));
     if ((context->d3d_info->wined3d_creation_flags & WINED3D_SRGB_READ_WRITE_CONTROL)
-            && gl_info->supported[EXT_TEXTURE_SRGB_DECODE] && !desc->srgb_decode)
+            && gl_info->supported[EXT_TEXTURE_SRGB_DECODE] && !sampler->desc.srgb_decode)
         GL_EXTCALL(glSamplerParameteri(sampler->name, GL_TEXTURE_SRGB_DECODE_EXT, GL_SKIP_DECODE_EXT));
     checkGLcall("sampler creation");
 
@@ -112,7 +106,7 @@
 }
 
 HRESULT CDECL wined3d_sampler_create(struct wined3d_device *device, const struct wined3d_sampler_desc *desc,
-        void *parent, struct wined3d_sampler **sampler)
+        void *parent, struct wined3d_sampler **sampler, BOOL from_cs)
 {
     struct wined3d_sampler *object;
 
@@ -134,7 +128,14 @@
     if (!(object = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(*object))))
         return E_OUTOFMEMORY;
 
-    wined3d_sampler_init(object, device, desc, parent);
+    object->refcount = 1;
+    object->device = device;
+    object->parent = parent;
+    object->desc = *desc;
+    if (from_cs)
+        wined3d_sampler_init(object);
+    else
+        wined3d_cs_emit_sampler_init(device->cs, object);
 
     TRACE("Created sampler %p.\n", object);
     *sampler = object;
diff -Naur wine-2.0a/dlls/wined3d/shader.c wine-2.0b/dlls/wined3d/shader.c
--- wine-2.0a/dlls/wined3d/shader.c	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/wined3d/shader.c	2017-07-11 20:37:51.000000000 +0100
@@ -3379,6 +3379,16 @@
             args->fog = WINED3D_FFP_PS_FOG_OFF;
         }
     }
+    /* Only inser the KIL fragment.texcoord[clip] line if clipping is used.
+     * It is expensive because KIL can break early Z discard. Its cheaper to
+     * have two shaders than KIL needlessly. The same applies to the
+     * clipplane emulation in GLSL with discard. */
+    if (!shader->device->adapter->d3d_info.vs_clipping && use_vs(state)
+            && state->render_states[WINED3D_RS_CLIPPING]
+            && state->render_states[WINED3D_RS_CLIPPLANEENABLE])
+    {
+        args->clip = TRUE;
+    }
 
     if (context->d3d_info->limits.varying_count < wined3d_max_compat_varyings(context->gl_info))
     {
diff -Naur wine-2.0a/dlls/wined3d/stateblock.c wine-2.0b/dlls/wined3d/stateblock.c
--- wine-2.0a/dlls/wined3d/stateblock.c	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/wined3d/stateblock.c	2017-07-11 20:37:51.000000000 +0100
@@ -991,8 +991,8 @@
         gl_primitive_type = stateblock->state.gl_primitive_type;
         prev = device->update_state->gl_primitive_type;
         device->update_state->gl_primitive_type = gl_primitive_type;
-        if (gl_primitive_type != prev && (gl_primitive_type == GL_POINTS || prev == GL_POINTS))
-            device_invalidate_state(device, STATE_POINT_ENABLE);
+        if (gl_primitive_type != prev)
+            wined3d_cs_emit_set_primitive_type(device->cs, gl_primitive_type);
     }
 
     if (stateblock->changed.indices)
diff -Naur wine-2.0a/dlls/wined3d/state.c wine-2.0b/dlls/wined3d/state.c
--- wine-2.0a/dlls/wined3d/state.c	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/wined3d/state.c	2017-07-11 20:37:51.000000000 +0100
@@ -612,7 +612,8 @@
     unsigned int clipplane_count = gl_info->limits.user_clip_distances;
     unsigned int i, enable_mask, disable_mask;
 
-    if (use_vs(state) && !context->d3d_info->vs_clipping)
+    if (use_vs(state) && !context->d3d_info->vs_clipping
+            && !(gl_info->quirks & WINED3D_CX_QUIRK_GLSL_CLIP_BROKEN))
     {
         static BOOL warned;
 
@@ -632,6 +633,9 @@
      * shader to update the enabled clipplanes. In case of fixed function, we
      * need to update the clipping field from ffp_vertex_settings. */
     context->shader_update_mask |= 1u << WINED3D_SHADER_TYPE_VERTEX;
+    /* If we are emulating user clip planes, in general we have to regenerate the PS. */
+    if (gl_info->quirks & WINED3D_CX_QUIRK_GLSL_CLIP_BROKEN)
+        context->shader_update_mask |= 1u << WINED3D_SHADER_TYPE_PIXEL;
 
     /* TODO: Keep track of previously enabled clipplanes to avoid unnecessary resetting
      * of already set values
@@ -3630,7 +3634,7 @@
             }
             else
             {
-                if (FAILED(wined3d_sampler_create(device, &desc, NULL, &sampler)))
+                if (FAILED(wined3d_sampler_create(device, &desc, NULL, &sampler, TRUE)))
                 {
                     ERR("Failed to create sampler.\n");
                     sampler = NULL;
diff -Naur wine-2.0a/dlls/wined3d/surface.c wine-2.0b/dlls/wined3d/surface.c
--- wine-2.0a/dlls/wined3d/surface.c	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/wined3d/surface.c	2017-07-11 20:37:51.000000000 +0100
@@ -284,7 +284,7 @@
         gl_info = context->gl_info;
     }
 
-    wined3d_texture_get_memory(texture, sub_resource_idx, &data, texture->resource.map_binding);
+    wined3d_texture_get_memory(texture, sub_resource_idx, &data, texture->resource.map_binding, FALSE);
     wined3d_texture_unmap_bo_address(&data, gl_info, GL_PIXEL_UNPACK_BUFFER);
 
     if (context)
@@ -320,7 +320,7 @@
         gl_info = context->gl_info;
     }
 
-    wined3d_texture_get_memory(texture, sub_resource_idx, &data, texture->resource.map_binding);
+    wined3d_texture_get_memory(texture, sub_resource_idx, &data, texture->resource.map_binding, FALSE);
     desc.pMemory = wined3d_texture_map_bo_address(&data, texture->sub_resources[sub_resource_idx].size,
             gl_info, GL_PIXEL_UNPACK_BUFFER, 0);
 
@@ -461,6 +461,26 @@
     context_release(context);
 }
 
+static void prepare_blit_quirks(const struct wined3d_device *device, const struct wined3d_gl_info *gl_info)
+{
+    /* ATI Macs blend blits even though GL_EXT_framebuffer_blit says that this
+     * operation does not blend. This sometimes even happens if GL_BLEND is
+     * disabled, although in my glut test case blending has to be enabled for
+     * the bug to occur. While we're at it, disable blending.
+     *
+     * Tracked by crossover hacks bug 5391. */
+    gl_info->gl_ops.gl.p_glDisable(GL_BLEND);
+    gl_info->gl_ops.gl.p_glBlendFunc(GL_ONE, GL_ZERO);
+    device_invalidate_state(device, STATE_RENDER(WINED3D_RS_ALPHABLENDENABLE));
+
+    gl_info->gl_ops.gl.p_glDisable(GL_ALPHA_TEST);
+    gl_info->gl_ops.gl.p_glAlphaFunc(GL_ALWAYS, 0.0);
+    device_invalidate_state(device, STATE_RENDER(WINED3D_RS_ALPHATESTENABLE));
+    gl_info->gl_ops.gl.p_glDisable(GL_STENCIL_TEST);
+    gl_info->gl_ops.gl.p_glStencilFunc(GL_ALWAYS, 0, 0);
+    device_invalidate_state(device, STATE_RENDER(WINED3D_RS_STENCILENABLE));
+}
+
 /* Blit between surface locations. Onscreen on different swapchains is not supported.
  * Depth / stencil is not supported. Context activation is done by the caller. */
 static void surface_blt_fbo(const struct wined3d_device *device,
@@ -582,11 +602,15 @@
     gl_info->gl_ops.gl.p_glDisable(GL_SCISSOR_TEST);
     context_invalidate_state(context, STATE_RENDER(WINED3D_RS_SCISSORTESTENABLE));
 
+    if (gl_info->quirks & WINED3D_CX_QUIRK_BLIT)
+        prepare_blit_quirks(device, gl_info);
+
     gl_info->fbo_ops.glBlitFramebuffer(src_rect.left, src_rect.top, src_rect.right, src_rect.bottom,
             dst_rect.left, dst_rect.top, dst_rect.right, dst_rect.bottom, GL_COLOR_BUFFER_BIT, gl_filter);
     checkGLcall("glBlitFramebuffer()");
 
-    if (wined3d_settings.strict_draw_ordering || (dst_location == WINED3D_LOCATION_DRAWABLE
+    if (wined3d_settings.strict_draw_ordering
+            || (dst_location == WINED3D_LOCATION_DRAWABLE
             && dst_texture->swapchain->front_buffer == dst_texture))
         gl_info->gl_ops.gl.p_glFlush();
 
@@ -675,8 +699,7 @@
 {
     struct wined3d_resource *resource = &surface->container->resource;
     struct wined3d_device *device = resource->device;
-    struct wined3d_rendertarget_view *view;
-    struct wined3d_view_desc view_desc;
+    struct wined3d_rendertarget_view view;
     const struct blit_shader *blitter;
     HRESULT hr;
 
@@ -687,21 +710,18 @@
         return WINED3DERR_INVALIDCALL;
     }
 
-    view_desc.format_id = resource->format->id;
-    view_desc.flags = 0;
-    view_desc.u.texture.level_idx = surface->texture_level;
-    view_desc.u.texture.level_count = 1;
-    view_desc.u.texture.layer_idx = surface->texture_layer;
-    view_desc.u.texture.layer_count = 1;
-    if (FAILED(hr = wined3d_rendertarget_view_create(&view_desc,
-            resource, NULL, &wined3d_null_parent_ops, &view)))
-    {
-        ERR("Failed to create rendertarget view, hr %#x.\n", hr);
-        return hr;
-    }
+    view.resource = resource;
+    view.parent = NULL;
+    view.parent_ops = &wined3d_null_parent_ops;
+    view.format = resource->format;
+    view.format_flags = resource->format_flags;
+    view.sub_resource_idx = surface->texture_layer * surface->container->level_count + surface->texture_level;
+    view.buffer_offset = 0;
+    view.width = wined3d_texture_get_level_width(surface->container, surface->texture_level);
+    view.height = wined3d_texture_get_level_height(surface->container, surface->texture_level);;
+    view.depth = 1;
 
-    hr = blitter->depth_fill(device, view, rect, WINED3DCLEAR_ZBUFFER, depth, 0);
-    wined3d_rendertarget_view_decref(view);
+    hr = blitter->depth_fill(device, &view, rect, WINED3DCLEAR_ZBUFFER, depth, 0);
 
     return hr;
 }
@@ -766,7 +786,7 @@
         }
     }
 
-    wined3d_texture_get_memory(texture, sub_resource_idx, &data, dst_location);
+    wined3d_texture_get_memory(texture, sub_resource_idx, &data, dst_location, FALSE);
 
     if (texture->flags & WINED3D_TEXTURE_COND_NP2_EMULATED)
     {
@@ -1163,7 +1183,7 @@
     wined3d_texture_bind_and_dirtify(dst_texture, context, FALSE);
 
     wined3d_texture_get_memory(src_texture, src_sub_resource_idx, &data,
-            src_texture->sub_resources[src_sub_resource_idx].locations);
+            src_texture->sub_resources[src_sub_resource_idx].locations, FALSE);
     wined3d_texture_get_pitch(src_texture, src_surface->texture_level, &src_row_pitch, &src_slice_pitch);
 
     wined3d_surface_upload_data(dst_surface, gl_info, src_format, src_rect,
@@ -1672,7 +1692,7 @@
     BOOL srcIsUpsideDown;
     struct wined3d_bo_address data;
 
-    wined3d_texture_get_memory(texture, sub_resource_idx, &data, dst_location);
+    wined3d_texture_get_memory(texture, sub_resource_idx, &data, dst_location, FALSE);
 
     restore_rt = context_get_rt_surface(old_ctx);
     if (restore_rt != surface)
@@ -1904,6 +1924,12 @@
                  */
                 LONG col;
 
+                if (!cxgames_hacks.enable_slow_blit)
+                {
+                    ERR("Slow pixel per pixel copy disabled, aborting.\n");
+                    break;
+                }
+
                 for (col = dst_rect.left; col < dst_rect.right; ++col)
                 {
                     gl_info->gl_ops.gl.p_glCopyTexSubImage2D(dst_surface->texture_target, dst_surface->texture_level,
@@ -2199,7 +2225,9 @@
         checkGLcall("glDeleteTextures(1, &backup)");
     }
 
-    if (wined3d_settings.strict_draw_ordering)
+    if (wined3d_use_csmt(device))
+        gl_info->gl_ops.gl.p_glFinish();
+    else if (wined3d_settings.strict_draw_ordering)
         gl_info->gl_ops.gl.p_glFlush(); /* Flush to ensure ordering across contexts. */
 
     context_release(context);
@@ -2265,7 +2293,7 @@
     gl_info = context->gl_info;
 
     /* Make sure the surface is up-to-date. This should probably use
-     * surface_load_location() and worry about the destination surface too,
+     * wined3d_texture_load_location() and worry about the destination surface too,
      * unless we're overwriting it completely. */
     wined3d_texture_load(src_texture, context, FALSE);
 
@@ -2309,8 +2337,11 @@
     /* Leave the opengl state valid for blitting */
     device->blitter->unset_shader(context->gl_info);
 
-    if (wined3d_settings.strict_draw_ordering
-            || (dst_texture->swapchain && dst_texture->swapchain->front_buffer == dst_texture))
+    if (wined3d_use_csmt(device))
+        gl_info->gl_ops.gl.p_glFinish();
+    else if (wined3d_settings.strict_draw_ordering
+            || (dst_texture->swapchain
+            && dst_texture->swapchain->front_buffer == dst_texture))
         gl_info->gl_ops.gl.p_glFlush(); /* Flush to ensure ordering across contexts. */
 
     if (restore_rt)
@@ -2321,8 +2352,7 @@
 {
     struct wined3d_resource *resource = &s->container->resource;
     struct wined3d_device *device = resource->device;
-    struct wined3d_rendertarget_view *view;
-    struct wined3d_view_desc view_desc;
+    struct wined3d_rendertarget_view view;
     const struct blit_shader *blitter;
     HRESULT hr;
 
@@ -2333,21 +2363,18 @@
         return WINED3DERR_INVALIDCALL;
     }
 
-    view_desc.format_id = resource->format->id;
-    view_desc.flags = 0;
-    view_desc.u.texture.level_idx = s->texture_level;
-    view_desc.u.texture.level_count = 1;
-    view_desc.u.texture.layer_idx = s->texture_layer;
-    view_desc.u.texture.layer_count = 1;
-    if (FAILED(hr = wined3d_rendertarget_view_create(&view_desc,
-            resource, NULL, &wined3d_null_parent_ops, &view)))
-    {
-        ERR("Failed to create rendertarget view, hr %#x.\n", hr);
-        return hr;
-    }
+    view.resource = resource;
+    view.parent = NULL;
+    view.parent_ops = &wined3d_null_parent_ops;
+    view.format = resource->format;
+    view.format_flags = resource->format_flags;
+    view.sub_resource_idx = s->texture_layer * s->container->level_count + s->texture_level;
+    view.buffer_offset = 0;
+    view.width = wined3d_texture_get_level_width(s->container, s->texture_level);
+    view.height = wined3d_texture_get_level_height(s->container, s->texture_level);;
+    view.depth = 1;
 
-    hr = blitter->color_fill(device, view, rect, color);
-    wined3d_rendertarget_view_decref(view);
+    hr = blitter->color_fill(device, &view, rect, color);
 
     return hr;
 }
@@ -2659,7 +2686,9 @@
 
         context_invalidate_state(context, STATE_FRAMEBUFFER);
 
-        if (wined3d_settings.strict_draw_ordering)
+        if (wined3d_use_csmt(device))
+            gl_info->gl_ops.gl.p_glFinish();
+        else if (wined3d_settings.strict_draw_ordering)
             gl_info->gl_ops.gl.p_glFlush(); /* Flush to ensure ordering across contexts. */
     }
     else if (location == WINED3D_LOCATION_DRAWABLE)
@@ -2676,7 +2705,9 @@
 
         context_invalidate_state(context, STATE_FRAMEBUFFER);
 
-        if (wined3d_settings.strict_draw_ordering)
+        if (wined3d_use_csmt(device))
+            gl_info->gl_ops.gl.p_glFinish();
+        else if (wined3d_settings.strict_draw_ordering)
             gl_info->gl_ops.gl.p_glFlush(); /* Flush to ensure ordering across contexts. */
     }
     else
@@ -2685,67 +2716,6 @@
     }
 }
 
-static DWORD resource_access_from_location(DWORD location)
-{
-    switch (location)
-    {
-        case WINED3D_LOCATION_SYSMEM:
-        case WINED3D_LOCATION_USER_MEMORY:
-        case WINED3D_LOCATION_BUFFER:
-            return WINED3D_RESOURCE_ACCESS_CPU;
-
-        case WINED3D_LOCATION_DRAWABLE:
-        case WINED3D_LOCATION_TEXTURE_SRGB:
-        case WINED3D_LOCATION_TEXTURE_RGB:
-        case WINED3D_LOCATION_RB_MULTISAMPLE:
-        case WINED3D_LOCATION_RB_RESOLVED:
-            return WINED3D_RESOURCE_ACCESS_GPU;
-
-        default:
-            FIXME("Unhandled location %#x.\n", location);
-            return 0;
-    }
-}
-
-static void surface_copy_simple_location(struct wined3d_surface *surface, DWORD location)
-{
-    unsigned int sub_resource_idx = surface_get_sub_resource_idx(surface);
-    struct wined3d_texture *texture = surface->container;
-    struct wined3d_device *device = texture->resource.device;
-    struct wined3d_texture_sub_resource *sub_resource;
-    struct wined3d_context *context;
-    const struct wined3d_gl_info *gl_info;
-    struct wined3d_bo_address dst, src;
-
-    sub_resource = &texture->sub_resources[sub_resource_idx];
-    wined3d_texture_get_memory(texture, sub_resource_idx, &dst, location);
-    wined3d_texture_get_memory(texture, sub_resource_idx, &src, sub_resource->locations);
-
-    if (dst.buffer_object)
-    {
-        context = context_acquire(device, NULL);
-        gl_info = context->gl_info;
-        GL_EXTCALL(glBindBuffer(GL_PIXEL_UNPACK_BUFFER, dst.buffer_object));
-        GL_EXTCALL(glBufferSubData(GL_PIXEL_UNPACK_BUFFER, 0, sub_resource->size, src.addr));
-        GL_EXTCALL(glBindBuffer(GL_PIXEL_UNPACK_BUFFER, 0));
-        checkGLcall("Upload PBO");
-        context_release(context);
-        return;
-    }
-    if (src.buffer_object)
-    {
-        context = context_acquire(device, NULL);
-        gl_info = context->gl_info;
-        GL_EXTCALL(glBindBuffer(GL_PIXEL_PACK_BUFFER, src.buffer_object));
-        GL_EXTCALL(glGetBufferSubData(GL_PIXEL_PACK_BUFFER, 0, sub_resource->size, dst.addr));
-        GL_EXTCALL(glBindBuffer(GL_PIXEL_PACK_BUFFER, 0));
-        checkGLcall("Download PBO");
-        context_release(context);
-        return;
-    }
-    memcpy(dst.addr, src.addr, sub_resource->size);
-}
-
 /* Context activation is done by the caller. */
 static void surface_load_sysmem(struct wined3d_surface *surface,
         struct wined3d_context *context, DWORD dst_location)
@@ -2758,12 +2728,6 @@
     wined3d_texture_prepare_location(texture, sub_resource_idx, context, dst_location);
 
     sub_resource = &texture->sub_resources[sub_resource_idx];
-    if (sub_resource->locations & surface_simple_locations)
-    {
-        surface_copy_simple_location(surface, dst_location);
-        return;
-    }
-
     if (sub_resource->locations & (WINED3D_LOCATION_RB_MULTISAMPLE | WINED3D_LOCATION_RB_RESOLVED))
         wined3d_texture_load_location(texture, sub_resource_idx, context, WINED3D_LOCATION_TEXTURE_RGB);
 
@@ -2912,7 +2876,7 @@
     /* Don't use PBOs for converted surfaces. During PBO conversion we look at
      * WINED3D_TEXTURE_CONVERTED but it isn't set (yet) in all cases it is
      * getting called. */
-    if ((format.convert || conversion) && texture->sub_resources[sub_resource_idx].buffer_object)
+    if ((format.convert || conversion) && texture->sub_resources[sub_resource_idx].buffer)
     {
         TRACE("Removing the pbo attached to surface %p.\n", surface);
 
@@ -2920,7 +2884,7 @@
         wined3d_texture_set_map_binding(texture, WINED3D_LOCATION_SYSMEM);
     }
 
-    wined3d_texture_get_memory(texture, sub_resource_idx, &data, sub_resource->locations);
+    wined3d_texture_get_memory(texture, sub_resource_idx, &data, sub_resource->locations, FALSE);
     if (format.convert)
     {
         /* This code is entered for texture formats which need a fixup. */
@@ -3008,45 +2972,11 @@
     unsigned int sub_resource_idx = surface_get_sub_resource_idx(surface);
     struct wined3d_texture *texture = surface->container;
     struct wined3d_texture_sub_resource *sub_resource;
-    unsigned int surface_w, surface_h;
     HRESULT hr;
 
     TRACE("surface %p, location %s.\n", surface, wined3d_debug_location(location));
 
-    surface_w = wined3d_texture_get_level_width(texture, surface->texture_level);
-    surface_h = wined3d_texture_get_level_height(texture, surface->texture_level);
-
     sub_resource = &texture->sub_resources[sub_resource_idx];
-    if (sub_resource->locations & location && (!(texture->resource.usage & WINED3DUSAGE_DEPTHSTENCIL)
-            || (surface->ds_current_size.cx == surface_w && surface->ds_current_size.cy == surface_h)))
-    {
-        TRACE("Location (%#x) is already up to date.\n", location);
-        return WINED3D_OK;
-    }
-
-    if (WARN_ON(d3d))
-    {
-        DWORD required_access = resource_access_from_location(location);
-        if ((texture->resource.access_flags & required_access) != required_access)
-            WARN("Operation requires %#x access, but surface only has %#x.\n",
-                    required_access, texture->resource.access_flags);
-    }
-
-    if (sub_resource->locations & WINED3D_LOCATION_DISCARDED)
-    {
-        TRACE("Surface previously discarded, nothing to do.\n");
-        wined3d_texture_prepare_location(texture, sub_resource_idx, context, location);
-        wined3d_texture_validate_location(texture, sub_resource_idx, location);
-        wined3d_texture_invalidate_location(texture, sub_resource_idx, WINED3D_LOCATION_DISCARDED);
-        goto done;
-    }
-
-    if (!sub_resource->locations)
-    {
-        ERR("Surface %p does not have any up to date location.\n", surface);
-        wined3d_texture_validate_location(texture, sub_resource_idx, WINED3D_LOCATION_DISCARDED);
-        return surface_load_location(surface, context, location);
-    }
 
     if (texture->resource.usage & WINED3DUSAGE_DEPTHSTENCIL)
     {
@@ -3093,14 +3023,6 @@
     }
 
 done:
-    wined3d_texture_validate_location(texture, sub_resource_idx, location);
-
-    if (texture->resource.usage & WINED3DUSAGE_DEPTHSTENCIL)
-    {
-        surface->ds_current_size.cx = surface_w;
-        surface->ds_current_size.cy = surface_h;
-    }
-
     return WINED3D_OK;
 }
 
@@ -3944,7 +3866,7 @@
     cpu_blit_blit_surface,
 };
 
-HRESULT wined3d_surface_blt(struct wined3d_surface *dst_surface, const RECT *dst_rect,
+void surface_blt_ugly(struct wined3d_surface *dst_surface, const RECT *dst_rect,
         struct wined3d_surface *src_surface, const RECT *src_rect, DWORD flags,
         const struct wined3d_blt_fx *fx, enum wined3d_texture_filter_type filter)
 {
@@ -3954,9 +3876,8 @@
     struct wined3d_texture *dst_texture = dst_surface->container;
     struct wined3d_device *device = dst_texture->resource.device;
     struct wined3d_swapchain *src_swapchain, *dst_swapchain;
-    struct wined3d_texture *src_texture = NULL;
-    unsigned int dst_w, dst_h, src_w, src_h;
-    unsigned int src_sub_resource_idx = 0;
+    struct wined3d_texture *src_texture;
+    unsigned int src_sub_resource_idx;
     DWORD src_ds_flags, dst_ds_flags;
     BOOL scale, convert;
 
@@ -3969,84 +3890,17 @@
             | WINED3D_BLT_DO_NOT_WAIT
             | WINED3D_BLT_ALPHA_TEST;
 
-    TRACE("dst_surface %p, dst_rect %s, src_surface %p, src_rect %s, flags %#x, fx %p, filter %s.\n",
-            dst_surface, wine_dbgstr_rect(dst_rect), src_surface, wine_dbgstr_rect(src_rect),
-            flags, fx, debug_d3dtexturefiltertype(filter));
-    TRACE("Usage is %s.\n", debug_d3dusage(dst_texture->resource.usage));
-
-    if (fx)
-    {
-        TRACE("fx %#x.\n", fx->fx);
-        TRACE("fill_color 0x%08x.\n", fx->fill_color);
-        TRACE("dst_color_key {0x%08x, 0x%08x}.\n",
-                fx->dst_color_key.color_space_low_value,
-                fx->dst_color_key.color_space_high_value);
-        TRACE("src_color_key {0x%08x, 0x%08x}.\n",
-                fx->src_color_key.color_space_low_value,
-                fx->src_color_key.color_space_high_value);
-    }
-
     if (src_surface)
     {
         src_texture = src_surface->container;
         src_sub_resource_idx = surface_get_sub_resource_idx(src_surface);
+        src_swapchain = src_texture->swapchain;
     }
-
-    if (dst_texture->sub_resources[dst_sub_resource_idx].map_count
-            || (src_texture && src_texture->sub_resources[src_sub_resource_idx].map_count))
-    {
-        WARN("Surface is busy, returning WINEDDERR_SURFACEBUSY.\n");
-        return WINEDDERR_SURFACEBUSY;
-    }
-
-    dst_w = wined3d_texture_get_level_width(dst_texture, dst_surface->texture_level);
-    dst_h = wined3d_texture_get_level_height(dst_texture, dst_surface->texture_level);
-    if (IsRectEmpty(dst_rect) || dst_rect->left > dst_w || dst_rect->left < 0
-            || dst_rect->top > dst_h || dst_rect->top < 0
-            || dst_rect->right > dst_w || dst_rect->right < 0
-            || dst_rect->bottom > dst_h || dst_rect->bottom < 0)
-    {
-        WARN("The application gave us a bad destination rectangle.\n");
-        return WINEDDERR_INVALIDRECT;
-    }
-
-    if (src_texture)
-    {
-        src_w = wined3d_texture_get_level_width(src_texture, src_surface->texture_level);
-        src_h = wined3d_texture_get_level_height(src_texture, src_surface->texture_level);
-        if (IsRectEmpty(src_rect) || src_rect->left > src_w || src_rect->left < 0
-                || src_rect->top > src_h || src_rect->top < 0
-                || src_rect->right > src_w || src_rect->right < 0
-                || src_rect->bottom > src_h || src_rect->bottom < 0)
-        {
-            WARN("The application gave us a bad source rectangle.\n");
-            return WINEDDERR_INVALIDRECT;
-        }
-    }
-
-    if (!fx || !(fx->fx))
-        flags &= ~WINED3D_BLT_FX;
-
-    if (flags & WINED3D_BLT_WAIT)
-        flags &= ~WINED3D_BLT_WAIT;
-
-    if (flags & WINED3D_BLT_ASYNC)
-    {
-        static unsigned int once;
-
-        if (!once++)
-            FIXME("Can't handle WINED3D_BLT_ASYNC flag.\n");
-        flags &= ~WINED3D_BLT_ASYNC;
-    }
-
-    /* WINED3D_BLT_DO_NOT_WAIT appeared in DX7. */
-    if (flags & WINED3D_BLT_DO_NOT_WAIT)
+    else
     {
-        static unsigned int once;
-
-        if (!once++)
-            FIXME("Can't handle WINED3D_BLT_DO_NOT_WAIT flag.\n");
-        flags &= ~WINED3D_BLT_DO_NOT_WAIT;
+        src_texture = NULL;
+        src_sub_resource_idx = 0;
+        src_swapchain = NULL;
     }
 
     if (!device->d3d_initialized)
@@ -4071,11 +3925,6 @@
         goto fallback;
     }
 
-    if (src_texture)
-        src_swapchain = src_texture->swapchain;
-    else
-        src_swapchain = NULL;
-
     dst_swapchain = dst_texture->swapchain;
 
     /* This isn't strictly needed. FBO blits for example could deal with
@@ -4111,22 +3960,16 @@
             TRACE("Depth fill.\n");
 
             if (!surface_convert_depth_to_float(dst_surface, fx->fill_color, &depth))
-                return WINED3DERR_INVALIDCALL;
+                return;
 
             if (SUCCEEDED(wined3d_surface_depth_fill(dst_surface, dst_rect, depth)))
-                return WINED3D_OK;
+                return;
         }
         else
         {
-            if (src_ds_flags != dst_ds_flags)
-            {
-                WARN("Rejecting depth / stencil blit between incompatible formats.\n");
-                return WINED3DERR_INVALIDCALL;
-            }
-
             if (SUCCEEDED(wined3d_surface_depth_blt(src_surface, src_texture->resource.draw_binding,
                     src_rect, dst_surface, dst_texture->resource.draw_binding, dst_rect)))
-                return WINED3D_OK;
+                return;
         }
     }
     else
@@ -4139,7 +3982,15 @@
 
         /* In principle this would apply to depth blits as well, but we don't
          * implement those in the CPU blitter at the moment. */
-        if ((dst_sub_resource->locations & dst_texture->resource.map_binding)
+        /* We want to avoid CPU blits (and thus resource maps) in CSMT for
+         * texture updates if the destination texture is in SYSMEM (usually
+         * because it's just been created).
+         * Another (probably better) option would be to not allocate DEFAULT
+         * pool resources in SYSMEM at init time. */
+        TRACE("dst locations %#x, map_binding %#x.\n",
+                dst_sub_resource->locations, dst_texture->resource.map_binding);
+        if (dst_texture->resource.pool != WINED3D_POOL_DEFAULT
+                && (dst_sub_resource->locations & dst_texture->resource.map_binding)
                 && (!src_texture || (src_sub_resource->locations & src_texture->resource.map_binding)))
         {
             if (scale)
@@ -4162,7 +4013,7 @@
                 goto fallback;
 
             if (SUCCEEDED(surface_color_fill(dst_surface, dst_rect, &color)))
-                return WINED3D_OK;
+                return;
         }
         else
         {
@@ -4185,7 +4036,7 @@
                 blit_op = WINED3D_BLIT_OP_COLOR_BLIT_ALPHATEST;
             }
             else if ((src_sub_resource->locations & WINED3D_LOCATION_SYSMEM)
-                    && !(dst_sub_resource->locations & WINED3D_LOCATION_SYSMEM))
+                    && dst_texture->resource.pool != WINED3D_POOL_SYSTEM_MEM)
             {
                 /* Upload */
                 if (scale)
@@ -4205,7 +4056,7 @@
                                     context, dst_texture->resource.draw_binding);
                             context_release(context);
                         }
-                        return WINED3D_OK;
+                        return;
                     }
                 }
             }
@@ -4229,7 +4080,7 @@
                 wined3d_swapchain_present(dst_swapchain, NULL, NULL, dst_swapchain->win_handle, 0);
                 dst_swapchain->desc.swap_effect = swap_effect;
 
-                return WINED3D_OK;
+                return;
             }
 
             if (fbo_blit_supported(&device->adapter->gl_info, blit_op,
@@ -4250,7 +4101,7 @@
                 wined3d_texture_invalidate_location(dst_texture, dst_sub_resource_idx,
                         ~dst_texture->resource.draw_binding);
 
-                return WINED3D_OK;
+                return;
             }
 
             blitter = wined3d_select_blitter(&device->adapter->gl_info, &device->adapter->d3d_info, blit_op,
@@ -4260,7 +4111,7 @@
             {
                 blitter->blit_surface(device, blit_op, filter, src_surface,
                         src_rect, dst_surface, dst_rect, color_key);
-                return WINED3D_OK;
+                return;
             }
         }
     }
@@ -4268,9 +4119,140 @@
 fallback:
     /* Special cases for render targets. */
     if (SUCCEEDED(surface_blt_special(dst_surface, dst_rect, src_surface, src_rect, flags, fx, filter)))
-        return WINED3D_OK;
+        return;
 
 cpu:
-    return surface_cpu_blt(dst_texture, dst_sub_resource_idx, &dst_box,
+    surface_cpu_blt(dst_texture, dst_sub_resource_idx, &dst_box,
             src_texture, src_sub_resource_idx, &src_box, flags, fx, filter);
+    return;
+}
+
+HRESULT wined3d_surface_blt(struct wined3d_surface *dst_surface, const RECT *dst_rect,
+        struct wined3d_surface *src_surface, const RECT *src_rect, DWORD flags,
+        const struct wined3d_blt_fx *fx, enum wined3d_texture_filter_type filter)
+{
+    struct wined3d_texture *dst_texture = dst_surface->container;
+    struct wined3d_device *device = dst_texture->resource.device;
+    unsigned int dst_sub_resource_idx = surface_get_sub_resource_idx(dst_surface), src_sub_resource_idx;
+    struct wined3d_texture_sub_resource *dst_sub_resource =
+            &dst_texture->sub_resources[dst_sub_resource_idx];
+    struct wined3d_texture_sub_resource *src_sub_resource = NULL;
+    unsigned int dst_w, dst_h, src_w, src_h;
+
+    TRACE("dst_surface %p, dst_rect %s, src_surface %p, src_rect %s, flags %#x, fx %p, filter %s.\n",
+            dst_surface, wine_dbgstr_rect(dst_rect), src_surface, wine_dbgstr_rect(src_rect),
+            flags, fx, debug_d3dtexturefiltertype(filter));
+    TRACE("Usage is %s.\n", debug_d3dusage(dst_texture->resource.usage));
+
+    if (fx)
+    {
+        TRACE("fx %#x.\n", fx->fx);
+        TRACE("fill_color 0x%08x.\n", fx->fill_color);
+        TRACE("dst_color_key {0x%08x, 0x%08x}.\n",
+                fx->dst_color_key.color_space_low_value,
+                fx->dst_color_key.color_space_high_value);
+        TRACE("src_color_key {0x%08x, 0x%08x}.\n",
+                fx->src_color_key.color_space_low_value,
+                fx->src_color_key.color_space_high_value);
+    }
+
+    if (src_surface)
+    {
+        src_sub_resource_idx = surface_get_sub_resource_idx(src_surface);
+        src_sub_resource = &src_surface->container->sub_resources[src_sub_resource_idx];
+    }
+
+    if (dst_sub_resource->map_count || (src_sub_resource && src_sub_resource->map_count))
+    {
+        /* TODO: Separate application maps from internal maps */
+        if (!wined3d_use_csmt(device))
+        {
+            WARN("Surface is busy, returning WINEDDERR_SURFACEBUSY.\n");
+            return WINEDDERR_SURFACEBUSY;
+        }
+
+        wined3d_cs_emit_glfinish(device->cs);
+        device->cs->ops->finish(device->cs);
+
+        if (dst_sub_resource->map_count || (src_sub_resource && src_sub_resource->map_count))
+        {
+            WARN("Surface is busy, returning WINEDDERR_SURFACEBUSY.\n");
+            return WINEDDERR_SURFACEBUSY;
+        }
+    }
+
+    dst_w = wined3d_texture_get_level_width(dst_texture, dst_surface->texture_level);
+    dst_h = wined3d_texture_get_level_height(dst_texture, dst_surface->texture_level);
+    if (IsRectEmpty(dst_rect) || dst_rect->left > dst_w || dst_rect->left < 0
+            || dst_rect->top > dst_h || dst_rect->top < 0
+            || dst_rect->right > dst_w || dst_rect->right < 0
+            || dst_rect->bottom > dst_h || dst_rect->bottom < 0)
+    {
+        WARN("The application gave us a bad destination rectangle.\n");
+        return WINEDDERR_INVALIDRECT;
+    }
+
+    if (src_surface)
+    {
+        DWORD src_ds_flags, dst_ds_flags;
+
+        src_w = wined3d_texture_get_level_width(src_surface->container, src_surface->texture_level);
+        src_h = wined3d_texture_get_level_height(src_surface->container, src_surface->texture_level);
+        if (IsRectEmpty(src_rect) || src_rect->left > src_w || src_rect->left < 0
+                || src_rect->top > src_h || src_rect->top < 0
+                || src_rect->right > src_w || src_rect->right < 0
+                || src_rect->bottom > src_h || src_rect->bottom < 0)
+        {
+            WARN("The application gave us a bad source rectangle.\n");
+            return WINEDDERR_INVALIDRECT;
+        }
+
+        dst_ds_flags = dst_texture->resource.format_flags
+                & (WINED3DFMT_FLAG_DEPTH | WINED3DFMT_FLAG_STENCIL);
+        src_ds_flags = src_surface->container->resource.format_flags
+                & (WINED3DFMT_FLAG_DEPTH | WINED3DFMT_FLAG_STENCIL);
+        if (src_ds_flags != dst_ds_flags)
+        {
+            WARN("Rejecting depth / stencil blit between incompatible formats.\n");
+            return WINED3DERR_INVALIDCALL;
+        }
+    }
+
+    /* FIXME: We should select the blitter in the main thread, that way we can return an error if the blit
+     * is unsupported without duplicating all the checks... */
+    if (flags & WINED3D_BLT_COLOR_FILL && (dst_surface->container->resource.format_flags & WINED3DFMT_FLAG_BLOCKS))
+    {
+        WARN("Block color fill, returning WINED3DERR_INVALIDCALL\n");
+        return WINED3DERR_INVALIDCALL;
+    }
+
+    if (!fx || !(fx->fx))
+        flags &= ~WINED3D_BLT_FX;
+
+    if (flags & WINED3D_BLT_WAIT)
+        flags &= ~WINED3D_BLT_WAIT;
+
+    if (flags & WINED3D_BLT_ASYNC)
+    {
+        static unsigned int once;
+
+        if (!once++)
+            FIXME("Can't handle WINED3D_BLT_ASYNC flag.\n");
+        flags &= ~WINED3D_BLT_ASYNC;
+    }
+
+    /* WINED3D_BLT_DO_NOT_WAIT appeared in DX7. */
+    if (flags & WINED3D_BLT_DO_NOT_WAIT)
+    {
+        static unsigned int once;
+
+        if (!once++)
+            FIXME("Can't handle WINED3D_BLT_DO_NOT_WAIT flag.\n");
+        flags &= ~WINED3D_BLT_DO_NOT_WAIT;
+    }
+
+    TRACE("Emitting blit %p <== %p\n", dst_surface, src_surface);
+    wined3d_cs_emit_blt(device->cs, dst_surface, dst_rect, src_surface, src_rect, flags, fx, filter);
+
+    return WINED3D_OK;
 }
diff -Naur wine-2.0a/dlls/wined3d/swapchain.c wine-2.0b/dlls/wined3d/swapchain.c
--- wine-2.0a/dlls/wined3d/swapchain.c	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/wined3d/swapchain.c	2017-07-11 20:37:51.000000000 +0100
@@ -112,6 +112,11 @@
 
     if (!refcount)
     {
+        struct wined3d_device *device = swapchain->device;
+
+        if (wined3d_use_csmt(device))
+            device->cs->ops->finish(device->cs);
+
         swapchain_cleanup(swapchain);
         swapchain->parent_ops->wined3d_object_destroyed(swapchain->parent);
         HeapFree(GetProcessHeap(), 0, swapchain);
@@ -484,7 +489,7 @@
         const RECT *src_rect, const RECT *dst_rect, DWORD flags)
 {
     struct wined3d_texture *back_buffer = swapchain->back_buffers[0];
-    const struct wined3d_fb_state *fb = &swapchain->device->fb;
+    const struct wined3d_fb_state *fb = &swapchain->device->cs->fb;
     const struct wined3d_gl_info *gl_info;
     struct wined3d_texture *logo_texture;
     struct wined3d_context *context;
@@ -577,8 +582,8 @@
         swapchain_blit(swapchain, context, src_rect, dst_rect);
     }
 
-    if (swapchain->num_contexts > 1)
-        gl_info->gl_ops.gl.p_glFinish();
+    if (swapchain->num_contexts > 1 && !wined3d_use_csmt(swapchain->device))
+        gl_info->gl_ops.gl.p_glFlush();
 
     /* call wglSwapBuffers through the gl table to avoid confusing the Steam overlay */
     gl_info->gl_ops.wgl.p_wglSwapBuffers(context->hdc);
@@ -624,10 +629,10 @@
         {
             surface_modify_ds_location(ds, WINED3D_LOCATION_DISCARDED,
                     fb->depth_stencil->width, fb->depth_stencil->height);
-            if (ds == swapchain->device->onscreen_depth_stencil)
+            if (ds == swapchain->device->cs->onscreen_depth_stencil)
             {
-                wined3d_texture_decref(swapchain->device->onscreen_depth_stencil->container);
-                swapchain->device->onscreen_depth_stencil = NULL;
+                wined3d_texture_decref(swapchain->device->cs->onscreen_depth_stencil->container);
+                swapchain->device->cs->onscreen_depth_stencil = NULL;
             }
         }
     }
@@ -749,6 +754,7 @@
 
 static void swapchain_update_render_to_fbo(struct wined3d_swapchain *swapchain)
 {
+    const struct wined3d_gl_info *gl_info = &swapchain->device->adapter->gl_info;
     RECT client_rect;
 
     if (wined3d_settings.offscreen_rendering_mode != ORM_FBO)
@@ -771,7 +777,8 @@
             swapchain->desc.multisample_type,
             swapchain->desc.multisample_quality);
 
-    if (!wined3d_settings.always_offscreen && !swapchain->desc.multisample_type
+    if (!(wined3d_settings.always_offscreen || (gl_info->quirks & WINED3D_CX_QUIRK_RENDER_TO_FBO))
+            && !swapchain->desc.multisample_type
             && swapchain->desc.backbuffer_width == client_rect.right
             && swapchain->desc.backbuffer_height == client_rect.bottom)
     {
@@ -806,6 +813,69 @@
     *quality = 0;
 }
 
+HRESULT swapchain_create_context_cs(struct wined3d_device *device, struct wined3d_swapchain *swapchain)
+{
+    const struct wined3d_adapter *adapter = device->adapter;
+    const struct wined3d_gl_info *gl_info = &adapter->gl_info;
+    UINT i;
+
+    static const enum wined3d_format_id formats[] =
+    {
+        WINED3DFMT_D24_UNORM_S8_UINT,
+        WINED3DFMT_D32_UNORM,
+        WINED3DFMT_R24_UNORM_X8_TYPELESS,
+        WINED3DFMT_D16_UNORM,
+        WINED3DFMT_S1_UINT_D15_UNORM
+    };
+
+    swapchain->context = HeapAlloc(GetProcessHeap(), 0, sizeof(*swapchain->context));
+    if (!swapchain->context)
+    {
+        ERR("Failed to create the context array.\n");
+        return E_OUTOFMEMORY;
+    }
+    swapchain->num_contexts = 1;
+
+    /* In WGL both color, depth and stencil are features of a pixel format. In case of D3D they are separate.
+     * You are able to add a depth + stencil surface at a later stage when you need it.
+     * In order to support this properly in WineD3D we need the ability to recreate the opengl context and
+     * drawable when this is required. This is very tricky as we need to reapply ALL opengl states for the new
+     * context, need torecreate shaders, textures and other resources.
+     *
+     * The context manager already takes care of the state problem and for the other tasks code from Reset
+     * can be used. These changes are way to risky during the 1.0 code freeze which is taking place right now.
+     * Likely a lot of other new bugs will be exposed. For that reason request a depth stencil surface all the
+     * time. It can cause a slight performance hit but fixes a lot of regressions. A fixme reminds of that this
+     * issue needs to be fixed. */
+    for (i = 0; i < (sizeof(formats) / sizeof(*formats)); i++)
+    {
+        swapchain->ds_format = wined3d_get_format(gl_info, formats[i], WINED3DUSAGE_DEPTHSTENCIL);
+        swapchain->context[0] = context_create(swapchain, swapchain->front_buffer, swapchain->ds_format);
+        if (swapchain->context[0]) break;
+        TRACE("Depth stencil format %s is not supported, trying next format\n",
+                debug_d3dformat(formats[i]));
+    }
+
+    if (!swapchain->context[0])
+    {
+        WARN("Failed to create context.\n");
+        HeapFree(GetProcessHeap(), 0, swapchain->context);
+        swapchain->context = NULL;
+        return WINED3DERR_NOTAVAILABLE;
+    }
+
+    if (wined3d_settings.offscreen_rendering_mode != ORM_FBO
+            && (!swapchain->desc.enable_auto_depth_stencil
+            || swapchain->desc.auto_depth_stencil_format != swapchain->ds_format->id))
+    {
+        FIXME("Add OpenGL context recreation support to context_validate_onscreen_formats\n");
+    }
+    context_release(swapchain->context[0]);
+    swapchain_update_swap_interval(swapchain);
+
+    return WINED3D_OK;
+}
+
 static HRESULT swapchain_init(struct wined3d_swapchain *swapchain, struct wined3d_device *device,
         struct wined3d_swapchain_desc *desc, void *parent, const struct wined3d_parent_ops *parent_ops)
 {
@@ -928,61 +998,8 @@
 
     if (!(device->wined3d->flags & WINED3D_NO3D))
     {
-        static const enum wined3d_format_id formats[] =
-        {
-            WINED3DFMT_D24_UNORM_S8_UINT,
-            WINED3DFMT_D32_UNORM,
-            WINED3DFMT_R24_UNORM_X8_TYPELESS,
-            WINED3DFMT_D16_UNORM,
-            WINED3DFMT_S1_UINT_D15_UNORM
-        };
-
-        const struct wined3d_gl_info *gl_info = &adapter->gl_info;
-
-        swapchain->context = HeapAlloc(GetProcessHeap(), 0, sizeof(*swapchain->context));
-        if (!swapchain->context)
-        {
-            ERR("Failed to create the context array.\n");
-            hr = E_OUTOFMEMORY;
-            goto err;
-        }
-        swapchain->num_contexts = 1;
-
-        /* In WGL both color, depth and stencil are features of a pixel format. In case of D3D they are separate.
-         * You are able to add a depth + stencil surface at a later stage when you need it.
-         * In order to support this properly in WineD3D we need the ability to recreate the opengl context and
-         * drawable when this is required. This is very tricky as we need to reapply ALL opengl states for the new
-         * context, need torecreate shaders, textures and other resources.
-         *
-         * The context manager already takes care of the state problem and for the other tasks code from Reset
-         * can be used. These changes are way to risky during the 1.0 code freeze which is taking place right now.
-         * Likely a lot of other new bugs will be exposed. For that reason request a depth stencil surface all the
-         * time. It can cause a slight performance hit but fixes a lot of regressions. A fixme reminds of that this
-         * issue needs to be fixed. */
-        for (i = 0; i < (sizeof(formats) / sizeof(*formats)); i++)
-        {
-            swapchain->ds_format = wined3d_get_format(gl_info, formats[i], WINED3DUSAGE_DEPTHSTENCIL);
-            swapchain->context[0] = context_create(swapchain, swapchain->front_buffer, swapchain->ds_format);
-            if (swapchain->context[0]) break;
-            TRACE("Depth stencil format %s is not supported, trying next format\n",
-                  debug_d3dformat(formats[i]));
-        }
-
-        if (!swapchain->context[0])
-        {
-            WARN("Failed to create context.\n");
-            hr = WINED3DERR_NOTAVAILABLE;
+        if (FAILED(hr = wined3d_cs_emit_create_swapchain_context(device->cs, swapchain)))
             goto err;
-        }
-
-        if (wined3d_settings.offscreen_rendering_mode != ORM_FBO
-                && (!desc->enable_auto_depth_stencil
-                || swapchain->desc.auto_depth_stencil_format != swapchain->ds_format->id))
-        {
-            FIXME("Add OpenGL context recreation support to context_validate_onscreen_formats\n");
-        }
-        context_release(swapchain->context[0]);
-        swapchain_update_swap_interval(swapchain);
     }
 
     if (swapchain->desc.backbuffer_count > 0)
@@ -1310,6 +1327,7 @@
         enum wined3d_multisample_type multisample_type, unsigned int multisample_quality)
 {
     BOOL update_desc = FALSE;
+    struct wined3d_device *device = swapchain->device;
 
     TRACE("swapchain %p, buffer_count %u, width %u, height %u, format %s, "
             "multisample_type %#x, multisample_quality %#x.\n",
@@ -1321,6 +1339,9 @@
     if (buffer_count && buffer_count != swapchain->desc.backbuffer_count)
         FIXME("Cannot change the back buffer count yet.\n");
 
+    if (wined3d_use_csmt(device))
+        device->cs->ops->finish(device->cs);
+
     if (!width || !height)
     {
         /* The application is requesting that either the swapchain width or
diff -Naur wine-2.0a/dlls/wined3d/texture.c wine-2.0b/dlls/wined3d/texture.c
--- wine-2.0a/dlls/wined3d/texture.c	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/wined3d/texture.c	2017-07-11 20:37:51.000000000 +0100
@@ -84,15 +84,16 @@
 {
     switch (location)
     {
-        case WINED3D_LOCATION_DISCARDED:
-            return 0;
-
         case WINED3D_LOCATION_SYSMEM:
+        case WINED3D_LOCATION_USER_MEMORY:
+        case WINED3D_LOCATION_BUFFER:
             return WINED3D_RESOURCE_ACCESS_CPU;
 
-        case WINED3D_LOCATION_BUFFER:
-        case WINED3D_LOCATION_TEXTURE_RGB:
+        case WINED3D_LOCATION_DRAWABLE:
         case WINED3D_LOCATION_TEXTURE_SRGB:
+        case WINED3D_LOCATION_TEXTURE_RGB:
+        case WINED3D_LOCATION_RB_MULTISAMPLE:
+        case WINED3D_LOCATION_RB_RESOLVED:
             return WINED3D_RESOURCE_ACCESS_GPU;
 
         default:
@@ -125,6 +126,7 @@
         sub_resource->locations &= ~WINED3D_LOCATION_SYSMEM;
     }
     wined3d_resource_free_sysmem(&texture->resource);
+    texture->resource.map_heap_memory = NULL;
 }
 
 void wined3d_texture_validate_location(struct wined3d_texture *texture,
@@ -174,12 +176,113 @@
                 sub_resource_idx, texture);
 }
 
+static BOOL wined3d_texture_copy_sysmem_location(struct wined3d_texture *texture,
+        unsigned int sub_resource_idx, struct wined3d_context *context, DWORD location)
+{
+    struct wined3d_device *device = texture->resource.device;
+    const struct wined3d_gl_info *gl_info;
+    struct wined3d_bo_address dst, src;
+    UINT size = texture->sub_resources[sub_resource_idx].size;
+
+    wined3d_texture_prepare_location(texture, sub_resource_idx, context, location);
+
+    wined3d_texture_get_memory(texture, sub_resource_idx, &dst, location, FALSE);
+    wined3d_texture_get_memory(texture, sub_resource_idx, &src,
+            texture->sub_resources[sub_resource_idx].locations, FALSE);
+
+    if (dst.buffer_object)
+    {
+        context = context_acquire(device, NULL);
+        gl_info = context->gl_info;
+        GL_EXTCALL(glBindBuffer(GL_PIXEL_UNPACK_BUFFER, dst.buffer_object));
+        GL_EXTCALL(glBufferSubData(GL_PIXEL_UNPACK_BUFFER, 0, size, src.addr));
+        GL_EXTCALL(glBindBuffer(GL_PIXEL_UNPACK_BUFFER, 0));
+        checkGLcall("Upload PBO");
+        context_release(context);
+        return TRUE;
+    }
+    if (src.buffer_object)
+    {
+        context = context_acquire(device, NULL);
+        gl_info = context->gl_info;
+        GL_EXTCALL(glBindBuffer(GL_PIXEL_PACK_BUFFER, src.buffer_object));
+        GL_EXTCALL(glGetBufferSubData(GL_PIXEL_PACK_BUFFER, 0, size, dst.addr));
+        GL_EXTCALL(glBindBuffer(GL_PIXEL_PACK_BUFFER, 0));
+        checkGLcall("Download PBO");
+        context_release(context);
+        return TRUE;
+    }
+    memcpy(dst.addr, src.addr, size);
+    return TRUE;
+}
+
 /* Context activation is done by the caller. Context may be NULL in
  * WINED3D_NO3D mode. */
 BOOL wined3d_texture_load_location(struct wined3d_texture *texture,
         unsigned int sub_resource_idx, struct wined3d_context *context, DWORD location)
 {
-    return texture->texture_ops->texture_load_location(texture, sub_resource_idx, context, location);
+    struct wined3d_surface *surface = texture->sub_resources[sub_resource_idx].u.surface;
+    DWORD current = texture->sub_resources[sub_resource_idx].locations;
+    unsigned int sub_resource_w, sub_resource_h;
+    BOOL ret;
+
+    TRACE("Texture %p, sub_resource %u, location %s.\n", texture, sub_resource_idx,
+            wined3d_debug_location(location));
+
+    sub_resource_w = wined3d_texture_get_level_width(texture, sub_resource_idx % texture->level_count);
+    sub_resource_h = wined3d_texture_get_level_height(texture, sub_resource_idx % texture->level_count);
+
+    if ((current & location) && (!(surface && (texture->resource.usage & WINED3DUSAGE_DEPTHSTENCIL))
+            || (surface->ds_current_size.cx == sub_resource_w
+            && surface->ds_current_size.cy == sub_resource_h)))
+    {
+        TRACE("Location (%#x) is already up to date.\n", location);
+        return TRUE;
+    }
+
+    if (WARN_ON(d3d))
+    {
+        DWORD required_access = wined3d_resource_access_from_location(location);
+        if ((texture->resource.access_flags & required_access) != required_access)
+            WARN("Operation requires %#x access, but texture only has %#x.\n",
+                 required_access, texture->resource.access_flags);
+    }
+
+    if (!current)
+    {
+        ERR("Texture %p, sub resource %u does not have any up to date location.\n", texture, sub_resource_idx);
+        wined3d_texture_validate_location(texture, sub_resource_idx, WINED3D_LOCATION_DISCARDED);
+        return wined3d_texture_load_location(texture, sub_resource_idx, context, location);
+    }
+
+    if (texture->sub_resources[sub_resource_idx].locations & WINED3D_LOCATION_DISCARDED)
+    {
+        wined3d_texture_prepare_location(texture, sub_resource_idx, context, location);
+        ret = TRUE;
+    }
+    else
+    {
+        static const DWORD sysmem_locations = WINED3D_LOCATION_SYSMEM | WINED3D_LOCATION_USER_MEMORY
+                | WINED3D_LOCATION_BUFFER;
+
+        if ((location & sysmem_locations) && (current & sysmem_locations))
+            ret = wined3d_texture_copy_sysmem_location(texture, sub_resource_idx, context, location);
+        else
+            ret = texture->texture_ops->texture_load_location(texture, sub_resource_idx, context, location);
+    }
+
+    if (ret)
+    {
+        wined3d_texture_validate_location(texture, sub_resource_idx, location);
+
+        if (surface && texture->resource.usage & WINED3DUSAGE_DEPTHSTENCIL)
+        {
+            surface->ds_current_size.cx = sub_resource_w;
+            surface->ds_current_size.cy = sub_resource_h;
+        }
+    }
+
+    return ret;
 }
 
 /* Context activation is done by the caller. */
@@ -224,18 +327,21 @@
 }
 
 void wined3d_texture_get_memory(struct wined3d_texture *texture, unsigned int sub_resource_idx,
-        struct wined3d_bo_address *data, DWORD locations)
+        struct wined3d_bo_address *data, DWORD locations, BOOL map)
 {
     struct wined3d_texture_sub_resource *sub_resource;
 
-    TRACE("texture %p, sub_resource_idx %u, data %p, locations %s.\n",
-            texture, sub_resource_idx, data, wined3d_debug_location(locations));
+    TRACE("texture %p, sub_resource_idx %u, data %p, locations %s, map %#x.\n",
+            texture, sub_resource_idx, data, wined3d_debug_location(locations), map);
 
     sub_resource = &texture->sub_resources[sub_resource_idx];
     if (locations & WINED3D_LOCATION_BUFFER)
     {
         data->addr = NULL;
-        data->buffer_object = sub_resource->buffer_object;
+        if (map)
+            data->buffer_object = sub_resource->map_buffer->name;
+        else
+            data->buffer_object = sub_resource->buffer->name;
         return;
     }
     if (locations & WINED3D_LOCATION_USER_MEMORY)
@@ -246,7 +352,10 @@
     }
     if (locations & WINED3D_LOCATION_SYSMEM)
     {
-        data->addr = texture->resource.heap_memory;
+        if (map)
+            data->addr = texture->resource.map_heap_memory;
+        else
+            data->addr = texture->resource.heap_memory;
         data->addr += sub_resource->offset;
         data->buffer_object = 0;
         return;
@@ -330,24 +439,32 @@
         texture->flags |= WINED3D_TEXTURE_GET_DC;
     if (flags & WINED3D_TEXTURE_CREATE_DISCARD)
         texture->flags |= WINED3D_TEXTURE_DISCARD;
+    if (wined3d_use_csmt(device) && wined3d_settings.cs_texture_optimization
+            && ((desc->usage & WINED3DUSAGE_DYNAMIC && !(desc->usage & WINED3DUSAGE_RENDERTARGET))
+            || desc->pool != WINED3D_POOL_DEFAULT))
+        texture->flags |= WINED3D_TEXTURE_PIN_SYSMEM;
 
     return WINED3D_OK;
 }
 
 /* Context activation is done by the caller. */
 static void wined3d_texture_remove_buffer_object(struct wined3d_texture *texture,
-        unsigned int sub_resource_idx, const struct wined3d_gl_info *gl_info)
+        unsigned int sub_resource_idx, struct wined3d_context *context)
 {
-    GLuint *buffer_object;
+    struct wined3d_gl_bo *buffer = texture->sub_resources[sub_resource_idx].buffer;
+    GLuint name = buffer->name;
 
-    buffer_object = &texture->sub_resources[sub_resource_idx].buffer_object;
-    GL_EXTCALL(glDeleteBuffers(1, buffer_object));
-    checkGLcall("glDeleteBuffers");
+    if (buffer != texture->sub_resources[sub_resource_idx].map_buffer)
+        ERR("Buffer is %p, map buffer is %p.\n", buffer,
+                texture->sub_resources[sub_resource_idx].map_buffer);
+
+    wined3d_device_release_bo(texture->resource.device, buffer, context);
+    texture->sub_resources[sub_resource_idx].buffer = NULL;
+    texture->sub_resources[sub_resource_idx].map_buffer = NULL;
     wined3d_texture_invalidate_location(texture, sub_resource_idx, WINED3D_LOCATION_BUFFER);
-    *buffer_object = 0;
 
     TRACE("Deleted buffer object %u for texture %p, sub-resource %u.\n",
-            *buffer_object, texture, sub_resource_idx);
+            name, texture, sub_resource_idx);
 }
 
 static void wined3d_texture_update_map_binding(struct wined3d_texture *texture)
@@ -367,7 +484,7 @@
                 && !wined3d_texture_load_location(texture, i, context, map_binding))
             ERR("Failed to load location %s.\n", wined3d_debug_location(map_binding));
         if (texture->resource.map_binding == WINED3D_LOCATION_BUFFER)
-            wined3d_texture_remove_buffer_object(texture, i, context->gl_info);
+            wined3d_texture_remove_buffer_object(texture, i, context);
     }
 
     if (context)
@@ -524,28 +641,30 @@
     unsigned int sub_count = texture->level_count * texture->layer_count;
     struct wined3d_device *device = texture->resource.device;
     struct wined3d_context *context = NULL;
-    const struct wined3d_gl_info *gl_info;
-    GLuint buffer_object;
+    struct wined3d_gl_bo *buffer;
     unsigned int i;
 
     TRACE("texture %p.\n", texture);
 
     for (i = 0; i < sub_count; ++i)
     {
-        if (!(buffer_object = texture->sub_resources[i].buffer_object))
+        if (texture->sub_resources[i].buffer != texture->sub_resources[i].map_buffer)
+            ERR("Buffer is %p, map buffer is %p.\n", texture->sub_resources[i].buffer,
+                    texture->sub_resources[i].map_buffer);
+
+        if (!(buffer = texture->sub_resources[i].buffer))
             continue;
 
-        TRACE("Deleting buffer object %u.\n", buffer_object);
+        TRACE("Deleting buffer object %u.\n", buffer->name);
 
         /* We may not be able to get a context in wined3d_texture_cleanup() in
          * general, but if a buffer object was previously created we can. */
         if (!context)
-        {
             context = context_acquire(device, NULL);
-            gl_info = context->gl_info;
-        }
 
-        GL_EXTCALL(glDeleteBuffers(1, &buffer_object));
+        wined3d_device_release_bo(device, buffer, context);
+        texture->sub_resources[i].buffer = NULL;
+        texture->sub_resources[i].map_buffer = NULL;
     }
     if (context)
         context_release(context);
@@ -1150,6 +1269,7 @@
     }
 
     wined3d_resource_free_sysmem(&texture->resource);
+    texture->resource.map_heap_memory = NULL;
 
     if ((texture->row_pitch = pitch))
         texture->slice_pitch = height * pitch;
@@ -1206,29 +1326,39 @@
     wined3d_texture_invalidate_location(texture, 0, ~valid_location);
 
     if (create_dib)
-        wined3d_surface_create_dc(surface);
+    {
+        HDC dc;
+        wined3d_texture_get_dc(texture, 0, &dc);
+        wined3d_texture_release_dc(texture, 0, dc);
+    }
 
     return WINED3D_OK;
 }
 
 /* Context activation is done by the caller. */
 static void wined3d_texture_prepare_buffer_object(struct wined3d_texture *texture,
-        unsigned int sub_resource_idx, const struct wined3d_gl_info *gl_info)
+        unsigned int sub_resource_idx, struct wined3d_context *context)
 {
     struct wined3d_texture_sub_resource *sub_resource;
 
     sub_resource = &texture->sub_resources[sub_resource_idx];
-    if (sub_resource->buffer_object)
+    if (sub_resource->buffer)
         return;
 
-    GL_EXTCALL(glGenBuffers(1, &sub_resource->buffer_object));
-    GL_EXTCALL(glBindBuffer(GL_PIXEL_UNPACK_BUFFER, sub_resource->buffer_object));
-    GL_EXTCALL(glBufferData(GL_PIXEL_UNPACK_BUFFER, sub_resource->size, NULL, GL_STREAM_DRAW));
-    GL_EXTCALL(glBindBuffer(GL_PIXEL_UNPACK_BUFFER, 0));
-    checkGLcall("Create buffer object");
+    sub_resource->buffer = wined3d_device_get_bo(texture->resource.device,
+            sub_resource->size, GL_STREAM_DRAW, GL_PIXEL_UNPACK_BUFFER, context);
+    sub_resource->map_buffer = sub_resource->buffer;
 
     TRACE("Created buffer object %u for texture %p, sub-resource %u.\n",
-            sub_resource->buffer_object, texture, sub_resource_idx);
+            sub_resource->buffer->name, texture, sub_resource_idx);
+
+    /* FIXME: PBOs are (still) allocated per sub resource, this is global for the texture. It *should* work
+     * since whether we use PBOs is a per-texture choice, but it is shaky.
+     *
+     * This is needed because otherwise the next unmap will re-assign it with the resource_changed
+     * message. Freeing the actual memory and setting the read pointer to 0 is
+     * the task of the worker thread. */
+    texture->resource.map_heap_memory = NULL;
 }
 
 static void wined3d_texture_force_reload(struct wined3d_texture *texture)
@@ -1346,6 +1476,7 @@
                 ERR("Failed to allocate system memory.\n");
                 return FALSE;
             }
+            texture->resource.heap_memory = texture->resource.map_heap_memory;
             return TRUE;
 
         case WINED3D_LOCATION_USER_MEMORY:
@@ -1354,7 +1485,7 @@
             return TRUE;
 
         case WINED3D_LOCATION_BUFFER:
-            wined3d_texture_prepare_buffer_object(texture, sub_resource_idx, context->gl_info);
+            wined3d_texture_prepare_buffer_object(texture, sub_resource_idx, context);
             return TRUE;
 
         case WINED3D_LOCATION_TEXTURE_RGB:
@@ -1390,7 +1521,7 @@
     FIXME("texture %p stub!\n", texture);
 }
 
-static struct wined3d_texture_sub_resource *wined3d_texture_get_sub_resource(struct wined3d_texture *texture,
+struct wined3d_texture_sub_resource *wined3d_texture_get_sub_resource(struct wined3d_texture *texture,
         unsigned int sub_resource_idx)
 {
     UINT sub_count = texture->level_count * texture->layer_count;
@@ -1445,6 +1576,7 @@
             context, box, data, row_pitch, slice_pitch);
 }
 
+/* Context activation is done by the caller. */
 static void texture2d_upload_data(struct wined3d_texture *texture, unsigned int sub_resource_idx,
         const struct wined3d_context *context, const struct wined3d_box *box,
         const struct wined3d_const_bo_address *data, unsigned int row_pitch, unsigned int slice_pitch)
@@ -1640,8 +1772,8 @@
             wined3d_texture_invalidate_location(texture, i, ~WINED3D_LOCATION_DISCARDED);
         }
 
-        if (sub_resource->buffer_object)
-            wined3d_texture_remove_buffer_object(texture, i, context->gl_info);
+        if (sub_resource->buffer)
+            wined3d_texture_remove_buffer_object(texture, i, context);
 
         if (resource->type == WINED3D_RTYPE_TEXTURE_2D)
         {
@@ -1666,20 +1798,95 @@
     wined3d_texture_unload_gl_texture(texture);
 }
 
+static void *wined3d_texture_map_internal(struct wined3d_texture *texture, unsigned int sub_resource_idx, DWORD flags)
+{
+    struct wined3d_device *device = texture->resource.device;
+    struct wined3d_context *context = NULL;
+    void *data;
+    BOOL ret;
+    struct wined3d_texture_sub_resource *sub_resource = wined3d_texture_get_sub_resource(texture, sub_resource_idx);
+    struct wined3d_bo_address bo_data;
+
+    if (device->d3d_initialized && !((texture->flags & WINED3D_TEXTURE_PIN_SYSMEM)
+            && (sub_resource->locations & texture->resource.map_binding)))
+        context = context_acquire(device, NULL);
+
+    if (flags & WINED3D_MAP_DISCARD)
+    {
+        /* MSDN says DISCARD on sub resource 0 discards the entire texture, whereas DISCARD on all other
+         * sub resources is ignored. Currently we can do it the MSDN way for sysmem, but not for buffers. */
+        if (sub_resource_idx != 0)
+            FIXME("Discard of sub resource %u.\n", sub_resource_idx);
+
+        switch (texture->resource.map_binding)
+        {
+            case WINED3D_LOCATION_BUFFER:
+                sub_resource->map_buffer = wined3d_device_get_bo(device, sub_resource->size,
+                        GL_STREAM_DRAW, GL_PIXEL_UNPACK_BUFFER, context);
+                if (!sub_resource->buffer)
+                    sub_resource->buffer = sub_resource->map_buffer;
+                ret = !!sub_resource->map_buffer;
+                break;
+
+            case WINED3D_LOCATION_SYSMEM:
+                if (!sub_resource_idx)
+                    wined3d_resource_allocate_sysmem(&texture->resource);
+                ret = !!texture->resource.heap_memory;
+                break;
+
+            default:
+                ret = wined3d_texture_prepare_location(texture, sub_resource_idx,
+                        context, texture->resource.map_binding);
+        }
+        TRACE("WINED3D_MAP_DISCARD flag passed, marking %s as up to date.\n",
+                wined3d_debug_location(texture->resource.map_binding));
+        if (ret)
+            wined3d_texture_validate_location(texture, sub_resource_idx, texture->resource.map_binding);
+    }
+    else
+    {
+        if (texture->resource.usage & WINED3DUSAGE_DYNAMIC)
+            WARN_(d3d_perf)("Mapping a dynamic texture without WINED3D_MAP_DISCARD.\n");
+        ret = wined3d_texture_load_location(texture,
+                sub_resource_idx, context, texture->resource.map_binding);
+    }
+
+    if (!ret)
+    {
+        ERR("Failed to prepare location.\n");
+        if (context)
+            context_release(context);
+        return NULL;
+    }
+
+    wined3d_texture_get_memory(texture, sub_resource_idx, &bo_data, texture->resource.map_binding, TRUE);
+    data = wined3d_texture_map_bo_address(&bo_data, sub_resource->size,
+            context ? context->gl_info : NULL, GL_PIXEL_UNPACK_BUFFER, flags);
+
+    if (context)
+        context_release(context);
+
+    if (texture->swapchain && texture->swapchain->front_buffer == texture)
+    {
+        RECT *r = &texture->swapchain->front_buffer_update;
+
+        /* FIXME: Preserve the map box... */
+        SetRect(r, 0, 0, texture->resource.width, texture->resource.height);
+        TRACE("Mapped front buffer %s.\n", wine_dbgstr_rect(r));
+    }
+
+    return data;
+}
+
 static HRESULT texture_resource_sub_resource_map(struct wined3d_resource *resource, unsigned int sub_resource_idx,
         struct wined3d_map_desc *map_desc, const struct wined3d_box *box, DWORD flags)
 {
     const struct wined3d_format *format = resource->format;
     struct wined3d_texture_sub_resource *sub_resource;
-    struct wined3d_device *device = resource->device;
     unsigned int fmt_flags = resource->format_flags;
-    const struct wined3d_gl_info *gl_info = NULL;
-    struct wined3d_context *context = NULL;
     struct wined3d_texture *texture;
-    struct wined3d_bo_address data;
     unsigned int texture_level;
     BYTE *base_memory;
-    BOOL ret;
 
     TRACE("resource %p, sub_resource_idx %u, map_desc %p, box %s, flags %#x.\n",
             resource, sub_resource_idx, map_desc, debug_box(box), flags);
@@ -1712,56 +1919,29 @@
             return WINED3DERR_INVALIDCALL;
     }
 
+    if (flags & WINED3D_MAP_NOOVERWRITE)
+        FIXME("WINED3D_MAP_NOOVERWRITE is not implemented yet.\n");
+
     if (texture->flags & WINED3D_TEXTURE_DC_IN_USE)
     {
         WARN("DC is in use.\n");
         return WINED3DERR_INVALIDCALL;
     }
 
+    /* FIXME: Is this safe? Since we no longer unconditionally wait for the
+     * resource to become idle, the CS can be accessing the texture at the
+     * same time we are. For example, a blit could result in an internal map,
+     * which would then break the "map_count" check below. */
     if (sub_resource->map_count)
     {
         WARN("Sub-resource is already mapped.\n");
         return WINED3DERR_INVALIDCALL;
     }
 
-    if (device->d3d_initialized)
-    {
-        context = context_acquire(device, NULL);
-        gl_info = context->gl_info;
-    }
-
-    if (flags & WINED3D_MAP_DISCARD)
-    {
-        TRACE("WINED3D_MAP_DISCARD flag passed, marking %s as up to date.\n",
-                wined3d_debug_location(texture->resource.map_binding));
-        if ((ret = wined3d_texture_prepare_location(texture, sub_resource_idx,
-                context, texture->resource.map_binding)))
-            wined3d_texture_validate_location(texture, sub_resource_idx, texture->resource.map_binding);
-    }
-    else
-    {
-        if (resource->usage & WINED3DUSAGE_DYNAMIC)
-            WARN_(d3d_perf)("Mapping a dynamic texture without WINED3D_MAP_DISCARD.\n");
-        ret = wined3d_texture_load_location(texture, sub_resource_idx, context, texture->resource.map_binding);
-    }
-
-    if (!ret)
-    {
-        ERR("Failed to prepare location.\n");
-        context_release(context);
-        return E_OUTOFMEMORY;
-    }
-
-    if (!(flags & (WINED3D_MAP_NO_DIRTY_UPDATE | WINED3D_MAP_READONLY)))
-        wined3d_texture_invalidate_location(texture, sub_resource_idx, ~texture->resource.map_binding);
+    if (resource->pool == WINED3D_POOL_DEFAULT && !(texture->flags & WINED3D_TEXTURE_PIN_SYSMEM))
+        WARN("Mapping a DEFAULT pool, non-dynamic texture.\n");
 
-    wined3d_texture_get_memory(texture, sub_resource_idx, &data, texture->resource.map_binding);
-    base_memory = wined3d_texture_map_bo_address(&data, sub_resource->size,
-            gl_info, GL_PIXEL_UNPACK_BUFFER, flags);
-    TRACE("Base memory pointer %p.\n", base_memory);
-
-    if (context)
-        context_release(context);
+    base_memory = wined3d_texture_map_internal(texture, sub_resource_idx, flags);
 
     if (fmt_flags & WINED3DFMT_FLAG_BROKEN_PITCH)
     {
@@ -1797,17 +1977,6 @@
         }
     }
 
-    if (texture->swapchain && texture->swapchain->front_buffer == texture)
-    {
-        RECT *r = &texture->swapchain->front_buffer_update;
-
-        if (!box)
-            SetRect(r, 0, 0, resource->width, resource->height);
-        else
-            SetRect(r, box->left, box->top, box->right, box->bottom);
-        TRACE("Mapped front buffer %s.\n", wine_dbgstr_rect(r));
-    }
-
     ++resource->map_count;
     ++sub_resource->map_count;
 
@@ -1817,14 +1986,66 @@
     return WINED3D_OK;
 }
 
+static void wined3d_texture_unmap_internal(struct wined3d_texture *texture, unsigned int sub_resource_idx)
+{
+    struct wined3d_device *device = texture->resource.device;
+    struct wined3d_context *context = NULL;
+    struct wined3d_bo_address data;
+
+    if (device->d3d_initialized && !(texture->flags & WINED3D_TEXTURE_PIN_SYSMEM))
+        context = context_acquire(device, NULL);
+
+    wined3d_texture_get_memory(texture, sub_resource_idx, &data, texture->resource.map_binding, TRUE);
+    wined3d_texture_unmap_bo_address(&data, context ? context->gl_info : NULL, GL_PIXEL_UNPACK_BUFFER);
+
+    if (context)
+        context_release(context);
+
+    if (texture->swapchain && texture->swapchain->front_buffer == texture)
+    {
+        struct wined3d_texture_sub_resource *sub_resource = &texture->sub_resources[sub_resource_idx];
+
+        if (!(sub_resource->locations & (WINED3D_LOCATION_DRAWABLE | WINED3D_LOCATION_TEXTURE_RGB)))
+            texture->swapchain->swapchain_ops->swapchain_frontbuffer_updated(texture->swapchain);
+    }
+    else if (texture->resource.format_flags & (WINED3DFMT_FLAG_DEPTH | WINED3DFMT_FLAG_STENCIL))
+    {
+        FIXME("Depth / stencil buffer locking is not implemented.\n");
+    }
+}
+
+void wined3d_texture_changed(struct wined3d_texture *texture, unsigned int sub_resource_idx,
+        struct wined3d_gl_bo *swap_buffer, void *swap_heap_memory)
+{
+    struct wined3d_texture_sub_resource *sub_resource = &texture->sub_resources[sub_resource_idx];
+
+    TRACE("texture %p, sub_resource_idx %u, swap_buffer %p, swap_heap_memory %p.\n",
+            texture, sub_resource_idx, swap_buffer, swap_heap_memory);
+
+    if (swap_buffer && swap_buffer != sub_resource->buffer)
+    {
+        struct wined3d_device *device = texture->resource.device;
+        struct wined3d_context *context = context_acquire(device, NULL);
+        TRACE("Swapping texture PBO.\n");
+        wined3d_device_release_bo(device, sub_resource->buffer, context);
+        context_release(context);
+        sub_resource->buffer = swap_buffer;
+    }
+
+    if (swap_heap_memory && swap_heap_memory != texture->resource.heap_memory && !sub_resource_idx)
+    {
+        TRACE("Swapping texture heap memory.\n");
+        wined3d_resource_free_sysmem(&texture->resource);
+        texture->resource.heap_memory = swap_heap_memory;
+    }
+
+    wined3d_texture_invalidate_location(texture, sub_resource_idx, ~texture->resource.map_binding);
+}
+
 static HRESULT texture_resource_sub_resource_unmap(struct wined3d_resource *resource, unsigned int sub_resource_idx)
 {
     struct wined3d_texture_sub_resource *sub_resource;
-    struct wined3d_device *device = resource->device;
-    const struct wined3d_gl_info *gl_info = NULL;
-    struct wined3d_context *context = NULL;
     struct wined3d_texture *texture;
-    struct wined3d_bo_address data;
 
     TRACE("resource %p, sub_resource_idx %u.\n", resource, sub_resource_idx);
 
@@ -1840,27 +2061,7 @@
         return WINEDDERR_NOTLOCKED;
     }
 
-    if (device->d3d_initialized)
-    {
-        context = context_acquire(device, NULL);
-        gl_info = context->gl_info;
-    }
-
-    wined3d_texture_get_memory(texture, sub_resource_idx, &data, texture->resource.map_binding);
-    wined3d_texture_unmap_bo_address(&data, gl_info, GL_PIXEL_UNPACK_BUFFER);
-
-    if (context)
-        context_release(context);
-
-    if (texture->swapchain && texture->swapchain->front_buffer == texture)
-    {
-        if (!(sub_resource->locations & (WINED3D_LOCATION_DRAWABLE | WINED3D_LOCATION_TEXTURE_RGB)))
-            texture->swapchain->swapchain_ops->swapchain_frontbuffer_updated(texture->swapchain);
-    }
-    else if (resource->format_flags & (WINED3DFMT_FLAG_DEPTH | WINED3DFMT_FLAG_STENCIL))
-    {
-        FIXME("Depth / stencil buffer locking is not implemented.\n");
-    }
+    wined3d_texture_unmap_internal(texture, sub_resource_idx);
 
     --sub_resource->map_count;
     if (!--resource->map_count && texture->update_map_binding)
@@ -1908,7 +2109,7 @@
     if (desc->usage & WINED3DUSAGE_DYNAMIC && desc->pool == WINED3D_POOL_MANAGED)
         FIXME("Trying to create a managed texture with dynamic usage.\n");
     if (!(desc->usage & (WINED3DUSAGE_DYNAMIC | WINED3DUSAGE_RENDERTARGET | WINED3DUSAGE_DEPTHSTENCIL))
-            && (flags & WINED3D_TEXTURE_CREATE_MAPPABLE))
+            && (flags & WINED3D_TEXTURE_CREATE_MAPPABLE) && desc->pool == WINED3D_POOL_DEFAULT)
         WARN("Creating a mappable texture in the default pool that doesn't specify dynamic usage.\n");
     if (desc->usage & WINED3DUSAGE_RENDERTARGET && desc->pool != WINED3D_POOL_DEFAULT)
         FIXME("Trying to create a render target that isn't in the default pool.\n");
@@ -2092,11 +2293,15 @@
 
             TRACE("Created surface level %u, layer %u @ %p.\n", i, j, surface);
 
-            if (((desc->usage & WINED3DUSAGE_OWNDC) || (device->wined3d->flags & WINED3D_NO3D))
-                    && FAILED(hr = wined3d_surface_create_dc(surface)))
+            if ((desc->usage & WINED3DUSAGE_OWNDC) || (device->wined3d->flags & WINED3D_NO3D))
             {
-                wined3d_texture_cleanup_sync(texture);
-                return hr;
+                HDC dc;
+                if (FAILED(hr = wined3d_texture_get_dc(texture, idx, &dc)))
+                {
+                    wined3d_texture_cleanup_sync(texture);
+                    return hr;
+                }
+                wined3d_texture_release_dc(texture, idx, dc);
             }
         }
     }
@@ -2252,7 +2457,6 @@
         struct wined3d_context *context, DWORD location)
 {
     struct wined3d_texture_sub_resource *sub_resource = &texture->sub_resources[sub_resource_idx];
-    DWORD required_access = wined3d_resource_access_from_location(location);
     unsigned int row_pitch, slice_pitch;
 
     TRACE("texture %p, sub_resource_idx %u, context %p, location %s.\n",
@@ -2260,30 +2464,9 @@
 
     TRACE("Current resource location %s.\n", wined3d_debug_location(sub_resource->locations));
 
-    if ((sub_resource->locations & location) == location)
-    {
-        TRACE("Location(s) already up to date.\n");
-        return TRUE;
-    }
-
-    if ((texture->resource.access_flags & required_access) != required_access)
-    {
-        ERR("Operation requires %#x access, but volume only has %#x.\n",
-                required_access, texture->resource.access_flags);
-        return FALSE;
-    }
-
     if (!wined3d_texture_prepare_location(texture, sub_resource_idx, context, location))
         return FALSE;
 
-    if (sub_resource->locations & WINED3D_LOCATION_DISCARDED)
-    {
-        TRACE("Volume previously discarded, nothing to do.\n");
-        wined3d_texture_validate_location(texture, sub_resource_idx, location);
-        wined3d_texture_invalidate_location(texture, sub_resource_idx, WINED3D_LOCATION_DISCARDED);
-        goto done;
-    }
-
     switch (location)
     {
         case WINED3D_LOCATION_TEXTURE_RGB:
@@ -2299,7 +2482,7 @@
             }
             else if (sub_resource->locations & WINED3D_LOCATION_BUFFER)
             {
-                struct wined3d_const_bo_address data = {sub_resource->buffer_object, NULL};
+                struct wined3d_const_bo_address data = {sub_resource->buffer->name, NULL};
                 wined3d_texture_bind_and_dirtify(texture, context,
                         location == WINED3D_LOCATION_TEXTURE_SRGB);
                 wined3d_texture_get_pitch(texture, sub_resource_idx, &row_pitch, &slice_pitch);
@@ -2345,7 +2528,7 @@
         case WINED3D_LOCATION_BUFFER:
             if (sub_resource->locations & (WINED3D_LOCATION_TEXTURE_RGB | WINED3D_LOCATION_TEXTURE_SRGB))
             {
-                struct wined3d_bo_address data = {sub_resource->buffer_object, NULL};
+                struct wined3d_bo_address data = {sub_resource->buffer->name, NULL};
 
                 if (sub_resource->locations & WINED3D_LOCATION_TEXTURE_RGB)
                     wined3d_texture_bind_and_dirtify(texture, context, FALSE);
@@ -2368,7 +2551,6 @@
             return FALSE;
     }
 
-done:
     wined3d_texture_validate_location(texture, sub_resource_idx, location);
 
     return TRUE;
@@ -2543,6 +2725,7 @@
     if (wined3d_texture_use_pbo(texture, gl_info))
     {
         wined3d_resource_free_sysmem(&texture->resource);
+        texture->resource.map_heap_memory = NULL;
         texture->resource.map_binding = WINED3D_LOCATION_BUFFER;
     }
 
@@ -2889,13 +3072,39 @@
     return WINED3D_OK;
 }
 
+void wined3d_texture_get_dc_cs(struct wined3d_texture *texture, unsigned int sub_resource_idx)
+{
+    struct wined3d_device *device = texture->resource.device;
+    struct wined3d_context *context = NULL;
+    struct wined3d_texture_sub_resource *sub_resource = &texture->sub_resources[sub_resource_idx];
+    struct wined3d_surface *surface = sub_resource->u.surface;
+
+    if (device->d3d_initialized)
+        context = context_acquire(device, NULL);
+
+    wined3d_texture_load_location(texture, sub_resource_idx, context, texture->resource.map_binding);
+    wined3d_texture_invalidate_location(texture, sub_resource_idx, ~texture->resource.map_binding);
+
+    if (!surface->dc)
+        texture->dc_hr = wined3d_surface_create_dc(surface);
+    else
+        texture->dc_hr = WINED3D_OK;
+    if (context)
+        context_release(context);
+    if (FAILED(texture->dc_hr))
+        return;
+
+    if (!(texture->flags & WINED3D_TEXTURE_GET_DC_LENIENT))
+        texture->flags |= WINED3D_TEXTURE_DC_IN_USE;
+    ++texture->resource.map_count;
+    ++sub_resource->map_count;
+}
+
 HRESULT CDECL wined3d_texture_get_dc(struct wined3d_texture *texture, unsigned int sub_resource_idx, HDC *dc)
 {
     struct wined3d_device *device = texture->resource.device;
     struct wined3d_texture_sub_resource *sub_resource;
-    struct wined3d_context *context = NULL;
     struct wined3d_surface *surface;
-    HRESULT hr = WINED3D_OK;
 
     TRACE("texture %p, sub_resource_idx %u, dc %p.\n", texture, sub_resource_idx, dc);
 
@@ -2920,28 +3129,30 @@
     if (texture->resource.map_count && !(texture->flags & WINED3D_TEXTURE_GET_DC_LENIENT))
         return WINED3DERR_INVALIDCALL;
 
-    if (device->d3d_initialized)
-        context = context_acquire(device, NULL);
+    wined3d_cs_emit_get_dc(device->cs, texture, sub_resource_idx);
+    if (FAILED(texture->dc_hr))
+        return texture->dc_hr;
 
-    wined3d_texture_load_location(texture, sub_resource_idx, context, texture->resource.map_binding);
-    wined3d_texture_invalidate_location(texture, sub_resource_idx, ~texture->resource.map_binding);
+    *dc = surface->dc;
+    TRACE("Returning dc %p.\n", *dc);
 
-    if (!surface->dc)
-        hr = wined3d_surface_create_dc(surface);
-    if (context)
-        context_release(context);
-    if (FAILED(hr))
-        return WINED3DERR_INVALIDCALL;
+    return WINED3D_OK;
+}
 
-    if (!(texture->flags & WINED3D_TEXTURE_GET_DC_LENIENT))
-        texture->flags |= WINED3D_TEXTURE_DC_IN_USE;
-    ++texture->resource.map_count;
-    ++sub_resource->map_count;
+void wined3d_texture_release_dc_cs(struct wined3d_texture *texture, unsigned int sub_resource_idx)
+{
+    struct wined3d_device *device = texture->resource.device;
+    struct wined3d_texture_sub_resource *sub_resource = &texture->sub_resources[sub_resource_idx];
+    struct wined3d_surface *surface = sub_resource->u.surface;
 
-    *dc = surface->dc;
-    TRACE("Returning dc %p.\n", *dc);
+    if (!(texture->resource.usage & WINED3DUSAGE_OWNDC) && !(device->wined3d->flags & WINED3D_NO3D))
+        wined3d_surface_destroy_dc(surface);
 
-    return hr;
+    --sub_resource->map_count;
+    if (!--texture->resource.map_count && texture->update_map_binding)
+        wined3d_texture_update_map_binding(texture);
+    if (!(texture->flags & WINED3D_TEXTURE_GET_DC_LENIENT))
+        texture->flags &= ~WINED3D_TEXTURE_DC_IN_USE;
 }
 
 HRESULT CDECL wined3d_texture_release_dc(struct wined3d_texture *texture, unsigned int sub_resource_idx, HDC dc)
@@ -2972,14 +3183,7 @@
         return WINED3DERR_INVALIDCALL;
     }
 
-    if (!(texture->resource.usage & WINED3DUSAGE_OWNDC) && !(device->wined3d->flags & WINED3D_NO3D))
-        wined3d_surface_destroy_dc(surface);
-
-    --sub_resource->map_count;
-    if (!--texture->resource.map_count && texture->update_map_binding)
-        wined3d_texture_update_map_binding(texture);
-    if (!(texture->flags & WINED3D_TEXTURE_GET_DC_LENIENT))
-        texture->flags &= ~WINED3D_TEXTURE_DC_IN_USE;
+    wined3d_cs_emit_release_dc(device->cs, texture, sub_resource_idx);
 
     return WINED3D_OK;
 }
diff -Naur wine-2.0a/dlls/wined3d/utils.c wine-2.0b/dlls/wined3d/utils.c
--- wine-2.0a/dlls/wined3d/utils.c	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/wined3d/utils.c	2017-07-11 20:37:51.000000000 +0100
@@ -5261,7 +5261,9 @@
                         break;
                 }
             }
-        } else {
+        }
+        else
+        {
             settings->op[i].color_fixup = COLOR_FIXUP_IDENTITY;
             settings->op[i].tex_type = WINED3D_GL_RES_TYPE_TEX_1D;
         }
diff -Naur wine-2.0a/dlls/wined3d/wined3d_main.c wine-2.0b/dlls/wined3d/wined3d_main.c
--- wine-2.0a/dlls/wined3d/wined3d_main.c	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/wined3d/wined3d_main.c	2017-07-11 20:37:51.000000000 +0100
@@ -91,6 +91,26 @@
     ~0U,            /* No PS shader model limit by default. */
     ~0u,            /* No CS shader model limit by default. */
     FALSE,          /* 3D support enabled by default. */
+    TRUE,           /* Multithreaded CS enabled by default. */
+    #ifdef _WIN64
+    TRUE,           /* CSMT texture maps optimization enabled by default on 64 bits. */
+    #else
+    FALSE,          /* CSMT texture maps optimization disabled by default on 32 bits. */
+    #endif
+};
+
+/* CXGames hacks, not in the main wined3d configuration settings */
+struct cxgames_hacks cxgames_hacks =
+{
+    FALSE,                      /* enable_slow_blit */
+    0,                          /* max_vertex_blend_matrices */
+    FALSE,                      /* safe_vs_consts */
+    0,                          /* fixed_vs_constants_limit */
+    NULL,                       /* No extensions disabled by default */
+    FALSE,                      /* Use the absolute value of the POW arguments in ARB */
+    FALSE,                      /* INTZ not blacklisted by default */
+    WINED3D_MAPBUF_STATIC_NV,   /* Don't use glMapBuffer on dynamic buffers with NV threading */
+    FALSE,                      /* No SM4 with just GLSL 1.30 by default */
 };
 
 struct wined3d * CDECL wined3d_create(DWORD flags)
@@ -223,6 +243,27 @@
                 wined3d_settings.glslRequested = FALSE;
             }
         }
+        if ( !get_config_key( hkey, appkey, "hl2_disable_glsl", buffer, size) )
+        {
+            /* This allows disabling GLSL for single HL2 mods(they all use hl2.exe).
+             * It is important that this key is evaluated *after* the UseGLS one,
+             * otherwise the useGLSL key may overwrite decisions made here
+             */
+            char *token;
+            LPSTR cmdline;
+            cmdline = GetCommandLineA();
+            TRACE("Checking command line for disabling GLSL per HL2 mod\n");
+            token = strtok(buffer, ";");
+            while(token) {
+                TRACE("Looking for \"%s\"\n", token);
+                if(strstr(cmdline, token)) {
+                    TRACE("Disabling GLSL for this HL2 mod\n");
+                    wined3d_settings.glslRequested = FALSE;
+                    break;
+                }
+                token = strtok(NULL, ";");
+            }
+        }
         if ( !get_config_key( hkey, appkey, "OffscreenRenderingMode", buffer, size) )
         {
             if (!strcmp(buffer,"backbuffer"))
@@ -279,6 +320,14 @@
             else
                 ERR("VideoMemorySize is %i but must be >0\n", TmpVideoMemorySize);
         }
+        if ( !get_config_key( hkey, appkey, "enable_slow_blit", buffer, size) )
+        {
+            if (!strcmp(buffer,"enable"))
+            {
+                TRACE("Enabling slow pixel per pixel blits\n");
+                cxgames_hacks.enable_slow_blit = TRUE;
+            }
+        }
         if ( !get_config_key( hkey, appkey, "WineLogo", buffer, size) )
         {
             size_t len = strlen(buffer) + 1;
@@ -304,6 +353,31 @@
             TRACE("Enforcing strict draw ordering.\n");
             wined3d_settings.strict_draw_ordering = TRUE;
         }
+        if (!get_config_key_dword(hkey, appkey, "MaxVertexBlendMatrices", &tmpvalue))
+        {
+            TRACE("Using %u for MaxVertexBlendMatrices.\n", tmpvalue);
+            cxgames_hacks.max_vertex_blend_matrices = tmpvalue;
+        }
+        if ( !get_config_key( hkey, appkey, "SafeVsConsts", buffer, size) )
+        {
+            if (!strcmp(buffer,"enable"))
+            {
+                TRACE("Advertising only always available shader constants\n");
+                cxgames_hacks.safe_vs_consts = TRUE;
+            }
+        }
+        /* CodeWeavers HACK bug 10104 - Allow a registry key to dictate the number of vertex constants. */
+        if (!get_config_key(hkey, appkey, "fixed_vs_constants_limit", buffer, size))
+        {
+            int constants = atoi(buffer);
+            if (constants >= 0)
+            {
+                cxgames_hacks.fixed_vs_constants_limit = constants;
+                TRACE("Fixing # of GLSL vs constants at %d.\n", constants);
+            }
+            else
+                ERR("fixed_vs_constants_limit must be >= 0.\n");
+        }
         if (!get_config_key(hkey, appkey, "AlwaysOffscreen", buffer, size)
                 && !strcmp(buffer,"disabled"))
         {
@@ -334,7 +408,87 @@
             TRACE("Disabling 3D support.\n");
             wined3d_settings.no_3d = TRUE;
         }
+        if (!get_config_key(hkey, appkey, "CSMT", buffer, size)
+                && !strcmp(buffer,"disabled"))
+        {
+            TRACE("Disabling multithreaded command stream.\n");
+            wined3d_settings.cs_multithreaded = FALSE;
+        }
+        if (!get_config_key(hkey, appkey, "CSMTTextureOptimization", buffer, size))
+        {
+            if (wined3d_settings.cs_texture_optimization && !strcmp(buffer, "disabled"))
+            {
+                TRACE("Disabling CSMT texture maps optimization.\n");
+                wined3d_settings.cs_texture_optimization = FALSE;
+            }
+            if (!wined3d_settings.cs_texture_optimization && !strcmp(buffer, "enabled"))
+            {
+                TRACE("Enabling CSMT texture maps optimization.\n");
+                wined3d_settings.cs_texture_optimization = TRUE;
+            }
+        }
+        /* CodeWeavers Hack bug 5501 - Allow registry disabling of OpenGL extensions. */
+        if (!get_config_key(hkey, appkey, "DisabledExtensions", buffer, size))
+        {
+            size_t size = strlen(buffer) + 1;
+            cxgames_hacks.disabled_extensions = HeapAlloc(GetProcessHeap(), 0, size);
+            if (cxgames_hacks.disabled_extensions)
+                memcpy(cxgames_hacks.disabled_extensions, buffer, size);
+        }
+        if (!get_config_key( hkey, appkey, "pow_abs", buffer, size) )
+        {
+            if (!strcmp(buffer,"disabled"))
+            {
+                TRACE("Disabling the ABS operator on POW src arguments in ARB.\n");
+                cxgames_hacks.no_pow_abs = TRUE;
+            }
+        }
+        if (!get_config_key(hkey, appkey, "NoINTZ", buffer, size))
+        {
+            if (!strcmp(buffer, "enabled"))
+            {
+                TRACE("Disabling INTZ support.\n");
+                cxgames_hacks.no_intz = TRUE;
+            }
+        }
+        if (!get_config_key(hkey, appkey, "AllowGlMapBuffer", buffer, size))
+        {
+            if (!strcmp(buffer, "always"))
+            {
+                TRACE("Always using glMapBuffer if possible.\n");
+                cxgames_hacks.allow_glmapbuffer = WINED3D_MAPBUF_ALWAYS;
+            }
+            else if (!strcmp(buffer, "static"))
+            {
+                TRACE("Using glMapBuffer only for static buffers.\n");
+                cxgames_hacks.allow_glmapbuffer = WINED3D_MAPBUF_STATIC;
+            }
+            else if (!strcmp(buffer, "never"))
+            {
+                TRACE("Never using glMapBuffer.\n");
+                cxgames_hacks.allow_glmapbuffer = WINED3D_MAPBUF_NEVER;
+            }
+            else if (!strcmp(buffer, "never_nv"))
+            {
+                TRACE("Never using glMapBuffer if NVidia's threaded optimizations are used.\n");
+                cxgames_hacks.allow_glmapbuffer = WINED3D_MAPBUF_NEVER_NV;
+            }
+            else
+            {
+                TRACE("Using glMapBuffer only for static buffers\n");
+                TRACE("if NVidia's threaded optimizations are used.\n");
+            }
+        }
+        if (!get_config_key(hkey, appkey, "GLSL130SM4", buffer, size))
+        {
+            if (!strcmp(buffer, "enabled"))
+            {
+                TRACE("Enabling SM4 on GLSL 1.30.\n");
+                cxgames_hacks.glsl130_sm4 = TRUE;
+            }
+        }
     }
+    ERR_(winediag)("CSMT %s.\n", wined3d_settings.cs_multithreaded ? "enabled" : "disabled");
 
     if (appkey) RegCloseKey( appkey );
     if (hkey) RegCloseKey( hkey );
@@ -366,6 +520,7 @@
     HeapFree(GetProcessHeap(), 0, wndproc_table.entries);
 
     HeapFree(GetProcessHeap(), 0, wined3d_settings.logo);
+    HeapFree(GetProcessHeap(), 0, cxgames_hacks.disabled_extensions);
     UnregisterClassA(WINED3D_OPENGL_WINDOW_CLASS_NAME, hInstDLL);
 
     DeleteCriticalSection(&wined3d_wndproc_cs);
diff -Naur wine-2.0a/dlls/wined3d/wined3d_private.h wine-2.0b/dlls/wined3d/wined3d_private.h
--- wine-2.0a/dlls/wined3d/wined3d_private.h	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/wined3d/wined3d_private.h	2017-07-11 20:37:51.000000000 +0100
@@ -31,6 +31,7 @@
 #define WINE_GLAPI
 #endif
 
+#include <assert.h>
 #include <stdarg.h>
 #include <math.h>
 #include <limits.h>
@@ -72,6 +73,14 @@
 #define WINED3D_QUIRK_LIMITED_TEX_FILTERING     0x00000100
 #define WINED3D_QUIRK_BROKEN_ARB_FOG            0x00000200
 
+#define WINED3D_CX_QUIRK_APPLE_DOUBLE_BUFFER    0x00010000
+#define WINED3D_CX_QUIRK_GLSL_CLIP_BROKEN       0x00020000
+#define WINED3D_CX_QUIRK_TEXCOORD_FOG           0x00040000
+#define WINED3D_CX_QUIRK_BROKEN_ARA             0x00080000
+#define WINED3D_CX_QUIRK_BLIT                   0x00100000
+#define WINED3D_CX_QUIRK_RENDER_TO_FBO          0x00200000
+#define WINED3D_CX_QUIRK_BROKEN_ROUND           0x00400000
+
 /* Texture format fixups */
 
 enum fixup_channel_source
@@ -277,6 +286,13 @@
 #endif
 }
 
+static inline void wined3d_pause(void)
+{
+#if defined(__GNUC__) && (defined(__i386__) || defined(__x86_64__))
+    __asm__ __volatile__( "rep;nop" : : : "memory" );
+#endif
+}
+
 #define ORM_BACKBUFFER  0
 #define ORM_FBO         1
 
@@ -307,10 +323,38 @@
     unsigned int max_sm_ps;
     unsigned int max_sm_cs;
     BOOL no_3d;
+    BOOL cs_multithreaded;
+    BOOL cs_texture_optimization;
 };
 
 extern struct wined3d_settings wined3d_settings DECLSPEC_HIDDEN;
 
+enum wined3d_map_buffer_mode
+{
+    WINED3D_MAPBUF_ALWAYS,
+    WINED3D_MAPBUF_STATIC,
+    WINED3D_MAPBUF_NEVER,
+    WINED3D_MAPBUF_STATIC_NV,
+    WINED3D_MAPBUF_NEVER_NV
+};
+
+struct cxgames_hacks
+{
+    BOOL enable_slow_blit;
+    UINT max_vertex_blend_matrices;
+    BOOL safe_vs_consts;
+    /* CodeWeavers Hack bug 10104 - Allow registry to fix vs constants. */
+    UINT fixed_vs_constants_limit;
+    /* CodeWeavers Hack bug 5501 - Allow registry disabling of OpenGL extensions. */
+    char *disabled_extensions;
+    BOOL no_pow_abs;
+    BOOL no_intz;
+    enum wined3d_map_buffer_mode allow_glmapbuffer;
+    BOOL glsl130_sm4;
+};
+
+extern struct cxgames_hacks cxgames_hacks DECLSPEC_HIDDEN;
+
 enum wined3d_shader_resource_type
 {
     WINED3D_SHADER_RESOURCE_NONE,
@@ -1162,6 +1206,8 @@
     WORD                        np2_fixup;
     WORD shadow; /* MAX_FRAGMENT_SAMPLERS, 16 */
     WORD texcoords_initialized; /* MAX_TEXTURES, 8 */
+    /* Emulate clipping via KIL / discard. */
+    BOOL clip;
     DWORD pointsprite : 1;
     DWORD flatshading : 1;
     DWORD alpha_test_func : 3;
@@ -1438,7 +1484,7 @@
 struct wined3d_query_ops
 {
     BOOL (*query_poll)(struct wined3d_query *query, DWORD flags);
-    void (*query_issue)(struct wined3d_query *query, DWORD flags);
+    BOOL (*query_issue)(struct wined3d_query *query, DWORD flags);
 };
 
 struct wined3d_query
@@ -1451,7 +1497,11 @@
     enum wined3d_query_type type;
     const void *data;
     DWORD data_size;
+    DWORD flags;
     const struct wined3d_query_ops *query_ops;
+
+    LONG counter_main, counter_retrieved;
+    struct list poll_list_entry;
 };
 
 union wined3d_gl_query_object
@@ -1493,6 +1543,7 @@
     GLuint id;
     struct wined3d_context *context;
     UINT64 samples;
+    BOOL started;
 };
 
 struct wined3d_timestamp_query
@@ -2504,6 +2555,14 @@
     struct wined3d_rasterizer_state *rasterizer_state;
 };
 
+struct wined3d_gl_bo
+{
+    GLuint name;
+    GLenum usage;
+    GLenum type_hint;
+    UINT size;
+};
+
 #define WINED3D_UNMAPPED_STAGE ~0U
 
 /* Multithreaded flag. Removed from the public header to signal that
@@ -2553,19 +2612,17 @@
     struct wined3d_device_creation_parameters create_parms;
     HWND focus_window;
 
-    struct wined3d_rendertarget_view *back_buffer_view;
     struct wined3d_swapchain **swapchains;
     UINT swapchain_count;
 
+    struct wined3d_fb_state fb;
+    struct wined3d_rendertarget_view *back_buffer_view;
+    struct wined3d_rendertarget_view *auto_depth_stencil_view;
+
     struct list             resources; /* a linked list to track resources created by the device */
     struct list             shaders;   /* a linked list to track shaders (pixel and vertex)      */
     struct wine_rb_tree samplers;
 
-    /* Render Target Support */
-    struct wined3d_fb_state fb;
-    struct wined3d_surface *onscreen_depth_stencil;
-    struct wined3d_rendertarget_view *auto_depth_stencil_view;
-
     /* For rendering to a texture using glCopyTexImage */
     GLuint                  depth_blt_texture;
 
@@ -2615,9 +2672,16 @@
         UINT message, WPARAM wparam, LPARAM lparam, WNDPROC proc) DECLSPEC_HIDDEN;
 void device_resource_add(struct wined3d_device *device, struct wined3d_resource *resource) DECLSPEC_HIDDEN;
 void device_resource_released(struct wined3d_device *device, struct wined3d_resource *resource) DECLSPEC_HIDDEN;
-void device_switch_onscreen_ds(struct wined3d_device *device, struct wined3d_context *context,
-        struct wined3d_surface *depth_stencil) DECLSPEC_HIDDEN;
 void device_invalidate_state(const struct wined3d_device *device, DWORD state) DECLSPEC_HIDDEN;
+void device_exec_update_texture(struct wined3d_context *context, struct wined3d_texture *src_texture,
+        struct wined3d_texture *dst_texture) DECLSPEC_HIDDEN;
+struct wined3d_gl_bo *wined3d_device_get_bo(struct wined3d_device *device, UINT size, GLenum gl_usage,
+        GLenum type_hint, struct wined3d_context *context) DECLSPEC_HIDDEN;
+void wined3d_device_release_bo(struct wined3d_device *device, struct wined3d_gl_bo *bo,
+        const struct wined3d_context *context) DECLSPEC_HIDDEN;
+void device_create_dummy_textures(struct wined3d_device *device, struct wined3d_context *context) DECLSPEC_HIDDEN;
+void device_delete_opengl_contexts_cs(struct wined3d_device *device,
+        struct wined3d_swapchain *swapchain) DECLSPEC_HIDDEN;
 
 static inline BOOL isStateDirty(const struct wined3d_context *context, DWORD state)
 {
@@ -2626,6 +2690,11 @@
     return context->isStateDirty[idx] & (1u << shift);
 }
 
+static inline BOOL wined3d_use_csmt(const struct wined3d_device *device)
+{
+    return wined3d_settings.cs_multithreaded && !(device->wined3d->flags & WINED3D_NO_CSMT);
+}
+
 #define WINED3D_RESOURCE_ACCESS_GPU     0x1
 #define WINED3D_RESOURCE_ACCESS_CPU     0x2
 
@@ -2662,7 +2731,7 @@
     UINT depth;
     UINT size;
     DWORD priority;
-    void *heap_memory;
+    void *heap_memory, *map_heap_memory;
     struct list resource_list_entry;
     LONG access_count;
 
@@ -2691,9 +2760,9 @@
     InterlockedDecrement(&resource->access_count);
 }
 
-static inline void wined3d_resource_wait_idle(struct wined3d_resource *resource)
+static inline BOOL wined3d_resource_is_idle(const struct wined3d_resource *resource)
 {
-    while (InterlockedCompareExchange(&resource->access_count, 0, 0));
+    return !resource->access_count;
 }
 
 void resource_cleanup(struct wined3d_resource *resource) DECLSPEC_HIDDEN;
@@ -2770,6 +2839,7 @@
     DWORD flags;
     GLenum target;
     DWORD update_map_binding;
+    HRESULT dc_hr;
 
     GLuint rb_multisample;
     GLuint rb_resolved;
@@ -2806,7 +2876,8 @@
 
         unsigned int map_count;
         DWORD locations;
-        GLuint buffer_object;
+        struct wined3d_gl_bo *buffer, *map_buffer;
+        BOOL unmap_dirtify;
     } sub_resources[1];
 };
 
@@ -2857,11 +2928,17 @@
         struct wined3d_context *context, BOOL srgb) DECLSPEC_HIDDEN;
 void wined3d_texture_bind_and_dirtify(struct wined3d_texture *texture,
         struct wined3d_context *context, BOOL srgb) DECLSPEC_HIDDEN;
+void wined3d_texture_changed(struct wined3d_texture *texture,
+        unsigned int sub_resource_idx, struct wined3d_gl_bo *swap_buffer,
+        void *swap_heap_memory) DECLSPEC_HIDDEN;
 BOOL wined3d_texture_check_block_align(const struct wined3d_texture *texture,
         unsigned int level, const struct wined3d_box *box) DECLSPEC_HIDDEN;
+void wined3d_texture_get_dc_cs(struct wined3d_texture *texture, unsigned int sub_resource_idx) DECLSPEC_HIDDEN;
 GLenum wined3d_texture_get_gl_buffer(const struct wined3d_texture *texture) DECLSPEC_HIDDEN;
 void wined3d_texture_get_memory(struct wined3d_texture *texture, unsigned int sub_resource_idx,
-        struct wined3d_bo_address *data, DWORD locations) DECLSPEC_HIDDEN;
+        struct wined3d_bo_address *data, DWORD locations, BOOL map) DECLSPEC_HIDDEN;
+struct wined3d_texture_sub_resource *wined3d_texture_get_sub_resource(struct wined3d_texture *texture,
+        unsigned int sub_resource_idx) DECLSPEC_HIDDEN;
 void wined3d_texture_invalidate_location(struct wined3d_texture *texture,
         unsigned int sub_resource_idx, DWORD location) DECLSPEC_HIDDEN;
 void wined3d_texture_load(struct wined3d_texture *texture,
@@ -2874,6 +2951,8 @@
         struct wined3d_context *context, DWORD location) DECLSPEC_HIDDEN;
 void wined3d_texture_prepare_texture(struct wined3d_texture *texture,
         struct wined3d_context *context, BOOL srgb) DECLSPEC_HIDDEN;
+void wined3d_texture_release_dc_cs(struct wined3d_texture *texture,
+        unsigned int sub_resource_idx) DECLSPEC_HIDDEN;
 void wined3d_texture_set_map_binding(struct wined3d_texture *texture, DWORD map_binding) DECLSPEC_HIDDEN;
 void wined3d_texture_set_swapchain(struct wined3d_texture *texture,
         struct wined3d_swapchain *swapchain) DECLSPEC_HIDDEN;
@@ -2996,6 +3075,9 @@
 void wined3d_surface_upload_data(struct wined3d_surface *surface, const struct wined3d_gl_info *gl_info,
         const struct wined3d_format *format, const RECT *src_rect, UINT src_pitch, const POINT *dst_point,
         BOOL srgb, const struct wined3d_const_bo_address *data) DECLSPEC_HIDDEN;
+void surface_blt_ugly(struct wined3d_surface *dst_surface, const RECT *dst_rect_in,
+        struct wined3d_surface *src_surface, const RECT *src_rect_in, DWORD flags,
+        const struct wined3d_blt_fx *fx, enum wined3d_texture_filter_type filter) DECLSPEC_HIDDEN;
 
 void draw_textured_quad(const struct wined3d_surface *src_surface, struct wined3d_context *context,
         const RECT *src_rect, const RECT *dst_rect, enum wined3d_texture_filter_type filter) DECLSPEC_HIDDEN;
@@ -3010,6 +3092,8 @@
     GLuint name;
 };
 
+void wined3d_sampler_init(struct wined3d_sampler *sampler) DECLSPEC_HIDDEN;
+
 struct wined3d_vertex_declaration_element
 {
     const struct wined3d_format *format;
@@ -3120,12 +3204,29 @@
     WINED3D_PUSH_CONSTANTS_PS_B,
 };
 
+#if defined(_WIN64)
+#define WINED3D_CS_QUEUE_SIZE 0x1000000
+#else
+#define WINED3D_CS_QUEUE_SIZE 0x100000
+#endif
+#define WINED3D_CS_SPIN_COUNT 10000000
+
+struct wined3d_cs_queue
+{
+    LONG head, tail;
+    BYTE data[WINED3D_CS_QUEUE_SIZE];
+};
+
 struct wined3d_cs_ops
 {
-    void *(*require_space)(struct wined3d_cs *cs, size_t size);
+    void *(*require_space)(struct wined3d_cs *cs, unsigned int size);
+    void *(*require_space_prio)(struct wined3d_cs *cs, unsigned int size);
     void (*submit)(struct wined3d_cs *cs);
+    void (*submit_prio)(struct wined3d_cs *cs);
     void (*push_constants)(struct wined3d_cs *cs, enum wined3d_push_constants p,
             unsigned int start_idx, unsigned int count, const void *constants);
+    void (*finish)(struct wined3d_cs *cs);
+    void (*finish_prio)(struct wined3d_cs *cs);
 };
 
 struct wined3d_cs
@@ -3134,25 +3235,59 @@
     struct wined3d_device *device;
     struct wined3d_fb_state fb;
     struct wined3d_state state;
+    HANDLE thread;
+    DWORD thread_id;
+    struct wined3d_surface *onscreen_depth_stencil;
 
-    size_t data_size;
+    struct wined3d_cs_queue queue, prio_queue;
+    unsigned int data_size, start, end;
     void *data;
+    struct list query_poll_list;
+
+    HANDLE event;
+    BOOL waiting_for_event;
+    LONG pending_presents;
 };
 
 struct wined3d_cs *wined3d_cs_create(struct wined3d_device *device) DECLSPEC_HIDDEN;
 void wined3d_cs_destroy(struct wined3d_cs *cs) DECLSPEC_HIDDEN;
+void wined3d_cs_switch_onscreen_ds(struct wined3d_cs *cs, struct wined3d_context *context,
+        struct wined3d_surface *depth_stencil) DECLSPEC_HIDDEN;
 
+void wined3d_cs_emit_blt(struct wined3d_cs *cs, struct wined3d_surface *dst_surface,
+        const RECT *dst_rect, struct wined3d_surface *src_surface,
+        const RECT *src_rect, DWORD flags, const struct wined3d_blt_fx *fx,
+        enum wined3d_texture_filter_type filter) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_buffer_invalidate_bo_range(struct wined3d_cs *cs,
+        struct wined3d_buffer *buffer, unsigned int offset, unsigned int size) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_buffer_swap_mem(struct wined3d_cs *cs, struct wined3d_buffer *buffer,
+        BYTE *mem) DECLSPEC_HIDDEN;
 void wined3d_cs_emit_clear(struct wined3d_cs *cs, DWORD rect_count, const RECT *rects,
         DWORD flags, const struct wined3d_color *color, float depth, DWORD stencil) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_clear_rtv(struct wined3d_cs *cs, struct wined3d_rendertarget_view *view,
+        const RECT *rect, DWORD flags, const struct wined3d_color *color, float depth, DWORD stencil,
+        const struct blit_shader *blitter) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_create_dummy_textures(struct wined3d_cs *cs) DECLSPEC_HIDDEN;
+HRESULT wined3d_cs_emit_create_swapchain_context(struct wined3d_cs *cs,
+        struct wined3d_swapchain *swapchain) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_create_vbo(struct wined3d_cs *cs, struct wined3d_buffer *buffer) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_delete_opengl_contexts(struct wined3d_cs *cs,
+        struct wined3d_swapchain *swapchain) DECLSPEC_HIDDEN;
 void wined3d_cs_emit_destroy_object(struct wined3d_cs *cs,
         void (*callback)(void *object), void *object) DECLSPEC_HIDDEN;
 void wined3d_cs_emit_draw(struct wined3d_cs *cs, int base_vertex_idx, unsigned int start_idx, unsigned int index_count,
         unsigned int start_instance, unsigned int instance_count, BOOL indexed) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_get_dc(struct wined3d_cs *cs, struct wined3d_texture *texture,
+        unsigned int sub_resource_idx) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_glfinish(struct wined3d_cs *cs) DECLSPEC_HIDDEN;
 void wined3d_cs_emit_preload_resource(struct wined3d_cs *cs, struct wined3d_resource *resource) DECLSPEC_HIDDEN;
 void wined3d_cs_emit_present(struct wined3d_cs *cs, struct wined3d_swapchain *swapchain,
         const RECT *src_rect, const RECT *dst_rect, HWND dst_window_override, DWORD flags) DECLSPEC_HIDDEN;
 void wined3d_cs_emit_query_issue(struct wined3d_cs *cs, struct wined3d_query *query, DWORD flags) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_release_dc(struct wined3d_cs *cs, struct wined3d_texture *texture,
+        unsigned int sub_resource_idx) DECLSPEC_HIDDEN;
 void wined3d_cs_emit_reset_state(struct wined3d_cs *cs) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_sampler_init(struct wined3d_cs *cs, struct wined3d_sampler *sampler) DECLSPEC_HIDDEN;
 void wined3d_cs_emit_set_clip_plane(struct wined3d_cs *cs, UINT plane_idx,
         const struct wined3d_vec4 *plane) DECLSPEC_HIDDEN;
 void wined3d_cs_emit_set_color_key(struct wined3d_cs *cs, struct wined3d_texture *texture,
@@ -3163,9 +3298,12 @@
         struct wined3d_rendertarget_view *view) DECLSPEC_HIDDEN;
 void wined3d_cs_emit_set_index_buffer(struct wined3d_cs *cs, struct wined3d_buffer *buffer,
         enum wined3d_format_id format_id, unsigned int offset) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_set_light(struct wined3d_cs *cs, const struct wined3d_light_info *light) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_set_light_enable(struct wined3d_cs *cs, unsigned int idx, BOOL enable) DECLSPEC_HIDDEN;
 void wined3d_cs_emit_set_material(struct wined3d_cs *cs, const struct wined3d_material *material) DECLSPEC_HIDDEN;
 void wined3d_cs_emit_set_predication(struct wined3d_cs *cs,
         struct wined3d_query *predicate, BOOL value) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_set_primitive_type(struct wined3d_cs *cs, GLenum primitive_type) DECLSPEC_HIDDEN;
 void wined3d_cs_emit_set_rasterizer_state(struct wined3d_cs *cs,
         struct wined3d_rasterizer_state *rasterizer_state) DECLSPEC_HIDDEN;
 void wined3d_cs_emit_set_render_state(struct wined3d_cs *cs,
@@ -3197,7 +3335,16 @@
 void wined3d_cs_emit_set_vertex_declaration(struct wined3d_cs *cs,
         struct wined3d_vertex_declaration *declaration) DECLSPEC_HIDDEN;
 void wined3d_cs_emit_set_viewport(struct wined3d_cs *cs, const struct wined3d_viewport *viewport) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_texture_changed(struct wined3d_cs *cs, struct wined3d_texture *texture,
+        unsigned int sub_resource_idx, struct wined3d_gl_bo *swap_buffer,
+        void *swap_heap_memory) DECLSPEC_HIDDEN;
 void wined3d_cs_emit_unload_resource(struct wined3d_cs *cs, struct wined3d_resource *resource) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_update_sub_resource(struct wined3d_cs *cs, struct wined3d_resource *resource,
+        unsigned int sub_resource_idx, const struct wined3d_box *box, const void *data, unsigned int row_pitch,
+        unsigned int slice_pitch) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_update_swap_interval(struct wined3d_cs *cs, struct wined3d_swapchain *swapchain) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_update_texture(struct wined3d_cs *cs, struct wined3d_texture *src,
+        struct wined3d_texture *dst) DECLSPEC_HIDDEN;
 HRESULT wined3d_cs_map(struct wined3d_cs *cs, struct wined3d_resource *resource, unsigned int sub_resource_idx,
         struct wined3d_map_desc *map_desc, const struct wined3d_box *box, unsigned int flags) DECLSPEC_HIDDEN;
 HRESULT wined3d_cs_unmap(struct wined3d_cs *cs, struct wined3d_resource *resource,
@@ -3209,6 +3356,23 @@
     cs->ops->push_constants(cs, p, start_idx, count, constants);
 }
 
+static inline void wined3d_resource_wait_idle(struct wined3d_resource *resource)
+{
+    if (!wined3d_use_csmt(resource->device) || resource->device->cs->thread_id == GetCurrentThreadId())
+        return;
+
+    while (InterlockedCompareExchange(&resource->access_count, 0, 0))
+        wined3d_pause();
+}
+
+#define WINED3D_BUFFER_HASDESC      0x01    /* A vertex description has been found. */
+#define WINED3D_BUFFER_USE_BO       0x02    /* Use a buffer object for this buffer. */
+#define WINED3D_BUFFER_DOUBLEBUFFER 0x04    /* Keep both a buffer object and a system memory copy for this buffer. */
+#define WINED3D_BUFFER_DISCARD      0x08    /* The next PreLoad may discard the buffer contents. */
+#define WINED3D_BUFFER_SYNC         0x10    /* There has been at least one synchronized map since the last preload. */
+#define WINED3D_BUFFER_MAP          0x20    /* There has been at least one map since the last preload. */
+#define WINED3D_BUFFER_APPLESYNC    0x40    /* Using sync as in GL_APPLE_flush_buffer_range. */
+
 /* TODO: Add tests and support for FLOAT16_4 POSITIONT, D3DCOLOR position, other
  * fixed function semantics as D3DCOLOR or FLOAT16 */
 enum wined3d_buffer_conversion_type
@@ -3235,6 +3399,7 @@
     GLenum buffer_type_hint;
     unsigned int bind_flags;
     DWORD flags;
+    BOOL ignore_discard;
     void *map_ptr;
 
     struct wined3d_map_range *maps;
@@ -3255,7 +3420,9 @@
     return CONTAINING_RECORD(resource, struct wined3d_buffer, resource);
 }
 
-void buffer_mark_used(struct wined3d_buffer *buffer) DECLSPEC_HIDDEN;
+BOOL buffer_create_buffer_object(struct wined3d_buffer *buffer, struct wined3d_context *context) DECLSPEC_HIDDEN;
+void buffer_invalidate_bo_range(struct wined3d_buffer *buffer, unsigned int offset, unsigned int size) DECLSPEC_HIDDEN;
+void buffer_swap_mem(struct wined3d_buffer *buffer, BYTE *mem) DECLSPEC_HIDDEN;
 DWORD wined3d_buffer_get_memory(struct wined3d_buffer *buffer,
         struct wined3d_bo_address *data, DWORD locations) DECLSPEC_HIDDEN;
 void wined3d_buffer_invalidate_location(struct wined3d_buffer *buffer, DWORD location) DECLSPEC_HIDDEN;
@@ -3379,6 +3546,8 @@
 
 void wined3d_swapchain_activate(struct wined3d_swapchain *swapchain, BOOL activate) DECLSPEC_HIDDEN;
 struct wined3d_context *swapchain_get_context(struct wined3d_swapchain *swapchain) DECLSPEC_HIDDEN;
+HRESULT swapchain_create_context_cs(struct wined3d_device *device,
+        struct wined3d_swapchain *swapchain) DECLSPEC_HIDDEN;
 void swapchain_destroy_contexts(struct wined3d_swapchain *swapchain) DECLSPEC_HIDDEN;
 HDC swapchain_get_backup_dc(struct wined3d_swapchain *swapchain) DECLSPEC_HIDDEN;
 void swapchain_update_draw_bindings(struct wined3d_swapchain *swapchain) DECLSPEC_HIDDEN;
@@ -3873,4 +4042,28 @@
 
 #define MAKEDWORD_VERSION(maj, min) (((maj & 0xffffu) << 16) | (min & 0xffffu))
 
+static inline void wined3d_set_fpu_cw(WORD cw)
+{
+#if defined(__GNUC__) && (defined(__i386__) || defined(__x86_64__))
+    __asm__ volatile ("fnclex");
+    __asm__ volatile ("fldcw %0" : : "m" (cw));
+#elif defined(__i386__) && defined(_MSC_VER)
+    __asm fnclex;
+    __asm fldcw cw;
+#endif
+}
+
+static inline WORD wined3d_get_fpu_cw(void)
+{
+    WORD cw = 0;
+#if defined(__GNUC__) && (defined(__i386__) || defined(__x86_64__))
+    __asm__ volatile ("fnstcw %0" : "=m" (cw));
+#elif defined(__i386__) && defined(_MSC_VER)
+    __asm fnstcw cw;
+#endif
+    return cw;
+}
+
+#define WINED3D_DEFAULT_FPU_CW 0x037f
+
 #endif
diff -Naur wine-2.0a/dlls/winejoystick.drv/joystick_driver.c wine-2.0b/dlls/winejoystick.drv/joystick_driver.c
--- wine-2.0a/dlls/winejoystick.drv/joystick_driver.c	1970-01-01 01:00:00.000000000 +0100
+++ wine-2.0b/dlls/winejoystick.drv/joystick_driver.c	2017-07-11 20:37:51.000000000 +0100
@@ -0,0 +1,504 @@
+/*
+ * Joystick functions using the Graphics Driver
+ *
+ * Copyright 2015 Aric Stewart
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ *
+ */
+
+#include "config.h"
+#include "wine/port.h"
+
+#ifndef HAVE_LINUX_JOYSTICK_H
+#if !defined(HAVE_IOKIT_HID_IOHIDLIB_H)
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <fcntl.h>
+#include <errno.h>
+
+#include "joystick.h"
+
+#include "winbase.h"
+#include "winreg.h"
+#include "wingdi.h"
+#include "winnls.h"
+#include "winternl.h"
+#include "wine/debug.h"
+
+#include "wine/unicode.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(joystick);
+
+#define MAXJOYSTICK (JOYSTICKID2 + 30)
+
+typedef struct tagGAMEPAD_DRIVER {
+    INT (CDECL *pGamePadCount)(void);
+    VOID (CDECL *pGamePadName)(int id, char *name, int length);
+    VOID (CDECL *pGamePadElementCount)(int id, DWORD *axis, DWORD *buttons, DWORD* povs, int axis_map[8]);
+    VOID (CDECL *pGamePadElementProps)(int id, int element, int *min, int *max);
+    VOID (CDECL *pGamePadPollValues)(int id, int *values);
+    BOOL (CDECL *pGamePadAlloc)(int id);
+    VOID (CDECL *pGamePadDealloc)(int id);
+} GAMEPAD_DRIVER;
+
+static GAMEPAD_DRIVER null_driver, lazy_load_driver;
+
+const GAMEPAD_DRIVER *GAMEPAD_Driver = &lazy_load_driver;
+
+enum { DRIVER_AXIS_X = 0,
+       DRIVER_AXIS_Y,
+       DRIVER_AXIS_Z,
+       DRIVER_AXIS_RX,
+       DRIVER_AXIS_RY,
+       DRIVER_AXIS_RZ,
+       NUM_AXES};
+
+struct axis {
+    int min_value, max_value;
+    int value_index;
+};
+
+typedef struct tagWINE_JSTCK {
+    int   joyIntf;
+    BOOL  in_use;
+
+    DWORD nrOfAxes;
+    DWORD nrOfButtons;
+    DWORD nrOfPOVs;
+    struct axis   axes[NUM_AXES];
+    int   values[512];
+} WINE_JSTCK;
+
+static  WINE_JSTCK  JSTCK_Data[MAXJOYSTICK];
+
+/**************************************************************************
+ *  JSTCK_drvGet    [internal]
+ */
+static WINE_JSTCK *JSTCK_drvGet(DWORD_PTR dwDevID)
+{
+    int	p;
+
+    if ((dwDevID - (DWORD_PTR)JSTCK_Data) % sizeof(JSTCK_Data[0]) != 0)
+        return NULL;
+    p = (dwDevID - (DWORD_PTR)JSTCK_Data) / sizeof(JSTCK_Data[0]);
+    if (p < 0 || p >= MAXJOYSTICK || !((WINE_JSTCK*)dwDevID)->in_use)
+        return NULL;
+
+    return (WINE_JSTCK*)dwDevID;
+}
+
+/**************************************************************************
+ *  driver_open
+ */
+LRESULT driver_open(LPSTR str, DWORD dwIntf)
+{
+    if (dwIntf >= MAXJOYSTICK || JSTCK_Data[dwIntf].in_use)
+        return 0;
+    if (dwIntf >= GAMEPAD_Driver->pGamePadCount())
+        return 0;
+
+    if (!GAMEPAD_Driver->pGamePadAlloc(dwIntf))
+    {
+        WARN("Driver gamepad alloc failed\n");
+        return 0;
+    }
+    JSTCK_Data[dwIntf].joyIntf = dwIntf;
+    JSTCK_Data[dwIntf].in_use = TRUE;
+    return (LRESULT)&JSTCK_Data[dwIntf];
+}
+
+/**************************************************************************
+ *  driver_close
+ */
+LRESULT driver_close(DWORD_PTR dwDevID)
+{
+    WINE_JSTCK* jstck = JSTCK_drvGet(dwDevID);
+
+    if (jstck == NULL)
+        return 0;
+    GAMEPAD_Driver->pGamePadDealloc(jstck->joyIntf);
+    jstck->in_use = FALSE;
+    return 1;
+}
+
+/**************************************************************************
+ * JoyGetDevCaps    [MMSYSTEM.102]
+ */
+LRESULT driver_joyGetDevCaps(DWORD_PTR dwDevID, LPJOYCAPSW lpCaps, DWORD dwSize)
+{
+    WINE_JSTCK* jstck;
+    char    identString[MAXPNAMELEN];
+    int     i;
+    int     axesMap[8];
+
+    if ((jstck = JSTCK_drvGet(dwDevID)) == NULL)
+        return MMSYSERR_NODRIVER;
+
+    GAMEPAD_Driver->pGamePadElementCount(jstck->joyIntf, &jstck->nrOfAxes,
+        &jstck->nrOfButtons, &jstck->nrOfPOVs, axesMap);
+    GAMEPAD_Driver->pGamePadName(jstck->joyIntf, identString, MAXPNAMELEN);
+    TRACE("Name: %s, #Axes: %d, #Buttons: %d\n",
+      identString, jstck->nrOfAxes, jstck->nrOfButtons);
+
+    memset(jstck->values, 0, sizeof(jstck->values));
+
+    lpCaps->wMid = MM_MICROSOFT;
+    lpCaps->wPid = MM_PC_JOYSTICK;
+    MultiByteToWideChar(CP_UNIXCP, 0, identString, -1, lpCaps->szPname, MAXPNAMELEN);
+    lpCaps->szPname[MAXPNAMELEN-1] = '\0';
+    lpCaps->wXmin = 0;
+    lpCaps->wXmax = 0xFFFF;
+    lpCaps->wYmin = 0;
+    lpCaps->wYmax = 0xFFFF;
+    lpCaps->wZmin = 0;
+    lpCaps->wZmax = (jstck->nrOfAxes >= 3) ? 0xFFFF : 0;
+    lpCaps->wNumButtons = jstck->nrOfButtons;
+    if (dwSize == sizeof(JOYCAPSW)) {
+        /* complete 95 structure */
+        lpCaps->wRmin = 0;
+        lpCaps->wRmax = 0xFFFF;
+        lpCaps->wUmin = 0;
+        lpCaps->wUmax = 0xFFFF;
+        lpCaps->wVmin = 0;
+        lpCaps->wVmax = 0xFFFF;
+        lpCaps->wMaxAxes = 6; /* same as MS Joystick Driver */
+        lpCaps->wNumAxes = 0; /* nr of axes in use */
+        lpCaps->wMaxButtons = 32; /* same as MS Joystick Driver */
+        lpCaps->szRegKey[0] = 0;
+        lpCaps->szOEMVxD[0] = 0;
+        lpCaps->wCaps = 0;
+
+        /* blank out the axes */
+        for (i = 0; i < NUM_AXES; i++)
+            jstck->axes[i].value_index = -1;
+
+        for (i = 0; i < jstck->nrOfAxes; i++) {
+            if (axesMap[i] < NUM_AXES)
+            {
+                int idx = axesMap[i];
+                jstck->axes[idx].value_index = i;
+                GAMEPAD_Driver->pGamePadElementProps(jstck->joyIntf, i,
+                    &jstck->axes[idx].min_value, &jstck->axes[idx].max_value);
+            }
+            switch (axesMap[i]) {
+                case DRIVER_AXIS_X:
+                case DRIVER_AXIS_Y:
+                    lpCaps->wNumAxes++;
+                    break;
+                case DRIVER_AXIS_Z:
+                    lpCaps->wNumAxes++;
+                    lpCaps->wCaps |= JOYCAPS_HASZ;
+                    break;
+                case DRIVER_AXIS_RZ:
+                    lpCaps->wNumAxes++;
+                    lpCaps->wCaps |= JOYCAPS_HASR;
+                    break;
+                case DRIVER_AXIS_RX:
+                    lpCaps->wNumAxes++;
+                    lpCaps->wCaps |= JOYCAPS_HASU;
+                    break;
+                case DRIVER_AXIS_RY:
+                    lpCaps->wNumAxes++;
+                    lpCaps->wCaps |= JOYCAPS_HASV;
+                    break;
+                default:
+                    WARN("Unknown axis %i(%u). Skipped.\n", axesMap[i], i);
+            }
+        }
+        if (jstck->nrOfPOVs > 0)
+            lpCaps->wCaps |= JOYCAPS_HASPOV | JOYCAPS_POV4DIR;
+    }
+
+    return JOYERR_NOERROR;
+}
+
+/**************************************************************************
+ *  driver_joyGetPos
+ */
+LRESULT driver_joyGetPosEx(DWORD_PTR dwDevID, LPJOYINFOEX lpInfo)
+{
+    static const struct {
+        DWORD flag;
+        off_t offset;
+    } axis_map[NUM_AXES] = {
+        { JOY_RETURNX, FIELD_OFFSET(JOYINFOEX, dwXpos) },
+        { JOY_RETURNY, FIELD_OFFSET(JOYINFOEX, dwYpos) },
+        { JOY_RETURNZ, FIELD_OFFSET(JOYINFOEX, dwZpos) },
+        { JOY_RETURNU, FIELD_OFFSET(JOYINFOEX, dwUpos) },
+        { JOY_RETURNV, FIELD_OFFSET(JOYINFOEX, dwVpos) },
+        { JOY_RETURNR, FIELD_OFFSET(JOYINFOEX, dwRpos) },
+    };
+
+    WINE_JSTCK* jstck;
+    int i;
+
+    if ((jstck = JSTCK_drvGet(dwDevID)) == NULL)
+        return MMSYSERR_NODRIVER;
+
+    GAMEPAD_Driver->pGamePadPollValues(jstck->joyIntf, jstck->values);
+
+    if (lpInfo->dwFlags & JOY_RETURNBUTTONS)
+    {
+        lpInfo->dwButtonNumber = 0;
+        lpInfo->dwButtons = 0x0;
+        for (i = 0; i < jstck->nrOfButtons; i++)
+        {
+            int data_index = jstck->nrOfAxes + (jstck->nrOfPOVs*2) + i;
+            if (jstck->values[data_index]) {
+                lpInfo->dwButtons |= (1 << i);
+                lpInfo->dwButtonNumber++;
+            }
+        }
+    }
+
+    for (i = 0; i < NUM_AXES; i++)
+    {
+        if (lpInfo->dwFlags & axis_map[i].flag)
+        {
+            DWORD* field = (DWORD*)((char*)lpInfo + axis_map[i].offset);
+            if (jstck->axes[i].value_index >= 0)
+            {
+                int dev_value = jstck->values[jstck->axes[i].value_index];
+                int value = dev_value - jstck->axes[i].min_value;
+                *field = MulDiv(value, 0xFFFF, jstck->axes[i].max_value - jstck->axes[i].min_value);
+            }
+            else
+            {
+                *field = 0;
+                lpInfo->dwFlags &= ~axis_map[i].flag;
+            }
+        }
+    }
+
+
+    if (lpInfo->dwFlags & JOY_RETURNPOV && jstck->nrOfPOVs > 0) {
+    int pov_data_index_x = jstck->nrOfAxes;
+    int pov_data_index_y = jstck->nrOfAxes+1;
+    if (jstck->values[pov_data_index_y]> 0) {
+        if (jstck->values[pov_data_index_x]< 0)
+            lpInfo->dwPOV = 22500; /* SW */
+        else if (jstck->values[pov_data_index_x]> 0)
+            lpInfo->dwPOV = 13500; /* SE */
+        else
+            lpInfo->dwPOV = 18000; /* S, JOY_POVBACKWARD */
+    } else if (jstck->values[pov_data_index_y]< 0) {
+        if (jstck->values[pov_data_index_x]< 0)
+            lpInfo->dwPOV = 31500; /* NW */
+        else if (jstck->values[pov_data_index_x]> 0)
+            lpInfo->dwPOV = 4500; /* NE */
+        else
+            lpInfo->dwPOV = 0; /* N, JOY_POVFORWARD */
+    } else if (jstck->values[pov_data_index_x]< 0)
+        lpInfo->dwPOV = 27000; /* W, JOY_POVLEFT */
+    else if (jstck->values[pov_data_index_x]> 0)
+        lpInfo->dwPOV = 9000; /* E, JOY_POVRIGHT */
+    else
+        lpInfo->dwPOV = JOY_POVCENTERED; /* Center */
+    }
+
+    TRACE("x: %d, y: %d, z: %d, r: %d, u: %d, v: %d, buttons: 0x%04x, flags: 0x%04x\n",
+      lpInfo->dwXpos, lpInfo->dwYpos, lpInfo->dwZpos,
+      lpInfo->dwRpos, lpInfo->dwUpos, lpInfo->dwVpos,
+      lpInfo->dwButtons, lpInfo->dwFlags);
+
+    return JOYERR_NOERROR;
+}
+
+/**************************************************************************
+ * driver_joyGetPos
+ */
+LRESULT driver_joyGetPos(DWORD_PTR dwDevID, LPJOYINFO lpInfo)
+{
+    JOYINFOEX   ji;
+    LONG        ret;
+
+    memset(&ji, 0, sizeof(ji));
+
+    ji.dwSize = sizeof(ji);
+    ji.dwFlags = JOY_RETURNX | JOY_RETURNY | JOY_RETURNZ | JOY_RETURNBUTTONS;
+    ret = driver_joyGetPosEx(dwDevID, &ji);
+    if (ret == JOYERR_NOERROR)  {
+        lpInfo->wXpos    = ji.dwXpos;
+        lpInfo->wYpos    = ji.dwYpos;
+        lpInfo->wZpos    = ji.dwZpos;
+        lpInfo->wButtons = ji.dwButtons;
+    }
+
+    return ret;
+}
+
+static HMODULE load_graphics_driver(void)
+{
+    static const WCHAR display_device_guid_propW[] = {
+        '_','_','w','i','n','e','_','d','i','s','p','l','a','y','_',
+        'd','e','v','i','c','e','_','g','u','i','d',0 };
+    static const WCHAR key_pathW[] = {
+        'S','y','s','t','e','m','\\',
+        'C','u','r','r','e','n','t','C','o','n','t','r','o','l','S','e','t','\\',
+        'C','o','n','t','r','o','l','\\',
+        'V','i','d','e','o','\\','{',0};
+    static const WCHAR displayW[] = {'}','\\','0','0','0','0',0};
+    static const WCHAR driverW[] = {'G','r','a','p','h','i','c','s','D','r','i','v','e','r',0};
+
+    HMODULE ret = 0;
+    HKEY hkey;
+    DWORD size;
+    WCHAR path[MAX_PATH];
+    WCHAR key[(sizeof(key_pathW) + sizeof(displayW)) / sizeof(WCHAR) + 40];
+    UINT guid_atom = HandleToULong( GetPropW( GetDesktopWindow(), display_device_guid_propW ));
+
+    if (!guid_atom) return 0;
+    memcpy( key, key_pathW, sizeof(key_pathW) );
+    if (!GlobalGetAtomNameW( guid_atom, key + strlenW(key), 40 )) return 0;
+    strcatW( key, displayW );
+    if (RegOpenKeyW( HKEY_LOCAL_MACHINE, key, &hkey )) return 0;
+    size = sizeof(path);
+    if (!RegQueryValueExW( hkey, driverW, NULL, NULL, (BYTE *)path, &size )) ret = LoadLibraryW( path );
+    RegCloseKey( hkey );
+    TRACE( "%s %p\n", debugstr_w(path), ret );
+
+    return ret;
+}
+
+static const GAMEPAD_DRIVER *load_driver(void)
+{
+    void *ptr;
+    HMODULE graphics_driver;
+    GAMEPAD_DRIVER *driver, *prev;
+
+    driver = HeapAlloc( GetProcessHeap(), 0 , sizeof(*driver) );
+    *driver = null_driver;
+
+    graphics_driver = load_graphics_driver();
+    if (graphics_driver)
+    {
+#define GET_USER_FUNC(name) \
+    do { if ((ptr = GetProcAddress( graphics_driver, #name ))) driver->p##name = ptr; } while(0)
+    GET_USER_FUNC(GamePadCount);
+    GET_USER_FUNC(GamePadName);
+    GET_USER_FUNC(GamePadElementCount);
+    GET_USER_FUNC(GamePadElementProps);
+    GET_USER_FUNC(GamePadPollValues);
+    GET_USER_FUNC(GamePadAlloc);
+    GET_USER_FUNC(GamePadDealloc);
+#undef GET_USER_FUNC
+    }
+
+    prev = InterlockedCompareExchangePointer( (void **)&GAMEPAD_Driver, driver, &lazy_load_driver );
+    if (prev != &lazy_load_driver)
+    {
+        /* another thread beat us to it */
+        HeapFree( GetProcessHeap(), 0, driver);
+        driver = prev;
+    }
+    else
+        LdrAddRefDll(0, graphics_driver);
+
+    return driver;
+}
+
+static INT CDECL loaderdrv_GamePadCount(void)
+{
+    return load_driver()->pGamePadCount();
+}
+
+static VOID CDECL loaderdrv_GamePadName(int id, char *name, int length)
+{
+    load_driver()->pGamePadName(id, name, length);
+}
+
+static VOID CDECL loaderdrv_GamePadElementCount(int id, DWORD *axis, DWORD *buttons, DWORD *povs, int axis_map[8])
+{
+    load_driver()->pGamePadElementCount(id, axis, buttons, povs, axis_map);
+}
+
+static VOID CDECL loaderdrv_GamePadElementProps(int id, int element, int *min, int* max)
+{
+    load_driver()->pGamePadElementProps(id, element, min, max);
+}
+
+static VOID CDECL loaderdrv_GamePadPollValues(int id, int* values)
+{
+    load_driver()->pGamePadPollValues(id, values);
+}
+
+static BOOL CDECL loaderdrv_GamePadAlloc(int id)
+{
+    return load_driver()->pGamePadAlloc(id);
+}
+
+static VOID CDECL loaderdrv_GamePadDealloc(int id)
+{
+    load_driver()->pGamePadDealloc(id);
+}
+
+static GAMEPAD_DRIVER lazy_load_driver =
+{
+    loaderdrv_GamePadCount,
+    loaderdrv_GamePadName,
+    loaderdrv_GamePadElementCount,
+    loaderdrv_GamePadElementProps,
+    loaderdrv_GamePadPollValues,
+    loaderdrv_GamePadAlloc,
+    loaderdrv_GamePadDealloc
+};
+
+static INT CDECL nulldrv_GamePadCount(void)
+{
+    return 0;
+}
+
+static VOID CDECL nulldrv_GamePadName(int id, char *name, int length)
+{
+}
+
+static VOID CDECL nulldrv_GamePadElementCount(int id, DWORD *axis, DWORD *buttons, DWORD *povs, int axis_map[8])
+{
+}
+
+static VOID CDECL nulldrv_GamePadElementProps(int id, int element, int *min, int* max)
+{
+}
+
+static VOID CDECL nulldrv_GamePadPollValues(int id, int* values)
+{
+}
+
+static BOOL CDECL nulldrv_GamePadAlloc(int id)
+{
+    return TRUE;
+}
+
+static VOID CDECL nulldrv_GamePadDealloc(int id)
+{
+}
+
+
+static GAMEPAD_DRIVER null_driver =
+{
+    nulldrv_GamePadCount,
+    nulldrv_GamePadName,
+    nulldrv_GamePadElementCount,
+    nulldrv_GamePadElementProps,
+    nulldrv_GamePadPollValues,
+    nulldrv_GamePadAlloc,
+    nulldrv_GamePadDealloc
+};
+
+#endif /* HAVE_LINUX_JOYSTICK_H */
+#endif /* HAVE_IOKIT_HID_IOHIDLIB_H */
diff -Naur wine-2.0a/dlls/winejoystick.drv/Makefile.in wine-2.0b/dlls/winejoystick.drv/Makefile.in
--- wine-2.0a/dlls/winejoystick.drv/Makefile.in	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/winejoystick.drv/Makefile.in	2017-07-11 20:37:51.000000000 +0100
@@ -1,8 +1,9 @@
 MODULE    = winejoystick.drv
-IMPORTS   = winmm user32
+IMPORTS   = winmm user32 advapi32
 EXTRALIBS = $(IOKIT_LIBS)
 
 C_SRCS = \
 	joystick.c \
+	joystick_driver.c \
 	joystick_linux.c \
 	joystick_osx.c
diff -Naur wine-2.0a/dlls/winemac.drv/clipboard.c wine-2.0b/dlls/winemac.drv/clipboard.c
--- wine-2.0a/dlls/winemac.drv/clipboard.c	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/winemac.drv/clipboard.c	2017-07-11 20:37:51.000000000 +0100
@@ -153,8 +153,14 @@
     { CF_PENDATA,           CFSTR("org.winehq.builtin.pendata"),            import_clipboard_data,          export_clipboard_data,      FALSE },
     { CF_RIFF,              CFSTR("org.winehq.builtin.riff"),               import_clipboard_data,          export_clipboard_data,      FALSE },
     { CF_SYLK,              CFSTR("org.winehq.builtin.sylk"),               import_clipboard_data,          export_clipboard_data,      FALSE },
+
     { CF_TEXT,              CFSTR("org.winehq.builtin.text"),               import_clipboard_data,          export_clipboard_data,      FALSE },
+#if 1 /* CodeWeavers Hack #12338: don't map CF_TIFF to Mac-native type since we don't ship libtiff */
+    { CF_TIFF,              CFSTR("org.winehq.builtin.tiff"),               import_clipboard_data,          export_clipboard_data,      FALSE },
+#else
     { CF_TIFF,              CFSTR("public.tiff"),                           import_clipboard_data,          export_clipboard_data,      FALSE },
+#endif
+
     { CF_WAVE,              CFSTR("com.microsoft.waveform-audio"),          import_clipboard_data,          export_clipboard_data,      FALSE },
 
     { CF_DIB,               CFSTR("org.winehq.builtin.dib"),                import_clipboard_data,          export_clipboard_data,      FALSE },
@@ -200,6 +206,7 @@
 static macdrv_window clipboard_cocoa_window;
 static UINT rendered_formats;
 static ULONG64 last_clipboard_update;
+static DWORD last_get_seqno;
 static WINE_CLIPFORMAT **current_mac_formats;
 static unsigned int nb_current_mac_formats;
 static WCHAR clipboard_pipe_name[256];
@@ -1819,6 +1826,7 @@
             return TRUE;
         case WM_CLIPBOARDUPDATE:
             if (is_clipboard_owner) break;  /* ignore our own changes */
+            if ((LONG)(GetClipboardSequenceNumber() - last_get_seqno) <= 0) break;
             set_mac_pasteboard_types_from_win32_clipboard();
             break;
         case WM_RENDERFORMAT:
@@ -2220,6 +2228,8 @@
         }
     }
 
+    last_get_seqno = GetClipboardSequenceNumber();
+
     CloseClipboard();
 
     return ret;
diff -Naur wine-2.0a/dlls/winemac.drv/cocoa_app.h wine-2.0b/dlls/winemac.drv/cocoa_app.h
--- wine-2.0a/dlls/winemac.drv/cocoa_app.h	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/winemac.drv/cocoa_app.h	2017-07-11 20:37:51.000000000 +0100
@@ -94,6 +94,9 @@
     BOOL beenActive;
 
     NSMutableSet* windowsBeingDragged;
+
+    // CrossOver Hack 10912: Mac Edit menu
+    NSMutableArray* changedKeyEquivalents;
 }
 
 @property (nonatomic) CGEventSourceKeyboardType keyboardType;
@@ -130,6 +133,9 @@
     - (BOOL) handleEvent:(NSEvent*)anEvent;
     - (void) didSendEvent:(NSEvent*)anEvent;
 
+    // CrossOver Hack 10912: Mac Edit menu
+    - (BOOL) isEditMenuAction:(SEL)selector;
+
 @end
 
 
diff -Naur wine-2.0a/dlls/winemac.drv/cocoa_app.m wine-2.0b/dlls/winemac.drv/cocoa_app.m
--- wine-2.0a/dlls/winemac.drv/cocoa_app.m	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/winemac.drv/cocoa_app.m	2017-07-11 20:37:51.000000000 +0100
@@ -211,6 +211,62 @@
         [super dealloc];
     }
 
+    // CrossOver Hack 10912: Mac Edit menu
+    - (BOOL) isEditMenuAction:(SEL)selector
+    {
+        return selector == @selector(copy:) || selector == @selector(cut:) ||
+               selector == @selector(delete:) || selector == @selector(paste:) ||
+               selector == @selector(selectAll:) || selector == @selector(undo:);
+    }
+
+    - (void) changeEditMenuKeyEquivalentsForWindow:(NSWindow*)window
+    {
+        if (mac_edit_menu == MAC_EDIT_MENU_DISABLED)
+        {
+            if ([window isKindOfClass:[WineWindow class]])
+            {
+                NSMutableArray* menus = [NSMutableArray arrayWithObject:[NSApp mainMenu]];
+
+                while ([menus count])
+                {
+                    NSMenu* menu = [menus objectAtIndex:0];
+                    [menus removeObjectAtIndex:0];
+
+                    for (NSMenuItem* item in [menu itemArray])
+                    {
+                        if ([self isEditMenuAction:[item action]] && ![item target] &&
+                            [[item keyEquivalent] length])
+                        {
+                            NSDictionary* record = [NSDictionary dictionaryWithObjectsAndKeys:
+                                                    item, @"menuItem",
+                                                    [item keyEquivalent], @"keyEquivalent",
+                                                    nil];
+                            if (!changedKeyEquivalents)
+                                changedKeyEquivalents = [[NSMutableArray alloc] init];
+                            [changedKeyEquivalents addObject:record];
+
+                            [item setKeyEquivalent:@""];
+                        }
+
+                        if ([item hasSubmenu])
+                            [menus addObject:[item submenu]];
+                    }
+                }
+            }
+            else
+            {
+                for (NSDictionary* record in changedKeyEquivalents)
+                {
+                    NSMenuItem* item = [record objectForKey:@"menuItem"];
+                    NSString* equiv = [record objectForKey:@"keyEquivalent"];
+                    [item setKeyEquivalent:equiv];
+                }
+
+                [changedKeyEquivalents removeAllObjects];
+            }
+        }
+    }
+
     - (void) transformProcessToForeground
     {
         if ([NSApp activationPolicy] != NSApplicationActivationPolicyRegular)
@@ -258,6 +314,23 @@
             [item setSubmenu:submenu];
             [mainMenu addItem:item];
 
+            // CrossOver Hack 10912: Mac Edit menu
+            if (mac_edit_menu != MAC_EDIT_MENU_DISABLED)
+            {
+                submenu = [[[NSMenu alloc] initWithTitle:@"Edit"] autorelease];
+                [submenu addItemWithTitle:@"Undo" action:@selector(undo:) keyEquivalent:@"z"];
+                [submenu addItem:[NSMenuItem separatorItem]];
+                [submenu addItemWithTitle:@"Cut" action:@selector(cut:) keyEquivalent:@"x"];
+                [submenu addItemWithTitle:@"Copy" action:@selector(copy:) keyEquivalent:@"c"];
+                [submenu addItemWithTitle:@"Paste" action:@selector(paste:) keyEquivalent:@"v"];
+                [submenu addItemWithTitle:@"Delete" action:@selector(delete:) keyEquivalent:@""];
+                [submenu addItemWithTitle:@"Select All" action:@selector(selectAll:) keyEquivalent:@"a"];
+                item = [[[NSMenuItem alloc] init] autorelease];
+                [item setTitle:@"Edit"];
+                [item setSubmenu:submenu];
+                [mainMenu addItem:item];
+            }
+
             // Window menu
             submenu = [[[NSMenu alloc] initWithTitle:WineLocalizedString(STRING_MENU_WINDOW)] autorelease];
             [submenu addItemWithTitle:WineLocalizedString(STRING_MENU_ITEM_MINIMIZE)
@@ -285,6 +358,9 @@
             [NSApp setMainMenu:mainMenu];
             [NSApp setWindowsMenu:submenu];
 
+            // CrossOver Hack 10912: Mac Edit menu
+            [self changeEditMenuKeyEquivalentsForWindow:[NSApp keyWindow]];
+
             [NSApp setApplicationIconImage:self.applicationIcon];
         }
     }
@@ -2053,6 +2129,16 @@
             NSWindow* window = [note object];
             [keyWindows removeObjectIdenticalTo:window];
             [keyWindows insertObject:window atIndex:0];
+            // CrossOver Hack 10912: Mac Edit menu
+            [self changeEditMenuKeyEquivalentsForWindow:window];
+        }];
+
+        // CrossOver Hack 10912: Mac Edit menu
+        [nc addObserverForName:NSWindowDidResignKeyNotification
+                        object:nil
+                         queue:nil
+                    usingBlock:^(NSNotification *note){
+            [self changeEditMenuKeyEquivalentsForWindow:nil];
         }];
 
         [nc addObserverForName:NSWindowWillCloseNotification
@@ -2625,12 +2711,21 @@
  * color depths from the icon resource.  If images is NULL or empty,
  * restores the default application image.
  */
-void macdrv_set_application_icon(CFArrayRef images)
+void macdrv_set_application_icon(CFArrayRef images, CFURLRef urlRef)
 {
     NSArray* imageArray = (NSArray*)images;
+    NSURL* url = (NSURL*)urlRef;
 
     OnMainThreadAsync(^{
-        [[WineApplicationController sharedController] setApplicationIconFromCGImageArray:imageArray];
+        // CrossOver Hack 13440: Get the icon from the passed-in URL if no images
+        WineApplicationController* controller = [WineApplicationController sharedController];
+        NSImage* image = nil;
+        if (!imageArray && url)
+            image = [[[NSImage alloc] initWithContentsOfURL:url] autorelease];
+        if (imageArray || ![image isValid])
+            [controller setApplicationIconFromCGImageArray:imageArray];
+        else
+            controller.applicationIcon = image;
     });
 }
 
diff -Naur wine-2.0a/dlls/winemac.drv/cocoa_main.m wine-2.0b/dlls/winemac.drv/cocoa_main.m
--- wine-2.0a/dlls/winemac.drv/cocoa_main.m	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/winemac.drv/cocoa_main.m	2017-07-11 20:37:51.000000000 +0100
@@ -70,6 +70,15 @@
     {
         [WineApplication sharedApplication];
         created_app = TRUE;
+
+        /* CrossOver hack 11196: Disable loading of input managers */
+        [[NSUserDefaults standardUserDefaults] registerDefaults:
+            [NSDictionary dictionaryWithObject:@"NO" forKey:@"NSUseCocoaInputServers"]];
+
+        /* CrossOver hack 12205: Prevent call to NSVersionOfRunTimeLibrary() during app startup.
+                                 It can crash if a Wine thread unloads a dylib simultaneously. */
+        [[NSUserDefaults standardUserDefaults] registerDefaults:
+            [NSDictionary dictionaryWithObject:@"YES" forKey:@"NSUseActiveDisplayForMainScreen"]];
     }
 
     if ([NSApp respondsToSelector:@selector(setWineController:)])
diff -Naur wine-2.0a/dlls/winemac.drv/cocoa_opengl.h wine-2.0b/dlls/winemac.drv/cocoa_opengl.h
--- wine-2.0a/dlls/winemac.drv/cocoa_opengl.h	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/winemac.drv/cocoa_opengl.h	2017-07-11 20:37:51.000000000 +0100
@@ -25,12 +25,14 @@
 {
     NSView* latentView;
     BOOL needsUpdate;
+    BOOL needsReattach;
     BOOL shouldClearToBlack;
 
     GLint backing_size[2];
 }
 
 @property BOOL needsUpdate;
+@property BOOL needsReattach;
 @property BOOL shouldClearToBlack;
 
 @end
diff -Naur wine-2.0a/dlls/winemac.drv/cocoa_opengl.m wine-2.0b/dlls/winemac.drv/cocoa_opengl.m
--- wine-2.0a/dlls/winemac.drv/cocoa_opengl.m	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/winemac.drv/cocoa_opengl.m	2017-07-11 20:37:51.000000000 +0100
@@ -35,7 +35,7 @@
 
 
 @implementation WineOpenGLContext
-@synthesize latentView, needsUpdate, shouldClearToBlack;
+@synthesize latentView, needsUpdate, needsReattach, shouldClearToBlack;
 
     - (void) dealloc
     {
@@ -215,6 +215,7 @@
                 [self setLatentView:nil];
         }
         needsUpdate = FALSE;
+        needsReattach = FALSE;
     }
 
 @end
@@ -279,6 +280,7 @@
             if (context.needsUpdate)
             {
                 context.needsUpdate = FALSE;
+                context.needsReattach = FALSE;
                 if (context.view)
                     [context setView:[[context class] dummyView]];
                 [context wine_updateBackingSize:&r.size];
@@ -328,7 +330,9 @@
 
     if (context.needsUpdate)
     {
+        BOOL reattach = context.needsReattach;
         context.needsUpdate = FALSE;
+        context.needsReattach = FALSE;
         if (context.latentView)
         {
             [context setView:context.latentView];
@@ -339,7 +343,14 @@
         }
         else
         {
-            [context update];
+            if (reattach)
+            {
+                NSView* view = [[context.view retain] autorelease];
+                [context clearDrawableLeavingSurfaceOnScreen];
+                context.view = view;
+            }
+            else
+                [context update];
             [context resetSurfaceIfBackingSizeChanged];
         }
     }
diff -Naur wine-2.0a/dlls/winemac.drv/cocoa_window.m wine-2.0b/dlls/winemac.drv/cocoa_window.m
--- wine-2.0a/dlls/winemac.drv/cocoa_window.m	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/winemac.drv/cocoa_window.m	2017-07-11 20:37:51.000000000 +0100
@@ -500,10 +500,19 @@
         [(WineWindow*)[self window] updateForGLSubviews];
     }
 
-    - (void) updateGLContexts
+    - (void) updateGLContexts:(BOOL)reattach
     {
         for (WineOpenGLContext* context in glContexts)
+        {
             context.needsUpdate = TRUE;
+            if (reattach)
+                context.needsReattach = TRUE;
+        }
+    }
+
+    - (void) updateGLContexts
+    {
+        [self updateGLContexts:NO];
     }
 
     - (BOOL) hasGLContext
@@ -605,6 +614,23 @@
         return NO;
     }
 
+    - (void) viewDidHide
+    {
+        [super viewDidHide];
+        if ([self hasGLContext])
+            [self invalidateHasGLDescendant];
+    }
+
+    - (void) viewDidUnhide
+    {
+        [super viewDidUnhide];
+        if ([self hasGLContext])
+        {
+            [self updateGLContexts:YES];
+            [self invalidateHasGLDescendant];
+        }
+    }
+
     - (void) completeText:(NSString*)text
     {
         macdrv_event* event;
@@ -651,12 +677,6 @@
         [super willRemoveSubview:subview];
     }
 
-    - (void) setHidden:(BOOL)hidden
-    {
-        [super setHidden:hidden];
-        [self invalidateHasGLDescendant];
-    }
-
     /*
      * ---------- NSTextInputClient methods ----------
      */
@@ -2133,6 +2153,8 @@
 
         if ([menuItem action] == @selector(makeKeyAndOrderFront:))
             ret = [self isKeyWindow] || (!self.disabled && !self.noActivate);
+        else if ([menuItem action] == @selector(undo:)) // CrossOver Hack 10912: Mac Edit menu
+            ret = TRUE;
         if ([menuItem action] == @selector(toggleFullScreen:) && (self.disabled || maximized))
             ret = NO;
 
@@ -2253,6 +2275,69 @@
         }
     }
 
+    // CrossOver Hack 10912: Mac Edit menu
+    - (void) sendEditMenuCommand:(int)command
+    {
+        macdrv_event* event;
+        NSTimeInterval now = [[NSProcessInfo processInfo] systemUptime];
+
+        if (mac_edit_menu == MAC_EDIT_MENU_DISABLED) // Shouldn't get here
+        {
+            ERR(@"The Mac Edit menu is supposed to be disabled\n");
+            NSBeep();
+            return;
+        }
+
+        event = macdrv_create_event(EDIT_MENU_COMMAND, self);
+        event->edit_menu_command.command = command;
+        event->edit_menu_command.time_ms = [[WineApplicationController sharedController] ticksForEventTime:now];
+
+        [queue postEvent:event];
+
+        macdrv_release_event(event);
+
+        // This is an even grosser hack than the rest of the support for the Edit
+        // menu.  We are deliberately leaving ourselves with an incorrect notion
+        // of the current modifier key state (for the case where the user used a
+        // Command-key shortcut to invoke an Edit menu item).  Both Wine and this
+        // class pretend that Command/Alt are not pressed so that, when the user
+        // actually releases the key, it doesn't put focus on the menu bar.  If
+        // the user keeps Command pressed and types another key, we'll think that
+        // Command was newly pressed and generate the appropriate event to get
+        // everybody back in sync.
+        lastModifierFlags &= ~(NX_COMMANDMASK | NX_DEVICELCMDKEYMASK | NX_DEVICERCMDKEYMASK);
+    }
+
+    - (void) copy:(id)sender
+    {
+        [self sendEditMenuCommand:EDIT_COMMAND_COPY];
+    }
+
+    - (void) cut:(id)sender
+    {
+        [self sendEditMenuCommand:EDIT_COMMAND_CUT];
+    }
+
+    - (void) delete:(id)sender
+    {
+        [self sendEditMenuCommand:EDIT_COMMAND_DELETE];
+    }
+
+    - (void) paste:(id)sender
+    {
+        [self sendEditMenuCommand:EDIT_COMMAND_PASTE];
+    }
+
+    - (void) selectAll:(id)sender
+    {
+        [self sendEditMenuCommand:EDIT_COMMAND_SELECT_ALL];
+    }
+
+    - (void) undo:(id)sender
+    {
+        [self sendEditMenuCommand:EDIT_COMMAND_UNDO];
+    }
+
     - (void) miniaturize:(id)sender
     {
         macdrv_event* event = macdrv_create_event(WINDOW_MINIMIZE_REQUESTED, self);
@@ -2481,6 +2566,19 @@
 
 
     /*
+     * ---------- NSObject method overrides ----------
+     */
+    // CrossOver Hack 10912: Mac Edit menu
+    - (BOOL) respondsToSelector:(SEL)selector
+    {
+        if (mac_edit_menu == MAC_EDIT_MENU_DISABLED && [[WineApplicationController sharedController] isEditMenuAction:selector])
+             return FALSE;
+
+        return [super respondsToSelector:selector];
+    }
+
+
+    /*
      * ---------- NSWindowDelegate methods ----------
      */
     - (NSSize) window:(NSWindow*)window willUseFullScreenContentSize:(NSSize)proposedSize
@@ -3340,7 +3438,7 @@
 
     if (CGRectIsNull(rect)) rect = CGRectZero;
 
-    OnMainThread(^{
+    OnMainThreadAsync(^{
         NSRect newFrame = NSRectFromCGRect(cgrect_mac_from_win(rect));
         NSRect oldFrame = [view frame];
 
@@ -3387,7 +3485,7 @@
     if (!superview)
         superview = [window contentView];
 
-    OnMainThread(^{
+    OnMainThreadAsync(^{
         if (superview == [view superview])
         {
             NSArray* subviews = [superview subviews];
@@ -3430,8 +3528,9 @@
     NSAutoreleasePool* pool = [[NSAutoreleasePool alloc] init];
     WineContentView* view = (WineContentView*)v;
 
-    OnMainThread(^{
+    OnMainThreadAsync(^{
         [view setHidden:hidden];
+        [(WineWindow*)view.window updateForGLSubviews];
     });
 
     [pool release];
diff -Naur wine-2.0a/dlls/winemac.drv/display.c wine-2.0b/dlls/winemac.drv/display.c
--- wine-2.0a/dlls/winemac.drv/display.c	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/winemac.drv/display.c	2017-07-11 20:37:51.000000000 +0100
@@ -1262,7 +1262,7 @@
  */
 BOOL CDECL macdrv_GetMonitorInfo(HMONITOR monitor, LPMONITORINFO info)
 {
-    static const WCHAR adapter_name[] = { '\\','\\','.','\\','D','I','S','P','L','A','Y','1',0 };
+    static const WCHAR adapter_name[] = { '\\','\\','.','\\','D','I','S','P','L','A','Y','%','d',0 }; /* CrossOver Hack 13441 */
     struct macdrv_display *displays;
     int num_displays;
     CGDirectDisplayID display_id;
@@ -1292,10 +1292,12 @@
         info->dwFlags = (i == 0) ? MONITORINFOF_PRIMARY : 0;
 
         if (info->cbSize >= sizeof(MONITORINFOEXW))
-            lstrcpyW(((MONITORINFOEXW*)info)->szDevice, adapter_name);
+            snprintfW(((MONITORINFOEXW*)info)->szDevice, sizeof(((MONITORINFOEXW*)info)->szDevice) / sizeof(WCHAR),
+                      adapter_name, i + 1); /* CrossOver Hack 13441 */
 
-        TRACE(" -> rcMonitor %s rcWork %s dwFlags %08x\n", wine_dbgstr_rect(&info->rcMonitor),
-              wine_dbgstr_rect(&info->rcWork), info->dwFlags);
+        TRACE(" -> rcMonitor %s rcWork %s dwFlags %08x szDevice %s\n", wine_dbgstr_rect(&info->rcMonitor),
+              wine_dbgstr_rect(&info->rcWork), info->dwFlags,
+              info->cbSize >= sizeof(MONITORINFOEXW) ? debugstr_w(((MONITORINFOEXW*)info)->szDevice) : "n/a");
     }
     else
     {
diff -Naur wine-2.0a/dlls/winemac.drv/event.c wine-2.0b/dlls/winemac.drv/event.c
--- wine-2.0a/dlls/winemac.drv/event.c	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/winemac.drv/event.c	2017-07-11 20:37:51.000000000 +0100
@@ -36,6 +36,7 @@
         "APP_DEACTIVATED",
         "APP_QUIT_REQUESTED",
         "DISPLAYS_CHANGED",
+        "EDIT_MENU_COMMAND", /* CrossOver Hack 10912: Mac Edit menu */
         "HOTKEY_PRESS",
         "IM_SET_TEXT",
         "KEY_PRESS",
@@ -86,6 +87,8 @@
 
     if (mask & QS_KEY)
     {
+        /* CrossOver Hack 10912: Mac Edit menu */
+        event_mask |= event_mask_for_type(EDIT_MENU_COMMAND);
         event_mask |= event_mask_for_type(KEY_PRESS);
         event_mask |= event_mask_for_type(KEY_RELEASE);
         event_mask |= event_mask_for_type(KEYBOARD_CHANGED);
@@ -224,6 +227,10 @@
     case DISPLAYS_CHANGED:
         macdrv_displays_changed(event);
         break;
+    /* CrossOver Hack 10912: Mac Edit menu */
+    case EDIT_MENU_COMMAND:
+        macdrv_edit_menu_command(event);
+        break;
     case HOTKEY_PRESS:
         macdrv_hotkey_press(event);
         break;
diff -Naur wine-2.0a/dlls/winemac.drv/keyboard.c wine-2.0b/dlls/winemac.drv/keyboard.c
--- wine-2.0a/dlls/winemac.drv/keyboard.c	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/winemac.drv/keyboard.c	2017-07-11 20:37:51.000000000 +0100
@@ -1059,6 +1059,176 @@
 }
 
 
+/* CrossOver Hack 10912: Mac Edit menu */
+static WORD vkey_to_scan(WORD vkey)
+{
+    struct macdrv_thread_data *thread_data = macdrv_init_thread_data();
+    int keyc;
+
+    for (keyc = 0; keyc < sizeof(thread_data->keyc2vkey)/sizeof(thread_data->keyc2vkey[0]); keyc++)
+    {
+        if (thread_data->keyc2vkey[keyc] == vkey)
+            return thread_data->keyc2scan[keyc];
+    }
+
+    return 0;
+}
+
+/***********************************************************************
+ *              macdrv_edit_menu_command
+ */
+void macdrv_edit_menu_command(const macdrv_event *event)
+{
+    HWND hwnd = macdrv_get_window_hwnd(event->window);
+
+    TRACE("hwnd %p command %d\n", hwnd, event->edit_menu_command.command);
+
+    if (mac_edit_menu == MAC_EDIT_MENU_DISABLED)
+    {
+        WARN("edit menu disabled, shouldn't be here\n");
+        return;
+    }
+
+    if (mac_edit_menu == MAC_EDIT_MENU_BY_KEY)
+    {
+        WORD key_vkey, key_scan;
+        BOOL left_alt_down, right_alt_down, control_down, need_control = TRUE;
+        WORD left_alt_scan, right_alt_scan, control_scan;
+        DWORD flags;
+
+        switch (event->edit_menu_command.command)
+        {
+            case EDIT_COMMAND_COPY:         key_vkey = 'C'; break;
+            case EDIT_COMMAND_CUT:          key_vkey = 'X'; break;
+            case EDIT_COMMAND_DELETE:       key_vkey = VK_BACK; need_control = FALSE; break;
+            case EDIT_COMMAND_PASTE:        key_vkey = 'V'; break;
+            case EDIT_COMMAND_SELECT_ALL:   key_vkey = 'A'; break;
+            case EDIT_COMMAND_UNDO:         key_vkey = 'Z'; break;
+            default:
+                WARN("unrecognized edit command %d\n", event->edit_menu_command.command);
+                return;
+        }
+        key_scan = vkey_to_scan(key_vkey);
+
+        left_alt_down = (GetAsyncKeyState(VK_LMENU) & 0x8000) != 0;
+        right_alt_down = (GetAsyncKeyState(VK_RMENU) & 0x8000) != 0;
+        if (need_control)
+            control_down = (GetAsyncKeyState(VK_CONTROL) & 0x8000) != 0;
+
+        if (left_alt_down)
+            left_alt_scan = vkey_to_scan(VK_LMENU);
+        if (right_alt_down)
+            right_alt_scan = vkey_to_scan(VK_RMENU);
+        if (need_control && !control_down)
+            control_scan = vkey_to_scan(VK_LCONTROL);
+
+        if ((left_alt_down && !left_alt_scan) || (right_alt_down && !right_alt_scan) ||
+            (need_control && !control_down && !control_scan) || !key_scan)
+        {
+            WARN("failed to find scan codes\n");
+            return;
+        }
+
+        /* Alt key may be down but we don't want it down for the Control-C/V/X/...
+           sequence that follows.  So simulate releasing it.  Unfortunately,
+           that will often put focus on the menu bar.  To counteract that,
+           we simulate pressing and releasing it again.  [An earlier attempt
+           to use WM_CANCELMODE for this purpose worked for some cases (e.g.
+           Notepad) but not others (e.g. Outlook 2010 and its ribbon).] */
+        if (left_alt_down)
+        {
+            flags = KEYEVENTF_KEYUP;
+            if (left_alt_scan & 0x100) flags |= KEYEVENTF_EXTENDEDKEY;
+            macdrv_send_keyboard_input(hwnd, VK_LMENU, left_alt_scan & 0xff, flags,
+                                       event->edit_menu_command.time_ms);
+        }
+        if (right_alt_down)
+        {
+            flags = KEYEVENTF_KEYUP;
+            if (right_alt_scan & 0x100) flags |= KEYEVENTF_EXTENDEDKEY;
+            macdrv_send_keyboard_input(hwnd, VK_RMENU, right_alt_scan & 0xff, flags,
+                                       event->edit_menu_command.time_ms);
+        }
+        if (left_alt_down ^ right_alt_down)
+        {
+            WORD vkey = left_alt_down ? VK_LMENU : VK_RMENU;
+            WORD scan = left_alt_down ? left_alt_scan : right_alt_scan;
+
+            flags = 0;
+            if (scan & 0x100) flags |= KEYEVENTF_EXTENDEDKEY;
+            macdrv_send_keyboard_input(hwnd, vkey, scan & 0xff, flags,
+                                       event->edit_menu_command.time_ms);
+            flags ^= KEYEVENTF_KEYUP;
+            macdrv_send_keyboard_input(hwnd, vkey, scan & 0xff, flags,
+                                       event->edit_menu_command.time_ms);
+        }
+
+        /* Simulate Control key press, if necessary. */
+        if (need_control && !control_down)
+        {
+            flags = 0;
+            if (control_scan & 0x100) flags |= KEYEVENTF_EXTENDEDKEY;
+            macdrv_send_keyboard_input(hwnd, VK_LCONTROL, control_scan & 0xff, flags,
+                                       event->edit_menu_command.time_ms);
+        }
+
+        /* Simulate press and release of the edit menu item accelerator key. */
+        flags = 0;
+        if (key_scan & 0x100) flags |= KEYEVENTF_EXTENDEDKEY;
+        macdrv_send_keyboard_input(hwnd, key_vkey, key_scan & 0xff, flags,
+                                   event->edit_menu_command.time_ms);
+
+        flags |= KEYEVENTF_KEYUP;
+        macdrv_send_keyboard_input(hwnd, key_vkey, key_scan & 0xff, flags,
+                                   event->edit_menu_command.time_ms);
+
+        /* Simulate Control key release to restore previous state, if necessary. */
+        if (need_control && !control_down)
+        {
+            flags = KEYEVENTF_KEYUP;
+            if (control_scan & 0x100) flags |= KEYEVENTF_EXTENDEDKEY;
+            macdrv_send_keyboard_input(hwnd, VK_LCONTROL, control_scan & 0xff, flags,
+                                       event->edit_menu_command.time_ms);
+        }
+
+        /* In theory, we should simulate an Alt key press here if it was down
+           when we started.  However, that would mean that focus would be put on
+           the menu bar when the user lets go, which we don't want.  Instead, we
+           leave Wine with an incorrect sense of the state of the Alt key.  The
+           Cocoa thread has also cleared its internal record that the Command
+           key is down.  That has two effects: 1) when the user releases the
+           Command key, the Cocoa code thinks nothing has changed and doesn't
+           generate an event; and 2) if the user keeps Command down and issues
+           another key event, the Cocoa code will think the Command key is newly
+           pressed and will generate an event.  In other words, it will resync
+           with the actual key state and generate only the events necessary. */
+    }
+    else // mac_edit_menu == MAC_EDIT_MENU_BY_MESSAGE
+    {
+        UINT msg;
+        LPARAM lparam = 0;
+        HWND focus;
+
+        switch (event->edit_menu_command.command)
+        {
+            case EDIT_COMMAND_COPY:         msg = WM_COPY; break;
+            case EDIT_COMMAND_CUT:          msg = WM_CUT; break;
+            case EDIT_COMMAND_DELETE:       msg = WM_CLEAR; break;
+            case EDIT_COMMAND_PASTE:        msg = WM_PASTE; break;
+            case EDIT_COMMAND_SELECT_ALL:   msg = EM_SETSEL; lparam = -1; break;
+            case EDIT_COMMAND_UNDO:         msg = EM_UNDO; break;
+            default:
+                WARN("unrecognized edit command %d\n", event->edit_menu_command.command);
+                return;
+        }
+
+        focus = GetFocus();
+        if (focus == hwnd || IsChild(hwnd, focus))
+            PostMessageW(focus, msg, 0, lparam);
+    }
+}
+
+
 /***********************************************************************
  *              macdrv_hotkey_press
  *
diff -Naur wine-2.0a/dlls/winemac.drv/macdrv_cocoa.h wine-2.0b/dlls/winemac.drv/macdrv_cocoa.h
--- wine-2.0a/dlls/winemac.drv/macdrv_cocoa.h	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/winemac.drv/macdrv_cocoa.h	2017-07-11 20:37:51.000000000 +0100
@@ -120,6 +120,22 @@
     TOPMOST_FLOAT_INACTIVE_ALL,
 };
 
+/* CrossOver Hack 10912: Mac Edit menu */
+enum {
+    MAC_EDIT_MENU_DISABLED,
+    MAC_EDIT_MENU_BY_MESSAGE,
+    MAC_EDIT_MENU_BY_KEY,
+};
+
+enum {
+    EDIT_COMMAND_COPY,
+    EDIT_COMMAND_CUT,
+    EDIT_COMMAND_DELETE,
+    EDIT_COMMAND_PASTE,
+    EDIT_COMMAND_SELECT_ALL,
+    EDIT_COMMAND_UNDO,
+};
+
 enum {
     GL_SURFACE_IN_FRONT_OPAQUE,
     GL_SURFACE_IN_FRONT_TRANSPARENT,
@@ -153,6 +169,8 @@
 extern int macdrv_err_on;
 extern int topmost_float_inactive DECLSPEC_HIDDEN;
 extern int capture_displays_for_fullscreen DECLSPEC_HIDDEN;
+/* CrossOver Hack 10912: Mac Edit menu */
+extern int mac_edit_menu DECLSPEC_HIDDEN;
 extern int left_option_is_alt DECLSPEC_HIDDEN;
 extern int right_option_is_alt DECLSPEC_HIDDEN;
 extern int allow_immovable_windows DECLSPEC_HIDDEN;
@@ -236,7 +254,7 @@
 extern int macdrv_start_cocoa_app(unsigned long long tickcount) DECLSPEC_HIDDEN;
 extern void macdrv_window_rejected_focus(const struct macdrv_event *event) DECLSPEC_HIDDEN;
 extern void macdrv_beep(void) DECLSPEC_HIDDEN;
-extern void macdrv_set_application_icon(CFArrayRef images) DECLSPEC_HIDDEN;
+extern void macdrv_set_application_icon(CFArrayRef images, CFURLRef url /* CrossOver Hack 13440 */) DECLSPEC_HIDDEN;
 extern void macdrv_quit_reply(int reply) DECLSPEC_HIDDEN;
 extern int macdrv_using_input_method(void) DECLSPEC_HIDDEN;
 extern void macdrv_set_mouse_capture_window(macdrv_window window) DECLSPEC_HIDDEN;
@@ -263,6 +281,7 @@
     APP_DEACTIVATED,
     APP_QUIT_REQUESTED,
     DISPLAYS_CHANGED,
+    EDIT_MENU_COMMAND, /* CrossOver Hack 10912: Mac Edit menu */
     HOTKEY_PRESS,
     IM_SET_TEXT,
     KEY_PRESS,
@@ -316,6 +335,11 @@
         struct {
             int activating;
         }                                           displays_changed;
+        /* CrossOver Hack 10912: Mac Edit menu */
+        struct {
+            int             command;
+            unsigned long   time_ms;
+        }                                           edit_menu_command;
         struct {
             unsigned int    vkey;
             unsigned int    mod_flags;
diff -Naur wine-2.0a/dlls/winemac.drv/macdrv.h wine-2.0b/dlls/winemac.drv/macdrv.h
--- wine-2.0a/dlls/winemac.drv/macdrv.h	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/winemac.drv/macdrv.h	2017-07-11 20:37:51.000000000 +0100
@@ -42,6 +42,9 @@
 extern BOOL disable_window_decorations DECLSPEC_HIDDEN;
 extern HMODULE macdrv_module DECLSPEC_HIDDEN;
 
+/* CrossOver Hack 14364 */
+extern BOOL force_backing_store DECLSPEC_HIDDEN;
+
 
 extern const char* debugstr_cf(CFTypeRef t) DECLSPEC_HIDDEN;
 
@@ -188,6 +191,8 @@
 extern void CDECL macdrv_SetCapture(HWND hwnd, UINT flags) DECLSPEC_HIDDEN;
 
 extern void macdrv_compute_keyboard_layout(struct macdrv_thread_data *thread_data) DECLSPEC_HIDDEN;
+/* CrossOver Hack 10912: Mac Edit menu */
+extern void macdrv_edit_menu_command(const macdrv_event *event) DECLSPEC_HIDDEN;
 extern void macdrv_keyboard_changed(const macdrv_event *event) DECLSPEC_HIDDEN;
 extern void macdrv_key_event(HWND hwnd, const macdrv_event *event) DECLSPEC_HIDDEN;
 extern void macdrv_hotkey_press(const macdrv_event *event) DECLSPEC_HIDDEN;
diff -Naur wine-2.0a/dlls/winemac.drv/macdrv_main.c wine-2.0b/dlls/winemac.drv/macdrv_main.c
--- wine-2.0a/dlls/winemac.drv/macdrv_main.c	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/winemac.drv/macdrv_main.c	2017-07-11 20:37:51.000000000 +0100
@@ -23,6 +23,7 @@
 
 #include <Security/AuthSession.h>
 #include <IOKit/pwr_mgt/IOPMLib.h>
+#include <unistd.h> /* CrossOver Hack 11095 */
 
 #include "macdrv.h"
 #include "winuser.h"
@@ -50,6 +51,8 @@
 BOOL skip_single_buffer_flushes = FALSE;
 BOOL allow_vsync = TRUE;
 BOOL allow_set_gamma = TRUE;
+/* CrossOver Hack 10912: Mac Edit menu */
+int mac_edit_menu = MAC_EDIT_MENU_BY_KEY;
 int left_option_is_alt = 0;
 int right_option_is_alt = 0;
 BOOL allow_software_rendering = FALSE;
@@ -61,6 +64,9 @@
 int retina_enabled = FALSE;
 HMODULE macdrv_module = 0;
 
+/* CrossOver Hack 14364 */
+BOOL force_backing_store = FALSE;
+
 CFDictionaryRef localized_strings;
 
 
@@ -166,6 +172,16 @@
     if (!get_config_key(hkey, appkey, "AllowSetGamma", buffer, sizeof(buffer)))
         allow_set_gamma = IS_OPTION_TRUE(buffer[0]);
 
+    /* CrossOver Hack 10912: Mac Edit menu */
+    if (!get_config_key(hkey, appkey, "EditMenu", buffer, sizeof(buffer)))
+    {
+        if (!strcmp(buffer, "message"))
+            mac_edit_menu = MAC_EDIT_MENU_BY_MESSAGE;
+        else if (!strcmp(buffer, "key"))
+            mac_edit_menu = MAC_EDIT_MENU_BY_KEY;
+        else
+            mac_edit_menu = MAC_EDIT_MENU_DISABLED;
+    }
     if (!get_config_key(hkey, appkey, "LeftOptionIsAlt", buffer, sizeof(buffer)))
         left_option_is_alt = IS_OPTION_TRUE(buffer[0]);
     if (!get_config_key(hkey, appkey, "RightOptionIsAlt", buffer, sizeof(buffer)))
@@ -202,6 +218,10 @@
     if (!get_config_key(hkey, NULL, "RetinaMode", buffer, sizeof(buffer)))
         retina_enabled = IS_OPTION_TRUE(buffer[0]);
 
+    /* CrossOver Hack 14364 */
+    if (!get_config_key(hkey, appkey, "ForceOpenGLBackingStore", buffer, sizeof(buffer)))
+        force_backing_store = IS_OPTION_TRUE(buffer[0]);
+
     if (appkey) RegCloseKey(appkey);
     if (hkey) RegCloseKey(hkey);
 }
@@ -267,6 +287,17 @@
     SessionAttributeBits attributes;
     OSStatus status;
 
+    /* CrossOver Hack 11095.  Cocoa makes a similar call to confstr() during
+       its first pass through the event loop, which happens on the main thread.
+       However, if Wine is double-fork()-ing on a background thread simultaneously
+       with the first such call, the child process can become deadlocked.  It
+       appears to be a bug in the system library.
+
+       By calling this here, we greatly reduce the likelihood of such a race
+       and deadlock. */
+    char dummy[256];
+    confstr(_CS_DARWIN_USER_CACHE_DIR, dummy, sizeof(dummy));
+
     status = SessionGetInfo(callerSecuritySession, NULL, &attributes);
     if (status != noErr || !(attributes & sessionHasGraphicAccess))
         return FALSE;
@@ -283,6 +314,11 @@
         return FALSE;
     }
 
+    /* CrossOver Hack 10188: Actually, this disables that hack.  Don't pass
+                             system tray icons to our launcher since the Mac
+                             driver handles them itself. */
+    unsetenv("CX_SYSTRAY_SOCKET");
+
     return TRUE;
 }
 
diff -Naur wine-2.0a/dlls/winemac.drv/opengl.c wine-2.0b/dlls/winemac.drv/opengl.c
--- wine-2.0a/dlls/winemac.drv/opengl.c	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/winemac.drv/opengl.c	2017-07-11 20:37:51.000000000 +0100
@@ -116,6 +116,7 @@
 
 #define USE_GL_FUNC(name) #name,
 static const char *opengl_func_names[] = { ALL_WGL_FUNCS };
+static const char *glu_func_names[] = { ALL_GLU_FUNCS }; /* CrossOver Hack 10798 */
 #undef USE_GL_FUNC
 
 
@@ -1477,7 +1478,7 @@
         attribs[n++] = pf->samples;
     }
 
-    if (pf->backing_store)
+    if (force_backing_store || pf->backing_store) /* CrossOver Hack 14364 */
         attribs[n++] = kCGLPFABackingStore;
 
 #if defined(MAC_OS_X_VERSION_10_7) && MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_7
@@ -4275,6 +4276,13 @@
         }
     }
 
+    /* CrossOver Hack 10798 */
+    for (i = 0; i < sizeof(glu_func_names)/sizeof(glu_func_names[0]); i++)
+    {
+        if (!(((void **)&opengl_funcs.glu)[i] = wine_dlsym(opengl_handle, glu_func_names[i], NULL, 0)))
+            WARN("%s not found in OpenGL\n", glu_func_names[i]);
+    }
+
     /* redirect some standard OpenGL functions */
 #define REDIRECT(func) \
     do { p##func = opengl_funcs.gl.p_##func; opengl_funcs.gl.p_##func = macdrv_##func; } while(0)
diff -Naur wine-2.0a/dlls/winemac.drv/window.c wine-2.0b/dlls/winemac.drv/window.c
--- wine-2.0a/dlls/winemac.drv/window.c	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/winemac.drv/window.c	2017-07-11 20:37:51.000000000 +0100
@@ -1094,7 +1094,7 @@
             macdrv_set_view_frame(data->cocoa_view, frame);
             force_z_order = TRUE;
         }
-        else
+        else if (!EqualRect(&data->whole_rect, old_whole_rect))
             macdrv_set_view_frame(data->cocoa_view, frame);
     }
 
@@ -1186,9 +1186,47 @@
     CFArrayRef images = create_app_icon_images();
     if (images)
     {
-        macdrv_set_application_icon(images);
+        macdrv_set_application_icon(images, NULL);
         CFRelease(images);
     }
+    else /* CrossOver Hack 13440: Find an icon from the CrossOver app bundle */
+    {
+        const char *cx_root;
+        if ((cx_root = getenv("CX_ROOT")) && cx_root[0])
+        {
+            CFURLRef url, temp;
+            url = CFURLCreateFromFileSystemRepresentation(NULL, (UInt8*)cx_root, strlen(cx_root), TRUE);
+            if (url)
+            {
+                temp = CFURLCreateCopyDeletingLastPathComponent(NULL, url);
+                CFRelease(url);
+                url = temp;
+            }
+            if (url)
+            {
+                temp = CFURLCreateCopyDeletingLastPathComponent(NULL, url);
+                CFRelease(url);
+                url = temp;
+            }
+            if (url)
+            {
+                temp = CFURLCreateCopyAppendingPathComponent(NULL, url, CFSTR("Resources"), TRUE);
+                CFRelease(url);
+                url = temp;
+            }
+            if (url)
+            {
+                temp = CFURLCreateCopyAppendingPathComponent(NULL, url, CFSTR("exeIcon.icns"), FALSE);
+                CFRelease(url);
+                url = temp;
+            }
+            if (url)
+            {
+                macdrv_set_application_icon(NULL, url);
+                CFRelease(url);
+            }
+        }
+    }
 }
 
 
@@ -1235,7 +1273,7 @@
     MSG msg;
     RECT origRect, movedRect, desktopRect;
     LONG hittest = (LONG)(wparam & 0x0f);
-    POINT capturePoint;
+    POINT capturePoint, pt;
     LONG style = GetWindowLongW(hwnd, GWL_STYLE);
     BOOL moved = FALSE;
     DWORD dwPoint = GetMessagePos();
@@ -1248,6 +1286,7 @@
 
     capturePoint.x = (short)LOWORD(dwPoint);
     capturePoint.y = (short)HIWORD(dwPoint);
+    pt = capturePoint;
     ClipCursor(NULL);
 
     TRACE("hwnd %p hittest %d, pos %d,%d\n", hwnd, hittest, capturePoint.x, capturePoint.y);
@@ -1297,7 +1336,6 @@
 
     while(1)
     {
-        POINT pt;
         int dx = 0, dy = 0;
         HMONITOR newmon;
 
@@ -1404,6 +1442,11 @@
                      SWP_NOACTIVATE | SWP_NOSIZE | SWP_NOZORDER);
     }
 
+    /* CrossOver hack 4274 */
+    /* Windows finishes this off with a WM_MOUSEMOVE with the current position.
+       This message is relied on by some games. */
+    PostMessageW(hwnd, WM_MOUSEMOVE, 0, MAKELONG(pt.x, pt.y));
+
     return 0;
 }
 
@@ -2021,7 +2064,7 @@
     data->window_rect = *window_rect;
     data->whole_rect  = *visible_rect;
     data->client_rect = *client_rect;
-    if (!data->ulw_layered)
+    if (data->cocoa_window && !data->ulw_layered)
     {
         if (surface) window_surface_add_ref(surface);
         if (new_style & WS_MINIMIZE)
diff -Naur wine-2.0a/dlls/winex11.drv/clipboard.c wine-2.0b/dlls/winex11.drv/clipboard.c
--- wine-2.0a/dlls/winex11.drv/clipboard.c	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/winex11.drv/clipboard.c	2017-07-11 20:37:51.000000000 +0100
@@ -1328,8 +1328,14 @@
 
     data = GlobalLock( handle );
 
+    /* CROSSOVER HACK: Bug 6613.
+     * Export all of the HTML instead of just the fragment. This ensures that
+     * any classes/styles defined outside the fragment are in the text/html
+     * export. Ideally, we should parse the HTML to find them and ensure that
+     * they are included but that "real" elements outside the fragment are not. */
+
     /* read the important fields */
-    field_value = get_html_description_field(data, "StartFragment:");
+    field_value = get_html_description_field(data, "StartHTML:");
     if (!field_value)
     {
         ERR("Couldn't find StartFragment value\n");
@@ -1337,7 +1343,7 @@
     }
     fragmentstart = atoi(field_value);
 
-    field_value = get_html_description_field(data, "EndFragment:");
+    field_value = get_html_description_field(data, "EndHTML:");
     if (!field_value)
     {
         ERR("Couldn't find EndFragment value\n");
@@ -1451,6 +1457,53 @@
     return ids;
 }
 
+/* CROSSOVER HACK: bug 5027 - OLE clipboard doesn't work across servers */
+static int is_local_format( UINT format )
+{
+    static const WCHAR DataObject[] = {'D','a','t','a','O','b','j','e','c','t',0};
+    static const WCHAR WineMarshalledDataObject[] = {'W','i','n','e',' ','M','a','r','s','h','a','l','l','e','d',' ','D','a','t','a','O','b','j','e','c','t',0};
+    static const WCHAR OlePrivateData[] = {'O','l','e',' ','P','r','i','v','a','t','e',' ','D','a','t','a',0};
+    static const WCHAR EmbedSource[] = {'E','m','b','e','d',' ','S','o','u','r','c','e',0};
+    static const WCHAR EmbeddedObject[] = {'E','m','b','e','d','d','e','d',' ','O','b','j','e','c','t',0};
+    static const WCHAR LinkSource[] = {'L','i','n','k',' ','S','o','u','r','c','e',0};
+    static const WCHAR CustomLinkSource[] = {'C','u','s','t','o','m',' ','L','i','n','k',' ','S','o','u','r','c','e',0};
+    static const WCHAR ObjectDescriptor[] = {'O','b','j','e','c','t',' ','D','e','s','c','r','i','p','t','o','r',0};
+    static const WCHAR LinkSourceDescriptor[] = {'L','i','n','k',' ','S','o','u','r','c','e',' ','D','e','s','c','r','i','p','t','o','r',0};
+    static const WCHAR OwnerLink[] = {'O','w','n','e','r','L','i','n','k',0};
+    static const WCHAR FileName[] = {'F','i','l','e','N','a','m','e',0};
+    static const WCHAR OfficeArt[] = {'+','O','f','f','i','c','e',' ','A','r','t',0};
+    static const WCHAR* local_formats[] = {
+        DataObject,
+        WineMarshalledDataObject,
+        OlePrivateData,
+        EmbedSource,
+        EmbeddedObject,
+        LinkSource,
+        CustomLinkSource,
+        ObjectDescriptor,
+        LinkSourceDescriptor,
+        OwnerLink,
+        FileName,
+        NULL};
+    int i;
+    WCHAR buffer[256];
+
+    GetClipboardFormatNameW( format, buffer, 256 );
+    for (i=0; local_formats[i]; i++)
+        if (lstrcmpW(buffer, local_formats[i]) == 0)
+            return TRUE;
+
+    for (i=0; buffer[i]; i++)
+        if (buffer[i] == '+')
+        {
+            if (lstrcmpW(&buffer[i], OfficeArt) == 0)
+                return TRUE;
+            break;
+        }
+
+    return FALSE;
+}
+
 
 /***********************************************************************
  *           is_format_available
@@ -1489,6 +1542,7 @@
     LIST_FOR_EACH_ENTRY( format, &format_list, struct clipboard_format, entry )
     {
         if (!format->export) continue;
+        if (is_local_format( format->id )) continue;
         /* formats with id==0 are always exported */
         if (format->id && !is_format_available( format->id, formats, count )) continue;
         TRACE( "%d: %s -> %s\n", pos, debugstr_format( format->id ), debugstr_xatom( format->atom ));
diff -Naur wine-2.0a/dlls/winex11.drv/desktop.c wine-2.0b/dlls/winex11.drv/desktop.c
--- wine-2.0a/dlls/winex11.drv/desktop.c	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/winex11.drv/desktop.c	2017-07-11 20:37:51.000000000 +0100
@@ -90,7 +90,7 @@
     return 0;
 }
 
-static LONG X11DRV_desktop_SetCurrentMode(int mode)
+static LONG X11DRV_desktop_SetCurrentMode(int mode, struct x11drv_mode_info *mode_info)
 {
     DWORD dwBpp = screen_bpp;
     if (dwBpp != dd_modes[mode].bpp)
diff -Naur wine-2.0a/dlls/winex11.drv/event.c wine-2.0b/dlls/winex11.drv/event.c
--- wine-2.0a/dlls/winex11.drv/event.c	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/winex11.drv/event.c	2017-07-11 20:37:51.000000000 +0100
@@ -21,6 +21,8 @@
 
 #include "config.h"
 
+#define NONAMELESSUNION
+
 #ifdef HAVE_POLL_H
 #include <poll.h>
 #endif
@@ -1660,6 +1662,17 @@
         }
         break;
 
+    case XEMBED_WINDOW_ACTIVATE:
+        {
+            struct x11drv_win_data *data = get_win_data( hwnd );
+
+            if (!data) return;
+            TRACE( "win %p/%lx XEMBED_WINDOW_ACTIVATE\n", hwnd, event->window );
+            if (data->embedder) xembed_request_focus( data->display, data->embedder, event->data.l[0] );
+            release_win_data( data );
+            break;
+        }
+
     case XEMBED_WINDOW_DEACTIVATE:
         TRACE( "win %p/%lx XEMBED_WINDOW_DEACTIVATE message\n", hwnd, event->window );
         focus_out( event->display, GetAncestor( hwnd, GA_ROOT ) );
diff -Naur wine-2.0a/dlls/winex11.drv/init.c wine-2.0b/dlls/winex11.drv/init.c
--- wine-2.0a/dlls/winex11.drv/init.c	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/winex11.drv/init.c	2017-07-11 20:37:51.000000000 +0100
@@ -375,9 +375,6 @@
                     RECT rect = physDev->dc_rect;
 
                     OffsetRect( &rect, -physDev->dc_rect.left, -physDev->dc_rect.top );
-                    /* The GL drawable may be lagged behind if we don't flush first, so
-                     * flush the display make sure we copy up-to-date data */
-                    XFlush( gdi_display );
                     XSetFunction( gdi_display, physDev->gc, GXcopy );
                     XCopyArea( gdi_display, data->gl_drawable, physDev->drawable, physDev->gc,
                                0, 0, rect.right, rect.bottom,
diff -Naur wine-2.0a/dlls/winex11.drv/keyboard.c wine-2.0b/dlls/winex11.drv/keyboard.c
--- wine-2.0a/dlls/winex11.drv/keyboard.c	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/winex11.drv/keyboard.c	2017-07-11 20:37:51.000000000 +0100
@@ -61,6 +61,10 @@
 WINE_DEFAULT_DEBUG_CHANNEL(keyboard);
 WINE_DECLARE_DEBUG_CHANNEL(key);
 
+#ifdef __APPLE__
+extern int ProcessMacInput(XKeyEvent*);
+#endif
+
 static int min_keycode, max_keycode, keysyms_per_keycode;
 static KeySym *key_mapping;
 static WORD keyc2vkey[256], keyc2scan[256];
@@ -1401,6 +1405,10 @@
     else
         ascii_chars = XLookupString(event, buf, sizeof(buf), &keysym, NULL);
 
+#ifdef __APPLE__
+	ProcessMacInput(event);
+#endif
+
     TRACE_(key)("nbyte = %d, status %d\n", ascii_chars, status);
 
     if (status == XLookupChars)
diff -Naur wine-2.0a/dlls/winex11.drv/mac_xim.c wine-2.0b/dlls/winex11.drv/mac_xim.c
--- wine-2.0a/dlls/winex11.drv/mac_xim.c	1970-01-01 01:00:00.000000000 +0100
+++ wine-2.0b/dlls/winex11.drv/mac_xim.c	2017-07-11 20:37:51.000000000 +0100
@@ -0,0 +1,82 @@
+/*
+ * Functions for further XIM control on the Mac intel OS X platform
+ *
+ * Copyright 2006,2008 CodeWeavers, Aric Stewart
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ *
+ */
+
+#ifdef __APPLE__
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdarg.h>
+
+/* X includes */
+#include <X11/Xatom.h>
+#include <X11/keysym.h>
+#include <X11/Xlib.h>
+#include <X11/Xresource.h>
+#include <X11/Xutil.h>
+#ifdef HAVE_XKB
+#include <X11/XKBlib.h>
+#endif
+
+/* Wine Includes */
+#include "windef.h"
+#include "winbase.h"
+#include "winuser.h"
+#include "wingdi.h"
+#include "winnls.h"
+#include "imm.h"
+#include "ddk/imm.h"
+#include "wine/debug.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(mac_ime);
+
+int ProcessMacInput(XKeyEvent *event)
+{
+    HWND wnd;
+    static HIMC hImc = NULL;
+    HIMC newImc = NULL;
+	KeySym keysym;
+
+	if (event->type != KeyPress)
+		return 0;
+
+    wnd = GetFocus();
+    newImc = ImmGetContext(wnd);
+
+    if (newImc != hImc)
+    {
+        hImc = newImc;
+        if (ImmGetIMEFileNameA(GetKeyboardLayout(0),NULL,0))
+        {
+            /* We have a non default IME  do not do our processing */
+            return 0;
+        }
+    }
+
+    if (hImc)
+    {
+	    XLookupString(event, NULL, 0, &keysym, NULL);
+        ImmEscapeW(GetKeyboardLayout(0),hImc,IME_ESC_PRIVATE_FIRST + 0x10, (LPVOID)keysym);
+        ImmEscapeW(GetKeyboardLayout(0),hImc,IME_ESC_PRIVATE_FIRST + 0x11, (LPVOID)(event->keycode-8));
+    }
+    return 0;
+}
+
+#endif /* __APPLE__ */
diff -Naur wine-2.0a/dlls/winex11.drv/Makefile.in wine-2.0b/dlls/winex11.drv/Makefile.in
--- wine-2.0a/dlls/winex11.drv/Makefile.in	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/winex11.drv/Makefile.in	2017-07-11 20:37:51.000000000 +0100
@@ -14,6 +14,7 @@
 	ime.c \
 	init.c \
 	keyboard.c \
+	mac_xim.c \
 	mouse.c \
 	opengl.c \
 	palette.c \
diff -Naur wine-2.0a/dlls/winex11.drv/opengl.c wine-2.0b/dlls/winex11.drv/opengl.c
--- wine-2.0a/dlls/winex11.drv/opengl.c	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/winex11.drv/opengl.c	2017-07-11 20:37:51.000000000 +0100
@@ -306,6 +306,7 @@
 
 #define USE_GL_FUNC(name) #name,
 static const char *opengl_func_names[] = { ALL_WGL_FUNCS };
+static const char *glu_func_names[] = { ALL_GLU_FUNCS }; /* CrossOver Hack 10798 */
 #undef USE_GL_FUNC
 
 static void X11DRV_WineGL_LoadExtensions(void);
@@ -419,6 +420,12 @@
 static Bool (*pglXQueryRendererIntegerMESA)(Display *dpy, int screen, int renderer, int attribute, unsigned int *value);
 static const char *(*pglXQueryRendererStringMESA)(Display *dpy, int screen, int renderer, int attribute);
 
+/* OpenML GLX Extensions */
+static Bool (*pglXWaitForSbcOML)( Display *dpy, GLXDrawable drawable,
+        INT64 target_sbc, INT64 *ust, INT64 *msc, INT64 *sbc );
+static INT64 (*pglXSwapBuffersMscOML)( Display *dpy, GLXDrawable drawable,
+        INT64 target_msc, INT64 divisor, INT64 remainder );
+
 /* Standard OpenGL */
 static void (*pglFinish)(void);
 static void (*pglFlush)(void);
@@ -580,6 +587,7 @@
 
 static BOOL WINAPI init_opengl( INIT_ONCE *once, void *param, void **context )
 {
+    void *glu_handle;
     char buffer[200];
     int error_base, event_base;
     unsigned int i;
@@ -603,6 +611,20 @@
         }
     }
 
+#ifdef SONAME_LIBGLU /* CrossOver Hack 10798 */
+    glu_handle = wine_dlopen(SONAME_LIBGLU, RTLD_NOW|RTLD_GLOBAL, buffer, sizeof(buffer));
+    if (glu_handle)
+    {
+        for (i = 0; i < sizeof(glu_func_names)/sizeof(glu_func_names[0]); i++)
+        {
+            if (!(((void **)&opengl_funcs.glu)[i] = wine_dlsym( glu_handle, glu_func_names[i], NULL, 0 )))
+                WARN( "%s not found in libGLU\n", glu_func_names[i] );
+        }
+    }
+    else
+        WARN( "Failed to load libGLU: %s\n", buffer );
+#endif
+
     /* redirect some standard OpenGL functions */
 #define REDIRECT(func) \
     do { p##func = opengl_funcs.gl.p_##func; opengl_funcs.gl.p_##func = w##func; } while(0)
@@ -712,7 +734,11 @@
         pglXGetFBConfigAttrib = pglXGetProcAddressARB((const GLubyte *) "glXGetFBConfigAttrib");
         pglXGetVisualFromFBConfig = pglXGetProcAddressARB((const GLubyte *) "glXGetVisualFromFBConfig");
         pglXQueryDrawable = pglXGetProcAddressARB((const GLubyte *) "glXQueryDrawable");
-    } else if (has_extension( WineGLInfo.glxExtensions, "GLX_SGIX_fbconfig")) {
+    } else if(
+#ifdef __APPLE__
+              TRUE ||
+#endif
+              has_extension( WineGLInfo.glxExtensions, "GLX_SGIX_fbconfig")) {
         pglXChooseFBConfig = pglXGetProcAddressARB((const GLubyte *) "glXChooseFBConfigSGIX");
         pglXGetFBConfigAttrib = pglXGetProcAddressARB((const GLubyte *) "glXGetFBConfigAttribSGIX");
         pglXGetVisualFromFBConfig = pglXGetProcAddressARB((const GLubyte *) "glXGetVisualFromFBConfigSGIX");
@@ -751,6 +777,12 @@
         pglXQueryRendererStringMESA = pglXGetProcAddressARB( (const GLubyte *)"glXQueryRendererStringMESA" );
     }
 
+    if (has_extension( WineGLInfo.glxExtensions, "GLX_OML_sync_control" ))
+    {
+        pglXWaitForSbcOML = pglXGetProcAddressARB( (const GLubyte *)"glXWaitForSbcOML" );
+        pglXSwapBuffersMscOML = pglXGetProcAddressARB( (const GLubyte *)"glXSwapBuffersMscOML" );
+    }
+
     X11DRV_WineGL_LoadExtensions();
     init_pixel_formats( gdi_display );
     return TRUE;
@@ -3299,6 +3331,7 @@
     struct x11drv_escape_flush_gl_drawable escape;
     struct gl_drawable *gl;
     struct wgl_context *ctx = NtCurrentTeb()->glContext;
+    INT64 ust, msc, sbc, target_sbc = 0;
 
     TRACE("(%p)\n", hdc);
 
@@ -3331,6 +3364,12 @@
                                    gl->rect.right - gl->rect.left, gl->rect.bottom - gl->rect.top );
             break;
         }
+        if (pglXSwapBuffersMscOML)
+        {
+            pglFlush();
+            target_sbc = pglXSwapBuffersMscOML( gdi_display, gl->drawable, 0, 0, 0 );
+            break;
+        }
         pglXSwapBuffers(gdi_display, gl->drawable);
         break;
     case DC_GL_CHILD_WIN:
@@ -3338,10 +3377,19 @@
         escape.gl_drawable = gl->window;
         /* fall through */
     default:
+        if (pglXSwapBuffersMscOML)
+        {
+            pglFlush();
+            target_sbc = pglXSwapBuffersMscOML( gdi_display, gl->drawable, 0, 0, 0 );
+            break;
+        }
         pglXSwapBuffers(gdi_display, gl->drawable);
         break;
     }
 
+    if (escape.gl_drawable && pglXWaitForSbcOML)
+        pglXWaitForSbcOML( gdi_display, gl->drawable, target_sbc, &ust, &msc, &sbc );
+
     release_gl_drawable( gl );
 
     if (escape.gl_drawable) ExtEscape( ctx->hdc, X11DRV_ESCAPE, sizeof(escape), (LPSTR)&escape, 0, NULL );
diff -Naur wine-2.0a/dlls/winex11.drv/settings.c wine-2.0b/dlls/winex11.drv/settings.c
--- wine-2.0a/dlls/winex11.drv/settings.c	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/winex11.drv/settings.c	2017-07-11 20:37:51.000000000 +0100
@@ -46,7 +46,7 @@
 
 /* pointers to functions that actually do the hard stuff */
 static int (*pGetCurrentMode)(void);
-static LONG (*pSetCurrentMode)(int mode);
+static LONG (*pSetCurrentMode)(int mode, struct x11drv_mode_info *mode_info);
 static const char *handler_name;
 
 /*
@@ -55,7 +55,7 @@
  */
 struct x11drv_mode_info *X11DRV_Settings_SetHandlers(const char *name,
                                                      int (*pNewGCM)(void),
-                                                     LONG (*pNewSCM)(int),
+                                                     LONG (*pNewSCM)(int, struct x11drv_mode_info *),
                                                      unsigned int nmodes,
                                                      int reserve_depths)
 {
@@ -136,7 +136,7 @@
     return 0;
 }
 
-static LONG X11DRV_nores_SetCurrentMode(int mode)
+static LONG X11DRV_nores_SetCurrentMode(int mode, struct x11drv_mode_info *mode_info)
 {
     if (mode == 0) return DISP_CHANGE_SUCCESSFUL;
     TRACE("Ignoring mode change request mode=%d\n", mode);
@@ -417,7 +417,7 @@
             write_registry_settings(devmode);
 
         if (!(flags & (CDS_TEST | CDS_NORESET)))
-            return pSetCurrentMode(i);
+            return pSetCurrentMode(i, &dd_modes[i]);
 
         return DISP_CHANGE_SUCCESSFUL;
     }
diff -Naur wine-2.0a/dlls/winex11.drv/window.c wine-2.0b/dlls/winex11.drv/window.c
--- wine-2.0a/dlls/winex11.drv/window.c	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/winex11.drv/window.c	2017-07-11 20:37:51.000000000 +0100
@@ -28,6 +28,7 @@
 #ifdef HAVE_UNISTD_H
 # include <unistd.h>
 #endif
+#include <sys/types.h>
 
 #include <X11/Xlib.h>
 #include <X11/Xresource.h>
@@ -92,6 +93,8 @@
 static const char foreign_window_prop[] = "__wine_x11_foreign_window";
 static const char whole_window_prop[] = "__wine_x11_whole_window";
 static const char clip_window_prop[]  = "__wine_x11_clip_window";
+static const char unix_pid_prop[]     = "__wine_x11_unix_pid";
+static const char cx_tag_prop[]       = "__wine_x11_cx_tag"; /* CW Hack 9517 */
 
 static CRITICAL_SECTION win_data_section;
 static CRITICAL_SECTION_DEBUG critsect_debug =
@@ -207,6 +210,20 @@
 
     if (!managed_mode) return FALSE;
 
+    /*
+     * CODEWEAVERS HACK
+     * Hack needed to have the mabinogi window not resized incorrectly
+     * by the x11 window manager.
+     */
+    if (1)
+    {
+        char class[80];
+        GetClassNameA(hwnd,class,sizeof class);
+
+        if (strcmp(class,"devcat_launcher") == 0)
+            return FALSE;
+    }
+
     /* child windows are not managed */
     style = GetWindowLongW( hwnd, GWL_STYLE );
     if ((style & (WS_CHILD|WS_POPUP)) == WS_CHILD) return FALSE;
@@ -217,6 +234,75 @@
     if ((style & WS_CAPTION) == WS_CAPTION) return TRUE;
     /* windows with thick frame are managed */
     if (style & WS_THICKFRAME) return TRUE;
+
+    /*
+     * CODEWEAVERS HACKS
+     */
+    if (1)
+    {
+        char class[80], *p;
+        GetClassNameA(hwnd,class,sizeof class);
+        ex_style = GetWindowLongW( hwnd, GWL_EXSTYLE );
+        /*
+         * In Scientific Word, the startup dialog should be managed.
+         * In SAP Netweaver, the tooltips should not (WS_EX_TOPMOST).
+         */
+        if ( (strcmp(class,"#32770")==0) &&
+            !(ex_style & WS_EX_TOPMOST) )
+            return TRUE;
+        if (strcmp(class,"SplashWnd")==0)
+            return TRUE;
+        if (strcmp(class,"iTunes")==0)
+            return TRUE;
+        if (strcmp(class,"QuickTimePlayerMain") == 0)
+            return TRUE; /* QuickTime 7.1 */
+        if ((p = strrchr(class, '\\')) && strcmp(p+1,"QuickTimePlayer.exe") == 0)
+            return TRUE; /* QuickTime 6.x */
+        if (strcmp(class,"PSFloatC")==0)
+            return TRUE;
+        /* the office 97 splash screen is not a toolbar */
+        if (strcmp(class,"MsoSplash") == 0)
+            return TRUE;
+        if ((strcmp(class,"IEFrame") == 0) && (style & WS_SYSMENU))
+            return TRUE;
+        /* for CRPSClient for WorldVistA */
+        if (strcmp(class,"TfrmSplash") == 0)
+            return TRUE;
+        /* Halo setup window */
+        if (strcmp(class,"EBUSetupWnd") == 0)
+            return TRUE;
+        /* AWR line style popup */
+        if (strcmp(class,"WTL_LineStyleColorDD") == 0)
+            return TRUE;
+        /* AWR fill style popup */
+        if (strcmp(class,"WTL_PatternColorDD") == 0)
+            return TRUE;
+        /* Quickbooks InstallShield window */
+        if (strcmp(class,"DlgcacClsName") == 0)
+            return TRUE;
+
+#ifdef __APPLE__
+        /* Macos does not like those windows to be managed, but Linux needs that(handled below in the
+         * POPUP | SYSMENU case
+         */
+        /* EVE online - Does not redraw otherwise*/
+        if(strcmp(class, "eveSplatter") == 0 || strcmp(class, "triuiScreen") == 0)
+            return FALSE;
+#endif
+
+        /* for outlook 2003 completion window */
+        if (strcmp(class,"REListBox20W") == 0 && (style & WS_POPUP) &&
+            (style & WS_SYSMENU))
+            return FALSE;
+
+        /* Outlook 2003 "Toast" window that appears when a new message is
+         * received. Should not be managed to prevent it grabbing keyboard
+         * focus */
+        if (strcmp(class,"NUIDialog") == 0 &&
+            (style & (WS_POPUP|WS_SYSMENU)) == (WS_POPUP|WS_SYSMENU))
+            return FALSE;
+    }
+
     if (style & WS_POPUP)
     {
         HMONITOR hmon;
@@ -923,6 +1009,10 @@
         ex_style = GetWindowLongW( data->hwnd, GWL_EXSTYLE );
     }
 
+    /* HACK for bug 13477. */
+    if (style & WS_MINIMIZE)
+        style |= WS_MINIMIZEBOX;
+
     set_size_hints( data, style );
     set_mwm_hints( data, style, ex_style );
     set_style_hints( data, style, ex_style );
@@ -1480,6 +1570,8 @@
     DWORD layered_flags;
     HRGN win_rgn;
     POINT pos;
+    const char* tag;
+    long tag_num;
 
     if (!data->managed && is_window_managed( data->hwnd, SWP_NOACTIVATE, &data->window_rect ))
     {
@@ -1517,6 +1609,14 @@
 
     XSaveContext( data->display, data->whole_window, winContext, (char *)data->hwnd );
     SetPropA( data->hwnd, whole_window_prop, (HANDLE)data->whole_window );
+    SetPropA( data->hwnd, unix_pid_prop, (HANDLE)getpid() );
+    /* CodeWeavers Hack 9517 */
+    if ((tag = getenv("CX_WINDOW_TAG")) && (tag_num = atol(tag)))
+    {
+        SetPropA( data->hwnd, cx_tag_prop, (HANDLE)tag_num );
+        XChangeProperty( data->display, data->whole_window, x11drv_atom(_CX_APPLEWM_TAG),
+                         XA_CARDINAL, 32, PropModeReplace, (unsigned char*)&tag_num, 1 );
+    }
 
     /* set the window text */
     if (!InternalGetWindowText( data->hwnd, text, sizeof(text)/sizeof(WCHAR) )) text[0] = 0;
@@ -1679,6 +1779,41 @@
 }
 
 
+/************************************************************************
+ *      wine_x11_adopt_window   (WINEX11.DRV.@)
+ *
+ * Adopt an external X window into the specified hwnd.
+ */
+BOOL wine_x11_adopt_window( HWND hwnd, Window xwin )
+{
+    Display *display = thread_init_display();
+    struct x11drv_win_data *data;
+    HWND old_parent, parent;
+    LONG style = GetWindowLongW( hwnd, GWL_STYLE );
+
+    if (!(parent = create_foreign_window( display, xwin ))) return FALSE;
+
+    if (!(data = get_win_data( hwnd ))) return FALSE;
+    make_window_embedded( data );
+    release_win_data( data );
+
+    old_parent = SetParent( hwnd, parent );
+    SetWindowLongW( hwnd, GWL_STYLE, (style & ~WS_POPUP) | WS_CHILD );
+
+    if (old_parent != GetDesktopWindow())
+        PostMessageW( old_parent, WM_CLOSE, 0, 0 );  /* make old parent destroy itself if it no longer has children */
+
+    TRACE( "new window for %p\n", hwnd );
+
+    if (!(data = get_win_data( hwnd ))) return FALSE;
+    XReparentWindow( display, data->whole_window, xwin, 0, 0 );
+    XMapWindow( display, data->whole_window );
+    XSync( display, False );
+    release_win_data( data );
+    return TRUE;
+}
+
+
 /***********************************************************************
  *		X11DRV_DestroyNotify
  */
diff -Naur wine-2.0a/dlls/winex11.drv/winex11.drv.spec wine-2.0b/dlls/winex11.drv/winex11.drv.spec
--- wine-2.0a/dlls/winex11.drv/winex11.drv.spec	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/winex11.drv/winex11.drv.spec	2017-07-11 20:37:51.000000000 +0100
@@ -49,6 +49,9 @@
 @ cdecl SystemParametersInfo(long long ptr long) X11DRV_SystemParametersInfo
 @ cdecl ThreadDetach() X11DRV_ThreadDetach
 
+# Adopted X windows
+@ cdecl wine_x11_adopt_window(long long)
+
 # WinTab32
 @ cdecl AttachEventQueueToTablet(long) X11DRV_AttachEventQueueToTablet
 @ cdecl GetCurrentPacket(ptr) X11DRV_GetCurrentPacket
diff -Naur wine-2.0a/dlls/winex11.drv/x11drv.h wine-2.0b/dlls/winex11.drv/x11drv.h
--- wine-2.0a/dlls/winex11.drv/x11drv.h	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/winex11.drv/x11drv.h	2017-07-11 20:37:51.000000000 +0100
@@ -476,6 +476,8 @@
     XATOM_text_rtf,
     XATOM_text_richtext,
     XATOM_text_uri_list,
+    XATOM__CX_WORKAREA, /* CodeWeavers Hack bug 5752 */
+    XATOM__CX_APPLEWM_TAG, /* CodeWeavers Hack bug 9517 */
     NB_XATOMS
 };
 
@@ -638,7 +640,7 @@
 void X11DRV_Settings_Init(void) DECLSPEC_HIDDEN;
 struct x11drv_mode_info *X11DRV_Settings_SetHandlers(const char *name,
                                                      int (*pNewGCM)(void),
-                                                     LONG (*pNewSCM)(int),
+                                                     LONG (*pNewSCM)(int, struct x11drv_mode_info *),
                                                      unsigned int nmodes,
                                                      int reserve_depths) DECLSPEC_HIDDEN;
 
diff -Naur wine-2.0a/dlls/winex11.drv/x11drv_main.c wine-2.0b/dlls/winex11.drv/x11drv_main.c
--- wine-2.0a/dlls/winex11.drv/x11drv_main.c	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/winex11.drv/x11drv_main.c	2017-07-11 20:37:51.000000000 +0100
@@ -186,7 +186,9 @@
     "text/plain",
     "text/rtf",
     "text/richtext",
-    "text/uri-list"
+    "text/uri-list",
+    "_CX_WORKAREA", /* CodeWeavers Hack bug 5752 */
+    "_CX_APPLEWM_TAG", /* CodeWeavers Hack bug 9517 */
 };
 
 /***********************************************************************
@@ -273,13 +275,16 @@
                error_evt->error_code, error_evt->request_code );
         return 0;
     }
+    ERR("XERROR: code %d request %d minor %d xid %08lx\n",
+        error_evt->error_code,
+        error_evt->request_code,
+        error_evt->minor_code,
+        error_evt->resourceid);
     if (TRACE_ON(synchronous))
     {
-        ERR( "X protocol error: serial=%ld, request_code=%d - breaking into debugger\n",
-             error_evt->serial, error_evt->request_code );
         DebugBreak();  /* force an entry in the debugger */
+        old_error_handler( display, error_evt );
     }
-    old_error_handler( display, error_evt );
     return 0;
 }
 
@@ -407,6 +412,15 @@
 
     get_config_key( hkey, appkey, "InputStyle", input_style, sizeof(input_style) );
 
+    if (!get_config_key(hkey, appkey, "NvThreads", buffer, sizeof(buffer)))
+    {
+        if (IS_OPTION_TRUE(buffer[0]))
+        {
+            setenv("__GL_THREADED_OPTIMIZATIONS", "1", 1);
+            SetEnvironmentVariableA("__GL_THREADED_OPTIMIZATIONS", "1");
+        }
+    }
+
     if (appkey) RegCloseKey( appkey );
     if (hkey) RegCloseKey( hkey );
 }
diff -Naur wine-2.0a/dlls/winex11.drv/xinerama.c wine-2.0b/dlls/winex11.drv/xinerama.c
--- wine-2.0a/dlls/winex11.drv/xinerama.c	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/winex11.drv/xinerama.c	2017-07-11 20:37:51.000000000 +0100
@@ -30,6 +30,7 @@
 #include "wine/library.h"
 #include "x11drv.h"
 #include "wine/debug.h"
+#include "wine/unicode.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(x11drv);
 
@@ -43,6 +44,7 @@
     MONITORINFOF_PRIMARY,       /* dwFlags */
     { '\\','\\','.','\\','D','I','S','P','L','A','Y','1',0 }   /* szDevice */
 };
+static const WCHAR monitor_deviceW[] = { '\\','\\','.','\\','D','I','S','P','L','A','Y','%','d',0 }; /* CrossOver Hack 13441 */
 
 static MONITORINFOEXW *monitors;
 static int nb_monitors;
@@ -67,12 +69,39 @@
     return index - 1;
 }
 
-static void query_work_area( RECT *rc_work )
+/* CodeWeavers Hack bug 5752: Converted to return a region and to query
+ * the _CX_WORKAREA property of the root window in preference to _NET_WORKAREA. */
+static HRGN query_work_area(void)
 {
     Atom type;
     int format;
     unsigned long count, remaining;
     long *work_area;
+    HRGN region = NULL;
+
+    if (!XGetWindowProperty( gdi_display, DefaultRootWindow(gdi_display), x11drv_atom(_CX_WORKAREA), 0,
+                             ~0, False, XA_CARDINAL, &type, &format, &count,
+                             &remaining, (unsigned char **)&work_area ))
+    {
+        if (type == XA_CARDINAL && format == 32 && count >= 4)
+        {
+            int i;
+            HRGN temp = CreateRectRgn( 0, 0, 0, 0 );
+
+            region = CreateRectRgn( 0, 0, 0, 0 );
+            for (i = 0; i + 3 < count; i += 4)
+            {
+                SetRectRgn( temp, work_area[i+0], work_area[i+1],
+                            work_area[i+0] + work_area[i+2], work_area[i+1] + work_area[i+3] );
+                CombineRgn( region, region, temp, RGN_OR );
+            }
+
+            DeleteObject( temp );
+            XFree( work_area );
+            return region;
+        }
+        XFree( work_area );
+    }
 
     if (!XGetWindowProperty( gdi_display, DefaultRootWindow(gdi_display), x11drv_atom(_NET_WORKAREA), 0,
                              ~0, False, XA_CARDINAL, &type, &format, &count,
@@ -80,11 +109,13 @@
     {
         if (type == XA_CARDINAL && format == 32 && count >= 4)
         {
-            SetRect( rc_work, work_area[0], work_area[1],
-                     work_area[0] + work_area[2], work_area[1] + work_area[3] );
+            region = CreateRectRgn( work_area[0], work_area[1],
+                                    work_area[0] + work_area[2], work_area[1] + work_area[3] );
         }
         XFree( work_area );
     }
+
+    return region;
 }
 
 static void query_desktop_work_area( RECT *rc_work )
@@ -127,20 +158,24 @@
 {
     int i, count, event_base, error_base;
     XineramaScreenInfo *screens;
-    RECT rc_work = {0, 0, 0, 0};
+    HRGN workarea_rgn, temp_rgn;
 
     if (!monitors)  /* first time around */
         load_xinerama();
 
-    query_work_area( &rc_work );
-
     if (!pXineramaQueryExtension || !pXineramaQueryScreens ||
         !pXineramaQueryExtension( gdi_display, &event_base, &error_base ) ||
         !(screens = pXineramaQueryScreens( gdi_display, &count ))) return 0;
 
+    /* CodeWeavers Hack bug 5752: made query_work_area return a region */
+    workarea_rgn = query_work_area();
+    temp_rgn = CreateRectRgn( 0, 0, 0, 0 );
+
     if (monitors != &default_monitor) HeapFree( GetProcessHeap(), 0, monitors );
     if ((monitors = HeapAlloc( GetProcessHeap(), 0, count * sizeof(*monitors) )))
     {
+        int device = 2; /* 1 is reserved for primary; CrossOver Hack 13441 */
+
         nb_monitors = count;
         for (i = 0; i < nb_monitors; i++)
         {
@@ -150,16 +185,30 @@
             monitors[i].rcMonitor.right  = screens[i].x_org + screens[i].width;
             monitors[i].rcMonitor.bottom = screens[i].y_org + screens[i].height;
             monitors[i].dwFlags          = 0;
-            if (!IntersectRect( &monitors[i].rcWork, &rc_work, &monitors[i].rcMonitor ))
+            if (workarea_rgn && temp_rgn)
+            {
+                SetRectRgn( temp_rgn, monitors[i].rcMonitor.left, monitors[i].rcMonitor.top,
+                            monitors[i].rcMonitor.right, monitors[i].rcMonitor.bottom );
+                if (CombineRgn( temp_rgn, temp_rgn, workarea_rgn, RGN_AND ) != ERROR)
+                    GetRgnBox( temp_rgn, &monitors[i].rcWork );
+            }
+            else
                 monitors[i].rcWork = monitors[i].rcMonitor;
-            /* FIXME: using the same device name for all monitors for now */
-            lstrcpyW( monitors[i].szDevice, default_monitor.szDevice );
         }
 
         get_primary()->dwFlags |= MONITORINFOF_PRIMARY;
+
+        /* CrossOver Hack 13441 */
+        for (i = 0; i < nb_monitors; i++)
+        {
+            snprintfW( monitors[i].szDevice, sizeof(monitors[i].szDevice) / sizeof(WCHAR),
+                       monitor_deviceW, (monitors[i].dwFlags & MONITORINFOF_PRIMARY) ? 1 : device++ );
+        }
     }
     else count = 0;
 
+    DeleteObject( workarea_rgn );
+    DeleteObject( temp_rgn );
     XFree( screens );
     return count;
 }
@@ -209,9 +258,19 @@
 
     if (root_window != DefaultRootWindow( gdi_display ) || !query_screens())
     {
+        /* CodeWeavers Hack bug 5752: made query_work_area return a region */
+        HRGN workarea, temp;
+
         default_monitor.rcWork = default_monitor.rcMonitor = rect;
         if (root_window == DefaultRootWindow( gdi_display ))
-            query_work_area( &default_monitor.rcWork );
+        {
+            workarea = query_work_area();
+            if ((temp = CreateRectRgnIndirect( &default_monitor.rcWork )) &&
+                CombineRgn( temp, temp, workarea, RGN_AND ) != ERROR)
+                GetRgnBox( temp, &default_monitor.rcWork );
+            DeleteObject( temp );
+            DeleteObject( workarea );
+        }
         else
             query_desktop_work_area( &default_monitor.rcWork );
         nb_monitors = 1;
diff -Naur wine-2.0a/dlls/winex11.drv/xrandr.c wine-2.0b/dlls/winex11.drv/xrandr.c
--- wine-2.0a/dlls/winex11.drv/xrandr.c	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/winex11.drv/xrandr.c	2017-07-11 20:37:51.000000000 +0100
@@ -58,6 +58,7 @@
 MAKE_FUNCPTR(XRRGetOutputInfo)
 MAKE_FUNCPTR(XRRGetScreenResources)
 MAKE_FUNCPTR(XRRSetCrtcConfig)
+MAKE_FUNCPTR(XRRSetScreenSize)
 static typeof(XRRGetScreenResources) *pXRRGetScreenResourcesCurrent;
 static RRMode *xrandr12_modes;
 static int primary_crtc;
@@ -102,6 +103,7 @@
         LOAD_FUNCPTR(XRRGetOutputInfo)
         LOAD_FUNCPTR(XRRGetScreenResources)
         LOAD_FUNCPTR(XRRSetCrtcConfig)
+        LOAD_FUNCPTR(XRRSetScreenSize)
         r = 2;
 #endif
 #undef LOAD_FUNCPTR
@@ -152,7 +154,7 @@
     return res;
 }
 
-static LONG xrandr10_set_current_mode( int mode )
+static LONG xrandr10_set_current_mode( int mode, struct x11drv_mode_info *mode_info )
 {
     SizeID size;
     Rotation rot;
@@ -320,11 +322,14 @@
     return ret;
 }
 
-static LONG xrandr12_set_current_mode( int mode )
+static LONG xrandr12_set_current_mode( int mode, struct x11drv_mode_info *mode_info )
 {
     Status status = RRSetConfigFailed;
+    Screen *screen;
+    XWindowAttributes attr;
     XRRScreenResources *resources;
     XRRCrtcInfo *crtc_info;
+    unsigned int max_width, max_height;
 
     mode = mode % xrandr_mode_count;
 
@@ -345,16 +350,41 @@
     TRACE("CRTC %d: mode %#lx, %ux%u+%d+%d.\n", primary_crtc, crtc_info->mode,
           crtc_info->width, crtc_info->height, crtc_info->x, crtc_info->y);
 
+    screen = DefaultScreenOfDisplay( gdi_display );
+    XGetWindowAttributes( gdi_display, root_window, &attr );
+    max_width = max(attr.width, mode_info->width);
+    max_height = max(attr.height, mode_info->height);
+
+    if (crtc_info->width == attr.width && crtc_info->height == attr.height)
+    {
+        if (max_width > attr.width || max_height > attr.height)
+        {
+            TRACE("CRTC matches the whole screen, also changing screen size.\n");
+            pXRRSetScreenSize( gdi_display, root_window, max_width, max_height,
+                               screen->mwidth, screen->mheight );
+        }
+    }
+
     status = pXRRSetCrtcConfig( gdi_display, resources, resources->crtcs[primary_crtc],
                                 CurrentTime, crtc_info->x, crtc_info->y, xrandr12_modes[mode],
                                 crtc_info->rotation, crtc_info->outputs, crtc_info->noutput );
 
+    if (crtc_info->width == attr.width && crtc_info->height == attr.height)
+    {
+        if (mode_info->width < max_width || mode_info->height < max_height)
+        {
+            TRACE("CRTC matches the whole screen, also changing screen size.\n");
+            pXRRSetScreenSize( gdi_display, root_window, mode_info->width, mode_info->height,
+                               screen->mwidth, screen->mheight );
+        }
+    }
+
     pXRRFreeCrtcInfo( crtc_info );
     pXRRFreeScreenResources( resources );
 
     if (status != RRSetConfigSuccess)
     {
-        ERR("Resolution change not successful -- perhaps display has changed?\n");
+        ERR("Resolution change not successful (%u) -- perhaps display has changed?\n", status);
         return DISP_CHANGE_FAILED;
     }
 
diff -Naur wine-2.0a/dlls/winex11.drv/xvidmode.c wine-2.0b/dlls/winex11.drv/xvidmode.c
--- wine-2.0a/dlls/winex11.drv/xvidmode.c	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/winex11.drv/xvidmode.c	2017-07-11 20:37:51.000000000 +0100
@@ -126,7 +126,7 @@
   return 0;
 }
 
-static LONG X11DRV_XF86VM_SetCurrentMode(int mode)
+static LONG X11DRV_XF86VM_SetCurrentMode(int mode, struct x11drv_mode_info *mode_info)
 {
   DWORD dwBpp = screen_bpp;
   /* only set modes from the original color depth */
diff -Naur wine-2.0a/dlls/winhttp/tests/url.c wine-2.0b/dlls/winhttp/tests/url.c
--- wine-2.0a/dlls/winhttp/tests/url.c	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/winhttp/tests/url.c	2017-07-11 20:37:51.000000000 +0100
@@ -118,7 +118,7 @@
 {
     URL_COMPONENTS uc;
     WCHAR *url;
-    DWORD len;
+    DWORD len, err;
     BOOL ret;
 
     /* NULL components */
@@ -144,22 +144,33 @@
     ok( !ret, "expected failure\n" );
     ok( GetLastError() == ERROR_INVALID_PARAMETER, "expected ERROR_INVALID_PARAMETER got %u\n", GetLastError() );
 
-    /* valid components, NULL url */
+    /* valid components, NULL url, insufficient length */
+    len = 0;
     SetLastError( 0xdeadbeef );
     ret = WinHttpCreateUrl( &uc, 0, NULL, &len );
     ok( !ret, "expected failure\n" );
-    ok( GetLastError() == ERROR_INSUFFICIENT_BUFFER ||
-        GetLastError() == ERROR_INVALID_PARAMETER,
-        "expected ERROR_INSUFFICIENT_BUFFER or ERROR_INVALID_PARAMETER got %u\n", GetLastError() );
+    ok( GetLastError() == ERROR_INSUFFICIENT_BUFFER, "expected ERROR_INSUFFICIENT_BUFFER got %u\n", GetLastError() );
+    ok( len == 57, "expected len 57 got %u\n", len );
+
+    /* valid components, NULL url, sufficient length */
+    SetLastError( 0xdeadbeef );
+    len = 256;
+    ret = WinHttpCreateUrl( &uc, 0, NULL, &len );
+    err = GetLastError();
+    ok( !ret, "expected failure\n" );
+    ok( err == ERROR_INVALID_PARAMETER || broken(err == ERROR_INSUFFICIENT_BUFFER) /* < win7 */,
+        "expected ERROR_INVALID_PARAMETER got %u\n", GetLastError() );
+    ok( len == 256 || broken(len == 57) /* < win7 */, "expected len 256 got %u\n", len );
 
     /* correct size, NULL url */
     fill_url_components( &uc );
     SetLastError( 0xdeadbeef );
     ret = WinHttpCreateUrl( &uc, 0, NULL, &len );
+    err = GetLastError();
     ok( !ret, "expected failure\n" );
-    ok( GetLastError() == ERROR_INSUFFICIENT_BUFFER ||
-        GetLastError() == ERROR_INVALID_PARAMETER,
-        "expected ERROR_INSUFFICIENT_BUFFER or ERROR_INVALID_PARAMETER got %u\n", GetLastError() );
+    ok( err == ERROR_INVALID_PARAMETER || broken(err == ERROR_INSUFFICIENT_BUFFER) /* < win7 */,
+        "expected ERROR_INVALID_PARAMETER got %u\n", GetLastError() );
+    ok( len == 256 || broken(len == 57) /* < win7 */, "expected len 256 got %u\n", len );
 
     /* valid components, allocated url, short length */
     SetLastError( 0xdeadbeef );
diff -Naur wine-2.0a/dlls/winhttp/url.c wine-2.0b/dlls/winhttp/url.c
--- wine-2.0a/dlls/winhttp/url.c	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/winhttp/url.c	2017-07-11 20:37:51.000000000 +0100
@@ -417,13 +417,12 @@
 {
     static const WCHAR formatW[] = {'%','u',0};
     static const WCHAR twoslashW[] = {'/','/'};
-
     DWORD len;
     INTERNET_SCHEME scheme;
 
     TRACE("%p, 0x%08x, %p, %p\n", uc, flags, url, required);
 
-    if (!uc || uc->dwStructSize != sizeof(URL_COMPONENTS) || !required || !url)
+    if (!uc || uc->dwStructSize != sizeof(URL_COMPONENTS) || !required)
     {
         set_last_error( ERROR_INVALID_PARAMETER );
         return FALSE;
@@ -437,6 +436,11 @@
         set_last_error( ERROR_INSUFFICIENT_BUFFER );
         return FALSE;
     }
+    if (!url)
+    {
+        set_last_error( ERROR_INVALID_PARAMETER );
+        return FALSE;
+    }
 
     url[0] = 0;
     *required = len;
diff -Naur wine-2.0a/dlls/wininet/http.c wine-2.0b/dlls/wininet/http.c
--- wine-2.0a/dlls/wininet/http.c	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/wininet/http.c	2017-07-11 20:37:51.000000000 +0100
@@ -2682,17 +2682,20 @@
 {
     netconn_stream_t *netconn_stream = (netconn_stream_t*)stream;
     BYTE buf[1024];
-    int len;
+    int len, res;
+    size_t size;
 
-    if(netconn_end_of_data(stream, req))
-        return TRUE;
+    if(netconn_stream->content_length == ~0u)
+        return FALSE;
 
-    do {
-        if(NETCON_recv(req->netconn, buf, sizeof(buf), FALSE, &len) != ERROR_SUCCESS)
+    while(netconn_stream->content_read < netconn_stream->content_length) {
+        size = min(sizeof(buf), netconn_stream->content_length-netconn_stream->content_read);
+        res = NETCON_recv(req->netconn, buf, size, FALSE, &len);
+        if(res || !len)
             return FALSE;
 
         netconn_stream->content_read += len;
-    }while(netconn_stream->content_read < netconn_stream->content_length);
+    }
 
     return TRUE;
 }
@@ -3123,6 +3126,7 @@
 
     http_request_t *req = (http_request_t*)hdr;
     DWORD res, read, cread, error = ERROR_SUCCESS;
+    BOOL force_sync = FALSE;
 
     TRACE("(%p %p %u %x)\n", req, buf, size, flags);
 
@@ -3131,7 +3135,18 @@
 
     INTERNET_SendCallback(&req->hdr, req->hdr.dwContext, INTERNET_STATUS_RECEIVING_RESPONSE, NULL, 0);
 
-    if (req->session->appInfo->hdr.dwFlags & INTERNET_FLAG_ASYNC)
+    if(req->session->appInfo->hdr.dwFlags & INTERNET_FLAG_ASYNC) {
+        char name[MAX_PATH], *p;
+        GetModuleFileNameA(GetModuleHandleA(NULL),name,MAX_PATH);
+        p = strrchr(name, '\\');
+        p = p ? p+1 : name;
+        if (!strcasecmp(p,"qw.exe")) {
+            FIXME("Forcing sync read for Quicken\n");
+            force_sync = TRUE;
+        }
+    }
+
+    if (!force_sync && (req->session->appInfo->hdr.dwFlags & INTERNET_FLAG_ASYNC))
     {
         read_file_ex_task_t *task;
 
diff -Naur wine-2.0a/dlls/wininet/netconnection.c wine-2.0b/dlls/wininet/netconnection.c
--- wine-2.0a/dlls/wininet/netconnection.c	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/wininet/netconnection.c	2017-07-11 20:37:51.000000000 +0100
@@ -192,6 +192,24 @@
         }
     }
 
+    if (err) /* CrossOver hack tracked by bug 6776 */
+    {
+        HKEY hkey;
+        DWORD type, value, size = sizeof(value);
+
+        /* @@ Wine registry key: HKCU\Software\Wine\wininet */
+        if (!RegOpenKeyA( HKEY_CURRENT_USER, "Software\\Wine\\wininet", &hkey ))
+        {
+            if (!RegQueryValueExA( hkey, "accept_invalid_certs", 0, &type, (BYTE *)&value, &size ) &&
+                type == REG_DWORD && value)
+            {
+                WARN("certificate is invalid, accepting it anyway\n");
+                err = ERROR_SUCCESS;
+            }
+            RegCloseKey( hkey );
+        }
+    }
+
     if(err) {
         WARN("failed %u\n", err);
         CertFreeCertificateChain(chain);
diff -Naur wine-2.0a/dlls/wininet/tests/http.c wine-2.0b/dlls/wininet/tests/http.c
--- wine-2.0a/dlls/wininet/tests/http.c	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/wininet/tests/http.c	2017-07-11 20:37:51.000000000 +0100
@@ -4652,7 +4652,14 @@
     _readex_expect_sync_data_len(line, req, flags, buf, buf_size, exdata, strlen(exdata));
 }
 
-static void send_response_and_wait(const char *response, BOOL close_connection, INTERNET_BUFFERSW *buf)
+static void close_connection(void)
+{
+    char c;
+    SetEvent(conn_wait_event);
+    recv(server_socket, &c, 1, 0);
+}
+
+static void send_response_and_wait(const char *response, BOOL do_close_connection, INTERNET_BUFFERSW *buf)
 {
     DWORD orig_size = buf->dwBufferLength;
 
@@ -4661,11 +4668,8 @@
     if(response)
         server_send_string(response);
 
-    if(close_connection) {
-        char c;
-        SetEvent(conn_wait_event);
-        recv(server_socket, &c, 1, 0);
-    }
+    if(do_close_connection)
+        close_connection();
 
     WaitForSingleObject(hCompleteEvent, INFINITE);
 
@@ -4821,6 +4825,41 @@
     CloseHandle(server_req_rec_event);
 }
 
+static void test_connection_break(int port)
+{
+    INTERNET_BUFFERSW ib;
+    test_request_t req;
+    char buf[24000];
+
+    if(!is_ie7plus)
+        return;
+
+    hCompleteEvent = CreateEventW(NULL, FALSE, FALSE, NULL);
+    conn_wait_event = CreateEventW(NULL, FALSE, FALSE, NULL);
+    server_req_rec_event = CreateEventW(NULL, FALSE, FALSE, NULL);
+
+    memset(&ib, 0, sizeof(ib));
+    ib.dwStructSize = sizeof(ib);
+    ib.lpvBuffer = buf;
+
+    trace("Testing InternetReadFileExW on broken connection...\n");
+
+    open_read_test_request(port, &req,
+                           "HTTP/1.1 200 OK\r\n"
+                           "Server: winetest\r\n"
+                           "Content-Length: 10000\r\n"
+                           "\r\n"
+                           "xx");
+
+    /* close connection and make sure that it's closed on handle release. */
+    close_connection();
+    SET_EXPECT(INTERNET_STATUS_CLOSING_CONNECTION);
+    SET_EXPECT(INTERNET_STATUS_CONNECTION_CLOSED);
+    close_async_handle(req.session, hCompleteEvent, 2);
+    CHECK_NOTIFIED(INTERNET_STATUS_CLOSING_CONNECTION);
+    CHECK_NOTIFIED(INTERNET_STATUS_CONNECTION_CLOSED);
+}
+
 static void test_long_url(int port)
 {
     char long_path[INTERNET_MAX_PATH_LENGTH*2] = "/echo_request?";
@@ -4919,6 +4958,7 @@
     test_basic_auth_credentials_reuse(si.port);
     test_async_read(si.port);
     test_http_read(si.port);
+    test_connection_break(si.port);
     test_long_url(si.port);
     test_remove_dot_segments(si.port);
 
diff -Naur wine-2.0a/dlls/winmm/Makefile.in wine-2.0b/dlls/winmm/Makefile.in
--- wine-2.0a/dlls/winmm/Makefile.in	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/winmm/Makefile.in	2017-07-11 20:37:51.000000000 +0100
@@ -1,7 +1,9 @@
 EXTRADEFS = -D_WINMM_
 MODULE    = winmm.dll
 IMPORTLIB = winmm
-IMPORTS   = uuid user32 advapi32 ole32 msacm32
+IMPORTS   = uuid user32 advapi32
+# CROSSOVER HACK for bug 8627: delay load ole32 and msacm32
+DELAYIMPORTS = ole32 msacm32
 
 C_SRCS = \
 	driver.c \
diff -Naur wine-2.0a/dlls/winspool.drv/generic.ppd wine-2.0b/dlls/winspool.drv/generic.ppd
--- wine-2.0a/dlls/winspool.drv/generic.ppd	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/winspool.drv/generic.ppd	2017-07-11 20:37:51.000000000 +0100
@@ -29,7 +29,7 @@
 
 *OpenUI *PageSize/Media Size: PickOne
 *OrderDependency: 10 AnySetup *PageSize
-*DefaultPageSize: A4
+*DefaultPageSize: Letter
 *PageSize Letter/Letter:	"<</PageSize[612 792]/ImagingBBox null>>setpagedevice"
 *PageSize Legal/Legal:		"<</PageSize[612 1008]/ImagingBBox null>>setpagedevice"
 *PageSize Executive/Executive:	"<</PageSize[522 756]/ImagingBBox null>>setpagedevice"
diff -Naur wine-2.0a/dlls/winspool.drv/wspool.c wine-2.0b/dlls/winspool.drv/wspool.c
--- wine-2.0a/dlls/winspool.drv/wspool.c	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/winspool.drv/wspool.c	2017-07-11 20:37:51.000000000 +0100
@@ -112,10 +112,15 @@
  */
 BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD reason, LPVOID lpReserved)
 {
+  static HMODULE hWineps;
+
   switch (reason)
   {
     case DLL_PROCESS_ATTACH: {
+      /* Hack to avoid loading/unloading wineps many times */
+      hWineps = LoadLibraryA("WINEPS.DRV");
       WINSPOOL_hInstance = hInstance;
+
       DisableThreadLibraryCalls(hInstance);
       WINSPOOL_LoadSystemPrinters();
       break;
@@ -124,6 +129,7 @@
       if (lpReserved) break;
       DeleteCriticalSection(&backend_cs);
       FreeLibrary(hlocalspl);
+      if(hWineps) FreeLibrary(hWineps);
       break;
   }
 
diff -Naur wine-2.0a/dlls/ws2_32/Makefile.in wine-2.0b/dlls/ws2_32/Makefile.in
--- wine-2.0a/dlls/ws2_32/Makefile.in	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/ws2_32/Makefile.in	2017-07-11 20:37:51.000000000 +0100
@@ -2,7 +2,7 @@
 MODULE    = ws2_32.dll
 IMPORTLIB = ws2_32
 DELAYIMPORTS = iphlpapi user32
-EXTRALIBS = $(POLL_LIBS)
+EXTRALIBS = $(POLL_LIBS) $(RT_LIBS)
 
 C_SRCS = \
 	async.c \
diff -Naur wine-2.0a/dlls/ws2_32/socket.c wine-2.0b/dlls/ws2_32/socket.c
--- wine-2.0a/dlls/ws2_32/socket.c	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/ws2_32/socket.c	2017-07-11 20:37:51.000000000 +0100
@@ -34,6 +34,12 @@
 #include <string.h>
 #include <sys/types.h>
 #include <limits.h>
+#ifdef HAVE_SYS_MMAN_H
+# include <sys/mman.h>
+#endif
+#ifdef HAVE_SYS_STAT_H
+# include <sys/stat.h>
+#endif
 #ifdef HAVE_SYS_IPC_H
 # include <sys/ipc.h>
 #endif
@@ -181,6 +187,7 @@
 
 WINE_DEFAULT_DEBUG_CHANNEL(winsock);
 WINE_DECLARE_DEBUG_CHANNEL(winediag);
+WINE_DECLARE_DEBUG_CHANNEL(oculus);
 
 /* names of the protocols */
 static const WCHAR NameIpxW[]   = {'I', 'P', 'X', '\0'};
@@ -3447,6 +3454,59 @@
     return wsaErrno();
 }
 
+static void try_OVR_map(const char *shm_name)
+{
+#ifdef HAVE_SHM_OPEN
+    int fd, ret;
+    HANDLE handle, map;
+    const char *winname = shm_name + 1;
+
+    fd = shm_open(shm_name, O_RDWR, S_IRUSR | S_IWUSR);
+    if(fd < 0){
+        TRACE_(oculus)("No %s shm object\n", shm_name);
+        return;
+    }
+
+    wine_server_send_fd(fd);
+
+    SERVER_START_REQ(alloc_file_handle)
+    {
+        req->access     = GENERIC_READ | GENERIC_WRITE;
+        req->attributes = FILE_ATTRIBUTE_NORMAL;
+        req->fd         = fd;
+        if (!(ret = wine_server_call( req )))
+            handle = wine_server_ptr_handle( reply->handle );
+    }
+    SERVER_END_REQ;
+
+    if(!ret){
+        map = CreateFileMappingA(handle, NULL, PAGE_READWRITE, 0, 0, winname);
+        if(!map){
+            WARN_(oculus)("Couldn't create mapping \"%s\", skipping\n", winname);
+            CloseHandle(handle);
+        }
+    }else
+        WARN_(oculus)("Couldn't allocate file handle\n");
+
+    TRACE_(oculus)("Created map for shm object %s\n", shm_name);
+
+    /* let the handles leak, as we want the mapping to exist until the
+     * session quits */
+#endif
+}
+
+static void setup_oculus(void)
+{
+    /* The hard-coded names below are not strictly correct. We should get the
+     * file paths from `ovrd` using the Oculus SDK. See NetClient::Hmd_Create,
+     * which gives us a HMDNetworkInfo which contains the filenames.
+     *
+     * In practice, there will only ever be one ovrd running and one Rift
+     * connected, so this is good enough. */
+    try_OVR_map("/OVR_cam_0_0");
+    try_OVR_map("/OVR_hmd_0_0");
+}
+
 /***********************************************************************
  *		connect		(WS2_32.4)
  */
@@ -3454,8 +3514,21 @@
 {
     int fd = get_sock_fd( s, FILE_READ_DATA, NULL );
 
+    static const IN6_ADDR ipv6_localhost = IN6ADDR_LOOPBACK_INIT;
+
     TRACE("socket %04lx, ptr %p %s, length %d\n", s, name, debugstr_sockaddr(name), namelen);
 
+#define OCULUS_VR_PORT 30322
+    if (name->sa_family == WS_AF_INET6 &&
+            !memcmp(((struct WS_sockaddr_in6 *)name)->sin6_addr.WS_s6_addr, ipv6_localhost.WS_s6_addr, sizeof(ipv6_localhost.WS_s6_addr)) &&
+            ntohs(((struct WS_sockaddr_in6 *)name)->sin6_port) == OCULUS_VR_PORT){
+        if (getenv("CX_DISABLE_OCULUS") == NULL){
+            TRACE_(oculus)("Client is connecting to Oculus port, setting up SHM maps\n");
+            setup_oculus();
+        }else
+            TRACE_(oculus)("Oculus support disabled in environment\n");
+    }
+
     if (fd != -1)
     {
         NTSTATUS status;
@@ -4920,6 +4993,7 @@
         static const GUID wsarecvmsg_guid = WSAID_WSARECVMSG;
         static const GUID wsasendmsg_guid = WSAID_WSASENDMSG;
 
+        total = sizeof(void*);
         if ( IsEqualGUID(&connectex_guid, in_buff) )
         {
             *(LPFN_CONNECTEX *)out_buff = WS2_ConnectEx;
diff -Naur wine-2.0a/dlls/xmllite/reader.c wine-2.0b/dlls/xmllite/reader.c
--- wine-2.0a/dlls/xmllite/reader.c	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/dlls/xmllite/reader.c	2017-07-11 20:37:51.000000000 +0100
@@ -2777,7 +2777,8 @@
     if (hr == S_OK)
     {
         TRACE("node type %s\n", debugstr_nodetype(This->nodetype));
-        *nodetype = This->nodetype;
+        if (nodetype)
+            *nodetype = This->nodetype;
     }
 
     return hr;
diff -Naur wine-2.0a/include/config.h.in wine-2.0b/include/config.h.in
--- wine-2.0a/include/config.h.in	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/include/config.h.in	2017-07-11 20:37:51.000000000 +0100
@@ -816,6 +816,9 @@
 /* Define to 1 if you have the `settimeofday' function. */
 #undef HAVE_SETTIMEOFDAY
 
+/* Define to 1 if you have the `shm_open' function. */
+#undef HAVE_SHM_OPEN
+
 /* Define to 1 if `interface_id' is a member of `sg_io_hdr_t'. */
 #undef HAVE_SG_IO_HDR_T_INTERFACE_ID
 
@@ -1412,6 +1415,9 @@
 /* Define to the soname of the libGL library. */
 #undef SONAME_LIBGL
 
+/* Define to the soname of the libGLU library. CrossOver Hack 10798 */
+#undef SONAME_LIBGLU
+
 /* Define to the soname of the libgnutls library. */
 #undef SONAME_LIBGNUTLS
 
diff -Naur wine-2.0a/include/shlobj.h wine-2.0b/include/shlobj.h
--- wine-2.0a/include/shlobj.h	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/include/shlobj.h	2017-07-11 20:37:51.000000000 +0100
@@ -57,6 +57,15 @@
     KF_FLAG_ALIAS_ONLY                  = 0x80000000
 } KNOWN_FOLDER_FLAG;
 
+enum
+{
+    GPFIDL_DEFAULT    = 0x00,
+    GPFIDL_ALTNAME    = 0x01,
+    GPFIDL_UNCPRINTER = 0x02
+};
+
+typedef int GPFIDL_FLAGS;
+
 UINT         WINAPI SHAddFromPropSheetExtArray(HPSXA,LPFNADDPROPSHEETPAGE,LPARAM);
 LPVOID       WINAPI SHAlloc(ULONG) __WINE_ALLOC_SIZE(1);
 HRESULT      WINAPI SHCoCreateInstance(LPCWSTR,const CLSID*,IUnknown*,REFIID,LPVOID*);
@@ -83,6 +92,7 @@
 BOOL         WINAPI SHGetPathFromIDListA(LPCITEMIDLIST,LPSTR);
 BOOL         WINAPI SHGetPathFromIDListW(LPCITEMIDLIST,LPWSTR);
 #define             SHGetPathFromIDList WINELIB_NAME_AW(SHGetPathFromIDList)
+BOOL         WINAPI SHGetPathFromIDListEx(PCIDLIST_ABSOLUTE,WCHAR*,DWORD,GPFIDL_FLAGS);
 INT          WINAPI SHHandleUpdateImage(LPCITEMIDLIST);
 HRESULT      WINAPI SHILCreateFromPath(LPCWSTR,LPITEMIDLIST*,DWORD*);
 HRESULT      WINAPI SHLoadOLE(LPARAM);
diff -Naur wine-2.0a/include/sspi.h wine-2.0b/include/sspi.h
--- wine-2.0a/include/sspi.h	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/include/sspi.h	2017-07-11 20:37:51.000000000 +0100
@@ -98,6 +98,9 @@
 SECURITY_STATUS SEC_ENTRY SspiEncodeStringsAsAuthIdentity(
     PCWSTR, PCWSTR, PCWSTR, PSEC_WINNT_AUTH_IDENTITY_OPAQUE *);
 
+SECURITY_STATUS SEC_ENTRY SspiPrepareForCredWrite(
+    PSEC_WINNT_AUTH_IDENTITY_OPAQUE, PCWSTR, PULONG, PCWSTR*, PCWSTR*, PUCHAR*, PULONG);
+
 ULONG SEC_ENTRY SspiPromptForCredentialsA(PCSTR, void *,
     ULONG, PCSTR, PSEC_WINNT_AUTH_IDENTITY_OPAQUE,
     PSEC_WINNT_AUTH_IDENTITY_OPAQUE *, int *, ULONG);
diff -Naur wine-2.0a/include/wine/wgl_driver.h wine-2.0b/include/wine/wgl_driver.h
--- wine-2.0a/include/wine/wgl_driver.h	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/include/wine/wgl_driver.h	2017-07-11 20:37:51.000000000 +0100
@@ -2951,6 +2951,61 @@
         BOOL       (WINE_GLAPI *p_wglSetPixelFormatWINE)(HDC,int);
         BOOL       (WINE_GLAPI *p_wglSwapIntervalEXT)(int);
     } ext;
+    /* CrossOver Hack 10798 */
+    struct
+    {
+        void       (WINE_GLAPI *p_gluBeginCurve)(void*);
+        void       (WINE_GLAPI *p_gluBeginPolygon)(void*);
+        void       (WINE_GLAPI *p_gluBeginSurface)(void*);
+        void       (WINE_GLAPI *p_gluBeginTrim)(void*);
+        GLint      (WINE_GLAPI *p_gluBuild1DMipmaps)(GLenum,GLint,GLsizei,GLenum,GLenum,const void *);
+        GLint      (WINE_GLAPI *p_gluBuild2DMipmaps)(GLenum,GLint,GLsizei,GLsizei,GLenum,GLenum,const void *);
+        void       (WINE_GLAPI *p_gluCylinder)(void*,GLdouble,GLdouble,GLdouble,GLint,GLint);
+        void       (WINE_GLAPI *p_gluDeleteNurbsRenderer)(void*);
+        void       (WINE_GLAPI *p_gluDeleteQuadric)(void*);
+        void       (WINE_GLAPI *p_gluDeleteTess)(void*);
+        void       (WINE_GLAPI *p_gluDisk)(void*,GLdouble,GLdouble,GLint,GLint);
+        void       (WINE_GLAPI *p_gluEndCurve)(void*);
+        void       (WINE_GLAPI *p_gluEndPolygon)(void*);
+        void       (WINE_GLAPI *p_gluEndSurface)(void*);
+        void       (WINE_GLAPI *p_gluEndTrim)(void*);
+        const GLubyte * (WINE_GLAPI *p_gluErrorString)(GLenum);
+        void       (WINE_GLAPI *p_gluGetNurbsProperty)(void*,GLenum,GLfloat*);
+        const GLubyte * (WINE_GLAPI *p_gluGetString)(GLenum);
+        void       (WINE_GLAPI *p_gluGetTessProperty)(void*,GLenum,GLdouble*);
+        void       (WINE_GLAPI *p_gluLoadSamplingMatrices)(void*,const GLfloat *,const GLfloat *,const GLint *);
+        void       (WINE_GLAPI *p_gluLookAt)(GLdouble,GLdouble,GLdouble,GLdouble,GLdouble,GLdouble,GLdouble,GLdouble,GLdouble);
+        void*      (WINE_GLAPI *p_gluNewNurbsRenderer)(void);
+        void*      (WINE_GLAPI *p_gluNewQuadric)(void);
+        void*      (WINE_GLAPI *p_gluNewTess)(void);
+        void       (WINE_GLAPI *p_gluNextContour)(void*,GLenum);
+        void       (WINE_GLAPI *p_gluNurbsCallback)(void*,GLenum,void *);
+        void       (WINE_GLAPI *p_gluNurbsCurve)(void*,GLint,GLfloat *,GLint,GLfloat *,GLint,GLenum);
+        void       (WINE_GLAPI *p_gluNurbsProperty)(void*,GLenum,GLfloat);
+        void       (WINE_GLAPI *p_gluNurbsSurface)(void*,GLint,GLfloat*,GLint,GLfloat*,GLint,GLint,GLfloat*,GLint,GLint,GLenum);
+        void       (WINE_GLAPI *p_gluOrtho2D)(GLdouble,GLdouble,GLdouble,GLdouble);
+        void       (WINE_GLAPI *p_gluPartialDisk)(void*,GLdouble,GLdouble,GLint,GLint,GLdouble,GLdouble);
+        void       (WINE_GLAPI *p_gluPerspective)(GLdouble,GLdouble,GLdouble,GLdouble);
+        void       (WINE_GLAPI *p_gluPickMatrix)(GLdouble,GLdouble,GLdouble,GLdouble,GLint *);
+        GLint      (WINE_GLAPI *p_gluProject)(GLdouble,GLdouble,GLdouble,const GLdouble *,const GLdouble *,const GLint *,GLdouble*,GLdouble*,GLdouble*);
+        void       (WINE_GLAPI *p_gluPwlCurve)(void*,GLint,GLfloat*,GLint,GLenum);
+        void       (WINE_GLAPI *p_gluQuadricCallback)(void*,GLenum,void *);
+        void       (WINE_GLAPI *p_gluQuadricDrawStyle)(void*,GLenum);
+        void       (WINE_GLAPI *p_gluQuadricNormals)(void*,GLenum);
+        void       (WINE_GLAPI *p_gluQuadricOrientation)(void*,GLenum);
+        void       (WINE_GLAPI *p_gluQuadricTexture)(void*,GLboolean);
+        GLint      (WINE_GLAPI *p_gluScaleImage)(GLenum,GLsizei,GLsizei,GLenum,const void *,GLsizei,GLsizei,GLenum,GLvoid*);
+        void       (WINE_GLAPI *p_gluSphere)(void*,GLdouble,GLint,GLint);
+        void       (WINE_GLAPI *p_gluTessBeginContour)(void*);
+        void       (WINE_GLAPI *p_gluTessBeginPolygon)(void*,GLvoid*);
+        void       (WINE_GLAPI *p_gluTessCallback)(void*,GLenum,void *);
+        void       (WINE_GLAPI *p_gluTessEndContour)(void*);
+        void       (WINE_GLAPI *p_gluTessEndPolygon)(void*);
+        void       (WINE_GLAPI *p_gluTessNormal)(void*,GLdouble,GLdouble,GLdouble);
+        void       (WINE_GLAPI *p_gluTessProperty)(void*,GLenum,GLdouble);
+        void       (WINE_GLAPI *p_gluTessVertex)(void*,GLdouble *,GLvoid*);
+        GLint      (WINE_GLAPI *p_gluUnProject)(GLdouble,GLdouble,GLdouble,const GLdouble *,const GLdouble *,const GLint *,GLdouble*,GLdouble*,GLdouble*);
+    } glu;
 };
 
 #define ALL_WGL_FUNCS \
@@ -3291,6 +3346,60 @@
     USE_GL_FUNC(glVertexPointer) \
     USE_GL_FUNC(glViewport)
 
+/* CrossOver Hack 10798 */
+#define ALL_GLU_FUNCS \
+    USE_GL_FUNC(gluBeginCurve) \
+    USE_GL_FUNC(gluBeginPolygon) \
+    USE_GL_FUNC(gluBeginSurface) \
+    USE_GL_FUNC(gluBeginTrim) \
+    USE_GL_FUNC(gluBuild1DMipmaps) \
+    USE_GL_FUNC(gluBuild2DMipmaps) \
+    USE_GL_FUNC(gluCylinder) \
+    USE_GL_FUNC(gluDeleteNurbsRenderer) \
+    USE_GL_FUNC(gluDeleteQuadric) \
+    USE_GL_FUNC(gluDeleteTess) \
+    USE_GL_FUNC(gluDisk) \
+    USE_GL_FUNC(gluEndCurve) \
+    USE_GL_FUNC(gluEndPolygon) \
+    USE_GL_FUNC(gluEndSurface) \
+    USE_GL_FUNC(gluEndTrim) \
+    USE_GL_FUNC(gluErrorString) \
+    USE_GL_FUNC(gluGetNurbsProperty) \
+    USE_GL_FUNC(gluGetString) \
+    USE_GL_FUNC(gluGetTessProperty) \
+    USE_GL_FUNC(gluLoadSamplingMatrices) \
+    USE_GL_FUNC(gluLookAt) \
+    USE_GL_FUNC(gluNewNurbsRenderer) \
+    USE_GL_FUNC(gluNewQuadric) \
+    USE_GL_FUNC(gluNewTess) \
+    USE_GL_FUNC(gluNextContour) \
+    USE_GL_FUNC(gluNurbsCallback) \
+    USE_GL_FUNC(gluNurbsCurve) \
+    USE_GL_FUNC(gluNurbsProperty) \
+    USE_GL_FUNC(gluNurbsSurface) \
+    USE_GL_FUNC(gluOrtho2D) \
+    USE_GL_FUNC(gluPartialDisk) \
+    USE_GL_FUNC(gluPerspective) \
+    USE_GL_FUNC(gluPickMatrix) \
+    USE_GL_FUNC(gluProject) \
+    USE_GL_FUNC(gluPwlCurve) \
+    USE_GL_FUNC(gluQuadricCallback) \
+    USE_GL_FUNC(gluQuadricDrawStyle) \
+    USE_GL_FUNC(gluQuadricNormals) \
+    USE_GL_FUNC(gluQuadricOrientation) \
+    USE_GL_FUNC(gluQuadricTexture) \
+    USE_GL_FUNC(gluScaleImage) \
+    USE_GL_FUNC(gluSphere) \
+    USE_GL_FUNC(gluTessBeginContour) \
+    USE_GL_FUNC(gluTessBeginPolygon) \
+    USE_GL_FUNC(gluTessCallback) \
+    USE_GL_FUNC(gluTessEndContour) \
+    USE_GL_FUNC(gluTessEndPolygon) \
+    USE_GL_FUNC(gluTessNormal) \
+    USE_GL_FUNC(gluTessProperty) \
+    USE_GL_FUNC(gluTessVertex) \
+    USE_GL_FUNC(gluUnProject)
+
 extern struct opengl_funcs * CDECL __wine_get_wgl_driver( HDC hdc, UINT version );
 extern BOOL CDECL __wine_set_pixel_format( HWND hwnd, int format );
 
diff -Naur wine-2.0a/include/wine/wined3d.h wine-2.0b/include/wine/wined3d.h
--- wine-2.0a/include/wine/wined3d.h	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/include/wine/wined3d.h	2017-07-11 20:37:51.000000000 +0100
@@ -1268,6 +1268,7 @@
 #define WINED3D_SRGB_READ_WRITE_CONTROL                         0x00000200
 #define WINED3D_LEGACY_UNBOUND_RESOURCE_COLOR                   0x00000400
 #define WINED3D_NO_PRIMITIVE_RESTART                            0x00000800
+#define WINED3D_NO_CSMT                                         0x00001000
 
 #define WINED3D_RESZ_CODE                                       0x7fa05000
 
@@ -2443,7 +2444,7 @@
 void __cdecl wined3d_rendertarget_view_set_parent(struct wined3d_rendertarget_view *view, void *parent);
 
 HRESULT __cdecl wined3d_sampler_create(struct wined3d_device *device, const struct wined3d_sampler_desc *desc,
-        void *parent, struct wined3d_sampler **sampler);
+        void *parent, struct wined3d_sampler **sampler, BOOL from_cs);
 ULONG __cdecl wined3d_sampler_decref(struct wined3d_sampler *sampler);
 void * __cdecl wined3d_sampler_get_parent(const struct wined3d_sampler *sampler);
 ULONG __cdecl wined3d_sampler_incref(struct wined3d_sampler *sampler);
diff -Naur wine-2.0a/libs/wine/collation.c wine-2.0b/libs/wine/collation.c
--- wine-2.0a/libs/wine/collation.c	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/libs/wine/collation.c	2017-07-11 20:37:51.000000000 +0100
@@ -75,34 +75,34 @@
     0x00000000, 0x02010111, 0x02020111, 0x02030111, 0x02040111, 0x02050111, 0x00000000, 0x00000000,
     0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
     0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-    0x02090111, 0x024b0111, 0x02700111, 0x02a90111, 0x09e00111, 0x02aa0111, 0x02a70111, 0x02690111,
-    0x027a0111, 0x027b0111, 0x02a20111, 0x039f0111, 0x022d0111, 0x02210111, 0x02550111, 0x02a40111,
-    0x0a0b0111, 0x0a0c0111, 0x0a0d0111, 0x0a0e0111, 0x0a0f0111, 0x0a100111, 0x0a110111, 0x0a120111,
-    0x0a130111, 0x0a140111, 0x02370111, 0x02350111, 0x03a30111, 0x03a40111, 0x03a50111, 0x024e0111,
-    0x02a10111, 0x0a150151, 0x0a290141, 0x0a3d0151, 0x0a490151, 0x0a650151, 0x0a910151, 0x0a990151,
+    0x01290111, 0x020c0111, 0x020d0111, 0x020f0111, 0x02100111, 0x02140111, 0x02190111, 0x01200111,
+    0x021b0111, 0x022d0111, 0x02350111, 0x02a70111, 0x02370111, 0x01210111, 0x024b0111, 0x024c0111,
+    0x0a0b0111, 0x0a0c0111, 0x0a0d0111, 0x0a0e0111, 0x0a0f0181, 0x0a100111, 0x0a110111, 0x0a120111,
+    0x0a130111, 0x0a140111, 0x024e0111, 0x024f0111, 0x02a90111, 0x02aa0111, 0x030a0111, 0x02550111,
+    0x025f0111, 0x0a150151, 0x0a290141, 0x0a3d0151, 0x0a490151, 0x0a650151, 0x0a910151, 0x0a990151,
     0x0ab90151, 0x0ad30161, 0x0ae70141, 0x0af70141, 0x0b030161, 0x0b2b0151, 0x0b330151, 0x0b4b0161,
     0x0b670141, 0x0b730141, 0x0b7f0141, 0x0ba70151, 0x0bbf0151, 0x0bd70141, 0x0bef0151, 0x0bfb0141,
-    0x0c030151, 0x0c070141, 0x0c130141, 0x027c0111, 0x02a60111, 0x027d0111, 0x020f0111, 0x021b0111,
-    0x020c0111, 0x0a150111, 0x0a290111, 0x0a3d0111, 0x0a490111, 0x0a650111, 0x0a910111, 0x0a990111,
+    0x0c030151, 0x0c070141, 0x0c130141, 0x02700111, 0x02780111, 0x02790111, 0x027a0111, 0x027b0111,
+    0x027c0111, 0x0a150111, 0x0a290111, 0x0a3d0111, 0x0a490111, 0x0a650111, 0x0a910111, 0x0a990111,
     0x0ab90111, 0x0ad30111, 0x0ae70111, 0x0af70111, 0x0b030111, 0x0b2b0111, 0x0b330111, 0x0b4b0111,
     0x0b670111, 0x0b730111, 0x0b7f0111, 0x0ba70111, 0x0bbf0111, 0x0bd70111, 0x0bef0111, 0x0bfb0111,
-    0x0c030111, 0x0c070111, 0x0c130111, 0x027e0111, 0x03a70111, 0x027f0111, 0x03aa0111, 0x00000000,
-    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x02060111, 0x00000000, 0x00000000,
+    0x0c030111, 0x0c070111, 0x0c130111, 0x027d0111, 0x027e0111, 0x027f0111, 0x029c0111, 0x00000000,
+    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
     0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
     0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
     0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-    0x02090141, 0x024c0111, 0x09df0111, 0x09e10111, 0x09de0111, 0x09e20111, 0x03a80111, 0x029c0111,
-    0x02140111, 0x029f0111, 0x0a150181, 0x02780111, 0x03a60111, 0x02200111, 0x02a00111, 0x02100111,
-    0x030a0111, 0x03a00111, 0x0a0d0151, 0x0a0e0151, 0x020d0111, 0x0c9f0121, 0x029d0111, 0x025f0111,
-    0x02190111, 0x0a0c0151, 0x0b4b01a1, 0x02790111, 0x0a0c0171, 0x0a0c0171, 0x0a0e0171, 0x024f0111,
+    0x01290121, 0x029d0111, 0x03a40111, 0x03a50111, 0x03a60111, 0x03a70111, 0x029f0111, 0x03a80111,
+    0x02a00111, 0x03aa0111, 0x0a150181, 0x03a00111, 0x09de0111, 0x01220111, 0x09df0111, 0x02a10111,
+    0x09e00111, 0x039f0111, 0x0a0d0151, 0x0a0e0151, 0x02a20111, 0x09e10111, 0x09e20111, 0x09ef0111,
+    0x02a40111, 0x0a0c0151, 0x0b4b01a1, 0x03a10111, 0x0a0c0171, 0x0a0c0171, 0x0a0c0171, 0x02a60111,
     0x0a150151, 0x0a150151, 0x0a150151, 0x0a150151, 0x0a150151, 0x0a150151, 0x0a190121, 0x0a3d0151,
     0x0a650151, 0x0a650151, 0x0a650151, 0x0a650151, 0x0ad30161, 0x0ad30161, 0x0ad30161, 0x0ad30161,
     0x0a5d0121, 0x0b330151, 0x0b4b0161, 0x0b4b0161, 0x0b4b0161, 0x0b4b0161, 0x0b4b0161, 0x03a20111,
-    0x0b530121, 0x0bd70141, 0x0bd70141, 0x0bd70141, 0x0bd70141, 0x0c070141, 0x0c3b0121, 0x0ba70131,
+    0x0b530121, 0x0bd70141, 0x0bd70141, 0x0bd70141, 0x0bd70141, 0x0c070141, 0x0bd40121, 0x0ba70131,
     0x0a150111, 0x0a150111, 0x0a150111, 0x0a150111, 0x0a150111, 0x0a150111, 0x0a190111, 0x0a3d0111,
     0x0a650111, 0x0a650111, 0x0a650111, 0x0a650111, 0x0ad30111, 0x0ad30111, 0x0ad30111, 0x0ad30111,
-    0x0a5d0111, 0x0b330111, 0x0b4b0111, 0x0b4b0111, 0x0b4b0111, 0x0b4b0111, 0x0b4b0111, 0x03a10111,
-    0x0b530111, 0x0bd70111, 0x0bd70111, 0x0bd70111, 0x0bd70111, 0x0c070111, 0x0c3b0111, 0x0c070111,
+    0x0a5d0111, 0x0b330111, 0x0b4b0111, 0x0b4b0111, 0x0b4b0111, 0x0b4b0111, 0x0b4b0111, 0x03a30111,
+    0x0b530111, 0x0bd70111, 0x0bd70111, 0x0bd70111, 0x0bd70111, 0x0c070111, 0x0bd40111, 0x0c070111,
     /* 0x0100 .. 0x01ff */
     0x0a150151, 0x0a150111, 0x0a150151, 0x0a150111, 0x0a150151, 0x0a150111, 0x0a3d0151, 0x0a3d0111,
     0x0a3d0151, 0x0a3d0111, 0x0a3d0151, 0x0a3d0111, 0x0a3d0151, 0x0a3d0111, 0x0a490151, 0x0a490111,
@@ -189,7 +189,7 @@
     0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0x020d0111, 0x02140111, 0x0c910121, 0x025f0111,
     0x0c950131, 0x0c990121, 0x0c9b0121, 0xffffffff, 0x0ca20121, 0xffffffff, 0x0ca80121, 0x0cac0121,
     0x0c9b0111, 0x0c910121, 0x0c920131, 0x0c930121, 0x0c940121, 0x0c950131, 0x0c980121, 0x0c990121,
-    0x0c9a0131, 0x0c9b0121, 0x0c9d0131, 0x0c9e0121, 0x0c9f0131, 0x0ca00121, 0x0ca10121, 0x0ca20121,
+    0x0c9a0131, 0x0c9b0121, 0x0c9d0131, 0x0c9e0121, 0x0c9f0121, 0x0ca00121, 0x0ca10121, 0x0ca20121,
     0x0ca30131, 0x0ca50131, 0xffffffff, 0x0ca60131, 0x0ca70121, 0x0ca80121, 0x0ca90131, 0x0caa0121,
     0x0cab0121, 0x0cac0121, 0x0c9b0121, 0x0ca80121, 0x0c910111, 0x0c950111, 0x0c990111, 0x0c9b0111,
     0x0ca80111, 0x0c910111, 0x0c920111, 0x0c930111, 0x0c940111, 0x0c950111, 0x0c980111, 0x0c990111,
@@ -929,12 +929,12 @@
     0xffffffff, 0xffffffff, 0x0cac0111, 0x0cac0111, 0x0cac0111, 0xffffffff, 0x0cac0111, 0x0cac0111,
     0x0ca20121, 0x0ca20121, 0x0cac0121, 0x0cac0121, 0x0cac0121, 0x020d0111, 0x02180111, 0xffffffff,
     /* 0x2000 .. 0x20ff */
-    0x02090131, 0x02090131, 0x02090131, 0x02090131, 0x02090131, 0x02090131, 0x02090131, 0x02090141,
-    0x02090131, 0x02090131, 0x02090131, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+    0x02090121, 0x02090121, 0x02090121, 0x02090121, 0x02090121, 0x02090121, 0x02090121, 0x02090131,
+    0x02090121, 0x02090121, 0x02090121, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
     0x02250111, 0x02250121, 0x02260111, 0x02270111, 0x02280111, 0x02290111, 0x03a90111, 0x021c0111,
     0x026a0111, 0x026b0111, 0x026c0111, 0x026d0111, 0x02710111, 0x02720111, 0x02730111, 0x02740111,
     0x02ae0111, 0x02af0111, 0x02b00111, 0x02b10111, 0x02550131, 0x02550131, 0x02550131, 0x02b20111,
-    0x02070111, 0x02080111, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x02090141,
+    0x02070111, 0x02080111, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x02090131,
     0x02ac0111, 0x02ad0111, 0x02b60111, 0x02b60121, 0x02b60121, 0x02b70111, 0x02b70121, 0x02b70121,
     0x02b90111, 0x026e0111, 0x026f0111, 0x02ba0111, 0x024b0131, 0x02540111, 0x02110111, 0x02bb0111,
     0x02bc0111, 0x02bd0111, 0x02be0111, 0x02b30111, 0x02a50111, 0x02860111, 0x02870111, 0xffffffff,
@@ -1292,7 +1292,7 @@
     0x09a90111, 0x09aa0111, 0x09ab0111, 0x09ac0111, 0x09ad0111, 0x09ae0111, 0x09af0111, 0x09b00111,
     0x09b10111, 0x09b20111, 0x09b30111, 0x09b40111, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
     /* 0x3000 .. 0x30ff */
-    0x02090121, 0x02340111, 0x025e0111, 0x02b80111, 0x09b50111, 0x09d70111, 0x192c0111, 0x0a0b0111,
+    0x02090111, 0x02340111, 0x025e0111, 0x02b80111, 0x09b50111, 0x09d70111, 0x192c0111, 0x0a0b0111,
     0x02880111, 0x02890111, 0x028a0111, 0x028b0111, 0x028c0111, 0x028d0111, 0x028e0111, 0x028f0111,
     0x02900111, 0x02910111, 0x09b60111, 0x09b70111, 0x02920111, 0x02930111, 0x02940111, 0x02950111,
     0x02960111, 0x02970111, 0x02980111, 0x02990111, 0x022a0111, 0x02750111, 0x02760111, 0x02770111,
@@ -1407,14 +1407,14 @@
     0x0a0c0131, 0x0a0c0131, 0x0a0c0131, 0x0a0c0131, 0x0a0d0131, 0x0a0d0131, 0x0a0d0131, 0x0a0d0131,
     0x0a0d0131, 0x0ab901a1, 0x0a490191, 0x0a1501a1, 0x0a290181, 0x0b4b01b1, 0x0b670181, 0xffffffff,
     0xffffffff, 0xffffffff, 0xffffffff, 0xfb400151, 0xfb400151, 0xfb400151, 0xfb400151, 0xfb400151,
-    0x0b670181, 0x0b3301b1, 0x0c9f0141, 0x0b2b01a1, 0x0af70171, 0x0af70181, 0x0b2b01b1, 0x0a990181,
-    0x0a3d01a1, 0x0af70171, 0x0b670181, 0x0b3301b1, 0x0c9f0141, 0x0c9f0141, 0x0b2b01a1, 0x0af70171,
-    0x0ab901b1, 0x0af70171, 0x0b2b01b1, 0x0a990181, 0x0bbf01a1, 0x0c9f0141, 0x0b2b01a1, 0x0a490191,
-    0x0af70171, 0x0a910191, 0x0b3301b1, 0x0c9f0141, 0x0b2b01a1, 0x0a3d01a1, 0x0af70171, 0x0b2b01a1,
+    0x0b670181, 0x0b3301b1, 0x0c9f0131, 0x0b2b01a1, 0x0af70171, 0x0af70181, 0x0b2b01b1, 0x0a990181,
+    0x0a3d01a1, 0x0af70171, 0x0b670181, 0x0b3301b1, 0x0c9f0131, 0x0c9f0131, 0x0b2b01a1, 0x0af70171,
+    0x0ab901b1, 0x0af70171, 0x0b2b01b1, 0x0a990181, 0x0bbf01a1, 0x0c9f0131, 0x0b2b01a1, 0x0a490191,
+    0x0af70171, 0x0a910191, 0x0b3301b1, 0x0c9f0131, 0x0b2b01a1, 0x0a3d01a1, 0x0af70171, 0x0b2b01a1,
     0x0a3d01a1, 0x0b2b01a1, 0x0af70171, 0x0b2b01a1, 0x0a3d01a1, 0x0b2b01a1, 0x0af70171, 0x0b2b01a1,
     0x0b2b01a1, 0x0b670191, 0x0af70171, 0x0b2b01b1, 0x0a990181, 0x0b7f01a1, 0x0b7f01a1, 0x0b7f01a1,
-    0x0b670181, 0x0b3301b1, 0x0c9f0141, 0x0b2b01a1, 0x0b670181, 0x0b3301b1, 0x0c9f0141, 0x0b2b01a1,
-    0x0af70171, 0x0b2b01b1, 0x0b670181, 0x0b3301b1, 0x0c9f0141, 0x0b2b01a1, 0x0af70171, 0x0b2b01b1,
+    0x0b670181, 0x0b3301b1, 0x0c9f0131, 0x0b2b01a1, 0x0b670181, 0x0b3301b1, 0x0c9f0131, 0x0b2b01a1,
+    0x0af70171, 0x0b2b01b1, 0x0b670181, 0x0b3301b1, 0x0c9f0131, 0x0b2b01a1, 0x0af70171, 0x0b2b01b1,
     0x0af70171, 0x0b2b01b1, 0x0a150191, 0x0a290191, 0x0a3d01a1, 0x0a3d01a1, 0x0a3d01b1, 0x0a3d01b1,
     0x0a490191, 0x0a990181, 0x0ab901a1, 0x0ab901b1, 0x0ad301b1, 0x0af70181, 0x0af70181, 0x0af70171,
     0x0b0301c1, 0x0b0301c1, 0x0b0301c1, 0x0b0301c1, 0x0b2b01a1, 0x0b2b01a1, 0x0b2b01a1, 0x0b670191,
@@ -1601,7 +1601,7 @@
     0xffffffff, 0x02110121, 0x02110121, 0x02110121, 0x02110121, 0x021b0131, 0x021b0131, 0x021b0131,
     0x022d0131, 0x02340121, 0x02550141, 0xffffffff, 0x02350131, 0x02370131, 0x024e0141, 0x024b0141,
     0x02280121, 0x027a0141, 0x027b0131, 0x027e0131, 0x027f0131, 0x02920121, 0x02930121, 0x02a90131,
-    0x02a70131, 0x02a20131, 0x039f0141, 0x02210131, 0x03a30131, 0x03a50131, 0x03a40131, 0xffffffff,
+    0x02a70131, 0x02a20131, 0x039f0141, 0x02210121, 0x03a30131, 0x03a50131, 0x03a40131, 0xffffffff,
     0x02a60131, 0x09e00131, 0x02aa0131, 0x02a10131, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
     0x00006831, 0x00006821, 0x00006921, 0xffffffff, 0x00006a21, 0xffffffff, 0x00006b31, 0x00006b21,
     0x00006c31, 0x00006c21, 0x00006d31, 0x00006d21, 0x00006e31, 0x00006e21, 0x00006f31, 0x00006f21,
@@ -1622,8 +1622,8 @@
     0x0f480141, 0x0f490161, 0x0f490151, 0x0f490131, 0x0f490141, 0x0f2d0151, 0x0f2d0141, 0x0f2d0151,
     0x0f2d0141, 0x0f2d0151, 0x0f2d0141, 0x0f2d0151, 0x0f2d0141, 0xffffffff, 0xffffffff, 0x00000000,
     /* 0xff00 .. 0xffff */
-    0xffffffff, 0x024b0121, 0x02700121, 0x02a90121, 0x09e00121, 0x02aa0121, 0x02a70121, 0x02690121,
-    0x027a0121, 0x027b0121, 0x02a20121, 0x039f0121, 0x022d0121, 0x02210121, 0x02550121, 0x02a40121,
+    0xffffffff, 0x024b0121, 0x02700121, 0x02a90121, 0x09e00121, 0x02aa0121, 0x02a70121, 0x02690111,
+    0x027a0121, 0x027b0121, 0x02a20121, 0x039f0121, 0x022d0121, 0x02210111, 0x02550121, 0x02a40121,
     0x0a0b0121, 0x0a0c0121, 0x0a0d0121, 0x0a0e0121, 0x0a0f0121, 0x0a100121, 0x0a110121, 0x0a120121,
     0x0a130121, 0x0a140121, 0x02370121, 0x02350121, 0x03a30121, 0x03a40121, 0x03a50121, 0x024e0121,
     0x02a10121, 0x0a150161, 0x0a290151, 0x0a3d0161, 0x0a490161, 0x0a650161, 0x0a910161, 0x0a990161,
diff -Naur wine-2.0a/libs/wine/ldt.c wine-2.0b/libs/wine/ldt.c
--- wine-2.0a/libs/wine/ldt.c	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/libs/wine/ldt.c	2017-07-11 20:37:51.000000000 +0100
@@ -99,6 +99,8 @@
 
 #ifdef __APPLE__
 #include <i386/user_ldt.h>
+#include <pthread.h>
+static pthread_mutex_t ldt_mutex = PTHREAD_MUTEX_INITIALIZER;
 #endif
 
 /* local copy of the LDT */
@@ -206,8 +208,10 @@
         if ((ret = sysi86(SI86DSCR, &ldt_mod)) == -1) perror("sysi86");
     }
 #elif defined(__APPLE__)
+    pthread_mutex_lock(&ldt_mutex);
     if ((ret = i386_set_ldt(index, (union ldt_entry *)entry, 1)) < 0)
         perror("i386_set_ldt");
+    pthread_mutex_unlock(&ldt_mutex);
 #elif defined(__GNU__)
     if ((ret = i386_set_ldt(mach_thread_self(), sel, (descriptor_list_t)entry, 1)) != KERN_SUCCESS)
         perror("i386_set_ldt");
diff -Naur wine-2.0a/libs/wine/loader.c wine-2.0b/libs/wine/loader.c
--- wine-2.0a/libs/wine/loader.c	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/libs/wine/loader.c	2017-07-11 20:37:51.000000000 +0100
@@ -49,6 +49,24 @@
 #undef LoadResource
 #undef GetCurrentThread
 #include <pthread.h>
+#include <mach-o/getsect.h> /* CrossOver Hack 13438 */
+#include <mach-o/dyld.h>
+
+/* CrossOver Hack 13438 */
+#define MAKEFUNC(f) static typeof(f) *p##f
+MAKEFUNC(CFNotificationCenterGetDistributedCenter);
+MAKEFUNC(CFRelease);
+MAKEFUNC(CFRunLoopAddSource);
+MAKEFUNC(CFRunLoopGetCurrent);
+MAKEFUNC(CFRunLoopRun);
+MAKEFUNC(CFRunLoopSourceCreate);
+MAKEFUNC(CFRunLoopSourceSignal);
+MAKEFUNC(CFRunLoopStop);
+MAKEFUNC(kCFRunLoopCommonModes);
+MAKEFUNC(MPCurrentTaskID);
+MAKEFUNC(MPTaskIsPreemptive);
+#undef MAKEFUNC
+
 #else
 extern char **environ;
 #endif
@@ -686,6 +704,87 @@
 };
 
 /***********************************************************************
+ *           apple_override_bundle_name
+ *
+ * Rewrite the bundle name in the Info.plist embedded in the loader.
+ * This is the only way to control the title of the application menu
+ * when using the Mac driver.  The GUI frameworks call down into Core
+ * Foundation to get the bundle name for that.
+ *
+ * CrossOver Hack 13438
+ */
+static void apple_override_bundle_name( int argc, char *argv[] )
+{
+    char* info_plist;
+    unsigned long remaining;
+    static const char prefix[] = "<key>CFBundleName</key>\n    <string>";
+    const size_t prefix_len = strlen(prefix);
+    static const char suffix[] = "</string>";
+    const size_t suffix_len = strlen(suffix);
+    static const char padding[] = "<!-- bundle name padding -->";
+    const size_t padding_len = strlen(padding);
+    char* bundle_name;
+    const char* p;
+    int bundle_name_len, max_bundle_name_len;
+    uintptr_t start, end;
+    const char* new_bundle_name;
+    int new_bundle_name_len;
+
+    if (argc < 2)
+        return;
+
+    info_plist = getsectdata("__TEXT", "__info_plist", &remaining);
+    if (!info_plist || !remaining)
+        return;
+    info_plist += _dyld_get_image_vmaddr_slide(0);
+
+    bundle_name = strnstr(info_plist, prefix, remaining);
+    if (!bundle_name)
+        return;
+
+    bundle_name += prefix_len;
+    remaining -= bundle_name - info_plist;
+    p = strnstr(bundle_name, suffix, remaining);
+    if (!p)
+        return;
+
+    bundle_name_len = p - bundle_name;
+    remaining -= bundle_name_len + suffix_len;
+
+    max_bundle_name_len = bundle_name_len;
+    if (padding_len <= remaining &&
+        !memcmp(bundle_name + bundle_name_len + suffix_len, padding, padding_len))
+        max_bundle_name_len += padding_len;
+
+    new_bundle_name = argv[1];
+    if ((p = strrchr(new_bundle_name, '\\'))) new_bundle_name = p + 1;
+    if ((p = strrchr(new_bundle_name, '/'))) new_bundle_name = p + 1;
+    if (strspn(new_bundle_name, "0123456789abcdefABCDEF") == 32 &&
+        new_bundle_name[32] == '.')
+        new_bundle_name += 33;
+    if ((p = strrchr(new_bundle_name, '.')) && p != new_bundle_name)
+        new_bundle_name_len = p - new_bundle_name;
+    else
+        new_bundle_name_len = strlen(new_bundle_name);
+    if (!new_bundle_name_len)
+        return;
+
+    start = (uintptr_t)bundle_name;
+    end = (uintptr_t)(bundle_name + max_bundle_name_len + suffix_len);
+    start &= ~(getpagesize() - 1);
+    end = (end + getpagesize() - 1) & ~(getpagesize() - 1);
+    if (mprotect((void*)start, end - start, PROT_READ|PROT_WRITE|PROT_EXEC) == 0)
+    {
+        int copy_len = min(new_bundle_name_len, max_bundle_name_len);
+        memcpy(bundle_name, new_bundle_name, copy_len);
+        memcpy(bundle_name + copy_len, suffix, suffix_len);
+        if (copy_len < max_bundle_name_len)
+            memset(bundle_name + copy_len + suffix_len, ' ', max_bundle_name_len - copy_len);
+        mprotect((void*)start, end - start, PROT_READ|PROT_EXEC);
+    }
+}
+
+/***********************************************************************
  *           apple_alloc_thread_stack
  *
  * Callback for wine_mmap_enum_reserved_areas to allocate space for
@@ -747,7 +846,7 @@
      * the run loop allows apple_main_thread() and thus wine_init() to
      * return. */
     if (!success)
-        CFRunLoopStop( CFRunLoopGetCurrent() );
+        pCFRunLoopStop( pCFRunLoopGetCurrent() );
 }
 
 
@@ -761,9 +860,53 @@
  */
 static void apple_main_thread( void (*init_func)(void) )
 {
+    void *corefoundation_handle, *coreservices_handle;
+    char error[1024];
     CFRunLoopSourceContext source_context = { 0 };
     CFRunLoopSourceRef source;
 
+    /* CrossOver Hack 13438: dynamically load CoreFoundation and CoreServices */
+    corefoundation_handle = wine_dlopen("/System/Library/Frameworks/CoreFoundation.framework/CoreFoundation",
+                                        RTLD_LAZY, error, sizeof(error));
+    if (!corefoundation_handle)
+    {
+        fprintf(stderr, "wine: failed to load CoreFoundation; %s\n", error);
+        return;
+    }
+
+#define LOADFUNC(f) if (!(p##f = wine_dlsym(corefoundation_handle, #f, error, sizeof(error)))) \
+                    { \
+                        fprintf(stderr, "wine: failed to load symbol %s; %s\n", #f, error); \
+                        return; \
+                    }
+    LOADFUNC(CFNotificationCenterGetDistributedCenter);
+    LOADFUNC(CFRelease);
+    LOADFUNC(CFRunLoopAddSource);
+    LOADFUNC(CFRunLoopGetCurrent);
+    LOADFUNC(CFRunLoopRun);
+    LOADFUNC(CFRunLoopSourceCreate);
+    LOADFUNC(CFRunLoopSourceSignal);
+    LOADFUNC(CFRunLoopStop);
+    LOADFUNC(kCFRunLoopCommonModes);
+#undef LOADFUNC
+
+    coreservices_handle = wine_dlopen("/System/Library/Frameworks/CoreServices.framework/CoreServices",
+                                        RTLD_LAZY, error, sizeof(error));
+    if (!coreservices_handle)
+    {
+        fprintf(stderr, "wine: failed to load CoreServices; %s\n", error);
+        return;
+    }
+
+#define LOADFUNC(f) if (!(p##f = wine_dlsym(coreservices_handle, #f, error, sizeof(error)))) \
+                    { \
+                        fprintf(stderr, "wine: failed to load symbol %s; %s\n", #f, error); \
+                        return; \
+                    }
+    LOADFUNC(MPCurrentTaskID);
+    LOADFUNC(MPTaskIsPreemptive);
+#undef LOADFUNC
+
     if (!pthread_main_np())
     {
         init_func();
@@ -773,12 +916,12 @@
     /* Multi-processing Services can get confused about the main thread if the
      * first time it's used is on a secondary thread.  Use it here to make sure
      * that doesn't happen. */
-    MPTaskIsPreemptive(MPCurrentTaskID());
+    pMPTaskIsPreemptive(pMPCurrentTaskID());
 
     /* Give ourselves the best chance of having the distributed notification
      * center scheduled on this thread's run loop.  In theory, it's scheduled
      * in the first thread to ask for it. */
-    CFNotificationCenterGetDistributedCenter();
+    pCFNotificationCenterGetDistributedCenter();
 
     /* We use this run loop source for two purposes.  First, a run loop exits
      * if it has no more sources scheduled.  So, we need at least one source
@@ -788,15 +931,16 @@
      * adding it and have its callback spin off the Wine thread. */
     source_context.info = init_func;
     source_context.perform = apple_create_wine_thread;
-    source = CFRunLoopSourceCreate( NULL, 0, &source_context );
+    source = pCFRunLoopSourceCreate( NULL, 0, &source_context );
 
     if (source)
     {
-        CFRunLoopAddSource( CFRunLoopGetCurrent(), source, kCFRunLoopCommonModes );
-        CFRunLoopSourceSignal( source );
-        CFRelease( source );
+        /* CrossOver Hack 13438 */
+        pCFRunLoopAddSource( pCFRunLoopGetCurrent(), source, *pkCFRunLoopCommonModes );
+        pCFRunLoopSourceSignal( source );
+        pCFRelease( source );
 
-        CFRunLoopRun(); /* Should never return, except on error. */
+        pCFRunLoopRun(); /* Should never return, except on error. */
     }
 
     /* If we get here (i.e. return), that indicates failure to our caller. */
@@ -807,7 +951,7 @@
 #ifdef __ANDROID__
 
 #ifndef WINE_JAVA_CLASS
-#define WINE_JAVA_CLASS "org/winehq/wine/WineActivity"
+#define WINE_JAVA_CLASS "org/winehq/wine/WineDriver"
 #endif
 
 static JavaVM *java_vm;
@@ -930,6 +1074,10 @@
     set_max_limit( RLIMIT_AS );
 #endif
 
+#ifdef __APPLE__ /* CrossOver Hack 13438 */
+    apple_override_bundle_name(argc, argv);
+#endif
+
     wine_init_argv0_path( argv[0] );
     build_dll_path();
     __wine_main_argc = argc;
diff -Naur wine-2.0a/libs/wine/Makefile.in wine-2.0b/libs/wine/Makefile.in
--- wine-2.0a/libs/wine/Makefile.in	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/libs/wine/Makefile.in	2017-07-11 20:37:51.000000000 +0100
@@ -1,4 +1,5 @@
-EXTRALIBS = $(DL_LIBS) $(COREFOUNDATION_LIBS) $(CORESERVICES_LIBS)
+# CrossOver Hack 13438: Don't link against CoreFoundation or CoreServices
+EXTRALIBS = $(DL_LIBS)
 EXTRADEFS = -DWINE_UNICODE_API=""
 
 C_SRCS = \
diff -Naur wine-2.0a/loader/wine.inf.in wine-2.0b/loader/wine.inf.in
--- wine-2.0a/loader/wine.inf.in	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/loader/wine.inf.in	2017-07-11 20:37:51.000000000 +0100
@@ -2501,7 +2501,7 @@
 11,,cryptdlg.dll,1
 11,,cryptnet.dll,1
 11,,devenum.dll,1
-11,,mscoree.dll,1
+;(cw)11,,mscoree.dll,1
 11,,mshtml.dll,1
 11,,msisip.dll,1
 11,,qcap.dll,1
@@ -2578,6 +2578,7 @@
 10,,regedit.exe
 11,,explorer.exe
 11,,iexplore.exe
+11,,netscape.exe,-
 11,,notepad.exe
 11,,winetest.exe,-
 12,,fltmgr.sys
@@ -3357,7 +3358,7 @@
 HKLM,%CurrentVersionNT%\SvcHost,"netsvcs",0x00010008,"Schedule"
 
 [Services]
-HKLM,%CurrentVersion%\RunServices,"winemenubuilder",2,"%11%\winemenubuilder.exe -a -r"
+;(cw)HKLM,%CurrentVersion%\RunServices,"winemenubuilder",2,"%11%\winemenubuilder.exe -a -r"
 HKLM,"System\CurrentControlSet\Services\Eventlog\Application",,16
 HKLM,"System\CurrentControlSet\Services\Eventlog\System",,16
 HKLM,"System\CurrentControlSet\Services\Tcpip\Parameters",,16
diff -Naur wine-2.0a/loader/wine_info.plist.in wine-2.0b/loader/wine_info.plist.in
--- wine-2.0a/loader/wine_info.plist.in	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/loader/wine_info.plist.in	2017-07-11 20:37:51.000000000 +0100
@@ -7,13 +7,13 @@
     <key>CFBundleDevelopmentRegion</key>
     <string>English</string>
     <key>CFBundleExecutable</key>
-    <string>wine</string>
+    <string>wineloader</string><!-- CrossOver Hack 10913 -->
     <key>CFBundleIdentifier</key>
-    <string>org.winehq.wine</string>
+    <string>com.codeweavers.CrossOver.wineloader</string><!-- CrossOver Hack 10913 -->
     <key>CFBundleInfoDictionaryVersion</key>
     <string>6.0</string>
     <key>CFBundleName</key>
-    <string>Wine</string>
+    <string>CrossOver-Hosted Application</string><!-- CrossOver Hack 10913 -->
     <key>CFBundlePackageType</key>
     <string>APPL</string>
     <key>CFBundleShortVersionString</key>
diff -Naur wine-2.0a/Makefile.in wine-2.0b/Makefile.in
--- wine-2.0a/Makefile.in	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/Makefile.in	2017-07-11 20:37:48.000000000 +0100
@@ -120,6 +120,31 @@
 distclean:: clean
 	$(RM) -r autom4te.cache documentation/html documentation/api-guide documentation/api-guide-xml documentation/man$(api_manext)
 
+UNWANTED_FILES = \
+	$(DESTDIR)$(bindir)/msiexec \
+	$(DESTDIR)$(bindir)/notepad \
+	$(DESTDIR)$(bindir)/regedit \
+	$(DESTDIR)$(bindir)/regsvr32 \
+	$(DESTDIR)$(bindir)/wineboot \
+	$(DESTDIR)$(bindir)/winecfg \
+	$(DESTDIR)$(bindir)/wineconsole \
+	$(DESTDIR)$(bindir)/winedbg \
+	$(DESTDIR)$(bindir)/winefile \
+	$(DESTDIR)$(bindir)/winemine \
+	$(DESTDIR)$(bindir)/winepath \
+	$(DESTDIR)$(dlldir)/icinfo.exe.so \
+	$(DESTDIR)$(dlldir)/clock.exe.so \
+	$(DESTDIR)$(dlldir)/progman.exe.so \
+	$(DESTDIR)$(dlldir)/view.exe.so \
+	$(DESTDIR)$(dlldir)/winemine.exe.so
+
+install-image: install-lib
+# Get rid of the files we don't want in the image
+	$(RM) -r $(DESTDIR)$(mandir) $(DESTDIR)$(datadir)/applications $(UNWANTED_FILES)
+# Rename the wine loader (don't ask)
+	test x$(filter wine,$(WINELOADER_PROGRAMS)) = x || mv $(DESTDIR)$(bindir)/wine $(DESTDIR)$(bindir)/wineloader
+	test x$(filter wine64,$(WINELOADER_PROGRAMS)) = x || mv $(DESTDIR)$(bindir)/wine64 $(DESTDIR)$(bindir)/wineloader64
+
 # Rules for uninstalling
 
 .PHONY: install install-lib install-dev uninstall __uninstall__
@@ -162,3 +187,8 @@
 tags ctags:
 	$(RM) tags
 	(test -d .git && git ls-files || find -L $(top_srcdir) -name '*.[ch]' -print) | xargs ctags -a $(TAGSFLAGS)
+
+# Manual dependencies
+
+dlls/wineandroid.drv/install-lib:: dlls/wineandroid.drv
+	@cd dlls/wineandroid.drv && $(MAKE) install-lib
diff -Naur wine-2.0a/po/ar.po wine-2.0b/po/ar.po
--- wine-2.0a/po/ar.po	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/po/ar.po	2017-07-11 20:37:51.000000000 +0100
@@ -382,8 +382,8 @@
 msgid "None"
 msgstr "ÙØ§ Ø´ÙØ¡"
 
-#: comctl32.rc:31 cryptui.rc:230 regedit.rc:237 taskmgr.rc:434 winedbg.rc:60
-#: winedbg.rc:75 wordpad.rc:180
+#: comctl32.rc:31 cryptui.rc:230 regedit.rc:237 taskmgr.rc:434 winedbg.rc:58
+#: winedbg.rc:70 wordpad.rc:172
 msgid "Close"
 msgstr "Ø¥ØºÙØ§Ù"
 
@@ -6731,7 +6731,7 @@
 msgid "Sound Selection"
 msgstr "Ø§Ø®ØªÙØ§Ø± Ø§ÙØµÙØª"
 
-#: msacm32.rc:39 winedbg.rc:76
+#: msacm32.rc:39 winedbg.rc:71
 msgid "&Save As..."
 msgstr "Ø§Ø­ÙØ¸ &Ùâ..."
 
@@ -14291,30 +14291,33 @@
 "sorry for the inconvenience."
 msgstr "Ø­ØµÙØª ÙØ´ÙÙØ© ÙØ¨ÙØ±Ø© ÙÙ Ø§ÙØ¨Ø±ÙØ§ÙØ¬ %s ÙÙØ¬Ø¨ Ø¥ØºÙØ§ÙÙÙØ¹ØªØ°Ø± ÙÙØ°Ø§ Ø§ÙØ­Ø¯Ø« ."
 
-#: winedbg.rc:58
+#: winedbg.rc:56
+#, fuzzy
 msgid ""
 "This can be caused by a problem in the program or a deficiency in Wine. You "
-"may want to check the <a href=\"http://appdb.winehq.org\">Application "
-"Database</a> for tips about running this application."
+"may want to check <a href=\"http://www.codeweavers.com/compatibility/"
+"\">http://www.codeweavers.com/compatibility/</a> for tips about running this "
+"application."
 msgstr ""
 "ÙØ­Ø¯Ø« ÙØ°Ø§ Ø¨Ø³Ø¨Ø¨ ÙØ´ÙÙØ© ÙÙ Ø§ÙØ¨Ø±ÙØ§ÙØ¬ Ø£Ù Ø¨Ø³Ø¨Ø¨ Ø¹Ø§Ø¦Ù ÙØ­ÙÙ Ø¯ÙÙ ØªØ´ØºÙÙÙ Ø¨ÙØ§ÙÙ ØÙÙÙÙÙ "
 "ÙØ±Ø§Ø¬Ø¹Ø© ÙØ§Ø¹Ø¯Ø© Ø¨ÙØ§ÙØ§Øª <a href=\"http://appdb.winehq.org\"> Ø§ÙØªØ·Ø¨ÙÙØ§Øª </a> ÙÙØ­ "
 "ØµÙÙ Ø¹ÙÙ Ø§ÙÙØµØ§Ø¦Ø­ Ø§ÙÙØ§Ø²ÙØ© ÙØªØ´ØºÙÙ Ø§ÙØªØ·Ø¨ÙÙ."
 
-#: winedbg.rc:61
+#: winedbg.rc:59
 msgid "Show &Details"
 msgstr "Ø£&Ø¸ÙØ± Ø§ÙØªÙÙØ§ØµÙÙ"
 
-#: winedbg.rc:66
+#: winedbg.rc:64
 msgid "Program Error Details"
 msgstr "ØªÙØ§ØµÙÙ Ø®Ø·Ø£ Ø§ÙØ¨Ø±ÙØ§ÙØ¬"
 
-#: winedbg.rc:73
+#: winedbg.rc:68
+#, fuzzy
 msgid ""
 "If this problem is not present under Windows and has not been reported yet, "
 "you can save the detailed information to a file using the \"Save As\" "
-"button, then <a href=\"http://wiki.winehq.org/Bugs\">file a bug report</a> "
-"and attach that file to the report."
+"button, then <a href=\"http://www.codeweavers.com/support/tickets/enter/"
+"\">file a bug report</a> and attach that file to the report."
 msgstr ""
 "Ø¥Ø°Ø§ ÙØ§ÙØª Ø§ÙÙØ´ÙÙØ© ØºÙØ± ÙÙØ¬ÙØ¯Ø© Ø¹ÙØ¯ ØªØ´ØºÙÙ Ø§ÙØ¨Ø±ÙØ§ÙØ¬ ÙÙ Ø¨ÙØ¦Ø© ÙÙØ¯ÙØ² Ø ÙÙÙ Ø­Ø§Ù ÙÙ "
 "ÙØªÙ Ø§ÙØªØ¨ÙÙØº Ø¹ÙÙØ§ ÙØ³Ø¨ÙÙØ§ ÙÙÙÙÙ Ø­ÙØ¸ Ø§ÙØªÙØ§ØµÙÙ Ø¨Ø§ÙØ¶ØºØ· Ø¹ÙÙ Ø²Ø± \"Ø§ÙØ­ÙØ¸ ÙÙ\" Ø«ÙÙ <a "
diff -Naur wine-2.0a/po/bg.po wine-2.0b/po/bg.po
--- wine-2.0a/po/bg.po	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/po/bg.po	2017-07-11 20:37:51.000000000 +0100
@@ -394,8 +394,8 @@
 msgid "None"
 msgstr "ÐÐ¸ÑÐ¾"
 
-#: comctl32.rc:31 cryptui.rc:230 regedit.rc:237 taskmgr.rc:434 winedbg.rc:60
-#: winedbg.rc:75 wordpad.rc:180
+#: comctl32.rc:31 cryptui.rc:230 regedit.rc:237 taskmgr.rc:434 winedbg.rc:58
+#: winedbg.rc:70 wordpad.rc:172
 msgid "Close"
 msgstr "ÐÐ°ÑÐ²Ð¾ÑÐ¸"
 
@@ -6867,7 +6867,7 @@
 msgid "Sound Selection"
 msgstr "ÐÐ¾ÑÐ²ÑÑÐ´ÐµÑÐµ Ð¸Ð·ÑÑÐ¸Ð²Ð°Ð½ÐµÑÐ¾ Ð½Ð° ÑÐ°Ð¹Ð»Ð°"
 
-#: msacm32.rc:39 winedbg.rc:76
+#: msacm32.rc:39 winedbg.rc:71
 #, fuzzy
 msgid "&Save As..."
 msgstr "Ð¡ÑÑÑÐ°Ð½Ð¸ &ÐºÐ°ÑÐ¾..."
@@ -13892,29 +13892,30 @@
 "sorry for the inconvenience."
 msgstr ""
 
-#: winedbg.rc:58
+#: winedbg.rc:56
 msgid ""
 "This can be caused by a problem in the program or a deficiency in Wine. You "
-"may want to check the <a href=\"http://appdb.winehq.org\">Application "
-"Database</a> for tips about running this application."
+"may want to check <a href=\"http://www.codeweavers.com/compatibility/"
+"\">http://www.codeweavers.com/compatibility/</a> for tips about running this "
+"application."
 msgstr ""
 
-#: winedbg.rc:61
+#: winedbg.rc:59
 #, fuzzy
 msgid "Show &Details"
 msgstr "&ÐÐ¾Ð´ÑÐ¾Ð±Ð½Ð¾ÑÑÐ¸"
 
-#: winedbg.rc:66
+#: winedbg.rc:64
 #, fuzzy
 msgid "Program Error Details"
 msgstr "Program Files"
 
-#: winedbg.rc:73
+#: winedbg.rc:68
 msgid ""
 "If this problem is not present under Windows and has not been reported yet, "
 "you can save the detailed information to a file using the \"Save As\" "
-"button, then <a href=\"http://wiki.winehq.org/Bugs\">file a bug report</a> "
-"and attach that file to the report."
+"button, then <a href=\"http://www.codeweavers.com/support/tickets/enter/"
+"\">file a bug report</a> and attach that file to the report."
 msgstr ""
 
 #: winedbg.rc:38
diff -Naur wine-2.0a/po/ca.po wine-2.0b/po/ca.po
--- wine-2.0a/po/ca.po	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/po/ca.po	2017-07-11 20:37:51.000000000 +0100
@@ -392,8 +392,8 @@
 msgid "None"
 msgstr "Cap"
 
-#: comctl32.rc:31 cryptui.rc:230 regedit.rc:237 taskmgr.rc:434 winedbg.rc:60
-#: winedbg.rc:75 wordpad.rc:180
+#: comctl32.rc:31 cryptui.rc:230 regedit.rc:237 taskmgr.rc:434 winedbg.rc:58
+#: winedbg.rc:70 wordpad.rc:172
 msgid "Close"
 msgstr "Tanca"
 
@@ -6747,7 +6747,7 @@
 msgid "Sound Selection"
 msgstr "SelecciÃ³ de so"
 
-#: msacm32.rc:39 winedbg.rc:76
+#: msacm32.rc:39 winedbg.rc:71
 msgid "&Save As..."
 msgstr "Anomena i &desa..."
 
@@ -14177,35 +14177,36 @@
 "El programa %s ha trobat un problema greu i necessita tancar-se. Sentim les "
 "molÃ¨sties."
 
-#: winedbg.rc:58
+#: winedbg.rc:56
 msgid ""
 "This can be caused by a problem in the program or a deficiency in Wine. You "
-"may want to check the <a href=\"http://appdb.winehq.org\">Application "
-"Database</a> for tips about running this application."
+"may want to check <a href=\"http://www.codeweavers.com/compatibility/"
+"\">http://www.codeweavers.com/compatibility/</a> for tips about running this "
+"application."
 msgstr ""
 "AixÃ² pot ser causat per un problema en el programa o una deficiÃ¨ncia en el "
-"Wine. Potser voleu comprovar la <a href=\"http://appdb.winehq.org\">base de "
-"dades d'aplicacions</a> per suggeriments sobre l'execuciÃ³ d'aquesta "
-"aplicaciÃ³."
+"Wine. Pot ser que vulgueu comprovar el <a href=\"http://www.codeweavers.com/"
+"compatibility/\">http://www.codeweavers.com/compatibility/</a> per "
+"suggeriments sobre executar aquesta aplicaciÃ³."
 
-#: winedbg.rc:61
+#: winedbg.rc:59
 msgid "Show &Details"
 msgstr "&Mostra detalls"
 
-#: winedbg.rc:66
+#: winedbg.rc:64
 msgid "Program Error Details"
 msgstr "Detalls d'error de programa"
 
-#: winedbg.rc:73
+#: winedbg.rc:68
 msgid ""
 "If this problem is not present under Windows and has not been reported yet, "
 "you can save the detailed information to a file using the \"Save As\" "
-"button, then <a href=\"http://wiki.winehq.org/Bugs\">file a bug report</a> "
-"and attach that file to the report."
+"button, then <a href=\"http://www.codeweavers.com/support/tickets/enter/"
+"\">file a bug report</a> and attach that file to the report."
 msgstr ""
 "Si aquest problema no estÃ  present en el Windows i encara no s'ha reportat, "
-"podeu desar la informaciÃ³ detallada a un fitxer utilitzant el botÃ³ "
-"\"Anomenar i Desar\", i llavors <a href=\"http://wiki.winehq.org/Bugs"
+"podeu desar la informaciÃ³ detallada a un fitxer mediant el botÃ³ \"Anomenar i "
+"Desar\", desprÃ©s <a href=\"http://www.codeweavers.com/support/tickets/enter/"
 "\">presentar un informe d'error</a> i ajuntar aquest fitxer a l'informe."
 
 #: winedbg.rc:38
diff -Naur wine-2.0a/po/cs.po wine-2.0b/po/cs.po
--- wine-2.0a/po/cs.po	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/po/cs.po	2017-07-11 20:37:51.000000000 +0100
@@ -389,8 +389,8 @@
 msgid "None"
 msgstr "Å½Ã¡dnÃ©"
 
-#: comctl32.rc:31 cryptui.rc:230 regedit.rc:237 taskmgr.rc:434 winedbg.rc:60
-#: winedbg.rc:75 wordpad.rc:180
+#: comctl32.rc:31 cryptui.rc:230 regedit.rc:237 taskmgr.rc:434 winedbg.rc:58
+#: winedbg.rc:70 wordpad.rc:172
 msgid "Close"
 msgstr "ZavÅÃ­t"
 
@@ -6689,7 +6689,7 @@
 msgid "Sound Selection"
 msgstr "VÃ½bÄr zvuku"
 
-#: msacm32.rc:39 winedbg.rc:76
+#: msacm32.rc:39 winedbg.rc:71
 msgid "&Save As..."
 msgstr "&UloÅ¾it jako..."
 
@@ -13990,31 +13990,33 @@
 "Aplikace %s zaznamenala zÃ¡vaÅ¾nÃ½ problÃ©m a je tÅeba ji uzavÅÃ­t. OmlouvÃ¡me se "
 "za zpÅ¯sobenÃ© obtÃ­Å¾e."
 
-#: winedbg.rc:58
+#: winedbg.rc:56
 msgid ""
 "This can be caused by a problem in the program or a deficiency in Wine. You "
-"may want to check the <a href=\"http://appdb.winehq.org\">Application "
-"Database</a> for tips about running this application."
+"may want to check <a href=\"http://www.codeweavers.com/compatibility/"
+"\">http://www.codeweavers.com/compatibility/</a> for tips about running this "
+"application."
 msgstr ""
 "Toto mÅ¯Å¾e bÃ½t zpÅ¯sobeno problÃ©mem v programu Äi nedostatkem ve Wine. "
 "PodÃ­vejte se prosÃ­m do <a href=\"http://appdb.winehq.org\">databÃ¡ze "
 "aplikacÃ­</a>, kde mohou bÃ½t popsÃ¡ny tipy pro provozovÃ¡nÃ­ konkrÃ©tnÃ­ho "
 "programu."
 
-#: winedbg.rc:61
+#: winedbg.rc:59
+#, fuzzy
 msgid "Show &Details"
 msgstr "Zobrazit podrobnosti"
 
-#: winedbg.rc:66
+#: winedbg.rc:64
 msgid "Program Error Details"
 msgstr "Podrobnosti chyby programu"
 
-#: winedbg.rc:73
+#: winedbg.rc:68
 msgid ""
 "If this problem is not present under Windows and has not been reported yet, "
 "you can save the detailed information to a file using the \"Save As\" "
-"button, then <a href=\"http://wiki.winehq.org/Bugs\">file a bug report</a> "
-"and attach that file to the report."
+"button, then <a href=\"http://www.codeweavers.com/support/tickets/enter/"
+"\">file a bug report</a> and attach that file to the report."
 msgstr ""
 "Pokud se tento problÃ©m v Microsoft Windows neprojevuje a nebyl doposud "
 "nahlÃ¡Å¡en, je moÅ¾nÃ© uloÅ¾it podrobnÃ© informace do souboru kliknutÃ­m na "
diff -Naur wine-2.0a/po/da.po wine-2.0b/po/da.po
--- wine-2.0a/po/da.po	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/po/da.po	2017-07-11 20:37:51.000000000 +0100
@@ -397,8 +397,8 @@
 msgid "None"
 msgstr "Ingen"
 
-#: comctl32.rc:31 cryptui.rc:230 regedit.rc:237 taskmgr.rc:434 winedbg.rc:60
-#: winedbg.rc:75 wordpad.rc:180
+#: comctl32.rc:31 cryptui.rc:230 regedit.rc:237 taskmgr.rc:434 winedbg.rc:58
+#: winedbg.rc:70 wordpad.rc:172
 msgid "Close"
 msgstr "Luk"
 
@@ -6774,7 +6774,7 @@
 msgid "Sound Selection"
 msgstr "Lyd valg"
 
-#: msacm32.rc:39 winedbg.rc:76
+#: msacm32.rc:39 winedbg.rc:71
 msgid "&Save As..."
 msgstr "Gem &som..."
 
@@ -14260,30 +14260,32 @@
 "Programmet %s er stÃ¸dt pÃ¥ et alvorligt problem, og er nÃ¸dt til at lukke. Vi "
 "beklager ulejligheden."
 
-#: winedbg.rc:58
+#: winedbg.rc:56
 msgid ""
 "This can be caused by a problem in the program or a deficiency in Wine. You "
-"may want to check the <a href=\"http://appdb.winehq.org\">Application "
-"Database</a> for tips about running this application."
+"may want to check <a href=\"http://www.codeweavers.com/compatibility/"
+"\">http://www.codeweavers.com/compatibility/</a> for tips about running this "
+"application."
 msgstr ""
 "Dette kan vÃ¦re forÃ¥rsaget af et problem i programmet, eller en mangel i "
-"Wine. Du kan evt. tjekke <a href=\"http://appdb.winehq.org\">Program "
-"Database</a> for tips til at kÃ¸re dette program."
+"Wine. Du kan evt. tjekke <a href=\"http://www.codeweavers.com/compatibility/"
+"\">http://www.codeweavers.com/compatibility/</a> for tips til at kÃ¸re dette "
+"program."
 
-#: winedbg.rc:61
+#: winedbg.rc:59
 msgid "Show &Details"
 msgstr "Vis &detaljer"
 
-#: winedbg.rc:66
+#: winedbg.rc:64
 msgid "Program Error Details"
 msgstr "Programfejl detaljer"
 
-#: winedbg.rc:73
+#: winedbg.rc:68
 msgid ""
 "If this problem is not present under Windows and has not been reported yet, "
 "you can save the detailed information to a file using the \"Save As\" "
-"button, then <a href=\"http://wiki.winehq.org/Bugs\">file a bug report</a> "
-"and attach that file to the report."
+"button, then <a href=\"http://www.codeweavers.com/support/tickets/enter/"
+"\">file a bug report</a> and attach that file to the report."
 msgstr ""
 "Hvis dette problem ikke er til stede under Windows, og det endnu ikke er "
 "blevet rapporteret, sÃ¥ kan du gemme den detaljerede information til en fil "
diff -Naur wine-2.0a/po/de.po wine-2.0b/po/de.po
--- wine-2.0a/po/de.po	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/po/de.po	2017-07-11 20:37:52.000000000 +0100
@@ -389,8 +389,8 @@
 msgid "None"
 msgstr "Kein"
 
-#: comctl32.rc:31 cryptui.rc:230 regedit.rc:237 taskmgr.rc:434 winedbg.rc:60
-#: winedbg.rc:75 wordpad.rc:180
+#: comctl32.rc:31 cryptui.rc:230 regedit.rc:237 taskmgr.rc:434 winedbg.rc:58
+#: winedbg.rc:70 wordpad.rc:172
 msgid "Close"
 msgstr "SchlieÃen"
 
@@ -6737,7 +6737,7 @@
 msgid "Sound Selection"
 msgstr "Soundauswahl"
 
-#: msacm32.rc:39 winedbg.rc:76
+#: msacm32.rc:39 winedbg.rc:71
 msgid "&Save As..."
 msgstr "Speichern &unter..."
 
@@ -14151,35 +14151,38 @@
 "Im Programm %s traten schwerwiegende Fehler auf und es muss beendet werden. "
 "Wir entschuldigen uns fÃ¼r die Unannehmlichkeit."
 
-#: winedbg.rc:58
+#: winedbg.rc:56
 msgid ""
 "This can be caused by a problem in the program or a deficiency in Wine. You "
-"may want to check the <a href=\"http://appdb.winehq.org\">Application "
-"Database</a> for tips about running this application."
+"may want to check <a href=\"http://www.codeweavers.com/compatibility/"
+"\">http://www.codeweavers.com/compatibility/</a> for tips about running this "
+"application."
 msgstr ""
 "Die Ursache kann ein Problem im Programm oder ein Fehler in Wine sein. Sie "
-"kÃ¶nnen in der <a href=\"http://appdb.winehq.org\">Anwendungsdatenbank</a> "
-"Tipps zum AusfÃ¼hren der Anwendung einholen."
+"kÃ¶nnen in der <a href=\"http://www.codeweavers.com/compatibility/\">http://"
+"www.codeweavers.com/compatibility/</a> Tipps zum ausfÃ¼hren der Anwendung "
+"einholen."
 
-#: winedbg.rc:61
+#: winedbg.rc:59
 msgid "Show &Details"
 msgstr "&Details anzeigen"
 
-#: winedbg.rc:66
+#: winedbg.rc:64
 msgid "Program Error Details"
 msgstr "Programmfehler-Details"
 
-#: winedbg.rc:73
+#: winedbg.rc:68
 msgid ""
 "If this problem is not present under Windows and has not been reported yet, "
 "you can save the detailed information to a file using the \"Save As\" "
-"button, then <a href=\"http://wiki.winehq.org/Bugs\">file a bug report</a> "
-"and attach that file to the report."
+"button, then <a href=\"http://www.codeweavers.com/support/tickets/enter/"
+"\">file a bug report</a> and attach that file to the report."
 msgstr ""
 "Tritt dieses Problem unter Windows nicht auf und wurde es noch nicht "
 "gemeldet, kÃ¶nnen Sie mit \"Speichern unter\" die detaillierten Informationen "
-"in einer Datei speichern, danach <a href=\"http://wiki.winehq.org/Bugs"
-"\">einen Fehlerbericht hinterlassen</a> und die Datei dort anhÃ¤ngen."
+"in einer Datei speichern, danach <a href=\"http://www.codeweavers.com/"
+"support/tickets/enter/\">einen Fehlerbericht hinterlassen</a> und die Datei "
+"dort anhÃ¤ngen."
 
 #: winedbg.rc:38
 msgid "Wine program crash"
diff -Naur wine-2.0a/po/el.po wine-2.0b/po/el.po
--- wine-2.0a/po/el.po	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/po/el.po	2017-07-11 20:37:52.000000000 +0100
@@ -373,8 +373,8 @@
 msgid "None"
 msgstr "ÎÎ±Î½Î­Î½Î±"
 
-#: comctl32.rc:31 cryptui.rc:230 regedit.rc:237 taskmgr.rc:434 winedbg.rc:60
-#: winedbg.rc:75 wordpad.rc:180
+#: comctl32.rc:31 cryptui.rc:230 regedit.rc:237 taskmgr.rc:434 winedbg.rc:58
+#: winedbg.rc:70 wordpad.rc:172
 msgid "Close"
 msgstr "ÎÎ»ÎµÎ¯ÏÎ¹Î¼Î¿"
 
@@ -6753,7 +6753,7 @@
 msgid "Sound Selection"
 msgstr ""
 
-#: msacm32.rc:39 winedbg.rc:76
+#: msacm32.rc:39 winedbg.rc:71
 #, fuzzy
 msgid "&Save As..."
 msgstr "ÎÏÎ¿Î¸Î®ÎºÎµÏÏÎ· ÏÏ"
@@ -13616,28 +13616,29 @@
 "sorry for the inconvenience."
 msgstr ""
 
-#: winedbg.rc:58
+#: winedbg.rc:56
 msgid ""
 "This can be caused by a problem in the program or a deficiency in Wine. You "
-"may want to check the <a href=\"http://appdb.winehq.org\">Application "
-"Database</a> for tips about running this application."
+"may want to check <a href=\"http://www.codeweavers.com/compatibility/"
+"\">http://www.codeweavers.com/compatibility/</a> for tips about running this "
+"application."
 msgstr ""
 
-#: winedbg.rc:61
+#: winedbg.rc:59
 #, fuzzy
 msgid "Show &Details"
 msgstr "ÎÎµÏÏÎ¿Î¼Î­ÏÎµÎ¹ÎµÏ"
 
-#: winedbg.rc:66
+#: winedbg.rc:64
 msgid "Program Error Details"
 msgstr ""
 
-#: winedbg.rc:73
+#: winedbg.rc:68
 msgid ""
 "If this problem is not present under Windows and has not been reported yet, "
 "you can save the detailed information to a file using the \"Save As\" "
-"button, then <a href=\"http://wiki.winehq.org/Bugs\">file a bug report</a> "
-"and attach that file to the report."
+"button, then <a href=\"http://www.codeweavers.com/support/tickets/enter/"
+"\">file a bug report</a> and attach that file to the report."
 msgstr ""
 
 #: winedbg.rc:38
diff -Naur wine-2.0a/po/en.po wine-2.0b/po/en.po
--- wine-2.0a/po/en.po	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/po/en.po	2017-07-11 20:37:52.000000000 +0100
@@ -388,8 +388,8 @@
 msgid "None"
 msgstr "None"
 
-#: comctl32.rc:31 cryptui.rc:230 regedit.rc:237 taskmgr.rc:434 winedbg.rc:60
-#: winedbg.rc:75 wordpad.rc:180
+#: comctl32.rc:31 cryptui.rc:230 regedit.rc:237 taskmgr.rc:434 winedbg.rc:58
+#: winedbg.rc:70 wordpad.rc:172
 msgid "Close"
 msgstr "Close"
 
@@ -6725,7 +6725,7 @@
 msgid "Sound Selection"
 msgstr "Sound Selection"
 
-#: msacm32.rc:39 winedbg.rc:76
+#: msacm32.rc:39 winedbg.rc:71
 msgid "&Save As..."
 msgstr "&Save As..."
 
@@ -14055,30 +14055,31 @@
 "The program %s has encountered a serious problem and needs to close. We are "
 "sorry for the inconvenience."
 
-#: winedbg.rc:58
+#: winedbg.rc:56
 msgid ""
 "This can be caused by a problem in the program or a deficiency in Wine. You "
-"may want to check the <a href=\"http://appdb.winehq.org\">Application "
-"Database</a> for tips about running this application."
+"may want to check <a href=\"http://www.codeweavers.com/compatibility/"
+"\">http://www.codeweavers.com/compatibility/</a> for tips about running this "
+"application."
 msgstr ""
 "This can be caused by a problem in the program or a deficiency in Wine. You "
 "may want to check the <a href=\"http://appdb.winehq.org\">Application "
 "Database</a> for tips about running this application."
 
-#: winedbg.rc:61
+#: winedbg.rc:59
 msgid "Show &Details"
 msgstr "Show &Details"
 
-#: winedbg.rc:66
+#: winedbg.rc:64
 msgid "Program Error Details"
 msgstr "Program Error Details"
 
-#: winedbg.rc:73
+#: winedbg.rc:68
 msgid ""
 "If this problem is not present under Windows and has not been reported yet, "
 "you can save the detailed information to a file using the \"Save As\" "
-"button, then <a href=\"http://wiki.winehq.org/Bugs\">file a bug report</a> "
-"and attach that file to the report."
+"button, then <a href=\"http://www.codeweavers.com/support/tickets/enter/"
+"\">file a bug report</a> and attach that file to the report."
 msgstr ""
 "If this problem is not present under Windows and has not been reported yet, "
 "you can save the detailed information to a file using the \"Save As\" "
diff -Naur wine-2.0a/po/en_US.po wine-2.0b/po/en_US.po
--- wine-2.0a/po/en_US.po	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/po/en_US.po	2017-07-11 20:37:52.000000000 +0100
@@ -388,8 +388,8 @@
 msgid "None"
 msgstr "None"
 
-#: comctl32.rc:31 cryptui.rc:230 regedit.rc:237 taskmgr.rc:434 winedbg.rc:60
-#: winedbg.rc:75 wordpad.rc:180
+#: comctl32.rc:31 cryptui.rc:230 regedit.rc:237 taskmgr.rc:434 winedbg.rc:58
+#: winedbg.rc:70 wordpad.rc:172
 msgid "Close"
 msgstr "Close"
 
@@ -6725,7 +6725,7 @@
 msgid "Sound Selection"
 msgstr "Sound Selection"
 
-#: msacm32.rc:39 winedbg.rc:76
+#: msacm32.rc:39 winedbg.rc:71
 msgid "&Save As..."
 msgstr "&Save As..."
 
@@ -14055,35 +14055,37 @@
 "The program %s has encountered a serious problem and needs to close. We are "
 "sorry for the inconvenience."
 
-#: winedbg.rc:58
+#: winedbg.rc:56
 msgid ""
 "This can be caused by a problem in the program or a deficiency in Wine. You "
-"may want to check the <a href=\"http://appdb.winehq.org\">Application "
-"Database</a> for tips about running this application."
+"may want to check <a href=\"http://www.codeweavers.com/compatibility/"
+"\">http://www.codeweavers.com/compatibility/</a> for tips about running this "
+"application."
 msgstr ""
 "This can be caused by a problem in the program or a deficiency in Wine. You "
-"may want to check the <a href=\"http://appdb.winehq.org\">Application "
-"Database</a> for tips about running this application."
+"may want to check <a href=\"http://www.codeweavers.com/compatibility/"
+"\">http://www.codeweavers.com/compatibility/</a> for tips about running this "
+"application."
 
-#: winedbg.rc:61
+#: winedbg.rc:59
 msgid "Show &Details"
 msgstr "Show &Details"
 
-#: winedbg.rc:66
+#: winedbg.rc:64
 msgid "Program Error Details"
 msgstr "Program Error Details"
 
-#: winedbg.rc:73
+#: winedbg.rc:68
 msgid ""
 "If this problem is not present under Windows and has not been reported yet, "
 "you can save the detailed information to a file using the \"Save As\" "
-"button, then <a href=\"http://wiki.winehq.org/Bugs\">file a bug report</a> "
-"and attach that file to the report."
+"button, then <a href=\"http://www.codeweavers.com/support/tickets/enter/"
+"\">file a bug report</a> and attach that file to the report."
 msgstr ""
 "If this problem is not present under Windows and has not been reported yet, "
 "you can save the detailed information to a file using the \"Save As\" "
-"button, then <a href=\"http://wiki.winehq.org/Bugs\">file a bug report</a> "
-"and attach that file to the report."
+"button, then <a href=\"http://www.codeweavers.com/support/tickets/enter/"
+"\">file a bug report</a> and attach that file to the report."
 
 #: winedbg.rc:38
 msgid "Wine program crash"
diff -Naur wine-2.0a/po/eo.po wine-2.0b/po/eo.po
--- wine-2.0a/po/eo.po	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/po/eo.po	2017-07-11 20:37:52.000000000 +0100
@@ -379,8 +379,8 @@
 msgid "None"
 msgstr "Neniu"
 
-#: comctl32.rc:31 cryptui.rc:230 regedit.rc:237 taskmgr.rc:434 winedbg.rc:60
-#: winedbg.rc:75 wordpad.rc:180
+#: comctl32.rc:31 cryptui.rc:230 regedit.rc:237 taskmgr.rc:434 winedbg.rc:58
+#: winedbg.rc:70 wordpad.rc:172
 msgid "Close"
 msgstr "Fermi"
 
@@ -6656,7 +6656,7 @@
 msgid "Sound Selection"
 msgstr "Sona elekto"
 
-#: msacm32.rc:39 winedbg.rc:76
+#: msacm32.rc:39 winedbg.rc:71
 msgid "&Save As..."
 msgstr "Konservu &kiel..."
 
@@ -13525,27 +13525,28 @@
 "sorry for the inconvenience."
 msgstr ""
 
-#: winedbg.rc:58
+#: winedbg.rc:56
 msgid ""
 "This can be caused by a problem in the program or a deficiency in Wine. You "
-"may want to check the <a href=\"http://appdb.winehq.org\">Application "
-"Database</a> for tips about running this application."
+"may want to check <a href=\"http://www.codeweavers.com/compatibility/"
+"\">http://www.codeweavers.com/compatibility/</a> for tips about running this "
+"application."
 msgstr ""
 
-#: winedbg.rc:61
+#: winedbg.rc:59
 msgid "Show &Details"
 msgstr "Pliaj &detaloj"
 
-#: winedbg.rc:66
+#: winedbg.rc:64
 msgid "Program Error Details"
 msgstr "Detaloj pri programa eraro"
 
-#: winedbg.rc:73
+#: winedbg.rc:68
 msgid ""
 "If this problem is not present under Windows and has not been reported yet, "
 "you can save the detailed information to a file using the \"Save As\" "
-"button, then <a href=\"http://wiki.winehq.org/Bugs\">file a bug report</a> "
-"and attach that file to the report."
+"button, then <a href=\"http://www.codeweavers.com/support/tickets/enter/"
+"\">file a bug report</a> and attach that file to the report."
 msgstr ""
 
 #: winedbg.rc:38
diff -Naur wine-2.0a/po/es.po wine-2.0b/po/es.po
--- wine-2.0a/po/es.po	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/po/es.po	2017-07-11 20:37:52.000000000 +0100
@@ -400,8 +400,8 @@
 msgid "None"
 msgstr "Ninguno"
 
-#: comctl32.rc:31 cryptui.rc:230 regedit.rc:237 taskmgr.rc:434 winedbg.rc:60
-#: winedbg.rc:75 wordpad.rc:180
+#: comctl32.rc:31 cryptui.rc:230 regedit.rc:237 taskmgr.rc:434 winedbg.rc:58
+#: winedbg.rc:70 wordpad.rc:172
 msgid "Close"
 msgstr "Cerrar"
 
@@ -6784,7 +6784,7 @@
 msgid "Sound Selection"
 msgstr "SelecciÃ³n de sonido"
 
-#: msacm32.rc:39 winedbg.rc:76
+#: msacm32.rc:39 winedbg.rc:71
 msgid "&Save As..."
 msgstr "&Guardar como..."
 
@@ -14355,35 +14355,37 @@
 "El programa %s ha encontrado un serio problema y necesita cerrarse. Nos "
 "disculpamos por los inconvenientes."
 
-#: winedbg.rc:58
+#: winedbg.rc:56
 msgid ""
 "This can be caused by a problem in the program or a deficiency in Wine. You "
-"may want to check the <a href=\"http://appdb.winehq.org\">Application "
-"Database</a> for tips about running this application."
+"may want to check <a href=\"http://www.codeweavers.com/compatibility/"
+"\">http://www.codeweavers.com/compatibility/</a> for tips about running this "
+"application."
 msgstr ""
 "Esto puede ser causado por un problema en el programa o a una deficiencia en "
-"Wine. QuizÃ¡ quieras verificar en <a href=\"http://appdb.winehq.org\">Base de "
-"Aplicaciones</a> consejos sobre cÃ³mo ejecutar esta aplicaciÃ³n."
+"Wine. QuizÃ¡ quieras verificar en <a href=\"http://www.codeweavers.com/"
+"compatibility/\">http://www.codeweavers.com/compatibility/</a> consejos "
+"sobre cÃ³mo ejecutar esta aplicaciÃ³n."
 
-#: winedbg.rc:61
+#: winedbg.rc:59
 msgid "Show &Details"
 msgstr "Mostrar &Detalles"
 
-#: winedbg.rc:66
+#: winedbg.rc:64
 msgid "Program Error Details"
 msgstr "Detalles del error de programa"
 
-#: winedbg.rc:73
+#: winedbg.rc:68
 msgid ""
 "If this problem is not present under Windows and has not been reported yet, "
 "you can save the detailed information to a file using the \"Save As\" "
-"button, then <a href=\"http://wiki.winehq.org/Bugs\">file a bug report</a> "
-"and attach that file to the report."
+"button, then <a href=\"http://www.codeweavers.com/support/tickets/enter/"
+"\">file a bug report</a> and attach that file to the report."
 msgstr ""
 "Si este problema no esta presente en Windows y no ha sido informado todavÃ­a, "
 "puedes salvar la informaciÃ³n detallada usando el botÃ³n \"Salvar Como\", "
-"entonces podrÃ¡s <a href=\"http://wiki.winehq.org/Bugs\">informar de un "
-"error</a> y adjuntar ese archivo al informe de fallo."
+"entonces podrÃ¡s <a href=\"http://www.codeweavers.com/support/tickets/enter/"
+"\">informar de un error</a> y adjuntar ese archivo al reporte de fallo."
 
 #: winedbg.rc:38
 msgid "Wine program crash"
diff -Naur wine-2.0a/po/fa.po wine-2.0b/po/fa.po
--- wine-2.0a/po/fa.po	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/po/fa.po	2017-07-11 20:37:52.000000000 +0100
@@ -373,8 +373,8 @@
 msgid "None"
 msgstr ""
 
-#: comctl32.rc:31 cryptui.rc:230 regedit.rc:237 taskmgr.rc:434 winedbg.rc:60
-#: winedbg.rc:75 wordpad.rc:180
+#: comctl32.rc:31 cryptui.rc:230 regedit.rc:237 taskmgr.rc:434 winedbg.rc:58
+#: winedbg.rc:70 wordpad.rc:172
 msgid "Close"
 msgstr ""
 
@@ -6740,7 +6740,7 @@
 msgid "Sound Selection"
 msgstr "Ø§ÙØªØ®Ø§Ø¨ &ÙÙÙ\tCtrl+A"
 
-#: msacm32.rc:39 winedbg.rc:76
+#: msacm32.rc:39 winedbg.rc:71
 #, fuzzy
 msgid "&Save As..."
 msgstr "Ø°Ø®ÛØ±Ù &Ø¨Ù ÙØ§Ù..."
@@ -13616,27 +13616,28 @@
 "sorry for the inconvenience."
 msgstr ""
 
-#: winedbg.rc:58
+#: winedbg.rc:56
 msgid ""
 "This can be caused by a problem in the program or a deficiency in Wine. You "
-"may want to check the <a href=\"http://appdb.winehq.org\">Application "
-"Database</a> for tips about running this application."
+"may want to check <a href=\"http://www.codeweavers.com/compatibility/"
+"\">http://www.codeweavers.com/compatibility/</a> for tips about running this "
+"application."
 msgstr ""
 
-#: winedbg.rc:61
+#: winedbg.rc:59
 msgid "Show &Details"
 msgstr ""
 
-#: winedbg.rc:66
+#: winedbg.rc:64
 msgid "Program Error Details"
 msgstr ""
 
-#: winedbg.rc:73
+#: winedbg.rc:68
 msgid ""
 "If this problem is not present under Windows and has not been reported yet, "
 "you can save the detailed information to a file using the \"Save As\" "
-"button, then <a href=\"http://wiki.winehq.org/Bugs\">file a bug report</a> "
-"and attach that file to the report."
+"button, then <a href=\"http://www.codeweavers.com/support/tickets/enter/"
+"\">file a bug report</a> and attach that file to the report."
 msgstr ""
 
 #: winedbg.rc:38
diff -Naur wine-2.0a/po/fi.po wine-2.0b/po/fi.po
--- wine-2.0a/po/fi.po	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/po/fi.po	2017-07-11 20:37:52.000000000 +0100
@@ -384,8 +384,8 @@
 msgid "None"
 msgstr "Ei valittu"
 
-#: comctl32.rc:31 cryptui.rc:230 regedit.rc:237 taskmgr.rc:434 winedbg.rc:60
-#: winedbg.rc:75 wordpad.rc:180
+#: comctl32.rc:31 cryptui.rc:230 regedit.rc:237 taskmgr.rc:434 winedbg.rc:58
+#: winedbg.rc:70 wordpad.rc:172
 msgid "Close"
 msgstr "Sulje"
 
@@ -6721,7 +6721,7 @@
 msgid "Sound Selection"
 msgstr "ÃÃ¤nivalinta"
 
-#: msacm32.rc:39 winedbg.rc:76
+#: msacm32.rc:39 winedbg.rc:71
 msgid "&Save As..."
 msgstr "Tallenna &nimellÃ¤..."
 
@@ -14021,35 +14021,37 @@
 "Ohjelma %s on kohdannut vakavan ongelman ja se on suljettava. Olemme "
 "pahoillamme haitasta."
 
-#: winedbg.rc:58
+#: winedbg.rc:56
 msgid ""
 "This can be caused by a problem in the program or a deficiency in Wine. You "
-"may want to check the <a href=\"http://appdb.winehq.org\">Application "
-"Database</a> for tips about running this application."
+"may want to check <a href=\"http://www.codeweavers.com/compatibility/"
+"\">http://www.codeweavers.com/compatibility/</a> for tips about running this "
+"application."
 msgstr ""
 "TÃ¤mÃ¤n voi aiheuttaa ongelma ohjelmassa tai puute WinessÃ¤. Saatat haluta "
-"kÃ¤ydÃ¤ <a href=\"http://appdb.winehq.org\">Application Databasessa</a>, josta "
-"saat vinkkejÃ¤ tÃ¤mÃ¤n ohjelman ajamiseen."
+"kÃ¤ydÃ¤ <a href=\"http://www.codeweavers.com/compatibility/\">http://www."
+"codeweavers.com/compatibility/</a>, josta saat vinkkejÃ¤ tÃ¤mÃ¤n ohjelman "
+"ajamiseen."
 
-#: winedbg.rc:61
+#: winedbg.rc:59
 msgid "Show &Details"
 msgstr "NÃ¤ytÃ¤ &tiedot"
 
-#: winedbg.rc:66
+#: winedbg.rc:64
 msgid "Program Error Details"
 msgstr "Ohjelman virhetiedot"
 
-#: winedbg.rc:73
+#: winedbg.rc:68
 msgid ""
 "If this problem is not present under Windows and has not been reported yet, "
 "you can save the detailed information to a file using the \"Save As\" "
-"button, then <a href=\"http://wiki.winehq.org/Bugs\">file a bug report</a> "
-"and attach that file to the report."
+"button, then <a href=\"http://www.codeweavers.com/support/tickets/enter/"
+"\">file a bug report</a> and attach that file to the report."
 msgstr ""
 "Jos tÃ¤tÃ¤ ongelmaa ei esiinny Windowsin kanssa eikÃ¤ sitÃ¤ ole vielÃ¤ "
 "raportoitu, voit tallentaa yksityiskohtaisemmat tiedot tiedostoon Tallenna "
-"nimellÃ¤ -kohdassa ja sitten <a href=\"http://wiki.winehq.org/Bugs\">lÃ¤hettÃ¤Ã¤ "
-"virheraportin</a> ja liittÃ¤Ã¤ tiedoston raporttiin."
+"nimellÃ¤ -kohdassa ja sitten <a href=\"http://www.codeweavers.com/support/"
+"tickets/enter/\">lÃ¤hettÃ¤Ã¤ virheraportin</a> ja liittÃ¤Ã¤ tiedoston raporttiin."
 
 #: winedbg.rc:38
 msgid "Wine program crash"
diff -Naur wine-2.0a/po/fr.po wine-2.0b/po/fr.po
--- wine-2.0a/po/fr.po	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/po/fr.po	2017-07-11 20:37:52.000000000 +0100
@@ -392,8 +392,8 @@
 msgid "None"
 msgstr "Aucune"
 
-#: comctl32.rc:31 cryptui.rc:230 regedit.rc:237 taskmgr.rc:434 winedbg.rc:60
-#: winedbg.rc:75 wordpad.rc:180
+#: comctl32.rc:31 cryptui.rc:230 regedit.rc:237 taskmgr.rc:434 winedbg.rc:58
+#: winedbg.rc:70 wordpad.rc:172
 msgid "Close"
 msgstr "Fermer"
 
@@ -6758,7 +6758,7 @@
 msgid "Sound Selection"
 msgstr "SÃ©lection du son"
 
-#: msacm32.rc:39 winedbg.rc:76
+#: msacm32.rc:39 winedbg.rc:71
 msgid "&Save As..."
 msgstr "&Enregistrer sous..."
 
@@ -14233,37 +14233,38 @@
 "Le programme %s a rencontrÃ© un problÃ¨me sÃ©rieux et doit Ãªtre fermÃ©. Nous "
 "somme dÃ©solÃ©s pour le dÃ©sagrÃ©ment subi."
 
-#: winedbg.rc:58
+#: winedbg.rc:56
 msgid ""
 "This can be caused by a problem in the program or a deficiency in Wine. You "
-"may want to check the <a href=\"http://appdb.winehq.org\">Application "
-"Database</a> for tips about running this application."
+"may want to check <a href=\"http://www.codeweavers.com/compatibility/"
+"\">http://www.codeweavers.com/compatibility/</a> for tips about running this "
+"application."
 msgstr ""
 "Cela peut Ãªtre causÃ© par une erreur dans le programme ou un dÃ©faut dans "
-"Wine. Vous pouvez consulter la <a href=\"http://appdb.winehq.org\">base de "
-"donnÃ©es d'applications</a> pour obtenir des conseils sur la faÃ§on d'exÃ©cuter "
-"cette application."
+"Wine. Vous pouvez consulter <a href=\"http://www.codeweavers.com/"
+"compatibility/\">http://www.codeweavers.com/compatibility/</a> pour obtenir "
+"des conseils sur la faÃ§on d'exÃ©cuter cette application."
 
-#: winedbg.rc:61
+#: winedbg.rc:59
 msgid "Show &Details"
 msgstr "Afficher les &dÃ©tails"
 
-#: winedbg.rc:66
+#: winedbg.rc:64
 msgid "Program Error Details"
 msgstr "DÃ©tails de l'erreur du programme"
 
-#: winedbg.rc:73
+#: winedbg.rc:68
 msgid ""
 "If this problem is not present under Windows and has not been reported yet, "
 "you can save the detailed information to a file using the \"Save As\" "
-"button, then <a href=\"http://wiki.winehq.org/Bugs\">file a bug report</a> "
-"and attach that file to the report."
+"button, then <a href=\"http://www.codeweavers.com/support/tickets/enter/"
+"\">file a bug report</a> and attach that file to the report."
 msgstr ""
 "Si ce problÃ¨me ne se produit pas sous Windows et n'a pas dÃ©jÃ  Ã©tÃ© rapportÃ©, "
 "vous pouvez enregistrer les informations dÃ©taillÃ©es dans un fichier en "
-"utilisant le bouton Â«Â Enregistrer sousÂ Â», et ensuite  <a href=\"http://wiki."
-"winehq.org/Bugs\">soumettre un rapport d'anomalie</a> en y attachant ledit "
-"fichier."
+"utilisant le bouton Â«Â Enregistrer sousÂ Â», et ensuite  <a href=\"http://www."
+"codeweavers.com/support/tickets/enter/\">soumettre un rapport d'anomalie</a> "
+"en y attachant ledit fichier."
 
 #: winedbg.rc:38
 msgid "Wine program crash"
diff -Naur wine-2.0a/po/he.po wine-2.0b/po/he.po
--- wine-2.0a/po/he.po	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/po/he.po	2017-07-11 20:37:52.000000000 +0100
@@ -393,8 +393,8 @@
 msgid "None"
 msgstr "×××"
 
-#: comctl32.rc:31 cryptui.rc:230 regedit.rc:237 taskmgr.rc:434 winedbg.rc:60
-#: winedbg.rc:75 wordpad.rc:180
+#: comctl32.rc:31 cryptui.rc:230 regedit.rc:237 taskmgr.rc:434 winedbg.rc:58
+#: winedbg.rc:70 wordpad.rc:172
 msgid "Close"
 msgstr "×¡×××¨×"
 
@@ -7000,7 +7000,7 @@
 msgid "Sound Selection"
 msgstr "××××¨×ª ×¦×××"
 
-#: msacm32.rc:39 winedbg.rc:76
+#: msacm32.rc:39 winedbg.rc:71
 msgid "&Save As..."
 msgstr "×©×××¨× &××©×..."
 
@@ -14152,12 +14152,13 @@
 "sorry for the inconvenience."
 msgstr "××ª×× ××ª %s × ×ª×§×× ××©×××× ××××¨× ××¢××× ××××¡××¨. ×× × ××ª× ×¦××× ×¢× ×× ×× ×¢××××ª."
 
-#: winedbg.rc:58
+#: winedbg.rc:56
 #, fuzzy
 msgid ""
 "This can be caused by a problem in the program or a deficiency in Wine. You "
-"may want to check the <a href=\"http://appdb.winehq.org\">Application "
-"Database</a> for tips about running this application."
+"may want to check <a href=\"http://www.codeweavers.com/compatibility/"
+"\">http://www.codeweavers.com/compatibility/</a> for tips about running this "
+"application."
 msgstr ""
 "××¢×× ×× ×¢×××× ×××××¨× ×¢×§× ×ª×§×× ××ª×× ××ª ×× ×××¡××¨ ××¡××× ×Ö¾Wine. ×××× ×××× ××¤× ××ª "
 "×××ª×××ª http://appdb.winehq.org ××§×××ª ×¢×¦××ª ×××¨×¦×ª ×××©×× ××.\n"
@@ -14165,22 +14166,22 @@
 "×× ×ª×§×× ×× ××× × ×§××××ª ××¢×ª ××¨×¦×ª Windows ××× ×××× ×¢××× ×¢××××, × ××ª× ××××× ×¢××× "
 "×××ª×××ª http://bugs.winehq.org."
 
-#: winedbg.rc:61
+#: winedbg.rc:59
 #, fuzzy
 msgid "Show &Details"
 msgstr "&×¤×¨×××"
 
-#: winedbg.rc:66
+#: winedbg.rc:64
 #, fuzzy
 msgid "Program Error Details"
 msgstr "×©×××× ××ª×× ××ª"
 
-#: winedbg.rc:73
+#: winedbg.rc:68
 msgid ""
 "If this problem is not present under Windows and has not been reported yet, "
 "you can save the detailed information to a file using the \"Save As\" "
-"button, then <a href=\"http://wiki.winehq.org/Bugs\">file a bug report</a> "
-"and attach that file to the report."
+"button, then <a href=\"http://www.codeweavers.com/support/tickets/enter/"
+"\">file a bug report</a> and attach that file to the report."
 msgstr ""
 
 #: winedbg.rc:38
diff -Naur wine-2.0a/po/hi.po wine-2.0b/po/hi.po
--- wine-2.0a/po/hi.po	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/po/hi.po	2017-07-11 20:37:52.000000000 +0100
@@ -368,8 +368,8 @@
 msgid "None"
 msgstr ""
 
-#: comctl32.rc:31 cryptui.rc:230 regedit.rc:237 taskmgr.rc:434 winedbg.rc:60
-#: winedbg.rc:75 wordpad.rc:180
+#: comctl32.rc:31 cryptui.rc:230 regedit.rc:237 taskmgr.rc:434 winedbg.rc:58
+#: winedbg.rc:70 wordpad.rc:172
 msgid "Close"
 msgstr ""
 
@@ -6636,7 +6636,7 @@
 msgid "Sound Selection"
 msgstr ""
 
-#: msacm32.rc:39 winedbg.rc:76
+#: msacm32.rc:39 winedbg.rc:71
 msgid "&Save As..."
 msgstr ""
 
@@ -13378,28 +13378,29 @@
 "sorry for the inconvenience."
 msgstr ""
 
-#: winedbg.rc:58
+#: winedbg.rc:56
 msgid ""
 "This can be caused by a problem in the program or a deficiency in Wine. You "
-"may want to check the <a href=\"http://appdb.winehq.org\">Application "
-"Database</a> for tips about running this application."
+"may want to check <a href=\"http://www.codeweavers.com/compatibility/"
+"\">http://www.codeweavers.com/compatibility/</a> for tips about running this "
+"application."
 msgstr ""
 
-#: winedbg.rc:61
+#: winedbg.rc:59
 msgid "Show &Details"
 msgstr ""
 
-#: winedbg.rc:66
+#: winedbg.rc:64
 #, fuzzy
 msgid "Program Error Details"
 msgstr "à¤¸à¥à¤à¤¨à¤¾ (&o)"
 
-#: winedbg.rc:73
+#: winedbg.rc:68
 msgid ""
 "If this problem is not present under Windows and has not been reported yet, "
 "you can save the detailed information to a file using the \"Save As\" "
-"button, then <a href=\"http://wiki.winehq.org/Bugs\">file a bug report</a> "
-"and attach that file to the report."
+"button, then <a href=\"http://www.codeweavers.com/support/tickets/enter/"
+"\">file a bug report</a> and attach that file to the report."
 msgstr ""
 
 #: winedbg.rc:38
diff -Naur wine-2.0a/po/hr.po wine-2.0b/po/hr.po
--- wine-2.0a/po/hr.po	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/po/hr.po	2017-07-11 20:37:52.000000000 +0100
@@ -387,8 +387,8 @@
 msgid "None"
 msgstr "NiÅ¡ta"
 
-#: comctl32.rc:31 cryptui.rc:230 regedit.rc:237 taskmgr.rc:434 winedbg.rc:60
-#: winedbg.rc:75 wordpad.rc:180
+#: comctl32.rc:31 cryptui.rc:230 regedit.rc:237 taskmgr.rc:434 winedbg.rc:58
+#: winedbg.rc:70 wordpad.rc:172
 msgid "Close"
 msgstr "Zatvori"
 
@@ -6736,7 +6736,7 @@
 msgid "Sound Selection"
 msgstr "Izbor zvuka"
 
-#: msacm32.rc:39 winedbg.rc:76
+#: msacm32.rc:39 winedbg.rc:71
 msgid "&Save As..."
 msgstr "&Spremi kao..."
 
@@ -13787,30 +13787,36 @@
 "Program %s je naiÅ¡ao na ozbiljan problem i mora biti zatvoren. IspriÄavamo "
 "se zbog neugodnosti."
 
-#: winedbg.rc:58
+#: winedbg.rc:56
+#, fuzzy
+#| msgid ""
+#| "This can be caused by a problem in the program or a deficiency in Wine. "
+#| "You may want to check the <a href=\"http://appdb.winehq.org\">Application "
+#| "Database</a> for tips about running this application."
 msgid ""
 "This can be caused by a problem in the program or a deficiency in Wine. You "
-"may want to check the <a href=\"http://appdb.winehq.org\">Application "
-"Database</a> for tips about running this application."
+"may want to check <a href=\"http://www.codeweavers.com/compatibility/"
+"\">http://www.codeweavers.com/compatibility/</a> for tips about running this "
+"application."
 msgstr ""
 "Uzrok ovome moÅ¾e biti problem u programu ili nedostatak u Wine-u. Provjerite "
 "<a href=\"http://appdb.winehq.org\">bazu aplikacija</a>za savjete o "
 "pokretanju ovog programa."
 
-#: winedbg.rc:61
+#: winedbg.rc:59
 msgid "Show &Details"
 msgstr "PokaÅ¾i &detalje"
 
-#: winedbg.rc:66
+#: winedbg.rc:64
 msgid "Program Error Details"
 msgstr "Detalji greÅ¡ke programa"
 
-#: winedbg.rc:73
+#: winedbg.rc:68
 msgid ""
 "If this problem is not present under Windows and has not been reported yet, "
 "you can save the detailed information to a file using the \"Save As\" "
-"button, then <a href=\"http://wiki.winehq.org/Bugs\">file a bug report</a> "
-"and attach that file to the report."
+"button, then <a href=\"http://www.codeweavers.com/support/tickets/enter/"
+"\">file a bug report</a> and attach that file to the report."
 msgstr ""
 
 #: winedbg.rc:38
diff -Naur wine-2.0a/po/hu.po wine-2.0b/po/hu.po
--- wine-2.0a/po/hu.po	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/po/hu.po	2017-07-11 20:37:52.000000000 +0100
@@ -401,8 +401,8 @@
 msgid "None"
 msgstr "Nincs"
 
-#: comctl32.rc:31 cryptui.rc:230 regedit.rc:237 taskmgr.rc:434 winedbg.rc:60
-#: winedbg.rc:75 wordpad.rc:180
+#: comctl32.rc:31 cryptui.rc:230 regedit.rc:237 taskmgr.rc:434 winedbg.rc:58
+#: winedbg.rc:70 wordpad.rc:172
 msgid "Close"
 msgstr "BezÃ¡rÃ¡s"
 
@@ -6792,7 +6792,7 @@
 msgid "Sound Selection"
 msgstr "Hang kivÃ¡lasztÃ¡s"
 
-#: msacm32.rc:39 winedbg.rc:76
+#: msacm32.rc:39 winedbg.rc:71
 msgid "&Save As..."
 msgstr "&MentÃ©s mÃ¡skÃ©nt..."
 
@@ -14258,35 +14258,37 @@
 "A %s program szembekerÃ¼lt egy komoly problÃ©mÃ¡val Ã©s ezÃ©rt szÃ¼ksÃ©ges bezÃ¡rni. "
 "ElnÃ©zÃ©st kÃ©rÃ¼nk a kellemetlensÃ©gÃ©rt."
 
-#: winedbg.rc:58
+#: winedbg.rc:56
 msgid ""
 "This can be caused by a problem in the program or a deficiency in Wine. You "
-"may want to check the <a href=\"http://appdb.winehq.org\">Application "
-"Database</a> for tips about running this application."
+"may want to check <a href=\"http://www.codeweavers.com/compatibility/"
+"\">http://www.codeweavers.com/compatibility/</a> for tips about running this "
+"application."
 msgstr ""
 "Ezt okozhatja egy programban lÃ©vÅ hiba vagy a Wine hiÃ¡nyossÃ¡ga. "
-"EllenÅrizheti a <a href=\"http://appdb.winehq.org\">AlkalmazÃ¡s adatbÃ¡zis</a> "
-"tippjeit az alkalmazÃ¡ssal kapcsolatban."
+"EllenÅrizheti a <a href=\"http://www.codeweavers.com/compatibility/\">http://"
+"www.codeweavers.com/compatibility/</a> tippjeit az alkalmazÃ¡ssal "
+"kapcsolatban."
 
-#: winedbg.rc:61
+#: winedbg.rc:59
 msgid "Show &Details"
 msgstr "&RÃ©szletek"
 
-#: winedbg.rc:66
+#: winedbg.rc:64
 msgid "Program Error Details"
 msgstr "Program hibarÃ©szletezÅ"
 
-#: winedbg.rc:73
+#: winedbg.rc:68
 msgid ""
 "If this problem is not present under Windows and has not been reported yet, "
 "you can save the detailed information to a file using the \"Save As\" "
-"button, then <a href=\"http://wiki.winehq.org/Bugs\">file a bug report</a> "
-"and attach that file to the report."
+"button, then <a href=\"http://www.codeweavers.com/support/tickets/enter/"
+"\">file a bug report</a> and attach that file to the report."
 msgstr ""
 "Ha ez a problÃ©ma mÃ©g nincs jelen Windows alatt Ã©s nem lett lejelentve, "
 "lementheti a rÃ©szletes informÃ¡ciÃ³t egy fÃ¡jlba a MentÃ©s mÃ¡skÃ©nt nyomÃ³gomb "
-"hasznÃ¡latÃ¡val, azutÃ¡n <a href=\"http://wiki.winehq.org/Bugs\">fÃ¡jl "
-"hibajelentÃ©shez</a> Ã©s csatolja azt a fÃ¡jlt a jelentÃ©shez."
+"hasznÃ¡latÃ¡val, azutÃ¡n <a href=\"http://www.codeweavers.com/support/tickets/"
+"enter/\">fÃ¡jl hibajelentÃ©shez</a> Ã©s csatolja azt a fÃ¡jlt a jelentÃ©shez."
 
 #: winedbg.rc:38
 msgid "Wine program crash"
diff -Naur wine-2.0a/po/it.po wine-2.0b/po/it.po
--- wine-2.0a/po/it.po	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/po/it.po	2017-07-11 20:37:52.000000000 +0100
@@ -407,8 +407,8 @@
 msgid "None"
 msgstr "Nessuno"
 
-#: comctl32.rc:31 cryptui.rc:230 regedit.rc:237 taskmgr.rc:434 winedbg.rc:60
-#: winedbg.rc:75 wordpad.rc:180
+#: comctl32.rc:31 cryptui.rc:230 regedit.rc:237 taskmgr.rc:434 winedbg.rc:58
+#: winedbg.rc:70 wordpad.rc:172
 msgid "Close"
 msgstr "Chiudi"
 
@@ -6801,7 +6801,7 @@
 msgid "Sound Selection"
 msgstr "Selezione dell'audio"
 
-#: msacm32.rc:39 winedbg.rc:76
+#: msacm32.rc:39 winedbg.rc:71
 msgid "&Save As..."
 msgstr "&Salva con nome..."
 
@@ -14358,35 +14358,37 @@
 "Il programma %s ha incontrato un errore e deve essere chiuso. Siamo "
 "spiacenti per l'inconveniente."
 
-#: winedbg.rc:58
+#: winedbg.rc:56
 msgid ""
 "This can be caused by a problem in the program or a deficiency in Wine. You "
-"may want to check the <a href=\"http://appdb.winehq.org\">Application "
-"Database</a> for tips about running this application."
+"may want to check <a href=\"http://www.codeweavers.com/compatibility/"
+"\">http://www.codeweavers.com/compatibility/</a> for tips about running this "
+"application."
 msgstr ""
 "CiÃ² puÃ² essere causato da un problema nel programma o da una mancanza di "
-"Wine. Potresti voler consultare il <a href=\"http://appdb.winehq.org"
-"\">Database delle applicazioni</a> per consigli su questa applicazione."
+"Wine. Potresti voler consultare il <a href=\"http://www.codeweavers.com/"
+"compatibility/\">http://www.codeweavers.com/compatibility/</a> per consigli "
+"su questa applicazione."
 
-#: winedbg.rc:61
+#: winedbg.rc:59
 msgid "Show &Details"
 msgstr "Mostra i &dettagli"
 
-#: winedbg.rc:66
+#: winedbg.rc:64
 msgid "Program Error Details"
 msgstr "Dettagli dell'errore del programma"
 
-#: winedbg.rc:73
+#: winedbg.rc:68
 msgid ""
 "If this problem is not present under Windows and has not been reported yet, "
 "you can save the detailed information to a file using the \"Save As\" "
-"button, then <a href=\"http://wiki.winehq.org/Bugs\">file a bug report</a> "
-"and attach that file to the report."
+"button, then <a href=\"http://www.codeweavers.com/support/tickets/enter/"
+"\">file a bug report</a> and attach that file to the report."
 msgstr ""
 "Se questo problema non Ã¨ presente sotto Windows e non Ã¨ stato ancora "
 "riportato, puoi salvare le informazioni dettagliate su un file usando il "
-"pulsante \"Salva con nome\", poi <a href=\"http://wiki.winehq.org/Bugs"
-"\">segnalalo</a> e allega quel file al report del bug."
+"pulsante \"Salva con nome\", poi <a href=\"http://www.codeweavers.com/"
+"support/tickets/enter/\">segnalalo</a> e allega quel file al report del bug."
 
 #: winedbg.rc:38
 msgid "Wine program crash"
diff -Naur wine-2.0a/po/ja.po wine-2.0b/po/ja.po
--- wine-2.0a/po/ja.po	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/po/ja.po	2017-07-11 20:37:52.000000000 +0100
@@ -390,8 +390,8 @@
 msgid "None"
 msgstr "ãªã"
 
-#: comctl32.rc:31 cryptui.rc:230 regedit.rc:237 taskmgr.rc:434 winedbg.rc:60
-#: winedbg.rc:75 wordpad.rc:180
+#: comctl32.rc:31 cryptui.rc:230 regedit.rc:237 taskmgr.rc:434 winedbg.rc:58
+#: winedbg.rc:70 wordpad.rc:172
 msgid "Close"
 msgstr "éãã"
 
@@ -6721,7 +6721,7 @@
 msgid "Sound Selection"
 msgstr "ãµã¦ã³ãã®é¸æ"
 
-#: msacm32.rc:39 winedbg.rc:76
+#: msacm32.rc:39 winedbg.rc:71
 msgid "&Save As..."
 msgstr "ååãä»ãã¦ä¿å­(&S)..."
 
@@ -14042,34 +14042,37 @@
 "ãã­ã°ã©ã  %s ã§éå¤§ãªåé¡ãçºçãããããçµäºããå¿è¦ãããã¾ãã ãä¸ä¾¿ãã"
 "ãããç³ãè¨³ããã¾ããã"
 
-#: winedbg.rc:58
+#: winedbg.rc:56
 msgid ""
 "This can be caused by a problem in the program or a deficiency in Wine. You "
-"may want to check the <a href=\"http://appdb.winehq.org\">Application "
-"Database</a> for tips about running this application."
+"may want to check <a href=\"http://www.codeweavers.com/compatibility/"
+"\">http://www.codeweavers.com/compatibility/</a> for tips about running this "
+"application."
 msgstr ""
 "ããã¯ãã­ã°ã©ã åã®åé¡ã Wine ã®æ¬ é¥ã«ãã£ã¦çºçãããã¨ãããã¾ãã<a "
-"href=\"http://appdb.winehq.org\">ã¢ããªã±ã¼ã·ã§ã³ ãã¼ã¿ãã¼ã¹</a>ã§ ãã®ã¢ã"
-"ãªã±ã¼ã·ã§ã³ãåä½ããããã³ãã ç¢ºèªããã¨ããã§ãããã"
+"href=\"http://www.codeweavers.com/compatibility/\">http://www.codeweavers."
+"com/compatibility/</a>ã§ ãã®ã¢ããªã±ã¼ã·ã§ã³ãåä½ããããã³ãã ç¢ºèªããã¨"
+"ããã§ãããã"
 
-#: winedbg.rc:61
+#: winedbg.rc:59
 msgid "Show &Details"
 msgstr "è©³ç´°ãè¡¨ç¤º(&D)"
 
-#: winedbg.rc:66
+#: winedbg.rc:64
 msgid "Program Error Details"
 msgstr "ãã­ã°ã©ã  ã¨ã©ã¼ã®è©³ç´°"
 
-#: winedbg.rc:73
+#: winedbg.rc:68
 msgid ""
 "If this problem is not present under Windows and has not been reported yet, "
 "you can save the detailed information to a file using the \"Save As\" "
-"button, then <a href=\"http://wiki.winehq.org/Bugs\">file a bug report</a> "
-"and attach that file to the report."
+"button, then <a href=\"http://www.codeweavers.com/support/tickets/enter/"
+"\">file a bug report</a> and attach that file to the report."
 msgstr ""
 "ãã®åé¡ã Windows ä¸ã§çºçãããã¨ããªãã¾ã å ±åããã¦ããªãå ´åã¯ã[ä¿å­ã"
-"ã]ãã¿ã³ãå©ç¨ãã¦è©³ç´°æå ±ãä¿å­ããä¸ã§ã <a href=\"http://wiki.winehq.org/"
-"Bugs\">ãã° ã¬ãã¼ããä½æ</a>ãããã®ãã¡ã¤ã«ãã¬ãã¼ãã«æ·»ä»ã§ãã¾ãã"
+"ã]ãã¿ã³ãå©ç¨ãã¦è©³ç´°æå ±ãä¿å­ããä¸ã§ã <a href=\"http://www.codeweavers."
+"com/support/tickets/enter/\">ãã° ã¬ãã¼ããä½æ</a>ãããã®ãã¡ã¤ã«ãã¬ãã¼"
+"ãã«æ·»ä»ã§ãã¾ãã"
 
 #: winedbg.rc:38
 msgid "Wine program crash"
diff -Naur wine-2.0a/po/ko.po wine-2.0b/po/ko.po
--- wine-2.0a/po/ko.po	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/po/ko.po	2017-07-11 20:37:52.000000000 +0100
@@ -388,8 +388,8 @@
 msgid "None"
 msgstr "ìì"
 
-#: comctl32.rc:31 cryptui.rc:230 regedit.rc:237 taskmgr.rc:434 winedbg.rc:60
-#: winedbg.rc:75 wordpad.rc:180
+#: comctl32.rc:31 cryptui.rc:230 regedit.rc:237 taskmgr.rc:434 winedbg.rc:58
+#: winedbg.rc:70 wordpad.rc:172
 msgid "Close"
 msgstr "ë«ê¸°"
 
@@ -6738,7 +6738,7 @@
 msgid "Sound Selection"
 msgstr "ì¬ì´ë ì í"
 
-#: msacm32.rc:39 winedbg.rc:76
+#: msacm32.rc:39 winedbg.rc:71
 msgid "&Save As..."
 msgstr "ë¤ë¥¸ ì´ë¦ ì ì¥(&S)..."
 
@@ -14304,35 +14304,37 @@
 "ì´ íë¡ê·¸ë¨ %s ì ì¬ê°í ë¬¸ì ì ì§ë©´í´ì ì¢ë£ë¥¼ íìë¡ í©ëë¤. ì°ë¦¬ë  ë¶í¸"
 "ì ë¼ì³ëë¦° ê±°ì ëíì¬ ì ê°ì íí¨ëë¤."
 
-#: winedbg.rc:58
+#: winedbg.rc:56
 msgid ""
 "This can be caused by a problem in the program or a deficiency in Wine. You "
-"may want to check the <a href=\"http://appdb.winehq.org\">Application "
-"Database</a> for tips about running this application."
+"may want to check <a href=\"http://www.codeweavers.com/compatibility/"
+"\">http://www.codeweavers.com/compatibility/</a> for tips about running this "
+"application."
 msgstr ""
 "ì´ ë¬¸ì ë íë¡ê·¸ë¨ì ë¬¸ì ë Wineì ê²°í¨ì¼ë¡ ì¸í´ ë°ìí  ì ììµëë¤. ë¹ì ì "
-"ì¤íí íë¡ê·¸ë¨ì ëíì¬   <a href=\"http://appdb.winehq.org\">Application "
-"Database</a> ìì ê´ë ¨ íì ì´í´ ë³¼ ì ììµëë¤."
+"ì¤íí íë¡ê·¸ë¨ì ëíì¬   <a href=\"http://www.codeweavers.com/"
+"compatibility/\">http://www.codeweavers.com/compatibility/</a> ìì ê´ë ¨ í"
+"ì ì´í´ ë³¼ ì ììµëë¤."
 
-#: winedbg.rc:61
+#: winedbg.rc:59
 msgid "Show &Details"
 msgstr "ìì¸í ë³´ì¬ì£¼ê¸°(&D)"
 
-#: winedbg.rc:66
+#: winedbg.rc:64
 msgid "Program Error Details"
 msgstr "ìì¸í íë¡ê·¸ë¨ ìë¬"
 
-#: winedbg.rc:73
+#: winedbg.rc:68
 msgid ""
 "If this problem is not present under Windows and has not been reported yet, "
 "you can save the detailed information to a file using the \"Save As\" "
-"button, then <a href=\"http://wiki.winehq.org/Bugs\">file a bug report</a> "
-"and attach that file to the report."
+"button, then <a href=\"http://www.codeweavers.com/support/tickets/enter/"
+"\">file a bug report</a> and attach that file to the report."
 msgstr ""
 "ë§ì½ ì´ ë¬¸ì ê° ìëì°ì¦ìë ì¡´ì¬íì§ ìê³  ìì§ ë³´ê³ ëì§ ììë¤ë©´,ë¹ì ì  \"ë¤"
 "ë¥¸ ì´ë¦ì¼ë¡ ì ì¥\" ë²í¼ì ì¬ì©í´ì ìì¸í ì ë³´ë¥¼ íì¼ë¡ ì ì¥í´ì, <a href="
-"\"http://wiki.winehq.org/Bugs\">ë²ê·¸ ë³´ê³  íì¼</a>ë¡ ê°ìë³´ê³ ìì íì¼ì ê°"
-"ì´ ì¬ë¦¬ì ììµëë¤."
+"\"http://www.codeweavers.com/support/tickets/enter/\">ë²ê·¸ ë³´ê³  íì¼</a>ë¡ ê°"
+"ìë³´ê³ ìì íì¼ì ê°ì´ ì¬ë¦¬ì ììµëë¤."
 
 #: winedbg.rc:38
 msgid "Wine program crash"
diff -Naur wine-2.0a/po/lt.po wine-2.0b/po/lt.po
--- wine-2.0a/po/lt.po	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/po/lt.po	2017-07-11 20:37:52.000000000 +0100
@@ -389,8 +389,8 @@
 msgid "None"
 msgstr "Joks"
 
-#: comctl32.rc:31 cryptui.rc:230 regedit.rc:237 taskmgr.rc:434 winedbg.rc:60
-#: winedbg.rc:75 wordpad.rc:180
+#: comctl32.rc:31 cryptui.rc:230 regedit.rc:237 taskmgr.rc:434 winedbg.rc:58
+#: winedbg.rc:70 wordpad.rc:172
 msgid "Close"
 msgstr "UÅ¾verti"
 
@@ -6731,7 +6731,7 @@
 msgid "Sound Selection"
 msgstr "Garso parinkimas"
 
-#: msacm32.rc:39 winedbg.rc:76
+#: msacm32.rc:39 winedbg.rc:71
 msgid "&Save As..."
 msgstr "IÅ¡saugoti k&aip..."
 
@@ -14065,35 +14065,37 @@
 "Programa %s susidÅ«rÄ su rimta problema ir turi bÅ«ti uÅ¾daryta. AtsipraÅ¡ome "
 "dÄl nepatogumÅ³."
 
-#: winedbg.rc:58
+#: winedbg.rc:56
 msgid ""
 "This can be caused by a problem in the program or a deficiency in Wine. You "
-"may want to check the <a href=\"http://appdb.winehq.org\">Application "
-"Database</a> for tips about running this application."
-msgstr ""
-"Programos problemos ar âWineâ trÅ«kumai gali bÅ«ti to prieÅ¾astimi. TurbÅ«t "
-"norÄsite patikrinti <a href=\"http://appdb.winehq.org\">programÅ³ duomenÅ³ "
-"bazÄ</a> dÄl patarimÅ³ Å¡ios programos vykdymui."
+"may want to check <a href=\"http://www.codeweavers.com/compatibility/"
+"\">http://www.codeweavers.com/compatibility/</a> for tips about running this "
+"application."
+msgstr ""
+"Programos problemos ar Wine trÅ«kumai gali bÅ«ti to prieÅ¾astimi. JÅ«s turbÅ«t "
+"norÄsite patikrinti <a href=\"http://www.codeweavers.com/compatibility/"
+"\">http://www.codeweavers.com/compatibility/</a> dÄl patarimÅ³ apie Å¡ios "
+"programos vykdymÄ."
 
-#: winedbg.rc:61
+#: winedbg.rc:59
 msgid "Show &Details"
 msgstr "Rodyti &iÅ¡samiau"
 
-#: winedbg.rc:66
+#: winedbg.rc:64
 msgid "Program Error Details"
 msgstr "IÅ¡samiau apie programos klaidÄ"
 
-#: winedbg.rc:73
+#: winedbg.rc:68
 msgid ""
 "If this problem is not present under Windows and has not been reported yet, "
 "you can save the detailed information to a file using the \"Save As\" "
-"button, then <a href=\"http://wiki.winehq.org/Bugs\">file a bug report</a> "
-"and attach that file to the report."
+"button, then <a href=\"http://www.codeweavers.com/support/tickets/enter/"
+"\">file a bug report</a> and attach that file to the report."
 msgstr ""
 "Jei Å¡ios problemos nÄra âWindowsâ sistemoje ir apie jÄ dar nebuvo praneÅ¡ta, "
 "galite iÅ¡saugoti iÅ¡samiÄ informacijÄ Ä¯ failÄ naudodami mygtukÄ âIÅ¡saugoti "
-"kaipâ, tada <a href=\"http://wiki.winehq.org/Bugs\">uÅ¾registruoti klaidÄ</a> "
-"ir prikabinti tÄ failÄ prie praneÅ¡imo."
+"kaipâ, tada <a href=\"http://www.codeweavers.com/support/tickets/enter/"
+"\">uÅ¾registruoti klaidÄ</a> ir prikabinti tÄ failÄ prie praneÅ¡imo."
 
 #: winedbg.rc:38
 msgid "Wine program crash"
diff -Naur wine-2.0a/po/ml.po wine-2.0b/po/ml.po
--- wine-2.0a/po/ml.po	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/po/ml.po	2017-07-11 20:37:52.000000000 +0100
@@ -368,8 +368,8 @@
 msgid "None"
 msgstr ""
 
-#: comctl32.rc:31 cryptui.rc:230 regedit.rc:237 taskmgr.rc:434 winedbg.rc:60
-#: winedbg.rc:75 wordpad.rc:180
+#: comctl32.rc:31 cryptui.rc:230 regedit.rc:237 taskmgr.rc:434 winedbg.rc:58
+#: winedbg.rc:70 wordpad.rc:172
 msgid "Close"
 msgstr ""
 
@@ -6636,7 +6636,7 @@
 msgid "Sound Selection"
 msgstr ""
 
-#: msacm32.rc:39 winedbg.rc:76
+#: msacm32.rc:39 winedbg.rc:71
 msgid "&Save As..."
 msgstr ""
 
@@ -13378,28 +13378,29 @@
 "sorry for the inconvenience."
 msgstr ""
 
-#: winedbg.rc:58
+#: winedbg.rc:56
 msgid ""
 "This can be caused by a problem in the program or a deficiency in Wine. You "
-"may want to check the <a href=\"http://appdb.winehq.org\">Application "
-"Database</a> for tips about running this application."
+"may want to check <a href=\"http://www.codeweavers.com/compatibility/"
+"\">http://www.codeweavers.com/compatibility/</a> for tips about running this "
+"application."
 msgstr ""
 
-#: winedbg.rc:61
+#: winedbg.rc:59
 msgid "Show &Details"
 msgstr ""
 
-#: winedbg.rc:66
+#: winedbg.rc:64
 #, fuzzy
 msgid "Program Error Details"
 msgstr "à´µà´¿_à´µà´°à´"
 
-#: winedbg.rc:73
+#: winedbg.rc:68
 msgid ""
 "If this problem is not present under Windows and has not been reported yet, "
 "you can save the detailed information to a file using the \"Save As\" "
-"button, then <a href=\"http://wiki.winehq.org/Bugs\">file a bug report</a> "
-"and attach that file to the report."
+"button, then <a href=\"http://www.codeweavers.com/support/tickets/enter/"
+"\">file a bug report</a> and attach that file to the report."
 msgstr ""
 
 #: winedbg.rc:38
diff -Naur wine-2.0a/po/nb_NO.po wine-2.0b/po/nb_NO.po
--- wine-2.0a/po/nb_NO.po	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/po/nb_NO.po	2017-07-11 20:37:52.000000000 +0100
@@ -387,8 +387,8 @@
 msgid "None"
 msgstr "Ingen"
 
-#: comctl32.rc:31 cryptui.rc:230 regedit.rc:237 taskmgr.rc:434 winedbg.rc:60
-#: winedbg.rc:75 wordpad.rc:180
+#: comctl32.rc:31 cryptui.rc:230 regedit.rc:237 taskmgr.rc:434 winedbg.rc:58
+#: winedbg.rc:70 wordpad.rc:172
 msgid "Close"
 msgstr "Lukk"
 
@@ -6731,7 +6731,7 @@
 msgid "Sound Selection"
 msgstr "Lydutvalg"
 
-#: msacm32.rc:39 winedbg.rc:76
+#: msacm32.rc:39 winedbg.rc:71
 msgid "&Save As..."
 msgstr "Lagre &som..."
 
@@ -14056,11 +14056,13 @@
 "Programmet %s har fÃ¥tt et alvorlig problem og mÃ¥ avsluttes. Vi beklager det "
 "inntrufne."
 
-#: winedbg.rc:58
+#: winedbg.rc:56
+#, fuzzy
 msgid ""
 "This can be caused by a problem in the program or a deficiency in Wine. You "
-"may want to check the <a href=\"http://appdb.winehq.org\">Application "
-"Database</a> for tips about running this application."
+"may want to check <a href=\"http://www.codeweavers.com/compatibility/"
+"\">http://www.codeweavers.com/compatibility/</a> for tips about running this "
+"application."
 msgstr ""
 "Dette kan skyldes et problem i programmet eller en feil i Wine. Du kan "
 "besÃ¸ke <a href=\"http://appdb.winehq.org\">Wines programdatabase</a> for rÃ¥d "
@@ -14074,12 +14076,12 @@
 msgid "Program Error Details"
 msgstr "Detaljer for programfeil"
 
-#: winedbg.rc:73
+#: winedbg.rc:68
 msgid ""
 "If this problem is not present under Windows and has not been reported yet, "
 "you can save the detailed information to a file using the \"Save As\" "
-"button, then <a href=\"http://wiki.winehq.org/Bugs\">file a bug report</a> "
-"and attach that file to the report."
+"button, then <a href=\"http://www.codeweavers.com/support/tickets/enter/"
+"\">file a bug report</a> and attach that file to the report."
 msgstr ""
 "Hvis dette problemet ikke oppstÃ¥r i Windows og ikke har blitt rapportert "
 "ennÃ¥, sÃ¥ kan du lagre detaljert informasjon til en fil ved Ã¥ trykke pÃ¥ "
diff -Naur wine-2.0a/po/nl.po wine-2.0b/po/nl.po
--- wine-2.0a/po/nl.po	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/po/nl.po	2017-07-11 20:37:52.000000000 +0100
@@ -390,8 +390,8 @@
 msgid "None"
 msgstr "Geen"
 
-#: comctl32.rc:31 cryptui.rc:230 regedit.rc:237 taskmgr.rc:434 winedbg.rc:60
-#: winedbg.rc:75 wordpad.rc:180
+#: comctl32.rc:31 cryptui.rc:230 regedit.rc:237 taskmgr.rc:434 winedbg.rc:58
+#: winedbg.rc:70 wordpad.rc:172
 msgid "Close"
 msgstr "Sluiten"
 
@@ -6774,7 +6774,7 @@
 msgid "Sound Selection"
 msgstr "Geluidskeuze"
 
-#: msacm32.rc:39 winedbg.rc:76
+#: msacm32.rc:39 winedbg.rc:71
 msgid "&Save As..."
 msgstr "&Opslaan als..."
 
@@ -14324,12 +14324,13 @@
 "Het programma %s is een serieus probleem tegengekomen en moet afgesloten "
 "worden. Excuses voor het ongemak."
 
-#: winedbg.rc:58
+#: winedbg.rc:56
 #, fuzzy
 msgid ""
 "This can be caused by a problem in the program or a deficiency in Wine. You "
-"may want to check the <a href=\"http://appdb.winehq.org\">Application "
-"Database</a> for tips about running this application."
+"may want to check <a href=\"http://www.codeweavers.com/compatibility/"
+"\">http://www.codeweavers.com/compatibility/</a> for tips about running this "
+"application."
 msgstr ""
 "Dit kan veroorzaakt worden door een probleem in het programma of een fout in "
 "Wine. U kunt zoeken op <a href=\"http://appdb.winehq.org\">Application "
@@ -14338,20 +14339,20 @@
 "Als dit probleem niet optreedt onder Windows en nog niet is gerapporteerd, "
 "dan kunt u <a href=\"http://wiki.winehq.org/Bugs\">een bug rapporteren</a>."
 
-#: winedbg.rc:61
+#: winedbg.rc:59
 msgid "Show &Details"
 msgstr "Toon &Details"
 
-#: winedbg.rc:66
+#: winedbg.rc:64
 msgid "Program Error Details"
 msgstr "Programmafout details"
 
-#: winedbg.rc:73
+#: winedbg.rc:68
 msgid ""
 "If this problem is not present under Windows and has not been reported yet, "
 "you can save the detailed information to a file using the \"Save As\" "
-"button, then <a href=\"http://wiki.winehq.org/Bugs\">file a bug report</a> "
-"and attach that file to the report."
+"button, then <a href=\"http://www.codeweavers.com/support/tickets/enter/"
+"\">file a bug report</a> and attach that file to the report."
 msgstr ""
 "Indien dit probleem zich niet voordoet onder Windows en het probleem is nog "
 "niet gerapporteerd, dan kunt U gedetailleerde informatie in een bestand "
diff -Naur wine-2.0a/po/or.po wine-2.0b/po/or.po
--- wine-2.0a/po/or.po	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/po/or.po	2017-07-11 20:37:52.000000000 +0100
@@ -368,8 +368,8 @@
 msgid "None"
 msgstr ""
 
-#: comctl32.rc:31 cryptui.rc:230 regedit.rc:237 taskmgr.rc:434 winedbg.rc:60
-#: winedbg.rc:75 wordpad.rc:180
+#: comctl32.rc:31 cryptui.rc:230 regedit.rc:237 taskmgr.rc:434 winedbg.rc:58
+#: winedbg.rc:70 wordpad.rc:172
 msgid "Close"
 msgstr ""
 
@@ -6636,7 +6636,7 @@
 msgid "Sound Selection"
 msgstr ""
 
-#: msacm32.rc:39 winedbg.rc:76
+#: msacm32.rc:39 winedbg.rc:71
 msgid "&Save As..."
 msgstr ""
 
@@ -13378,28 +13378,29 @@
 "sorry for the inconvenience."
 msgstr ""
 
-#: winedbg.rc:58
+#: winedbg.rc:56
 msgid ""
 "This can be caused by a problem in the program or a deficiency in Wine. You "
-"may want to check the <a href=\"http://appdb.winehq.org\">Application "
-"Database</a> for tips about running this application."
+"may want to check <a href=\"http://www.codeweavers.com/compatibility/"
+"\">http://www.codeweavers.com/compatibility/</a> for tips about running this "
+"application."
 msgstr ""
 
-#: winedbg.rc:61
+#: winedbg.rc:59
 msgid "Show &Details"
 msgstr ""
 
-#: winedbg.rc:66
+#: winedbg.rc:64
 #, fuzzy
 msgid "Program Error Details"
 msgstr "à¬¸à­à¬à¬¨à¬¾ (&o)"
 
-#: winedbg.rc:73
+#: winedbg.rc:68
 msgid ""
 "If this problem is not present under Windows and has not been reported yet, "
 "you can save the detailed information to a file using the \"Save As\" "
-"button, then <a href=\"http://wiki.winehq.org/Bugs\">file a bug report</a> "
-"and attach that file to the report."
+"button, then <a href=\"http://www.codeweavers.com/support/tickets/enter/"
+"\">file a bug report</a> and attach that file to the report."
 msgstr ""
 
 #: winedbg.rc:38
diff -Naur wine-2.0a/po/pa.po wine-2.0b/po/pa.po
--- wine-2.0a/po/pa.po	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/po/pa.po	2017-07-11 20:37:52.000000000 +0100
@@ -368,8 +368,8 @@
 msgid "None"
 msgstr ""
 
-#: comctl32.rc:31 cryptui.rc:230 regedit.rc:237 taskmgr.rc:434 winedbg.rc:60
-#: winedbg.rc:75 wordpad.rc:180
+#: comctl32.rc:31 cryptui.rc:230 regedit.rc:237 taskmgr.rc:434 winedbg.rc:58
+#: winedbg.rc:70 wordpad.rc:172
 msgid "Close"
 msgstr ""
 
@@ -6636,7 +6636,7 @@
 msgid "Sound Selection"
 msgstr ""
 
-#: msacm32.rc:39 winedbg.rc:76
+#: msacm32.rc:39 winedbg.rc:71
 msgid "&Save As..."
 msgstr ""
 
@@ -13378,28 +13378,29 @@
 "sorry for the inconvenience."
 msgstr ""
 
-#: winedbg.rc:58
+#: winedbg.rc:56
 msgid ""
 "This can be caused by a problem in the program or a deficiency in Wine. You "
-"may want to check the <a href=\"http://appdb.winehq.org\">Application "
-"Database</a> for tips about running this application."
+"may want to check <a href=\"http://www.codeweavers.com/compatibility/"
+"\">http://www.codeweavers.com/compatibility/</a> for tips about running this "
+"application."
 msgstr ""
 
-#: winedbg.rc:61
+#: winedbg.rc:59
 msgid "Show &Details"
 msgstr ""
 
-#: winedbg.rc:66
+#: winedbg.rc:64
 #, fuzzy
 msgid "Program Error Details"
 msgstr "à¨à¨¾à¨£à¨à¨¾à¨°à©(&o)"
 
-#: winedbg.rc:73
+#: winedbg.rc:68
 msgid ""
 "If this problem is not present under Windows and has not been reported yet, "
 "you can save the detailed information to a file using the \"Save As\" "
-"button, then <a href=\"http://wiki.winehq.org/Bugs\">file a bug report</a> "
-"and attach that file to the report."
+"button, then <a href=\"http://www.codeweavers.com/support/tickets/enter/"
+"\">file a bug report</a> and attach that file to the report."
 msgstr ""
 
 #: winedbg.rc:38
diff -Naur wine-2.0a/po/pl.po wine-2.0b/po/pl.po
--- wine-2.0a/po/pl.po	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/po/pl.po	2017-07-11 20:37:52.000000000 +0100
@@ -394,8 +394,8 @@
 msgid "None"
 msgstr "Brak"
 
-#: comctl32.rc:31 cryptui.rc:230 regedit.rc:237 taskmgr.rc:434 winedbg.rc:60
-#: winedbg.rc:75 wordpad.rc:180
+#: comctl32.rc:31 cryptui.rc:230 regedit.rc:237 taskmgr.rc:434 winedbg.rc:58
+#: winedbg.rc:70 wordpad.rc:172
 msgid "Close"
 msgstr "Zamknij"
 
@@ -6745,7 +6745,7 @@
 msgid "Sound Selection"
 msgstr "WybÃ³r dÅºwiÄku"
 
-#: msacm32.rc:39 winedbg.rc:76
+#: msacm32.rc:39 winedbg.rc:71
 msgid "&Save As..."
 msgstr "&Zapisz jako..."
 
@@ -14166,35 +14166,37 @@
 "Program %s napotkaÅ powaÅ¼ny problem i musi zakoÅczyÄ dziaÅanie. Przepraszamy "
 "za tÄ niedogodnoÅÄ."
 
-#: winedbg.rc:58
+#: winedbg.rc:56
 msgid ""
 "This can be caused by a problem in the program or a deficiency in Wine. You "
-"may want to check the <a href=\"http://appdb.winehq.org\">Application "
-"Database</a> for tips about running this application."
+"may want to check <a href=\"http://www.codeweavers.com/compatibility/"
+"\">http://www.codeweavers.com/compatibility/</a> for tips about running this "
+"application."
 msgstr ""
 "Powodem bÅÄdu moÅ¼e byÄ problem w programie lub braki w Wine. Zajrzyj do <a "
-"href=\"http://appdb.winehq.org\">Bazy danych aplikacji</a> po wskazÃ³wki na "
-"temat uruchomienia tej aplikacji."
+"href=\"http://www.codeweavers.com/compatibility/\">http://www.codeweavers."
+"com/compatibility/</a> po wskazÃ³wki na temat uruchomienia tej aplikacji."
 
-#: winedbg.rc:61
+#: winedbg.rc:59
 msgid "Show &Details"
 msgstr "PokaÅ¼ &szczegÃ³Åy"
 
-#: winedbg.rc:66
+#: winedbg.rc:64
 msgid "Program Error Details"
 msgstr "SzczegÃ³Åy bÅÄdu programu"
 
-#: winedbg.rc:73
+#: winedbg.rc:68
 msgid ""
 "If this problem is not present under Windows and has not been reported yet, "
 "you can save the detailed information to a file using the \"Save As\" "
-"button, then <a href=\"http://wiki.winehq.org/Bugs\">file a bug report</a> "
-"and attach that file to the report."
+"button, then <a href=\"http://www.codeweavers.com/support/tickets/enter/"
+"\">file a bug report</a> and attach that file to the report."
 msgstr ""
 "JeÅ¼eli problem ten nie wystÄpuje w systemie Windows i nie zostaÅ jeszcze "
 "zgÅoszony, to moÅ¼esz zapisaÄ szczegÃ³Åowe informacje do pliku uÅ¼ywajÄc "
-"przycisku \"Zapisz jako\", a nastÄpnie <a href=\"http://wiki.winehq.org/Bugs"
-"\">wypeÅniÄ zgÅoszenie o bÅÄdzie</a> i doÅÄczyÄ ten plik do zgÅoszenia."
+"przycisku \"Zapisz jako\", a nastÄpnie <a href=\"http://www.codeweavers.com/"
+"support/tickets/enter/\">wypeÅniÄ zgÅoszenie o bÅÄdzie</a> i doÅÄczyÄ ten "
+"plik do zgÅoszenia."
 
 #: winedbg.rc:38
 msgid "Wine program crash"
diff -Naur wine-2.0a/po/pt_BR.po wine-2.0b/po/pt_BR.po
--- wine-2.0a/po/pt_BR.po	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/po/pt_BR.po	2017-07-11 20:37:52.000000000 +0100
@@ -390,8 +390,8 @@
 msgid "None"
 msgstr "Nenhuma"
 
-#: comctl32.rc:31 cryptui.rc:230 regedit.rc:237 taskmgr.rc:434 winedbg.rc:60
-#: winedbg.rc:75 wordpad.rc:180
+#: comctl32.rc:31 cryptui.rc:230 regedit.rc:237 taskmgr.rc:434 winedbg.rc:58
+#: winedbg.rc:70 wordpad.rc:172
 msgid "Close"
 msgstr "Fechar"
 
@@ -6741,7 +6741,7 @@
 msgid "Sound Selection"
 msgstr "SeleÃ§Ã£o de som"
 
-#: msacm32.rc:39 winedbg.rc:76
+#: msacm32.rc:39 winedbg.rc:71
 msgid "&Save As..."
 msgstr "&Salvar como..."
 
@@ -14127,35 +14127,36 @@
 "O programa %s encontrou um problema sÃ©rio e precisa ser fechado. Pedimos "
 "desculpa pela inconveniÃªncia."
 
-#: winedbg.rc:58
+#: winedbg.rc:56
 msgid ""
 "This can be caused by a problem in the program or a deficiency in Wine. You "
-"may want to check the <a href=\"http://appdb.winehq.org\">Application "
-"Database</a> for tips about running this application."
+"may want to check <a href=\"http://www.codeweavers.com/compatibility/"
+"\">http://www.codeweavers.com/compatibility/</a> for tips about running this "
+"application."
 msgstr ""
 "Isto pode ter sido causado por um problema no programa ou no Wine. VocÃª pode "
-"visitar o <a href=\"http://appdb.winehq.org\">Banco de Dados de Aplicativos "
-"</a> para dicas de como rodar este aplicativo."
+"visitar o <a href=\"http://www.codeweavers.com/compatibility/\">http://www."
+"codeweavers.com/compatibility/</a> para dicas de como rodar este aplicativo."
 
-#: winedbg.rc:61
+#: winedbg.rc:59
 msgid "Show &Details"
 msgstr "Mostrar &Detalhes"
 
-#: winedbg.rc:66
+#: winedbg.rc:64
 msgid "Program Error Details"
 msgstr "Detalhes do Erro do Programa"
 
-#: winedbg.rc:73
+#: winedbg.rc:68
 msgid ""
 "If this problem is not present under Windows and has not been reported yet, "
 "you can save the detailed information to a file using the \"Save As\" "
-"button, then <a href=\"http://wiki.winehq.org/Bugs\">file a bug report</a> "
-"and attach that file to the report."
+"button, then <a href=\"http://www.codeweavers.com/support/tickets/enter/"
+"\">file a bug report</a> and attach that file to the report."
 msgstr ""
 "Se este problema nÃ£o estÃ¡ presente no Windows e nÃ£o foi reportado ainda, "
 "vocÃª pode salvar a informaÃ§Ã£o detalhada do arquivo usando o botÃ£o \"Salvar "
-"Como\", <a href=\"http://wiki.winehq.org/Bugs\">enviar um relatÃ³rio de erro</"
-"a> e anexar o arquivo ao relatÃ³rio."
+"Como\", <a href=\"http://www.codeweavers.com/support/tickets/enter/\">enviar "
+"um relatÃ³rio de erro</a> e anexar o arquivo ao relatÃ³rio."
 
 #: winedbg.rc:38
 msgid "Wine program crash"
diff -Naur wine-2.0a/po/pt_PT.po wine-2.0b/po/pt_PT.po
--- wine-2.0a/po/pt_PT.po	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/po/pt_PT.po	2017-07-11 20:37:52.000000000 +0100
@@ -390,8 +390,8 @@
 msgid "None"
 msgstr "Nenhum"
 
-#: comctl32.rc:31 cryptui.rc:230 regedit.rc:237 taskmgr.rc:434 winedbg.rc:60
-#: winedbg.rc:75 wordpad.rc:180
+#: comctl32.rc:31 cryptui.rc:230 regedit.rc:237 taskmgr.rc:434 winedbg.rc:58
+#: winedbg.rc:70 wordpad.rc:172
 msgid "Close"
 msgstr "Fechar"
 
@@ -6737,7 +6737,7 @@
 msgid "Sound Selection"
 msgstr "SelecÃ§Ã£o de som"
 
-#: msacm32.rc:39 winedbg.rc:76
+#: msacm32.rc:39 winedbg.rc:71
 msgid "&Save As..."
 msgstr "&Gravar como..."
 
@@ -14144,30 +14144,32 @@
 "O programa %s encontrou um problema sÃ©rio e precisa ser encerrado. Pedimos "
 "desculpa pelo incÃ³modo."
 
-#: winedbg.rc:58
+#: winedbg.rc:56
 msgid ""
 "This can be caused by a problem in the program or a deficiency in Wine. You "
-"may want to check the <a href=\"http://appdb.winehq.org\">Application "
-"Database</a> for tips about running this application."
+"may want to check <a href=\"http://www.codeweavers.com/compatibility/"
+"\">http://www.codeweavers.com/compatibility/</a> for tips about running this "
+"application."
 msgstr ""
 "Isto pode ser causado por um problema no programa ou uma deficiÃªncia no "
-"Wine. Pode querer visitar a <a href='http://appdb.winehq.org'>Base de Dados "
-"de AplicaÃ§Ãµes</a> para dicas de como correr esta aplicaÃ§Ã£o."
+"Wine. Pode querer visitar a <a href=\"http://www.codeweavers.com/"
+"compatibility/\">http://www.codeweavers.com/compatibility/</a> para dicas de "
+"como correr esta aplicaÃ§Ã£o."
 
-#: winedbg.rc:61
+#: winedbg.rc:59
 msgid "Show &Details"
 msgstr "Mostrar &Detalhes"
 
-#: winedbg.rc:66
+#: winedbg.rc:64
 msgid "Program Error Details"
 msgstr "Detalhes do erro no programa"
 
-#: winedbg.rc:73
+#: winedbg.rc:68
 msgid ""
 "If this problem is not present under Windows and has not been reported yet, "
 "you can save the detailed information to a file using the \"Save As\" "
-"button, then <a href=\"http://wiki.winehq.org/Bugs\">file a bug report</a> "
-"and attach that file to the report."
+"button, then <a href=\"http://www.codeweavers.com/support/tickets/enter/"
+"\">file a bug report</a> and attach that file to the report."
 msgstr ""
 
 #: winedbg.rc:38
diff -Naur wine-2.0a/po/rm.po wine-2.0b/po/rm.po
--- wine-2.0a/po/rm.po	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/po/rm.po	2017-07-11 20:37:52.000000000 +0100
@@ -375,8 +375,8 @@
 msgid "None"
 msgstr ""
 
-#: comctl32.rc:31 cryptui.rc:230 regedit.rc:237 taskmgr.rc:434 winedbg.rc:60
-#: winedbg.rc:75 wordpad.rc:180
+#: comctl32.rc:31 cryptui.rc:230 regedit.rc:237 taskmgr.rc:434 winedbg.rc:58
+#: winedbg.rc:70 wordpad.rc:172
 msgid "Close"
 msgstr ""
 
@@ -6684,7 +6684,7 @@
 msgid "Sound Selection"
 msgstr ""
 
-#: msacm32.rc:39 winedbg.rc:76
+#: msacm32.rc:39 winedbg.rc:71
 msgid "&Save As..."
 msgstr ""
 
@@ -13478,27 +13478,28 @@
 "sorry for the inconvenience."
 msgstr ""
 
-#: winedbg.rc:58
+#: winedbg.rc:56
 msgid ""
 "This can be caused by a problem in the program or a deficiency in Wine. You "
-"may want to check the <a href=\"http://appdb.winehq.org\">Application "
-"Database</a> for tips about running this application."
+"may want to check <a href=\"http://www.codeweavers.com/compatibility/"
+"\">http://www.codeweavers.com/compatibility/</a> for tips about running this "
+"application."
 msgstr ""
 
-#: winedbg.rc:61
+#: winedbg.rc:59
 msgid "Show &Details"
 msgstr ""
 
-#: winedbg.rc:66
+#: winedbg.rc:64
 msgid "Program Error Details"
 msgstr ""
 
-#: winedbg.rc:73
+#: winedbg.rc:68
 msgid ""
 "If this problem is not present under Windows and has not been reported yet, "
 "you can save the detailed information to a file using the \"Save As\" "
-"button, then <a href=\"http://wiki.winehq.org/Bugs\">file a bug report</a> "
-"and attach that file to the report."
+"button, then <a href=\"http://www.codeweavers.com/support/tickets/enter/"
+"\">file a bug report</a> and attach that file to the report."
 msgstr ""
 
 #: winedbg.rc:38
diff -Naur wine-2.0a/po/ro.po wine-2.0b/po/ro.po
--- wine-2.0a/po/ro.po	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/po/ro.po	2017-07-11 20:37:52.000000000 +0100
@@ -376,8 +376,8 @@
 msgid "None"
 msgstr "Nespecificat"
 
-#: comctl32.rc:31 cryptui.rc:230 regedit.rc:237 taskmgr.rc:434 winedbg.rc:60
-#: winedbg.rc:75 wordpad.rc:180
+#: comctl32.rc:31 cryptui.rc:230 regedit.rc:237 taskmgr.rc:434 winedbg.rc:58
+#: winedbg.rc:70 wordpad.rc:172
 msgid "Close"
 msgstr "Ãnchide"
 
@@ -6792,7 +6792,7 @@
 msgid "Sound Selection"
 msgstr "SelecÈie sunet"
 
-#: msacm32.rc:39 winedbg.rc:76
+#: msacm32.rc:39 winedbg.rc:71
 msgid "&Save As..."
 msgstr "&SalveazÄ ca..."
 
@@ -14022,30 +14022,32 @@
 "Programul %s a Ã®ntÃ¢mpinat o problemÄ gravÄ Èi trebuie sÄ se Ã®nchidÄ. Ne "
 "cerem scuze pentru neplÄcerile create."
 
-#: winedbg.rc:58
+#: winedbg.rc:56
 msgid ""
 "This can be caused by a problem in the program or a deficiency in Wine. You "
-"may want to check the <a href=\"http://appdb.winehq.org\">Application "
-"Database</a> for tips about running this application."
+"may want to check <a href=\"http://www.codeweavers.com/compatibility/"
+"\">http://www.codeweavers.com/compatibility/</a> for tips about running this "
+"application."
 msgstr ""
 "Cauza poate fi o problemÄ Ã®n program sau o deficienÈÄ Ã®n Wine. PuteÈi "
-"consulta http://appdb.winehq.org pentru sugestii privind executarea acestei "
-"aplicaÈii."
+"consulta <a href=\"http://www.codeweavers.com/compatibility/\">http://www."
+"codeweavers.com/compatibility/</a> pentru sugestii privind executarea "
+"acestei aplicaÈii."
 
-#: winedbg.rc:61
+#: winedbg.rc:59
 msgid "Show &Details"
 msgstr "AfiÈeazÄ &detalii"
 
-#: winedbg.rc:66
+#: winedbg.rc:64
 msgid "Program Error Details"
 msgstr "Detalii eroare de program"
 
-#: winedbg.rc:73
+#: winedbg.rc:68
 msgid ""
 "If this problem is not present under Windows and has not been reported yet, "
 "you can save the detailed information to a file using the \"Save As\" "
-"button, then <a href=\"http://wiki.winehq.org/Bugs\">file a bug report</a> "
-"and attach that file to the report."
+"button, then <a href=\"http://www.codeweavers.com/support/tickets/enter/"
+"\">file a bug report</a> and attach that file to the report."
 msgstr ""
 
 #: winedbg.rc:38
diff -Naur wine-2.0a/po/ru.po wine-2.0b/po/ru.po
--- wine-2.0a/po/ru.po	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/po/ru.po	2017-07-11 20:37:52.000000000 +0100
@@ -390,8 +390,8 @@
 msgid "None"
 msgstr "ÐÐµÑ"
 
-#: comctl32.rc:31 cryptui.rc:230 regedit.rc:237 taskmgr.rc:434 winedbg.rc:60
-#: winedbg.rc:75 wordpad.rc:180
+#: comctl32.rc:31 cryptui.rc:230 regedit.rc:237 taskmgr.rc:434 winedbg.rc:58
+#: winedbg.rc:70 wordpad.rc:172
 msgid "Close"
 msgstr "ÐÐ°ÐºÑÑÑÑ"
 
@@ -6734,7 +6734,7 @@
 msgid "Sound Selection"
 msgstr "ÐÑÐ±Ð¾Ñ Ð·Ð²ÑÐºÐ°"
 
-#: msacm32.rc:39 winedbg.rc:76
+#: msacm32.rc:39 winedbg.rc:71
 msgid "&Save As..."
 msgstr "&Ð¡Ð¾ÑÑÐ°Ð½Ð¸ÑÑ ÐºÐ°Ðº..."
 
@@ -14056,34 +14056,36 @@
 "Ð Ð¿ÑÐ¾Ð³ÑÐ°Ð¼Ð¼Ðµ %s Ð¾Ð±Ð½Ð°ÑÑÐ¶ÐµÐ½Ð° ÑÐµÑÑÑÐ·Ð½Ð°Ñ Ð¾ÑÐ¸Ð±ÐºÐ°. ÐÑÐ¾Ð³ÑÐ°Ð¼Ð¼Ð° Ð±ÑÐ´ÐµÑ Ð·Ð°ÐºÑÑÑÐ°. "
 "ÐÑÐ¸Ð½Ð¾ÑÐ¸Ð¼ Ð¸Ð·Ð²Ð¸Ð½ÐµÐ½Ð¸Ñ Ð·Ð° Ð½ÐµÑÐ´Ð¾Ð±ÑÑÐ²Ð¾."
 
-#: winedbg.rc:58
+#: winedbg.rc:56
 msgid ""
 "This can be caused by a problem in the program or a deficiency in Wine. You "
-"may want to check the <a href=\"http://appdb.winehq.org\">Application "
-"Database</a> for tips about running this application."
+"may want to check <a href=\"http://www.codeweavers.com/compatibility/"
+"\">http://www.codeweavers.com/compatibility/</a> for tips about running this "
+"application."
 msgstr ""
 "ÐÑÐ¸Ð±ÐºÐ° Ð¼Ð¾Ð³Ð»Ð° Ð±ÑÑÑ Ð²ÑÐ·Ð²Ð°Ð½Ð° Ð¿ÑÐ¾Ð±Ð»ÐµÐ¼Ð¾Ð¹ Ð² Ð¿ÑÐ¾Ð³ÑÐ°Ð¼Ð¼Ðµ Ð¸Ð»Ð¸ Ð½ÐµÐ´Ð¾ÑÐ°Ð±Ð¾ÑÐºÐ¾Ð¹ Ð² Wine. ÐÑ "
-"Ð¼Ð¾Ð¶ÐµÑÐµ Ð¿Ð¾ÑÐµÑÐ¸ÑÑ <a href=\"http://appdb.winehq.org\">Application Database</a> "
-"Ð¸ Ð¿Ð¾Ð¸ÑÐºÐ°ÑÑ ÑÐ¾Ð²ÐµÑÑ Ð¾ Ð·Ð°Ð¿ÑÑÐºÐµ ÑÑÐ¾Ð¹ Ð¿ÑÐ¾Ð³ÑÐ°Ð¼Ð¼Ñ."
+"Ð¼Ð¾Ð¶ÐµÑÐµ Ð¿Ð¾ÑÐµÑÐ¸ÑÑ <a href=\"http://www.codeweavers.com/compatibility/\">http://"
+"www.codeweavers.com/compatibility/</a> Ð¸ Ð¿Ð¾Ð¸ÑÐºÐ°ÑÑ ÑÐ¾Ð²ÐµÑÑ Ð¾ Ð·Ð°Ð¿ÑÑÐºÐµ ÑÑÐ¾Ð¹ "
+"Ð¿ÑÐ¾Ð³ÑÐ°Ð¼Ð¼Ñ."
 
-#: winedbg.rc:61
+#: winedbg.rc:59
 msgid "Show &Details"
 msgstr "&ÐÐ¾Ð´ÑÐ¾Ð±Ð½Ð¾"
 
-#: winedbg.rc:66
+#: winedbg.rc:64
 msgid "Program Error Details"
 msgstr "ÐÐ¾Ð´ÑÐ¾Ð±Ð½Ð¾ÑÑÐ¸ Ð¾Ð± Ð¾ÑÐ¸Ð±ÐºÐµ"
 
-#: winedbg.rc:73
+#: winedbg.rc:68
 msgid ""
 "If this problem is not present under Windows and has not been reported yet, "
 "you can save the detailed information to a file using the \"Save As\" "
-"button, then <a href=\"http://wiki.winehq.org/Bugs\">file a bug report</a> "
-"and attach that file to the report."
+"button, then <a href=\"http://www.codeweavers.com/support/tickets/enter/"
+"\">file a bug report</a> and attach that file to the report."
 msgstr ""
 "ÐÑÐ»Ð¸ ÑÑÐ° Ð¿ÑÐ¾Ð±Ð»ÐµÐ¼Ð° Ð¾ÑÑÑÑÑÑÐ²ÑÐµÑ Ð² Windows Ð¸ Ð¾ Ð½ÐµÐ¹ ÐµÑÑ Ð½Ð¸ÐºÑÐ¾ Ð½Ðµ ÑÐ¾Ð¾Ð±ÑÐ¸Ð», Ð²Ñ "
 "Ð¼Ð¾Ð¶ÐµÑÐµ ÑÐ¾ÑÑÐ°Ð½Ð¸ÑÑ Ð¿Ð¾Ð´ÑÐ¾Ð±Ð½ÑÑ Ð¸Ð½ÑÐ¾ÑÐ¼Ð°ÑÐ¸Ñ Ð² ÑÐ°Ð¹Ð» Ñ Ð¿Ð¾Ð¼Ð¾ÑÑÑ ÐºÐ½Ð¾Ð¿ÐºÐ¸ Â«Ð¡Ð¾ÑÑÐ°Ð½Ð¸ÑÑ "
-"ÐºÐ°ÐºÂ», Ð·Ð°ÑÐµÐ¼ <a href=\"http://wiki.winehq.org/Bugs\">ÑÐ¾Ð¾Ð±ÑÐ¸ÑÑ Ð¾Ð± Ð¾ÑÐ¸Ð±ÐºÐµ</a> Ð¸ "
+"ÐºÐ°ÐºÂ», Ð·Ð°ÑÐµÐ¼ <a href=\"http://www.codeweavers.com/support/tickets/enter/\">ÑÐ¾Ð¾Ð±ÑÐ¸ÑÑ Ð¾Ð± Ð¾ÑÐ¸Ð±ÐºÐµ</a> Ð¸ "
 "Ð¿ÑÐ¸Ð»Ð¾Ð¶Ð¸ÑÑ ÑÑÐ¾Ñ ÑÐ°Ð¹Ð» Ðº Ð¾ÑÑÐµÑÑ."
 
 #: winedbg.rc:38
diff -Naur wine-2.0a/po/sk.po wine-2.0b/po/sk.po
--- wine-2.0a/po/sk.po	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/po/sk.po	2017-07-11 20:37:52.000000000 +0100
@@ -407,8 +407,8 @@
 msgid "None"
 msgstr "Å½iadne"
 
-#: comctl32.rc:31 cryptui.rc:230 regedit.rc:237 taskmgr.rc:434 winedbg.rc:60
-#: winedbg.rc:75 wordpad.rc:180
+#: comctl32.rc:31 cryptui.rc:230 regedit.rc:237 taskmgr.rc:434 winedbg.rc:58
+#: winedbg.rc:70 wordpad.rc:172
 msgid "Close"
 msgstr "ZavrieÅ¥"
 
@@ -6740,7 +6740,7 @@
 msgid "Sound Selection"
 msgstr ""
 
-#: msacm32.rc:39 winedbg.rc:76
+#: msacm32.rc:39 winedbg.rc:71
 #, fuzzy
 msgid "&Save As..."
 msgstr "UloÅ¾iÅ¥ ako"
@@ -13719,19 +13719,20 @@
 "sorry for the inconvenience."
 msgstr ""
 
-#: winedbg.rc:58
+#: winedbg.rc:56
 msgid ""
 "This can be caused by a problem in the program or a deficiency in Wine. You "
-"may want to check the <a href=\"http://appdb.winehq.org\">Application "
-"Database</a> for tips about running this application."
+"may want to check <a href=\"http://www.codeweavers.com/compatibility/"
+"\">http://www.codeweavers.com/compatibility/</a> for tips about running this "
+"application."
 msgstr ""
 
-#: winedbg.rc:61
+#: winedbg.rc:59
 #, fuzzy
 msgid "Show &Details"
 msgstr "&Detaily"
 
-#: winedbg.rc:66
+#: winedbg.rc:64
 #, fuzzy
 msgid "Program Error Details"
 msgstr ""
@@ -13740,12 +13741,12 @@
 "#-#-#-#-#  sk.po (Wine)  #-#-#-#-#\n"
 "&Properties"
 
-#: winedbg.rc:73
+#: winedbg.rc:68
 msgid ""
 "If this problem is not present under Windows and has not been reported yet, "
 "you can save the detailed information to a file using the \"Save As\" "
-"button, then <a href=\"http://wiki.winehq.org/Bugs\">file a bug report</a> "
-"and attach that file to the report."
+"button, then <a href=\"http://www.codeweavers.com/support/tickets/enter/"
+"\">file a bug report</a> and attach that file to the report."
 msgstr ""
 
 #: winedbg.rc:38
diff -Naur wine-2.0a/po/sl.po wine-2.0b/po/sl.po
--- wine-2.0a/po/sl.po	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/po/sl.po	2017-07-11 20:37:52.000000000 +0100
@@ -406,8 +406,8 @@
 msgid "None"
 msgstr "Brez"
 
-#: comctl32.rc:31 cryptui.rc:230 regedit.rc:237 taskmgr.rc:434 winedbg.rc:60
-#: winedbg.rc:75 wordpad.rc:180
+#: comctl32.rc:31 cryptui.rc:230 regedit.rc:237 taskmgr.rc:434 winedbg.rc:58
+#: winedbg.rc:70 wordpad.rc:172
 msgid "Close"
 msgstr "Zapri"
 
@@ -6793,7 +6793,7 @@
 msgid "Sound Selection"
 msgstr "Izbira zvoka"
 
-#: msacm32.rc:39 winedbg.rc:76
+#: msacm32.rc:39 winedbg.rc:71
 msgid "&Save As..."
 msgstr "&Shrani kot ..."
 
@@ -14286,35 +14286,36 @@
 "Program %s je naletel na resno napako in se mora zapreti. Å½al nam je za "
 "nevÅ¡eÄnosti."
 
-#: winedbg.rc:58
+#: winedbg.rc:56
 msgid ""
 "This can be caused by a problem in the program or a deficiency in Wine. You "
-"may want to check the <a href=\"http://appdb.winehq.org\">Application "
-"Database</a> for tips about running this application."
+"may want to check <a href=\"http://www.codeweavers.com/compatibility/"
+"\">http://www.codeweavers.com/compatibility/</a> for tips about running this "
+"application."
 msgstr ""
 "Napako lahko povzroÄi problem v pogramu ali pomankljivost v Wine. Poglejte v "
-"<a href=\"http://appdb.winehq.org\">Application Database</a> za nasvete "
-"glede poganjanja te aplikacije."
+"<a href=\"http://www.codeweavers.com/compatibility/\">http://www.codeweavers."
+"com/compatibility/</a> za nasvete glede poganjanja te aplikacije."
 
-#: winedbg.rc:61
+#: winedbg.rc:59
 msgid "Show &Details"
 msgstr "PokaÅ¾i &Podrobnosti"
 
-#: winedbg.rc:66
+#: winedbg.rc:64
 msgid "Program Error Details"
 msgstr "Podrobnosti napake v programu"
 
-#: winedbg.rc:73
+#: winedbg.rc:68
 msgid ""
 "If this problem is not present under Windows and has not been reported yet, "
 "you can save the detailed information to a file using the \"Save As\" "
-"button, then <a href=\"http://wiki.winehq.org/Bugs\">file a bug report</a> "
-"and attach that file to the report."
+"button, then <a href=\"http://www.codeweavers.com/support/tickets/enter/"
+"\">file a bug report</a> and attach that file to the report."
 msgstr ""
 "Äe ta teÅ¾ava ni prisotna na sistemu Windows in Å¡e ni bila prijavljena, vas "
 "prosimo, da shranite podrobnosti napake v datoteko preko gumba \"Shrani kot"
-"\", nato pa <a href=\"http://bugs.winehq.org\">prijavite napako</a> in ji "
-"priloÅ¾ite ravno ustvarjeno datoteko."
+"\", nato pa <a href=\"http://www.codeweavers.com/support/tickets/enter/"
+"\">prijavite napako</a> in ji priloÅ¾ite ravno ustvarjeno datoteko."
 
 #: winedbg.rc:38
 msgid "Wine program crash"
diff -Naur wine-2.0a/po/sr_RS@cyrillic.po wine-2.0b/po/sr_RS@cyrillic.po
--- wine-2.0a/po/sr_RS@cyrillic.po	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/po/sr_RS@cyrillic.po	2017-07-11 20:37:52.000000000 +0100
@@ -394,8 +394,8 @@
 msgid "None"
 msgstr "ÐÐ¸ÑÑÐ°"
 
-#: comctl32.rc:31 cryptui.rc:230 regedit.rc:237 taskmgr.rc:434 winedbg.rc:60
-#: winedbg.rc:75 wordpad.rc:180
+#: comctl32.rc:31 cryptui.rc:230 regedit.rc:237 taskmgr.rc:434 winedbg.rc:58
+#: winedbg.rc:70 wordpad.rc:172
 msgid "Close"
 msgstr "ÐÐ°ÑÐ²Ð¾ÑÐ¸"
 
@@ -7014,7 +7014,7 @@
 msgid "Sound Selection"
 msgstr "ÐÐ·Ð±Ð¾Ñ Ð·Ð²ÑÐºÐ°"
 
-#: msacm32.rc:39 winedbg.rc:76
+#: msacm32.rc:39 winedbg.rc:71
 msgid "&Save As..."
 msgstr "&Ð¡Ð°ÑÑÐ²Ð°Ñ ÐºÐ°Ð¾..."
 
@@ -14205,12 +14205,13 @@
 "ÐÑÐ¾Ð³ÑÐ°Ð¼ %s ÑÐµ Ð½Ð°Ð¸ÑÐ°Ð¾ Ð½Ð° Ð¾Ð·Ð±Ð¸ÑÐ°Ð½ Ð¿ÑÐ¾Ð±Ð»ÐµÐ¼ Ð¸ Ð¼Ð¾ÑÐ° Ð±Ð¸ÑÐ¸ Ð·Ð°ÑÐ²Ð¾ÑÐµÐ½. ÐÐ·Ð²Ð¸ÑÐ°Ð²Ð°Ð¼Ð¾ ÑÐµ "
 "Ð·Ð±Ð¾Ð³ Ð½ÐµÐ¿ÑÐ¸ÑÐ°ÑÐ½Ð¾ÑÑÐ¸."
 
-#: winedbg.rc:58
+#: winedbg.rc:56
 #, fuzzy
 msgid ""
 "This can be caused by a problem in the program or a deficiency in Wine. You "
-"may want to check the <a href=\"http://appdb.winehq.org\">Application "
-"Database</a> for tips about running this application."
+"may want to check <a href=\"http://www.codeweavers.com/compatibility/"
+"\">http://www.codeweavers.com/compatibility/</a> for tips about running this "
+"application."
 msgstr ""
 "Ð£Ð·ÑÐ¾Ðº Ð¾Ð²Ð¾Ð¼Ðµ Ð¼Ð¾Ð¶Ðµ Ð±Ð¸ÑÐ¸ Ð¿ÑÐ¾Ð±Ð»ÐµÐ¼ Ñ Ð¿ÑÐ¾Ð³ÑÐ°Ð¼Ñ Ð¸Ð»Ð¸ Ð½ÐµÐ´Ð¾ÑÑÐ°ÑÐ°Ðº Ñ Wine-Ñ. ÐÑÐ¾Ð²ÐµÑÐ¸ÑÐµ "
 "http://appdb.winehq.org Ð·Ð° ÑÐ°Ð²ÐµÑÐµ Ð¾ Ð¿Ð¾ÐºÑÐµÑÐ°ÑÑ Ð¾Ð²Ð¾Ð³ Ð¿ÑÐ¾Ð³ÑÐ°Ð¼Ð°.\n"
@@ -14218,22 +14219,22 @@
 "ÐÐºÐ¾ Ð¾Ð²Ð°Ñ Ð¿ÑÐ¾Ð±Ð»ÐµÐ¼ Ð½Ð¸ÑÐµ Ð¿ÑÐ¸ÑÑÑÐ°Ð½ Ð¿Ð¾Ð´ Windows-Ð¾Ð¼ Ð¸ ÑÐ¾Ñ ÑÐ²ÐµÐº Ð½Ð¸ÑÐµ Ð¿ÑÐ¸ÑÐ°Ð²ÑÐµÐ½, "
 "Ð¿ÑÐ¸ÑÐ°Ð²Ð¸ÑÐµ Ð³Ð° Ð½Ð° http://bugs.winehq.org."
 
-#: winedbg.rc:61
+#: winedbg.rc:59
 #, fuzzy
 msgid "Show &Details"
 msgstr "&ÐÐµÑÐ°ÑÐ¸"
 
-#: winedbg.rc:66
+#: winedbg.rc:64
 #, fuzzy
 msgid "Program Error Details"
 msgstr "ÐÑÐ¾Ð³ÑÐ°Ð¼ÑÐºÐ° Ð³ÑÐµÑÐºÐ°"
 
-#: winedbg.rc:73
+#: winedbg.rc:68
 msgid ""
 "If this problem is not present under Windows and has not been reported yet, "
 "you can save the detailed information to a file using the \"Save As\" "
-"button, then <a href=\"http://wiki.winehq.org/Bugs\">file a bug report</a> "
-"and attach that file to the report."
+"button, then <a href=\"http://www.codeweavers.com/support/tickets/enter/"
+"\">file a bug report</a> and attach that file to the report."
 msgstr ""
 
 #: winedbg.rc:38
diff -Naur wine-2.0a/po/sr_RS@latin.po wine-2.0b/po/sr_RS@latin.po
--- wine-2.0a/po/sr_RS@latin.po	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/po/sr_RS@latin.po	2017-07-11 20:37:52.000000000 +0100
@@ -403,8 +403,8 @@
 "#-#-#-#-#  sr_RS@latin.po (Wine)  #-#-#-#-#\n"
 "Nista"
 
-#: comctl32.rc:31 cryptui.rc:230 regedit.rc:237 taskmgr.rc:434 winedbg.rc:60
-#: winedbg.rc:75 wordpad.rc:180
+#: comctl32.rc:31 cryptui.rc:230 regedit.rc:237 taskmgr.rc:434 winedbg.rc:58
+#: winedbg.rc:70 wordpad.rc:172
 msgid "Close"
 msgstr "Zatvori"
 
@@ -7107,7 +7107,7 @@
 msgid "Sound Selection"
 msgstr "Izbor zvuka"
 
-#: msacm32.rc:39 winedbg.rc:76
+#: msacm32.rc:39 winedbg.rc:71
 msgid "&Save As..."
 msgstr "&SaÄuvaj kao..."
 
@@ -14361,12 +14361,13 @@
 "Program %s je naiÅ¡ao na ozbiljan problem i mora biti zatvoren. Izvinjavamo "
 "se zbog neprijatnosti."
 
-#: winedbg.rc:58
+#: winedbg.rc:56
 #, fuzzy
 msgid ""
 "This can be caused by a problem in the program or a deficiency in Wine. You "
-"may want to check the <a href=\"http://appdb.winehq.org\">Application "
-"Database</a> for tips about running this application."
+"may want to check <a href=\"http://www.codeweavers.com/compatibility/"
+"\">http://www.codeweavers.com/compatibility/</a> for tips about running this "
+"application."
 msgstr ""
 "Uzrok ovome moÅ¾e biti problem u programu ili nedostatak u Wine-u. Proverite "
 "http://appdb.winehq.org za savete o pokretanju ovog programa.\n"
@@ -14374,22 +14375,22 @@
 "Ako ovaj problem nije prisutan pod Windows-om i joÅ¡ uvek nije prijavljen, "
 "prijavite ga na http://bugs.winehq.org."
 
-#: winedbg.rc:61
+#: winedbg.rc:59
 #, fuzzy
 msgid "Show &Details"
 msgstr "&Detalji"
 
-#: winedbg.rc:66
+#: winedbg.rc:64
 #, fuzzy
 msgid "Program Error Details"
 msgstr "Programska greÅ¡ka"
 
-#: winedbg.rc:73
+#: winedbg.rc:68
 msgid ""
 "If this problem is not present under Windows and has not been reported yet, "
 "you can save the detailed information to a file using the \"Save As\" "
-"button, then <a href=\"http://wiki.winehq.org/Bugs\">file a bug report</a> "
-"and attach that file to the report."
+"button, then <a href=\"http://www.codeweavers.com/support/tickets/enter/"
+"\">file a bug report</a> and attach that file to the report."
 msgstr ""
 
 #: winedbg.rc:38
diff -Naur wine-2.0a/po/sv.po wine-2.0b/po/sv.po
--- wine-2.0a/po/sv.po	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/po/sv.po	2017-07-11 20:37:52.000000000 +0100
@@ -387,8 +387,8 @@
 msgid "None"
 msgstr "Ingen"
 
-#: comctl32.rc:31 cryptui.rc:230 regedit.rc:237 taskmgr.rc:434 winedbg.rc:60
-#: winedbg.rc:75 wordpad.rc:180
+#: comctl32.rc:31 cryptui.rc:230 regedit.rc:237 taskmgr.rc:434 winedbg.rc:58
+#: winedbg.rc:70 wordpad.rc:172
 msgid "Close"
 msgstr "StÃ¤ng"
 
@@ -6724,7 +6724,7 @@
 msgid "Sound Selection"
 msgstr "Ljudval"
 
-#: msacm32.rc:39 winedbg.rc:76
+#: msacm32.rc:39 winedbg.rc:71
 msgid "&Save As..."
 msgstr "&Spara som..."
 
@@ -13913,30 +13913,31 @@
 "Programmet %s har stÃ¶tt pÃ¥ ett allvarligt problem och mÃ¥ste avslutas. Vi ber "
 "om ursÃ¤kt fÃ¶r besvÃ¤ret."
 
-#: winedbg.rc:58
+#: winedbg.rc:56
 msgid ""
 "This can be caused by a problem in the program or a deficiency in Wine. You "
-"may want to check the <a href=\"http://appdb.winehq.org\">Application "
-"Database</a> for tips about running this application."
+"may want to check <a href=\"http://www.codeweavers.com/compatibility/"
+"\">http://www.codeweavers.com/compatibility/</a> for tips about running this "
+"application."
 msgstr ""
 "Detta kan ha orsakats av ett fel i programmet eller en brist i Wine. Du kan "
-"sÃ¶ka pÃ¥ <a href=\"http://appdb.winehq.org\">Application Database</a> efter "
-"tips om hur man kÃ¶r detta program."
+"sÃ¶ka pÃ¥ <a href=\"http://www.codeweavers.com/compatibility/\">http://www."
+"codeweavers.com/compatibility/</a> efter tips om hur man kÃ¶r detta program."
 
-#: winedbg.rc:61
+#: winedbg.rc:59
 msgid "Show &Details"
 msgstr "Visa &Detaljer"
 
-#: winedbg.rc:66
+#: winedbg.rc:64
 msgid "Program Error Details"
 msgstr "Detaljer om programfel"
 
-#: winedbg.rc:73
+#: winedbg.rc:68
 msgid ""
 "If this problem is not present under Windows and has not been reported yet, "
 "you can save the detailed information to a file using the \"Save As\" "
-"button, then <a href=\"http://wiki.winehq.org/Bugs\">file a bug report</a> "
-"and attach that file to the report."
+"button, then <a href=\"http://www.codeweavers.com/support/tickets/enter/"
+"\">file a bug report</a> and attach that file to the report."
 msgstr ""
 "Om denna problem inte presenterar sig i Windows och Ã¤nnu inte har "
 "rapporterats, kan du spara detaljerna till ett fil med knappen \"Spara som\" "
diff -Naur wine-2.0a/po/te.po wine-2.0b/po/te.po
--- wine-2.0a/po/te.po	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/po/te.po	2017-07-11 20:37:52.000000000 +0100
@@ -368,8 +368,8 @@
 msgid "None"
 msgstr ""
 
-#: comctl32.rc:31 cryptui.rc:230 regedit.rc:237 taskmgr.rc:434 winedbg.rc:60
-#: winedbg.rc:75 wordpad.rc:180
+#: comctl32.rc:31 cryptui.rc:230 regedit.rc:237 taskmgr.rc:434 winedbg.rc:58
+#: winedbg.rc:70 wordpad.rc:172
 msgid "Close"
 msgstr ""
 
@@ -6636,7 +6636,7 @@
 msgid "Sound Selection"
 msgstr ""
 
-#: msacm32.rc:39 winedbg.rc:76
+#: msacm32.rc:39 winedbg.rc:71
 msgid "&Save As..."
 msgstr ""
 
@@ -13378,28 +13378,29 @@
 "sorry for the inconvenience."
 msgstr ""
 
-#: winedbg.rc:58
+#: winedbg.rc:56
 msgid ""
 "This can be caused by a problem in the program or a deficiency in Wine. You "
-"may want to check the <a href=\"http://appdb.winehq.org\">Application "
-"Database</a> for tips about running this application."
+"may want to check <a href=\"http://www.codeweavers.com/compatibility/"
+"\">http://www.codeweavers.com/compatibility/</a> for tips about running this "
+"application."
 msgstr ""
 
-#: winedbg.rc:61
+#: winedbg.rc:59
 msgid "Show &Details"
 msgstr ""
 
-#: winedbg.rc:66
+#: winedbg.rc:64
 #, fuzzy
 msgid "Program Error Details"
 msgstr "à°¸à°®à°¾à°à°¾à°°à°®à± (&o)"
 
-#: winedbg.rc:73
+#: winedbg.rc:68
 msgid ""
 "If this problem is not present under Windows and has not been reported yet, "
 "you can save the detailed information to a file using the \"Save As\" "
-"button, then <a href=\"http://wiki.winehq.org/Bugs\">file a bug report</a> "
-"and attach that file to the report."
+"button, then <a href=\"http://www.codeweavers.com/support/tickets/enter/"
+"\">file a bug report</a> and attach that file to the report."
 msgstr ""
 
 #: winedbg.rc:38
diff -Naur wine-2.0a/po/th.po wine-2.0b/po/th.po
--- wine-2.0a/po/th.po	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/po/th.po	2017-07-11 20:37:52.000000000 +0100
@@ -372,8 +372,8 @@
 msgid "None"
 msgstr "à¹à¸¡à¹à¸¡à¸µà¹à¸¥à¸¢"
 
-#: comctl32.rc:31 cryptui.rc:230 regedit.rc:237 taskmgr.rc:434 winedbg.rc:60
-#: winedbg.rc:75 wordpad.rc:180
+#: comctl32.rc:31 cryptui.rc:230 regedit.rc:237 taskmgr.rc:434 winedbg.rc:58
+#: winedbg.rc:70 wordpad.rc:172
 msgid "Close"
 msgstr "à¸à¸µà¸"
 
@@ -6765,7 +6765,7 @@
 msgid "Sound Selection"
 msgstr "à¸à¹à¸²à¸¥à¸±à¸à¸à¸°à¸¥à¸; "
 
-#: msacm32.rc:39 winedbg.rc:76
+#: msacm32.rc:39 winedbg.rc:71
 #, fuzzy
 msgid "&Save As..."
 msgstr "à¸à¸±à¸à¸à¸·à¸à¹à¸à¹à¸..."
@@ -13651,29 +13651,30 @@
 "sorry for the inconvenience."
 msgstr ""
 
-#: winedbg.rc:58
+#: winedbg.rc:56
 msgid ""
 "This can be caused by a problem in the program or a deficiency in Wine. You "
-"may want to check the <a href=\"http://appdb.winehq.org\">Application "
-"Database</a> for tips about running this application."
+"may want to check <a href=\"http://www.codeweavers.com/compatibility/"
+"\">http://www.codeweavers.com/compatibility/</a> for tips about running this "
+"application."
 msgstr ""
 
-#: winedbg.rc:61
+#: winedbg.rc:59
 #, fuzzy
 msgid "Show &Details"
 msgstr "à¸£à¸²à¸¢à¸¥à¸°à¹à¸­à¸µà¸¢à¸"
 
-#: winedbg.rc:66
+#: winedbg.rc:64
 #, fuzzy
 msgid "Program Error Details"
 msgstr "à¸à¸£à¸±à¸à¹à¸à¹à¸à¸à¸²à¸¬à¸´à¸à¸²"
 
-#: winedbg.rc:73
+#: winedbg.rc:68
 msgid ""
 "If this problem is not present under Windows and has not been reported yet, "
 "you can save the detailed information to a file using the \"Save As\" "
-"button, then <a href=\"http://wiki.winehq.org/Bugs\">file a bug report</a> "
-"and attach that file to the report."
+"button, then <a href=\"http://www.codeweavers.com/support/tickets/enter/"
+"\">file a bug report</a> and attach that file to the report."
 msgstr ""
 
 #: winedbg.rc:38
diff -Naur wine-2.0a/po/tr.po wine-2.0b/po/tr.po
--- wine-2.0a/po/tr.po	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/po/tr.po	2017-07-11 20:37:52.000000000 +0100
@@ -390,8 +390,8 @@
 msgid "None"
 msgstr "HiÃ§biri"
 
-#: comctl32.rc:31 cryptui.rc:230 regedit.rc:237 taskmgr.rc:434 winedbg.rc:60
-#: winedbg.rc:75 wordpad.rc:180
+#: comctl32.rc:31 cryptui.rc:230 regedit.rc:237 taskmgr.rc:434 winedbg.rc:58
+#: winedbg.rc:70 wordpad.rc:172
 msgid "Close"
 msgstr "Kapat"
 
@@ -6728,7 +6728,7 @@
 msgid "Sound Selection"
 msgstr "Ses SeÃ§imi"
 
-#: msacm32.rc:39 winedbg.rc:76
+#: msacm32.rc:39 winedbg.rc:71
 msgid "&Save As..."
 msgstr "&FarklÄ± Kaydet..."
 
@@ -14071,30 +14071,31 @@
 "%s programÄ± ciddi bir problemle karÅÄ±laÅtÄ± ve kapatÄ±lacak. Bu durumdan "
 "dolayÄ± Ã¶zÃ¼r dileriz."
 
-#: winedbg.rc:58
+#: winedbg.rc:56
 msgid ""
 "This can be caused by a problem in the program or a deficiency in Wine. You "
-"may want to check the <a href=\"http://appdb.winehq.org\">Application "
-"Database</a> for tips about running this application."
+"may want to check <a href=\"http://www.codeweavers.com/compatibility/"
+"\">http://www.codeweavers.com/compatibility/</a> for tips about running this "
+"application."
 msgstr ""
 "Bu, programdaki veya Wine'deki bir sorundan dolayÄ± olabilir. Bu uygulamayÄ± "
 "Ã§alÄ±ÅtÄ±rma hakkÄ±nda ipuÃ§larÄ± iÃ§in <a href=\"http://appdb.winehq.org"
 "\">Uygulama VeritabanÄ±</a> sayfasÄ±nÄ± kontrol etmek isteyebilirsiniz."
 
-#: winedbg.rc:61
+#: winedbg.rc:59
 msgid "Show &Details"
 msgstr "DetaylarÄ± &GÃ¶ster"
 
-#: winedbg.rc:66
+#: winedbg.rc:64
 msgid "Program Error Details"
 msgstr "Program Hata DetaylarÄ±"
 
-#: winedbg.rc:73
+#: winedbg.rc:68
 msgid ""
 "If this problem is not present under Windows and has not been reported yet, "
 "you can save the detailed information to a file using the \"Save As\" "
-"button, then <a href=\"http://wiki.winehq.org/Bugs\">file a bug report</a> "
-"and attach that file to the report."
+"button, then <a href=\"http://www.codeweavers.com/support/tickets/enter/"
+"\">file a bug report</a> and attach that file to the report."
 msgstr ""
 "EÄer bu problem Windows'ta yoksa ve henÃ¼z bildirilmemiÅse, \"FarklÄ± Kaydet\" "
 "dÃ¼Ämesi kullanarak ayrÄ±ntÄ±lÄ± bilgiyi bir dosyaya kaydedebilir; ardÄ±ndan bu "
diff -Naur wine-2.0a/po/uk.po wine-2.0b/po/uk.po
--- wine-2.0a/po/uk.po	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/po/uk.po	2017-07-11 20:37:52.000000000 +0100
@@ -385,8 +385,8 @@
 msgid "None"
 msgstr "ÐÐµÐ¼Ð°Ñ"
 
-#: comctl32.rc:31 cryptui.rc:230 regedit.rc:237 taskmgr.rc:434 winedbg.rc:60
-#: winedbg.rc:75 wordpad.rc:180
+#: comctl32.rc:31 cryptui.rc:230 regedit.rc:237 taskmgr.rc:434 winedbg.rc:58
+#: winedbg.rc:70 wordpad.rc:172
 msgid "Close"
 msgstr "ÐÐ°ÐºÑÐ¸ÑÐ¸"
 
@@ -6738,7 +6738,7 @@
 msgid "Sound Selection"
 msgstr "ÐÐ¸Ð±ÑÑ Ð·Ð²ÑÐºÑ"
 
-#: msacm32.rc:39 winedbg.rc:76
+#: msacm32.rc:39 winedbg.rc:71
 msgid "&Save As..."
 msgstr "ÐÐ±ÐµÑÐµÐ³ÑÐ¸ &ÑÐº..."
 
@@ -14142,30 +14142,31 @@
 "Ð Ð¿ÑÐ¾Ð³ÑÐ°Ð¼Ñ %s ÑÑÐ°Ð»Ð°ÑÑ ÑÐµÑÐ¹Ð¾Ð·Ð½Ð° Ð¿Ð¾Ð¼Ð¸Ð»ÐºÐ°. ÐÑÐ¾Ð³ÑÐ°Ð¼Ð° Ð¿Ð¾Ð²Ð¸Ð½Ð½Ð° Ð±ÑÑÐ¸ Ð·Ð°ÐºÑÐ¸ÑÐ°. "
 "ÐÐ¸Ð±Ð°ÑÑÐµ Ð·Ð° Ð½ÐµÐ·ÑÑÑÐ½Ð¾ÑÑÑ."
 
-#: winedbg.rc:58
+#: winedbg.rc:56
 msgid ""
 "This can be caused by a problem in the program or a deficiency in Wine. You "
-"may want to check the <a href=\"http://appdb.winehq.org\">Application "
-"Database</a> for tips about running this application."
+"may want to check <a href=\"http://www.codeweavers.com/compatibility/"
+"\">http://www.codeweavers.com/compatibility/</a> for tips about running this "
+"application."
 msgstr ""
 "Ð¦Ðµ Ð¼Ð¾Ð³Ð»Ð¾ Ð±ÑÑÐ¸ Ð²Ð¸ÐºÐ»Ð¸ÐºÐ°Ð½Ðµ Ð¿ÑÐ¾Ð±Ð»ÐµÐ¼Ð¾Ñ Ð² Ð¿ÑÐ¾Ð³ÑÐ°Ð¼Ñ Ð°Ð±Ð¾ Ð½ÐµÐ´Ð¾ÑÐ¾Ð±ÐºÐ¾Ñ Ð² Wine. ÐÐ¸ "
 "Ð¼Ð¾Ð¶ÐµÑÐµ Ð²ÑÐ´Ð²ÑÐ´Ð°ÑÐ¸ <a href=\"http://appdb.winehq.org\">ÐÐ°Ð·Ñ Ð´Ð°Ð½Ð¸Ñ Ð¿ÑÐ¾Ð³ÑÐ°Ð¼</a> "
 "ÑÐ° Ð¿Ð¾ÑÑÐºÐ°ÑÐ¸ Ð¿Ð¾ÑÐ°Ð´Ð¸ ÑÐ¾Ð´Ð¾ Ð·Ð°Ð¿ÑÑÐºÑ ÑÑÑÑ Ð¿ÑÐ¾Ð³ÑÐ°Ð¼Ð¸."
 
-#: winedbg.rc:61
+#: winedbg.rc:59
 msgid "Show &Details"
 msgstr "&ÐÐµÑÐ°Ð»ÑÐ½Ð¾"
 
-#: winedbg.rc:66
+#: winedbg.rc:64
 msgid "Program Error Details"
 msgstr "ÐÐ°Ð½Ñ Ð¿ÑÐ¾ Ð¿Ð¾Ð¼Ð¸Ð»ÐºÑ Ð¿ÑÐ¾Ð³ÑÐ°Ð¼Ð¸"
 
-#: winedbg.rc:73
+#: winedbg.rc:68
 msgid ""
 "If this problem is not present under Windows and has not been reported yet, "
 "you can save the detailed information to a file using the \"Save As\" "
-"button, then <a href=\"http://wiki.winehq.org/Bugs\">file a bug report</a> "
-"and attach that file to the report."
+"button, then <a href=\"http://www.codeweavers.com/support/tickets/enter/"
+"\">file a bug report</a> and attach that file to the report."
 msgstr ""
 "Ð¯ÐºÑÐ¾ ÑÑ Ð¿ÑÐ¾Ð±Ð»ÐµÐ¼Ð° Ð²ÑÐ´ÑÑÑÐ½Ñ Ð·-Ð¿ÑÐ´ Windows, Ñ Ð¿ÑÐ¾ Ð½ÐµÑ ÑÐµ Ð½Ðµ Ð¿Ð¾Ð²ÑÐ´Ð¾Ð¼Ð»ÐµÐ½Ð¾, ÐÐ¸ "
 "Ð¼Ð¾Ð¶ÐµÑÐµ Ð·Ð±ÐµÑÐµÐ³ÑÐ¸ Ð´ÐµÑÐ°Ð»ÑÐ½Ñ ÑÐ½ÑÐ¾ÑÐ¼Ð°ÑÑÑ Ñ ÑÐ°Ð¹Ð», Ð²Ð¸ÐºÐ¾ÑÐ¸ÑÑÐ¾Ð²ÑÑÑÐ¸ ÐºÐ½Ð¾Ð¿ÐºÑ \"Save As"
diff -Naur wine-2.0a/po/wa.po wine-2.0b/po/wa.po
--- wine-2.0a/po/wa.po	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/po/wa.po	2017-07-11 20:37:52.000000000 +0100
@@ -379,8 +379,8 @@
 msgid "None"
 msgstr ""
 
-#: comctl32.rc:31 cryptui.rc:230 regedit.rc:237 taskmgr.rc:434 winedbg.rc:60
-#: winedbg.rc:75 wordpad.rc:180
+#: comctl32.rc:31 cryptui.rc:230 regedit.rc:237 taskmgr.rc:434 winedbg.rc:58
+#: winedbg.rc:70 wordpad.rc:172
 msgid "Close"
 msgstr ""
 
@@ -6715,7 +6715,7 @@
 msgid "Sound Selection"
 msgstr ""
 
-#: msacm32.rc:39 winedbg.rc:76
+#: msacm32.rc:39 winedbg.rc:71
 #, fuzzy
 msgid "&Save As..."
 msgstr "Schaper Ã¨t r&lomer..."
@@ -13555,28 +13555,29 @@
 "sorry for the inconvenience."
 msgstr ""
 
-#: winedbg.rc:58
+#: winedbg.rc:56
 msgid ""
 "This can be caused by a problem in the program or a deficiency in Wine. You "
-"may want to check the <a href=\"http://appdb.winehq.org\">Application "
-"Database</a> for tips about running this application."
+"may want to check <a href=\"http://www.codeweavers.com/compatibility/"
+"\">http://www.codeweavers.com/compatibility/</a> for tips about running this "
+"application."
 msgstr ""
 
-#: winedbg.rc:61
+#: winedbg.rc:59
 msgid "Show &Details"
 msgstr ""
 
-#: winedbg.rc:66
+#: winedbg.rc:64
 #, fuzzy
 msgid "Program Error Details"
 msgstr "&PropietÃ©s"
 
-#: winedbg.rc:73
+#: winedbg.rc:68
 msgid ""
 "If this problem is not present under Windows and has not been reported yet, "
 "you can save the detailed information to a file using the \"Save As\" "
-"button, then <a href=\"http://wiki.winehq.org/Bugs\">file a bug report</a> "
-"and attach that file to the report."
+"button, then <a href=\"http://www.codeweavers.com/support/tickets/enter/"
+"\">file a bug report</a> and attach that file to the report."
 msgstr ""
 
 #: winedbg.rc:38
diff -Naur wine-2.0a/po/wine.pot wine-2.0b/po/wine.pot
--- wine-2.0a/po/wine.pot	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/po/wine.pot	2017-07-11 20:37:52.000000000 +0100
@@ -361,8 +361,8 @@
 msgid "None"
 msgstr ""
 
-#: comctl32.rc:31 cryptui.rc:230 regedit.rc:237 taskmgr.rc:434 winedbg.rc:60
-#: winedbg.rc:75 wordpad.rc:180
+#: comctl32.rc:31 cryptui.rc:230 regedit.rc:237 taskmgr.rc:434 winedbg.rc:58
+#: winedbg.rc:70 wordpad.rc:172
 msgid "Close"
 msgstr ""
 
@@ -6595,7 +6595,7 @@
 msgid "Sound Selection"
 msgstr ""
 
-#: msacm32.rc:39 winedbg.rc:76
+#: msacm32.rc:39 winedbg.rc:71
 msgid "&Save As..."
 msgstr ""
 
@@ -13307,27 +13307,28 @@
 "sorry for the inconvenience."
 msgstr ""
 
-#: winedbg.rc:58
+#: winedbg.rc:56
 msgid ""
 "This can be caused by a problem in the program or a deficiency in Wine. You "
-"may want to check the <a href=\"http://appdb.winehq.org\">Application "
-"Database</a> for tips about running this application."
+"may want to check <a href=\"http://www.codeweavers.com/compatibility/"
+"\">http://www.codeweavers.com/compatibility/</a> for tips about running this "
+"application."
 msgstr ""
 
-#: winedbg.rc:61
+#: winedbg.rc:59
 msgid "Show &Details"
 msgstr ""
 
-#: winedbg.rc:66
+#: winedbg.rc:64
 msgid "Program Error Details"
 msgstr ""
 
-#: winedbg.rc:73
+#: winedbg.rc:68
 msgid ""
 "If this problem is not present under Windows and has not been reported yet, "
 "you can save the detailed information to a file using the \"Save As\" "
-"button, then <a href=\"http://wiki.winehq.org/Bugs\">file a bug report</a> "
-"and attach that file to the report."
+"button, then <a href=\"http://www.codeweavers.com/support/tickets/enter/"
+"\">file a bug report</a> and attach that file to the report."
 msgstr ""
 
 #: winedbg.rc:38
diff -Naur wine-2.0a/po/zh_CN.po wine-2.0b/po/zh_CN.po
--- wine-2.0a/po/zh_CN.po	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/po/zh_CN.po	2017-07-11 20:37:52.000000000 +0100
@@ -374,8 +374,8 @@
 msgid "None"
 msgstr "æ "
 
-#: comctl32.rc:31 cryptui.rc:230 regedit.rc:237 taskmgr.rc:434 winedbg.rc:60
-#: winedbg.rc:75 wordpad.rc:180
+#: comctl32.rc:31 cryptui.rc:230 regedit.rc:237 taskmgr.rc:434 winedbg.rc:58
+#: winedbg.rc:70 wordpad.rc:172
 msgid "Close"
 msgstr "å³é­"
 
@@ -6671,7 +6671,7 @@
 msgid "Sound Selection"
 msgstr "å£°é³éæ©"
 
-#: msacm32.rc:39 winedbg.rc:76
+#: msacm32.rc:39 winedbg.rc:71
 msgid "&Save As..."
 msgstr "ä¿å­ä¸º(&S)â¦"
 
@@ -13812,29 +13812,30 @@
 "sorry for the inconvenience."
 msgstr "ç¨åº %s éå°ä¸¥éçé®é¢éè¦å³é­ãæä»¬å¯¹æ­¤é æçä¸ä¾¿è¡¨ç¤ºæ±æ­ã"
 
-#: winedbg.rc:58
+#: winedbg.rc:56
 msgid ""
 "This can be caused by a problem in the program or a deficiency in Wine. You "
-"may want to check the <a href=\"http://appdb.winehq.org\">Application "
-"Database</a> for tips about running this application."
+"may want to check <a href=\"http://www.codeweavers.com/compatibility/"
+"\">http://www.codeweavers.com/compatibility/</a> for tips about running this "
+"application."
 msgstr ""
 "è¿å¯è½æ¯ç±ç¨åºçé®é¢æè Wine çç¼ºé·é æçãä½ å¯è½éè¦æ¥ç <a href=\"http://"
 "appdb.winehq.org\">Application Databa</a> æ¥è·åè¿è¡è¯¥åºç¨çç¸å³æå·§ã"
 
-#: winedbg.rc:61
+#: winedbg.rc:59
 msgid "Show &Details"
 msgstr "è¯¦ç»ä¿¡æ¯ (&D)"
 
-#: winedbg.rc:66
+#: winedbg.rc:64
 msgid "Program Error Details"
 msgstr "ç¨åºéè¯¯è¯¦æ"
 
-#: winedbg.rc:73
+#: winedbg.rc:68
 msgid ""
 "If this problem is not present under Windows and has not been reported yet, "
 "you can save the detailed information to a file using the \"Save As\" "
-"button, then <a href=\"http://wiki.winehq.org/Bugs\">file a bug report</a> "
-"and attach that file to the report."
+"button, then <a href=\"http://www.codeweavers.com/support/tickets/enter/"
+"\">file a bug report</a> and attach that file to the report."
 msgstr ""
 "è¥è¯¥é®é¢å¨ Windows ä¸ä¼åºç°å¹¶ä¸æªæ¾è¢«æ¥åè¿ï¼æ¨å¯ä»¥ä½¿ç¨âå¦å­ä¸ºâæé®å°è¯¦ç»ä¿¡æ¯"
 "ä¿å­ä¸ºä¸ä¸ªæä»¶ï¼ç¶å<a href=\"http://wiki.winehq.org/Bugs\">æ°å»ºä¸ä¸ªéè¯¯æ¥å"
diff -Naur wine-2.0a/po/zh_TW.po wine-2.0b/po/zh_TW.po
--- wine-2.0a/po/zh_TW.po	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/po/zh_TW.po	2017-07-11 20:37:52.000000000 +0100
@@ -377,8 +377,8 @@
 msgid "None"
 msgstr "ç¡"
 
-#: comctl32.rc:31 cryptui.rc:230 regedit.rc:237 taskmgr.rc:434 winedbg.rc:60
-#: winedbg.rc:75 wordpad.rc:180
+#: comctl32.rc:31 cryptui.rc:230 regedit.rc:237 taskmgr.rc:434 winedbg.rc:58
+#: winedbg.rc:70 wordpad.rc:172
 msgid "Close"
 msgstr "éé"
 
@@ -6701,7 +6701,7 @@
 msgid "Sound Selection"
 msgstr "è²é³é¸æ"
 
-#: msacm32.rc:39 winedbg.rc:76
+#: msacm32.rc:39 winedbg.rc:71
 msgid "&Save As..."
 msgstr "å¦å­çº(&S)..."
 
@@ -14177,29 +14177,30 @@
 "sorry for the inconvenience."
 msgstr "ç¨å¼ %s éå°äºå´éçåé¡èéè¦ééãæåå°æ¼é æçä¸ä¾¿æå°æ±æ­ã"
 
-#: winedbg.rc:58
+#: winedbg.rc:56
 msgid ""
 "This can be caused by a problem in the program or a deficiency in Wine. You "
-"may want to check the <a href=\"http://appdb.winehq.org\">Application "
-"Database</a> for tips about running this application."
+"may want to check <a href=\"http://www.codeweavers.com/compatibility/"
+"\">http://www.codeweavers.com/compatibility/</a> for tips about running this "
+"application."
 msgstr ""
 "éåå¯è½æ¯ç± Wine ä¸­çç¨å¼åé¡æç¼ºå¤±æé æãæ¨å¯è½è¦æª¢æ¥<a href=\"http://"
 "appdb.winehq.org\">æç¨ç¨å¼è³æåº«</a>ä»¥ç²å¾éæ¼å·è¡éåæç¨ç¨å¼çç¥è¨£ã"
 
-#: winedbg.rc:61
+#: winedbg.rc:59
 msgid "Show &Details"
 msgstr "é¡¯ç¤ºè©³ç´°è³è¨(&D)"
 
-#: winedbg.rc:66
+#: winedbg.rc:64
 msgid "Program Error Details"
 msgstr "ç¨å¼é¯èª¤è©³ç´°è³è¨"
 
-#: winedbg.rc:73
+#: winedbg.rc:68
 msgid ""
 "If this problem is not present under Windows and has not been reported yet, "
 "you can save the detailed information to a file using the \"Save As\" "
-"button, then <a href=\"http://wiki.winehq.org/Bugs\">file a bug report</a> "
-"and attach that file to the report."
+"button, then <a href=\"http://www.codeweavers.com/support/tickets/enter/"
+"\">file a bug report</a> and attach that file to the report."
 msgstr ""
 "å¦æéååé¡å¨ Windows ä¹ä¸ä¸æåºç¾ä¸æªæ¾è¢«å ±åï¼æ¨å¯ä»¥ä½¿ç¨ãå¦å­æ°æªã æé"
 "å°è©³ç´°çè³è¨å²å­å°æªæ¡ï¼ç¶å¾<a href=\"http://wiki.winehq.org/Bugs\">ç¼éé¯èª¤"
diff -Naur wine-2.0a/programs/arp/main.c wine-2.0b/programs/arp/main.c
--- wine-2.0a/programs/arp/main.c	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/programs/arp/main.c	2017-07-11 20:37:52.000000000 +0100
@@ -16,10 +16,26 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  */
 
+#include <windows.h>
 #include "wine/debug.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(arp);
 
+static int printA(const char *msgA)
+{
+    DWORD len;
+    DWORD count, ret;
+
+    len = lstrlenA(msgA);
+    ret = WriteConsoleA(GetStdHandle(STD_OUTPUT_HANDLE), msgA, len, &count, NULL);
+    if (!ret)
+    {
+        WriteFile(GetStdHandle(STD_OUTPUT_HANDLE), msgA, len, &count, FALSE);
+    }
+
+    return count;
+}
+
 int wmain(int argc, WCHAR *argv[])
 {
     int i;
@@ -29,5 +45,7 @@
         WINE_FIXME(" %s", wine_dbgstr_w(argv[i]));
     WINE_FIXME("\n");
 
+    printA("\n");
+
     return 0;
 }
diff -Naur wine-2.0a/programs/explorer/explorer.c wine-2.0b/programs/explorer/explorer.c
--- wine-2.0a/programs/explorer/explorer.c	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/programs/explorer/explorer.c	2017-07-11 20:37:52.000000000 +0100
@@ -20,6 +20,9 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  */
 
+#include <stdio.h>
+#include <unistd.h>
+
 #define COBJMACROS
 
 #include "wine/unicode.h"
@@ -593,9 +596,27 @@
 {
     IShellFolder* desktop,*folder;
     LPITEMIDLIST root_pidl;
+#ifdef __ANDROID__
+    ITEMIDLIST *favorites_pidl;
+#endif
     HRESULT hres;
 
     SHGetDesktopFolder(&desktop);
+#ifdef __ANDROID__
+    hres = SHGetSpecialFolderLocation(NULL, CSIDL_FAVORITES, &favorites_pidl);
+    if (SUCCEEDED(hres))
+    {
+        hres = IShellFolder_BindToObject(desktop, favorites_pidl, NULL,
+                                         &IID_IShellFolder, (void **)&folder);
+        CoTaskMemFree(favorites_pidl);
+        if (SUCCEEDED(hres))
+        {
+            IShellFolder_Release(desktop);
+            return folder;
+        }
+    }
+#endif
+
     if (!params->root[0])
     {
         return desktop;
@@ -745,6 +766,25 @@
     INITCOMMONCONTROLSEX init_info;
 
     memset(&parameters,0,sizeof(parameters));
+
+    /*  CodeWeavers-specific hack:  We need to exclude ourselves
+        from the winewrapper's wait-children process.  So we'll
+        close the wait-children pipe if it is defined.  */
+    {
+        char *waitchild_envstring;
+        unsigned int waitchild_pipeid;
+        waitchild_envstring = getenv("WINE_WAIT_CHILD_PIPE");
+        if (waitchild_envstring)
+        {
+            waitchild_pipeid = atoi(waitchild_envstring);
+            if (waitchild_pipeid)
+            { 
+                close(waitchild_pipeid);
+            }
+            unsetenv("WINE_WAIT_CHILD_PIPE");
+        }
+    }
+
     explorer_hInstance = hinstance;
     parse_command_line(cmdline,&parameters);
     hres = OleInitialize(NULL);
diff -Naur wine-2.0a/programs/iexplore/iexplore.inf wine-2.0b/programs/iexplore/iexplore.inf
--- wine-2.0a/programs/iexplore/iexplore.inf	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/programs/iexplore/iexplore.inf	2017-07-11 20:37:52.000000000 +0100
@@ -37,6 +37,8 @@
 HKLM,"Software\Microsoft\Internet Explorer","Build",,"98112"
 HKLM,"Software\Microsoft\Internet Explorer","Version",,"9.0.8112.16421"
 HKLM,"Software\Microsoft\Internet Explorer","W2kVersion",,"9.0.8112.16421"
+HKLM,"Software\Microsoft\Windows\CurrentVersion\Uninstall\CXHTML","DisplayName",,"CrossOver HTML engine"
+HKLM,"Software\Microsoft\Windows\CurrentVersion\Uninstall\CXHTML","UninstallString",,"iexplore -unregserver"
 
 
 [Strings]
diff -Naur wine-2.0a/programs/taskmgr/taskmgr.c wine-2.0b/programs/taskmgr/taskmgr.c
--- wine-2.0a/programs/taskmgr/taskmgr.c	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/programs/taskmgr/taskmgr.c	2017-07-11 20:37:52.000000000 +0100
@@ -379,9 +379,9 @@
     TaskManagerSettings.ShowProcessesFromAllUsers = FALSE; /* Server-only? */
     TaskManagerSettings.Column_ImageName = TRUE;
     TaskManagerSettings.Column_PID = TRUE;
-    TaskManagerSettings.Column_CPUUsage = TRUE;
-    TaskManagerSettings.Column_CPUTime = TRUE;
-    TaskManagerSettings.Column_MemoryUsage = TRUE;
+    TaskManagerSettings.Column_CPUUsage = FALSE;
+    TaskManagerSettings.Column_CPUTime = FALSE;
+    TaskManagerSettings.Column_MemoryUsage = FALSE;
     TaskManagerSettings.Column_MemoryUsageDelta = FALSE;
     TaskManagerSettings.Column_PeakMemoryUsage = FALSE;
     TaskManagerSettings.Column_PageFaults = FALSE;
diff -Naur wine-2.0a/programs/wineboot/shutdown.c wine-2.0b/programs/wineboot/shutdown.c
--- wine-2.0a/programs/wineboot/shutdown.c	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/programs/wineboot/shutdown.c	2017-07-11 20:37:52.000000000 +0100
@@ -23,7 +23,7 @@
 #include "winbase.h"
 #include "winuser.h"
 #include "tlhelp32.h"
-
+#include "wine/unicode.h"
 #include "wine/debug.h"
 
 #include "resource.h"
@@ -290,7 +290,8 @@
     /* Check whether the app quit on its own */
     ret = WaitForSingleObject( process_handle, 0 );
     CloseHandle( process_handle );
-    if (ret == WAIT_TIMEOUT)
+    /* CODEWEAVERS HACK: avoid killing winewrapper, other processes will be killed in kill_processes */
+    if (0 && ret == WAIT_TIMEOUT)
     {
         /* If not, it returned from all WM_ENDSESSION and is finished cleaning
          * up, so we can safely kill the process. */
@@ -389,8 +390,12 @@
         process.dwSize = sizeof(process);
         for (res = Process32FirstW( snapshot, &process ); res; res = Process32NextW( snapshot, &process ))
         {
+            static const WCHAR winewrapperW[] = {'w','i','n','e','w','r','a','p','p','e','r',0};
             if (process.th32ProcessID == GetCurrentProcessId()) continue;
             if (process.th32ProcessID == desktop_pid) continue;
+            /* CODEWEAVERS HACK: don't kill winewrapper so end-of-installation
+             * detection works properly */
+            if (strstrW( process.szExeFile, winewrapperW )) continue;
             WINE_TRACE("killing process %04x %s\n",
                        process.th32ProcessID, wine_dbgstr_w(process.szExeFile) );
             if (!(handle = OpenProcess( PROCESS_TERMINATE, FALSE, process.th32ProcessID )))
diff -Naur wine-2.0a/programs/wineboot/wineboot.c wine-2.0b/programs/wineboot/wineboot.c
--- wine-2.0a/programs/wineboot/wineboot.c	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/programs/wineboot/wineboot.c	2017-07-11 20:37:52.000000000 +0100
@@ -976,6 +976,20 @@
     strcatW( buffer, inf );
     MultiByteToWideChar( CP_UNIXCP, 0, inf_path, -1, buffer + strlenW(buffer), inf_len );
 
+    if (1)
+    {
+        /* CROSSOVER HACK bug 7736. Do prefix initialization in the root desktop. */
+        static WCHAR root[] = {'r','o','o','t',0};
+        HDESK desktop;
+
+        desktop = CreateDesktopW(root, NULL, NULL, 0, GENERIC_ALL, NULL);
+        if (desktop)
+        {
+            SetThreadDesktop(desktop);
+            CloseHandle(desktop);
+        }
+    }
+
     if (CreateProcessW( app, buffer, NULL, NULL, FALSE, 0, NULL, NULL, &si, &pi ))
         CloseHandle( pi.hThread );
     else
@@ -985,6 +999,42 @@
     return pi.hProcess;
 }
 
+/* ---------------------------------------------------------------
+**   This function is a CrossOver HACK for 9411 / 8979.
+** --------------------------------------------------------------- */
+static char* setup_dll_overrides(void)
+{
+    /* See CXBT.pm for reference */
+    static char overrides[] = "shdocvw=b;*iexplore.exe=b;advpack=b;atl=b;oleaut32=b;rpcrt4=b";
+    char* old_dlloverrides;
+    HANDLE hFile;
+
+    /* Save the original dll overrides so we can restore them after running
+     * rundll32.
+     */
+    old_dlloverrides = getenv("WINEDLLOVERRIDES");
+    if (old_dlloverrides)
+        old_dlloverrides = strdup(old_dlloverrides);
+
+    /* Check whether shdocvw is usable */
+    hFile = CreateFileA("c:/windows/system32/shdocvw.dll", FILE_READ_DATA,
+                        FILE_SHARE_READ | FILE_SHARE_WRITE,
+                        NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
+    if (hFile != INVALID_HANDLE_VALUE)
+    {
+        char buf[0x40+20];
+        if (ReadFile(hFile, buf, sizeof(buf), NULL, NULL))
+        {
+            if (strncmp(buf+0x40, "Wine placeholder DLL", 20) != 0)
+                overrides[8] = 'd';
+        }
+        CloseHandle(hFile);
+    }
+    WINE_TRACE("for rundll32: WINEDLLOVERRIDES=%s\n", overrides);
+    setenv("WINEDLLOVERRIDES", overrides, 1);
+    return old_dlloverrides;
+}
+
 /* execute rundll32 on the wine.inf file if necessary */
 static void update_wineprefix( BOOL force )
 {
@@ -1011,10 +1061,12 @@
     {
         HANDLE process;
         DWORD count = 0;
+        char* old_dlloverrides = setup_dll_overrides();
 
         if ((process = start_rundll32( inf_path, FALSE )))
         {
-            HWND hwnd = show_wait_window();
+            /* HACK: Disable the wait window as it is deemed confusing */
+            HWND hwnd = 1 ? NULL : show_wait_window();
             for (;;)
             {
                 MSG msg;
@@ -1028,7 +1080,14 @@
             }
             DestroyWindow( hwnd );
         }
-        WINE_MESSAGE( "wine: configuration in '%s' has been updated.\n", config_dir );
+        WINE_TRACE( "wine: configuration in '%s' has been updated.\n", config_dir );
+        if (old_dlloverrides)
+        {
+            setenv("WINEDLLOVERRIDES", old_dlloverrides, 1);
+            free(old_dlloverrides);
+        }
+        else
+            unsetenv("WINEDLLOVERRIDES");
     }
 
 done:
@@ -1244,10 +1303,34 @@
         ProcessRunKeys( HKEY_LOCAL_MACHINE, RunServicesW, FALSE, FALSE );
         start_services_process();
     }
-    if (init || update) update_wineprefix( update );
+
+    if (end_session || kill || restart) /* CodeWeavers hack: let reboot.exe do the reboot processing */
+    {
+        static const WCHAR rebootW[] = { '\\','r','e','b','o','o','t','.','e','x','e',0 };
+        WCHAR cmdline[MAX_PATH + sizeof(rebootW)/sizeof(WCHAR)];
+        PROCESS_INFORMATION pi;
+        STARTUPINFOW si;
+
+        GetSystemDirectoryW( cmdline, MAX_PATH );
+        lstrcatW( cmdline, rebootW );
+        memset( &si, 0, sizeof si );
+        si.cb = sizeof si;
+        if (CreateProcessW( NULL, cmdline, NULL, NULL, FALSE, 0, NULL, NULL, &si, &pi ))
+        {
+            WaitForSingleObject( pi.hProcess, INFINITE );
+            CloseHandle( pi.hProcess );
+            CloseHandle( pi.hThread );
+            goto done;
+        }
+        WINE_ERR("Failed to start reboot\n");
+    }
 
     create_volatile_environment_registry_key();
 
+    if (init || update) update_wineprefix( update );
+
+    goto done;  /* CodeWeavers hack: reboot.exe should have handled these already */
+
     ProcessRunKeys( HKEY_LOCAL_MACHINE, RunOnceW, TRUE, TRUE );
 
     if (!init && !restart)
@@ -1257,6 +1340,7 @@
         ProcessStartupItems();
     }
 
+done:
     WINE_TRACE("Operation done\n");
 
     SetEvent( event );
diff -Naur wine-2.0a/programs/winebrowser/main.c wine-2.0b/programs/winebrowser/main.c
--- wine-2.0a/programs/winebrowser/main.c	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/programs/winebrowser/main.c	2017-07-11 20:37:52.000000000 +0100
@@ -125,7 +125,8 @@
         { '/','u','s','r','/','b','i','n','/','o','p','e','n',0,0 };
 #else
     static const WCHAR defaultbrowsers[] =
-        {'x','d','g','-','o','p','e','n',0,
+        {'l','a','u','n','c','h','u','r','l',0,
+         'x','d','g','-','o','p','e','n',0,
          'f','i','r','e','f','o','x',0,
          'k','o','n','q','u','e','r','o','r',0,
          'm','o','z','i','l','l','a',0,
diff -Naur wine-2.0a/programs/winedbg/Makefile.in wine-2.0b/programs/winedbg/Makefile.in
--- wine-2.0a/programs/winedbg/Makefile.in	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/programs/winedbg/Makefile.in	2017-07-11 20:37:52.000000000 +0100
@@ -3,6 +3,7 @@
 IMPORTS   = psapi dbghelp advapi32
 DELAYIMPORTS = comdlg32 shell32 comctl32 user32 gdi32
 EXTRALIBS = $(POLL_LIBS)
+EXTRAINCL = -I$(top_srcdir)/..
 
 C_SRCS = \
 	be_arm.c \
diff -Naur wine-2.0a/programs/winedbg/winedbg.rc wine-2.0b/programs/winedbg/winedbg.rc
--- wine-2.0a/programs/winedbg/winedbg.rc	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/programs/winedbg/winedbg.rc	2017-07-11 20:37:52.000000000 +0100
@@ -52,9 +52,7 @@
     LTEXT           "The program %s has encountered a serious problem and needs \
                     to close. We are sorry for the inconvenience.",
                     IDC_STATIC_TXT1,27,10,224,30
-    CONTROL         "This can be caused by a problem in the program or a deficiency in Wine. \
-                    You may want to check the <a href=\"http://appdb.winehq.org\">Application Database</a> \
-                    for tips about running this application.",
+    CONTROL         WINDEBUG_WHAT_HAPPENED_MESSAGE,
                     IDC_STATIC_TXT2,"SysLink",0,27,60,224,100
     DEFPUSHBUTTON   "Close", IDOK, 205, 151, 60, 16, WS_TABSTOP
     PUSHBUTTON      "Show &Details", ID_DETAILS, 140, 151, 60, 16, WS_TABSTOP
@@ -66,10 +64,7 @@
 FONT 8, "MS Shell Dlg"
 BEGIN
     EDITTEXT        IDC_CRASH_TXT, 4, 4, 392, 272, ES_MULTILINE | ES_READONLY | WS_HSCROLL | WS_VSCROLL, WS_TABSTOP
-    CONTROL         "If this problem is not present under Windows and has not been reported yet, \
-                     you can save the detailed information to a file using the \"Save As\" button, \
-                     then <a href=\"http://wiki.winehq.org/Bugs\">file a bug report</a> \
-                     and attach that file to the report.",
+    CONTROL         WINDEBUG_USER_SUGGESTION_MESSAGE,
                     IDC_STATIC_TXT2,"SysLink",0,6,285,388,32
     DEFPUSHBUTTON   "Close", IDOK, 326, 320, 70, 16, WS_TABSTOP
     PUSHBUTTON      "&Save As...", ID_SAVEAS, 252, 320, 70, 16, WS_TABSTOP
diff -Naur wine-2.0a/programs/winemenubuilder/cxmenu.c wine-2.0b/programs/winemenubuilder/cxmenu.c
--- wine-2.0a/programs/winemenubuilder/cxmenu.c	1970-01-01 01:00:00.000000000 +0100
+++ wine-2.0b/programs/winemenubuilder/cxmenu.c	2017-07-11 20:37:52.000000000 +0100
@@ -0,0 +1,446 @@
+/*
+ * Invoke the CrossOver menu management scripts.
+ *
+ * Copyright 2012 Francois Gouget
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include "config.h"
+#include "wine/port.h"
+
+#include <stdio.h>
+
+#define COBJMACROS
+
+#include <windows.h>
+#include <shlobj.h>
+#include <shlwapi.h>
+#include <errno.h>
+#include "wine/debug.h"
+#include "cxmenu.h"
+
+
+WINE_DEFAULT_DEBUG_CHANNEL(menubuilder);
+
+
+int cx_mode = 1;
+int cx_dump_menus = 0;
+FILE *cx_menu_file = NULL;
+
+#ifdef __ANDROID__
+int cx_write_to_file = 1;
+#else
+int cx_write_to_file = 0;
+#endif
+
+
+/*
+ * Functions to invoke the CrossOver menu management scripts.
+ */
+
+static int cx_wineshelllink(const char* link, int is_desktop, const char* root,
+                            const char* path, const char* args,
+                            const char* icon_name, const char* description, const char* arch)
+{
+    const char *argv[20];
+    int pos = 0;
+    int retcode;
+
+    argv[pos++] = "wineshelllink";
+    argv[pos++] = "--utf8";
+    argv[pos++] = "--root";
+    argv[pos++] = root;
+    argv[pos++] = "--link";
+    argv[pos++] = link;
+    argv[pos++] = "--path";
+    argv[pos++] = path;
+    argv[pos++] = is_desktop ? "--desktop" : "--menu";
+    if (args && strlen(args))
+    {
+        argv[pos++] = "--args";
+        argv[pos++] = args;
+    }
+    if (icon_name)
+    {
+        argv[pos++] = "--icon";
+        argv[pos++] = icon_name;
+    }
+    if (description && strlen(description))
+    {
+        argv[pos++] = "--descr";
+        argv[pos++] = description;
+    }
+    if (arch && strlen(arch))
+    {
+        argv[pos++] = "--arch";
+        argv[pos++] = arch;
+    }
+    argv[pos] = NULL;
+
+    retcode = _spawnvp(_P_WAIT, argv[0], argv);
+    if (retcode!=0)
+        WINE_ERR("%s returned %d\n", argv[0], retcode);
+    return retcode;
+}
+
+static char* cx_escape_string(const char* src)
+{
+    const char* s;
+    char *dst, *d;
+    DWORD len;
+
+    len=1;
+    for (s=src; *s; s++)
+    {
+        switch (*s)
+        {
+        case '\"':
+        case '\\':
+            len+=2;
+            break;
+        default:
+            len+=1;
+        }
+    }
+
+    dst=d=HeapAlloc(GetProcessHeap(), 0, len);
+    for (s=src; *s; s++)
+    {
+        switch (*s)
+        {
+        case '\"':
+            *d='\\';
+            d++;
+            *d='\"';
+            d++;
+            break;
+        case '\\':
+            *d='\\';
+            d++;
+            *d='\\';
+            d++;
+            break;
+        default:
+            *d=*s;
+            d++;
+        }
+    }
+    *d='\0';
+
+    return dst;
+}
+
+static void cx_print_value(const char* name, const char* value)
+{
+    if (value)
+    {
+        char* str = cx_escape_string(value);
+        fprintf(cx_menu_file, "\"%s\" = \"%s\"\n", name, str);
+        HeapFree(GetProcessHeap(), 0, str);
+    }
+}
+
+static void cx_write_profile_value(const char *fname, const char *section,
+                                   const char* key, const char* value)
+{
+    if (value)
+    {
+        char* str = cx_escape_string(value);
+        char *str2 = HeapAlloc(GetProcessHeap(), 0, strlen(str) + 3);
+        strcpy(str2, "\"");
+        strcat(str2, str);
+        strcat(str2, "\"");
+
+        if (WritePrivateProfileStringA(section, key, str2, fname))
+            WINE_TRACE("Failed to dump %s for %s : %d\n", key, section, GetLastError());
+        HeapFree(GetProcessHeap(), 0, str);
+        HeapFree(GetProcessHeap(), 0, str2);
+    }
+}
+
+
+static void cx_dump_menu(const char* link, int is_desktop, const char* root,
+                         const char* path, const char* args,
+                         const char* icon_name, const char* description, const char* arch)
+{
+    const char *s = "/menuItems.txt";
+    char *fname = malloc(strlen(xdg_data_dir) + strlen(s) + 1 );
+    sprintf(fname, "%s%s", xdg_data_dir, s);
+
+    /* -----------------------------------------------------------
+    **   The Menu hack in particular is tracked by 
+    ** CrossOver Hack 13785.
+    ** (the whole system of cx_mode hacks in winemenubuilder
+    ** is a diff from winehq which does not appear to be tracked
+    ** by a bug in the hacks milestone.)
+    ** ----------------------------------------------------------- */
+    if (!cx_menu_file)
+    {
+        if (cx_write_to_file)
+        {
+            if (!(cx_menu_file = fopen(fname, "a+")))
+                WINE_TRACE("Could not open menu file %s : %d (%s)\n", fname,
+                           errno, strerror(errno));
+        }
+
+        if (!cx_menu_file)
+            cx_menu_file = stdout;
+    }
+
+    if (cx_menu_file == stdout)
+    {
+        fprintf(cx_menu_file, "[%s]\n", link);
+        cx_print_value("IsMenu", (is_desktop ? "0" : "1"));
+        cx_print_value("Root", root);
+        cx_print_value("Path", path);
+        cx_print_value("Args", args);
+        cx_print_value("Icon", icon_name);
+        cx_print_value("Description", description);
+        cx_print_value("Arch", arch);
+        fprintf(cx_menu_file, "\n");
+    }
+    else
+    {
+        cx_write_profile_value(fname, link, "IsMenu", (is_desktop ? "0" : "1"));
+        cx_write_profile_value(fname, link, "Root", root);
+        cx_write_profile_value(fname, link, "Path", path);
+        cx_write_profile_value(fname, link, "Args", args);
+        cx_write_profile_value(fname, link, "Icon", icon_name);
+        cx_write_profile_value(fname, link, "Description", description);
+        cx_write_profile_value(fname, link, "Arch", arch);
+    }
+    free(fname);
+}
+
+int cx_process_menu(LPCWSTR linkW, BOOL is_desktop, DWORD root_csidl,
+                    LPCWSTR pathW, LPCWSTR argsW,
+                    LPCSTR icon_name, LPCSTR description, LPCSTR arch)
+{
+    WCHAR rootW[MAX_PATH];
+    char *link, *root, *path, *args;
+    int rc;
+
+    link = wchars_to_utf8_chars(linkW);
+    SHGetSpecialFolderPathW(NULL, rootW, root_csidl, FALSE);
+    root = wchars_to_utf8_chars(rootW);
+    path = pathW ? wchars_to_utf8_chars(pathW) : NULL;
+    args = argsW ? wchars_to_utf8_chars(argsW) : NULL;
+
+    WINE_TRACE("link='%s' %s: '%s' path='%s' args='%s' icon='%s' desc='%s' arch='%s'\n",
+               link, is_desktop ? "desktop" : "menu", root,
+               path, args, icon_name, description, arch);
+
+    if (cx_dump_menus || cx_write_to_file)
+    {
+        rc = 0;
+        cx_dump_menu(link, is_desktop, root, path, args, icon_name, description, arch);
+    }
+    else
+        rc = cx_wineshelllink(link, is_desktop, root, path, args, icon_name, description, arch);
+
+    HeapFree(GetProcessHeap(), 0, link);
+    HeapFree(GetProcessHeap(), 0, root);
+    HeapFree(GetProcessHeap(), 0, path);
+    HeapFree(GetProcessHeap(), 0, args);
+    return rc;
+}
+
+static IShellLinkW* load_link(const WCHAR* link)
+{
+    HRESULT r;
+    IShellLinkW *sl;
+    IPersistFile *pf;
+
+    r = CoCreateInstance(&CLSID_ShellLink, NULL, CLSCTX_INPROC_SERVER, &IID_IShellLinkW, (void**)&sl);
+    if (SUCCEEDED(r))
+        r = IShellLinkW_QueryInterface(sl, &IID_IPersistFile, (void**)&pf);
+    if (SUCCEEDED(r))
+    {
+        r = IPersistFile_Load(pf, link, STGM_READ);
+        IPersistFile_Release(pf);
+    }
+
+    if (FAILED(r))
+    {
+        IShellLinkW_Release(sl);
+        sl = NULL;
+    }
+
+    return sl;
+}
+
+BOOL cx_link_is_64_bit(IShellLinkW *sl, int recurse_level)
+{
+    static const WCHAR lnk[] = {'.','l','n','k',0};
+    HRESULT hr;
+    WCHAR temp[MAX_PATH];
+    WCHAR path[MAX_PATH];
+    const WCHAR *ext;
+    DWORD type;
+
+    hr = IShellLinkW_GetPath(sl, temp, sizeof(temp)/sizeof(temp[0]), NULL, SLGP_RAWPATH);
+    if (hr != S_OK || !temp[0])
+        return FALSE;
+    ExpandEnvironmentStringsW(temp, path, sizeof(path)/sizeof(path[0]));
+
+    ext = PathFindExtensionW(path);
+    if (!lstrcmpiW(ext, lnk) && recurse_level < 5)
+    {
+        IShellLinkW *sl2 = load_link(path);
+        if (sl2)
+        {
+            BOOL ret = cx_link_is_64_bit(sl2, recurse_level + 1);
+            IShellLinkW_Release(sl2);
+            return ret;
+        }
+    }
+
+    if (!GetBinaryTypeW(path, &type))
+        return FALSE;
+
+    return (type == SCS_64BIT_BINARY);
+}
+
+/*
+ * A CrossOver winemenubuilder extension.
+ */
+
+static BOOL cx_process_dir(WCHAR* dir)
+{
+    static const WCHAR wWILD[]={'\\','*',0};
+    static const WCHAR wDOT[]={'.',0};
+    static const WCHAR wDOTDOT[]={'.','.',0};
+    static const WCHAR wLNK[]={'.','l','n','k',0};
+    static const WCHAR wURL[]={'.','u','r','l',0};
+    HANDLE hFind;
+    WIN32_FIND_DATAW item;
+    int lendir, len;
+    WCHAR* path;
+    BOOL rc;
+
+    WINE_TRACE("scanning directory %s\n", wine_dbgstr_w(dir));
+    lendir = lstrlenW(dir);
+    lstrcatW(dir, wWILD);
+    hFind=FindFirstFileW(dir, &item);
+    if (hFind == INVALID_HANDLE_VALUE)
+    {
+        WINE_TRACE("unable to open the '%s' directory\n", wine_dbgstr_w(dir));
+        return FALSE;
+    }
+
+    rc = TRUE;
+    path = HeapAlloc(GetProcessHeap(), 0, (lendir+1+MAX_PATH+2+1)*sizeof(WCHAR));
+    lstrcpyW(path, dir);
+    path[lendir] = '\\';
+    while (1)
+    {
+        if (lstrcmpW(item.cFileName, wDOT) && lstrcmpW(item.cFileName, wDOTDOT))
+        {
+            WINE_TRACE("  %s\n", wine_dbgstr_w(item.cFileName));
+            len=lstrlenW(item.cFileName);
+            if ((item.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) ||
+                (len >= 5 && lstrcmpiW(item.cFileName+len-4, wLNK) == 0) ||
+                (len >= 5 && lstrcmpiW(item.cFileName+len-4, wURL) == 0))
+            {
+                lstrcpyW(path+lendir+1, item.cFileName);
+                if (item.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
+                {
+                    if (!(item.dwFileAttributes & FILE_ATTRIBUTE_REPARSE_POINT))  /* skip symlinks */
+                    {
+                        if (!cx_process_dir(path))
+                            rc = FALSE;
+                    }
+                }
+                else if (len >= 5 && lstrcmpiW(item.cFileName+len-4, wURL) == 0)
+                {
+                    WINE_TRACE("  url %s\n", wine_dbgstr_w(path));
+
+                    if (!Process_URL(path, FALSE))
+                        rc = FALSE;
+                }
+                else
+                {
+                    WINE_TRACE("  link %s\n", wine_dbgstr_w(path));
+
+                    if (!Process_Link(path, FALSE))
+                        rc=FALSE;
+                }
+            }
+        }
+
+        if (!FindNextFileW(hFind, &item))
+        {
+            if (GetLastError() != ERROR_NO_MORE_FILES)
+            {
+                WINE_TRACE("got error %d while scanning the '%s' directory\n", GetLastError(), wine_dbgstr_w(dir));
+                rc = FALSE;
+            }
+            FindClose(hFind);
+            break;
+        }
+    }
+
+    HeapFree(GetProcessHeap(), 0, path);
+    return rc;
+}
+
+BOOL cx_process_all_menus(void)
+{
+    static const DWORD locations[] = {
+        /* CSIDL_STARTUP, Not interested in this one */
+        CSIDL_DESKTOPDIRECTORY, CSIDL_STARTMENU,
+        /* CSIDL_COMMON_STARTUP, Not interested in this one */
+        CSIDL_COMMON_DESKTOPDIRECTORY, CSIDL_COMMON_STARTMENU };
+    WCHAR dir[MAX_PATH+2]; /* +2 for cx_process_dir() */
+    char* unix_dir;
+    struct stat st;
+    DWORD i, len;
+    BOOL rc;
+
+    rc = TRUE;
+    for (i = 0; i < sizeof(locations)/sizeof(locations[0]); i++)
+    {
+        if (!SHGetSpecialFolderPathW(0, dir, locations[i], FALSE))
+        {
+            WINE_TRACE("unable to get the path of folder %08x\n", locations[i]);
+            /* Some special folders are not defined in some bottles
+             * so this is not an error
+             */
+            continue;
+        }
+
+        len = lstrlenW(dir);
+        if (len >= MAX_PATH)
+        {
+            /* We've just trashed memory! Hopefully we are OK */
+            WINE_TRACE("Ignoring special folder %08x because its path is too long: %s\n", locations[i], wine_dbgstr_w(dir));
+            rc = FALSE;
+            continue;
+        }
+
+        /* Only scan directories. This is particularly important for Desktop
+         * which may be a symbolic link to the native desktop.
+         */
+        unix_dir = wine_get_unix_file_name(dir);
+        if (!unix_dir || lstat(unix_dir, &st) || !S_ISDIR(st.st_mode))
+            WINE_TRACE("'%s' is not a directory, skipping it\n", unix_dir);
+        else if (!cx_process_dir(dir))
+            rc = FALSE;
+        if (unix_dir)
+            HeapFree(GetProcessHeap(), 0, unix_dir);
+    }
+    return rc;
+}
diff -Naur wine-2.0a/programs/winemenubuilder/cxmenu.h wine-2.0b/programs/winemenubuilder/cxmenu.h
--- wine-2.0a/programs/winemenubuilder/cxmenu.h	1970-01-01 01:00:00.000000000 +0100
+++ wine-2.0b/programs/winemenubuilder/cxmenu.h	2017-07-11 20:37:52.000000000 +0100
@@ -0,0 +1,48 @@
+/*
+ * Header for the CrossOver menu management scripts.
+ *
+ * Copyright 2012 Francois Gouget
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+#ifndef _CXMENU_
+#define _CXMENU_
+
+/* Some global variables */
+extern int cx_mode;
+extern int cx_dump_menus;
+extern char *xdg_data_dir;
+extern FILE *cx_menu_file;
+extern int cx_write_to_file;
+
+
+/* Functions used by the cxmenu backend */
+char* wchars_to_utf8_chars(LPCWSTR string);
+
+/* The backend functions */
+int cx_process_menu(LPCWSTR linkW, BOOL is_desktop, DWORD root_csidl,
+                    LPCWSTR pathW, LPCWSTR argsW,
+                    LPCSTR icon_name, LPCSTR description, LPCSTR arch);
+
+BOOL cx_link_is_64_bit(IShellLinkW *sl, int recurse_level);
+
+/* Functions used by the winemenubuilder extensions */
+BOOL Process_Link( LPCWSTR linkname, BOOL bWait );
+BOOL Process_URL( LPCWSTR urlname, BOOL bWait );
+
+/* The winemenubuilder extensions */
+BOOL cx_process_all_menus(void);
+
+#endif /* _CXMENU_ */
diff -Naur wine-2.0a/programs/winemenubuilder/Makefile.in wine-2.0b/programs/winemenubuilder/Makefile.in
--- wine-2.0a/programs/winemenubuilder/Makefile.in	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/programs/winemenubuilder/Makefile.in	2017-07-11 20:37:52.000000000 +0100
@@ -3,4 +3,5 @@
 IMPORTS   = uuid windowscodecs shell32 shlwapi ole32 user32 advapi32
 
 C_SRCS = \
+	cxmenu.c \
 	winemenubuilder.c
diff -Naur wine-2.0a/programs/winemenubuilder/winemenubuilder.c wine-2.0b/programs/winemenubuilder/winemenubuilder.c
--- wine-2.0a/programs/winemenubuilder/winemenubuilder.c	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/programs/winemenubuilder/winemenubuilder.c	2017-07-11 20:37:52.000000000 +0100
@@ -97,6 +97,8 @@
 #include "wine/list.h"
 #include "wine/rbtree.h"
 
+#include "cxmenu.h"
+
 WINE_DEFAULT_DEBUG_CHANNEL(menubuilder);
 
 #define in_desktop_dir(csidl) ((csidl)==CSIDL_DESKTOPDIRECTORY || \
@@ -192,7 +194,7 @@
 DEFINE_GUID(CLSID_WICIcnsEncoder, 0x312fb6f1,0xb767,0x409d,0x8a,0x6d,0x0f,0xc1,0x54,0xd4,0xf0,0x5c);
 
 static char *xdg_config_dir;
-static char *xdg_data_dir;
+char *xdg_data_dir;
 static char *xdg_desktop_dir;
 
 
@@ -309,7 +311,7 @@
     return ret;
 }
 
-static char* wchars_to_utf8_chars(LPCWSTR string)
+char* wchars_to_utf8_chars(LPCWSTR string)
 {
     char *ret;
     INT size = WideCharToMultiByte(CP_UTF8, 0, string, -1, NULL, 0, NULL, NULL);
@@ -1081,6 +1083,8 @@
         if (SUCCEEDED(hr))
             hr = validate_ico(ppStream, ppIconDirEntries, numEntries);
     }
+    if (FAILED(hr) && cx_mode) /* Let cxmenu provide the fallback */
+        return hr;
     if (FAILED(hr) && !bWait)
     {
         hr = open_default_icon(ppStream);
@@ -1218,8 +1222,23 @@
         hr = E_OUTOFMEMORY;
         goto end;
     }
+    if (cx_mode)
+    {
+        char* icnsDir = heap_printf("%s/windata/cxmenu/icons", getenv("WINEPREFIX"));
+        if (icnsDir == NULL)
+        {
+            hr = E_OUTOFMEMORY;
+            goto end;
+        }
+        create_directories(icnsDir);
+        icnsPath = heap_printf("%s/%s.icns", icnsDir, *nativeIdentifier);
+        HeapFree(GetProcessHeap(), 0, icnsDir);
+    }
+    else
+    {
     if (!(tmpdir = getenv("TMPDIR"))) tmpdir = "/tmp";
     icnsPath = heap_printf("%s/%s.icns", tmpdir, *nativeIdentifier);
+    }
     if (icnsPath == NULL)
     {
         hr = E_OUTOFMEMORY;
@@ -2771,6 +2790,7 @@
                                    '\\','s','t','a','r','t','.','e','x','e',0};
     char *link_name = NULL, *icon_name = NULL, *work_dir = NULL;
     char *escaped_path = NULL, *escaped_args = NULL, *description = NULL;
+    const char *arch = NULL; /* CrossOver hack 14227 */
     WCHAR szTmp[INFOTIPSIZE];
     WCHAR szDescription[INFOTIPSIZE], szPath[MAX_PATH], szWorkDir[MAX_PATH];
     WCHAR szArgs[INFOTIPSIZE], szIconPath[MAX_PATH];
@@ -2844,6 +2864,11 @@
                  wine_dbgstr_w( szIconPath[0] ? szIconPath : szPath ));
     }
 
+    /* CrossOver hack 14227 */
+    if (cx_link_is_64_bit(sl, 0))
+        arch = "x86_64";
+    WINE_TRACE("arch       : %s\n", wine_dbgstr_a(arch));
+
     unix_link = wine_get_unix_file_name(link);
     if (unix_link == NULL)
     {
@@ -2918,6 +2943,14 @@
         goto cleanup;
     }
 
+    if (cx_mode)
+    {
+        r = cx_process_menu(link, in_desktop_dir(csidl), csidl,
+                            szPath, szArgs, icon_name, description, arch);
+        ReleaseSemaphore( hsem, 1, NULL );
+        goto cleanup;
+    }
+
     if (in_desktop_dir(csidl))
     {
         char *location;
@@ -3090,6 +3123,16 @@
         WINE_ERR("failed wait for semaphore\n");
         goto cleanup;
     }
+
+    if (cx_mode)
+    {
+        r = cx_process_menu(link, in_desktop_dir(csidl), csidl,
+                            NULL, NULL, icon_name, NULL, NULL);
+        ReleaseSemaphore(hSem, 1, NULL);
+        ret = (r != 0);
+        goto cleanup;
+    }
+
     if (in_desktop_dir(csidl))
     {
         char *location;
@@ -3171,7 +3214,7 @@
     return ret;
 }
 
-static BOOL Process_Link( LPCWSTR linkname, BOOL bWait )
+BOOL Process_Link( LPCWSTR linkname, BOOL bWait )
 {
     IShellLinkW *sl;
     IPersistFile *pf;
@@ -3232,7 +3275,7 @@
     return !r;
 }
 
-static BOOL Process_URL( LPCWSTR urlname, BOOL bWait )
+BOOL Process_URL( LPCWSTR urlname, BOOL bWait )
 {
     IUniformResourceLocatorW *url;
     IPersistFile *pf;
@@ -3614,6 +3657,8 @@
     static const WCHAR dash_tW[] = {'-','t',0};
     static const WCHAR dash_uW[] = {'-','u',0};
     static const WCHAR dash_wW[] = {'-','w',0};
+    static const WCHAR cx_allW[] = {'-','-','c','x','-','a','l','l','-','m','e','n','u','s',0};
+    static const WCHAR cx_dump_menusW[] = {'-','-','c','x','-','d','u','m','p','-','m','e','n','u','s',0};
 
     LPWSTR token = NULL, p;
     BOOL bWait = FALSE;
@@ -3621,6 +3666,9 @@
     HRESULT hr;
     int ret = 0;
 
+    if (cx_mode)
+        xdg_data_dir = heap_printf("%s/windata/cxmenu", getenv("WINEPREFIX"));
+    else
     if (!init_xdg())
         return 1;
 
@@ -3638,11 +3686,13 @@
 	    break;
         if( !strcmpW( token, dash_aW ) )
         {
+            if (!cx_mode)
             RefreshFileTypeAssociations();
             continue;
         }
         if( !strcmpW( token, dash_rW ) )
         {
+            if (!cx_mode)
             cleanup_menus();
             continue;
         }
@@ -3660,6 +3710,16 @@
                      thumbnail_lnk(lnkFile, outputFile);
             }
         }
+        else if( !lstrcmpW( token, cx_allW ) )
+        {
+            if (!cx_process_all_menus())
+            {
+	        WINE_ERR("failed to build some menu items\n");
+                ret = 1;
+            }
+        }
+        else if( !lstrcmpW( token, cx_dump_menusW ) )
+            cx_dump_menus = 1;
 	else if( token[0] == '-' )
 	{
 	    WINE_ERR( "unknown option %s\n", wine_dbgstr_w(token) );
@@ -3680,6 +3740,9 @@
         }
     }
 
+    if (cx_menu_file && cx_menu_file != stdout)
+        fclose( cx_menu_file );
+
     CoUninitialize();
     return ret;
 }
diff -Naur wine-2.0a/server/process.c wine-2.0b/server/process.c
--- wine-2.0a/server/process.c	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/server/process.c	2017-07-11 20:37:52.000000000 +0100
@@ -344,6 +344,66 @@
 
 #define PTID_OFFSET 8  /* offset for first ptid value */
 
+/* crossover usage logging support */
+
+#include <sys/types.h>
+#include <sys/stat.h>
+#include "wine/library.h"
+#include "wine/unicode.h"
+
+static void log_process_event( struct process *process, const char *fmt, ... )
+{
+    static unsigned int bottle_inode = 0;
+    const char *name = getenv( "CX_WINE_USAGE_LOGFILE" );
+    const char *appid = getenv( "CX_BOTTLE_CREATOR_APPID" );
+    struct process_dll *exe;
+    char *ptr, *buffer, prefix[128], bottleid[12];
+    int fd, len1, len2, len3, len4;
+    va_list args;
+
+    appid = appid ? appid : "--unknown--";    
+
+    if (!name || name[0] != '/') return;  /* needs to be an absolute path */
+
+    if ((fd = open( name, O_WRONLY | O_APPEND | O_CREAT, 0600 )) == -1) return;
+
+    if (!list_head( &process->dlls )) goto done;
+    exe = LIST_ENTRY( list_head( &process->dlls ), struct process_dll, entry );
+
+    if (!bottle_inode)
+    {
+        struct stat st;
+        if (!stat( wine_get_config_dir(), &st ))
+            bottle_inode = st.st_ino;
+    }
+
+    va_start( args, fmt );
+    len1 = vsnprintf( prefix, sizeof(prefix), fmt, args );
+    va_end( args );
+    len2 = snprintf( bottleid, sizeof(bottleid), "%u ", bottle_inode );
+    len3 = wine_utf8_wcstombs( 0, exe->filename, exe->namelen/sizeof(WCHAR), NULL, 0 );
+    len4 = strlen( appid );
+
+    if (len1 < 0 || len1 >= sizeof(prefix) ||
+        len2 < 0 || len2 >= sizeof(bottleid) ||
+        len3 < 0)
+        goto done;
+    if (!(buffer = ptr = malloc( len1 + len2 + len3 + len4 + 3 ))) goto done;
+    memcpy( ptr, prefix, len1 );
+    ptr += len1;
+    memcpy( ptr, bottleid, len2 );
+    ptr += len2;
+    ptr += wine_utf8_wcstombs( 0, exe->filename, exe->namelen/sizeof(WCHAR), ptr, len3 );
+    *ptr++ = ' ';
+    memcpy( ptr, appid, len4 );
+    ptr += len4;
+    *ptr++ = '\n';
+    write( fd, buffer, ptr - buffer );
+    free( buffer );
+done:
+    close( fd );
+}
+
 /* allocate a new process or thread id */
 unsigned int alloc_ptid( void *ptr )
 {
@@ -850,6 +910,9 @@
     /* close the console attached to this process, if any */
     free_console( process );
 
+    if (!process->is_system)
+        log_process_event( process, "exit %x %u ", process->exit_code, (unsigned)((process->end_time-process->start_time)/TICKS_PER_SEC) );
+
     while ((ptr = list_head( &process->rawinput_devices )))
     {
         struct rawinput_device_entry *entry = LIST_ENTRY( ptr, struct rawinput_device_entry, entry );
diff -Naur wine-2.0a/server/thread.c wine-2.0b/server/thread.c
--- wine-2.0a/server/thread.c	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/server/thread.c	2017-07-11 20:37:52.000000000 +0100
@@ -60,7 +60,7 @@
 #elif defined(__powerpc__)
 static const unsigned int supported_cpus = CPU_FLAG(CPU_POWERPC);
 #elif defined(__arm__)
-static const unsigned int supported_cpus = CPU_FLAG(CPU_ARM);
+static const unsigned int supported_cpus = CPU_FLAG(CPU_ARM) | CPU_FLAG(CPU_x86);
 #elif defined(__aarch64__)
 static const unsigned int supported_cpus = CPU_FLAG(CPU_ARM64) | CPU_FLAG(CPU_ARM);
 #else
diff -Naur wine-2.0a/tools/buildimage wine-2.0b/tools/buildimage
--- wine-2.0a/tools/buildimage	2017-01-24 20:17:22.000000000 +0000
+++ wine-2.0b/tools/buildimage	2017-07-11 20:37:52.000000000 +0100
@@ -1,6 +1,6 @@
 #! /usr/bin/perl -w
 #
-# Render SVG files containing one or more images into an ICO or BMP.
+# Render SVG files containing one or more images into an ICO, BMP, or PNG.
 #
 # Copyright (C) 2010 Joel Holdsworth
 #
@@ -27,6 +27,7 @@
 # Parse the parameters
 my $svgFileName = $ARGV[0];
 my $outFileName = $ARGV[1];
+my $optSize;
 
 die "Cannot open SVG file" unless defined($svgFileName);
 die "Cannot open output file" unless defined($outFileName);
@@ -34,7 +35,15 @@
 $outFileName =~ m/(.*)\.(.*)/;
 my $outName = $1;
 my $ext = lc($2);
-die "Only BMP and ICO outputs are supported" unless $ext eq "bmp" or $ext eq "ico";
+die "Only BMP, ICO, and PNG outputs are supported" unless $ext eq "bmp" or $ext eq "ico" or $ext eq "png";
+
+if (defined($ARGV[2]) && ($ARGV[2] eq "--size") && defined($ARGV[3]))
+{
+    $ARGV[3] =~ m/(\d+)/;
+    $optSize = $1;
+}
+
+die "You must specify a size with -s SIZE for PNG output." if ($ext eq "png" && !defined($optSize));
 
 my $renderedSVGFileName = "$svgFileName.png";
 my @pngFiles;
@@ -78,7 +87,7 @@
     my $width = 0;
     my $height = 0;
 
-    if($ext eq "ico") {
+    if($ext eq "ico" or $ext eq "png") {
         return unless $id =~ /icon:(\d*)-(\d*)/;
         $size = $1;
         $depth = $2;
@@ -130,7 +139,7 @@
         return;
     }
 
-    if ($width >= 128 && $height >= 128)
+    if ($width >= 128 && $height >= 128 && $ext ne "png")
     {
         push(@pngFilesRaw, $pngFileName);
     }
@@ -180,6 +189,45 @@
         shell $convert, "png:$pngFile", $outFileName;
     }
 
+} elsif($ext eq "png") {
+
+    my $depth;
+    my $diff;
+    my $size;
+    my $bestFitDepth;
+    my $bestFitDiff;
+    my $bestFitFile;
+    my $bestFitSize = 0;
+
+    foreach my $file (@pngFiles) {
+        $file =~ /.*-(\d*)-(\d*)\.png/;
+        $size = $1;
+        $depth = $2;
+
+        $diff = abs($size - $optSize);
+
+        if (!defined($bestFitDiff) || $diff <= $bestFitDiff)
+        {
+            $bestFitDiff = $diff;
+
+            if($bestFitSize != $size)
+            {
+                $bestFitSize = $size;
+                $bestFitDepth = 0;
+            }
+
+            if ($depth > $bestFitDepth)
+            {
+                $bestFitDepth = $depth;
+                $bestFitFile = $file;
+            }
+        }
+    }
+    copy($bestFitFile, $outFileName) or die "Could not copy $bestFitFile to $outFileName";
+    if ($bestFitSize != $optSize)
+    {
+        warn "No $optSize x $optSize icon found in $svgFileName: using $bestFitSize x $bestFitSize instead.";
+    }
 }
 
 # Delete the intermediate images
