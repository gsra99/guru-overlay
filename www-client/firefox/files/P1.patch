# Bug 1487811 - P1: Update Widevine headers and C++ code to prepare for CDM interface 10 support. r=cpearce, a=RyanVM

# Update content_decryption_module.h and other Widevine headers. This removes the CDM8 interface and adds in the CDM10 and CDM11 interfaces. As such this patch removes references to CDM8 from the code and adds some of the foundations for supporting CDM10. Most of the CDM10 code will be implemented in another bug, but there are a number of cases where it was straight forward to shuffle CDM8+9 code

diff --git a/dom/media/fake-cdm/cdm-test-decryptor.h b/dom/media/fake-cdm/cdm-test-decryptor.h
--- a/dom/media/fake-cdm/cdm-test-decryptor.h
+++ b/dom/media/fake-cdm/cdm-test-decryptor.h
@@ -40,42 +40,43 @@ class FakeDecryptor : public cdm::Conten
   void CloseSession(uint32_t aPromiseId, const char* aSessionId,
                     uint32_t aSessionIdSize) override {}
 
   void RemoveSession(uint32_t aPromiseId, const char* aSessionId,
                      uint32_t aSessionIdSize) override {}
 
   void TimerExpired(void* aContext) override {}
 
-  cdm::Status Decrypt(const cdm::InputBuffer& aEncryptedBuffer,
+  cdm::Status Decrypt(const cdm::InputBuffer_1& aEncryptedBuffer,
                       cdm::DecryptedBlock* aDecryptedBuffer) override {
     return cdm::Status::kDecodeError;
   }
 
   cdm::Status InitializeAudioDecoder(
-      const cdm::AudioDecoderConfig& aAudioDecoderConfig) override {
+      const cdm::AudioDecoderConfig_1& aAudioDecoderConfig) override {
     return cdm::Status::kDecodeError;
   }
 
   cdm::Status InitializeVideoDecoder(
-      const cdm::VideoDecoderConfig& aVideoDecoderConfig) override {
+      const cdm::VideoDecoderConfig_1& aVideoDecoderConfig) override {
     return cdm::Status::kDecodeError;
   }
 
   void DeinitializeDecoder(cdm::StreamType aDecoderType) override {}
 
   void ResetDecoder(cdm::StreamType aDecoderType) override {}
 
-  cdm::Status DecryptAndDecodeFrame(const cdm::InputBuffer& aEncryptedBuffer,
+  cdm::Status DecryptAndDecodeFrame(const cdm::InputBuffer_1& aEncryptedBuffer,
                                     cdm::VideoFrame* aVideoFrame) override {
     return cdm::Status::kDecodeError;
   }
 
-  cdm::Status DecryptAndDecodeSamples(const cdm::InputBuffer& aEncryptedBuffer,
-                                      cdm::AudioFrames* aAudioFrame) override {
+  cdm::Status DecryptAndDecodeSamples(
+      const cdm::InputBuffer_1& aEncryptedBuffer,
+      cdm::AudioFrames* aAudioFrame) override {
     return cdm::Status::kDecodeError;
   }
 
   void OnPlatformChallengeResponse(
       const cdm::PlatformChallengeResponse& aResponse) override {}
 
   void OnQueryOutputProtectionStatus(cdm::QueryResult aResult,
                                      uint32_t aLinkMask,
diff --git a/dom/media/gmp/ChromiumCDMAdapter.cpp b/dom/media/gmp/ChromiumCDMAdapter.cpp
--- a/dom/media/gmp/ChromiumCDMAdapter.cpp
+++ b/dom/media/gmp/ChromiumCDMAdapter.cpp
@@ -42,18 +42,18 @@ ChromiumCDMAdapter::ChromiumCDMAdapter(
 #endif
   PopulateHostFiles(Move(aHostPathPairs));
 }
 
 void ChromiumCDMAdapter::SetAdaptee(PRLibrary* aLib) { mLib = aLib; }
 
 void* ChromiumCdmHost(int aHostInterfaceVersion, void* aUserData) {
   GMP_LOG("ChromiumCdmHostFunc(%d, %p)", aHostInterfaceVersion, aUserData);
-  if (aHostInterfaceVersion != cdm::Host_8::kVersion &&
-      aHostInterfaceVersion != cdm::Host_9::kVersion) {
+  if (aHostInterfaceVersion != cdm::Host_9::kVersion &&
+      aHostInterfaceVersion != cdm::Host_10::kVersion) {
     return nullptr;
   }
   return aUserData;
 }
 
 #define STRINGIFY(s) _STRINGIFY(s)
 #define _STRINGIFY(s) #s
 
@@ -98,31 +98,31 @@ GMPErr ChromiumCDMAdapter::GMPInit(const
 
   return GMPNoErr;
 }
 
 GMPErr ChromiumCDMAdapter::GMPGetAPI(const char* aAPIName, void* aHostAPI,
                                      void** aPluginAPI, uint32_t aDecryptorId) {
   GMP_LOG("ChromiumCDMAdapter::GMPGetAPI(%s, 0x%p, 0x%p, %u) this=0x%p",
           aAPIName, aHostAPI, aPluginAPI, aDecryptorId, this);
-  bool isCDM9 = !strcmp(aAPIName, CHROMIUM_CDM_API);
-  bool isCDM8 = !strcmp(aAPIName, CHROMIUM_CDM_API_BACKWARD_COMPAT);
-  if (isCDM8 || isCDM9) {
+  bool isCDM10 = !strcmp(aAPIName, CHROMIUM_CDM_API);
+  bool isCDM9 = !strcmp(aAPIName, CHROMIUM_CDM_API_BACKWARD_COMPAT);
+  if (isCDM9 || isCDM10) {
     auto create = reinterpret_cast<decltype(::CreateCdmInstance)*>(
         PR_FindFunctionSymbol(mLib, "CreateCdmInstance"));
     if (!create) {
       GMP_LOG(
           "ChromiumCDMAdapter::GMPGetAPI(%s, 0x%p, 0x%p, %u) this=0x%p "
           "FAILED to find CreateCdmInstance",
           aAPIName, aHostAPI, aPluginAPI, aDecryptorId, this);
       return GMPGenericErr;
     }
 
-    int version = isCDM8 ? cdm::ContentDecryptionModule_8::kVersion
-                         : cdm::ContentDecryptionModule_9::kVersion;
+    int version = isCDM9 ? cdm::ContentDecryptionModule_9::kVersion
+                         : cdm::ContentDecryptionModule_10::kVersion;
     void* cdm =
         create(version, kEMEKeySystemWidevine.get(),
                kEMEKeySystemWidevine.Length(), &ChromiumCdmHost, aHostAPI);
     if (!cdm) {
       GMP_LOG(
           "ChromiumCDMAdapter::GMPGetAPI(%s, 0x%p, 0x%p, %u) this=0x%p "
           "FAILED to create cdm version %d",
           aAPIName, aHostAPI, aPluginAPI, aDecryptorId, this, version);
@@ -146,20 +146,20 @@ void ChromiumCDMAdapter::GMPShutdown() {
   }
 }
 
 /* static */
 bool ChromiumCDMAdapter::Supports(int32_t aModuleVersion,
                                   int32_t aInterfaceVersion,
                                   int32_t aHostVersion) {
   return aModuleVersion == CDM_MODULE_VERSION &&
-         (aInterfaceVersion == cdm::ContentDecryptionModule_8::kVersion ||
-          aInterfaceVersion == cdm::ContentDecryptionModule_9::kVersion) &&
-         (aHostVersion == cdm::Host_8::kVersion ||
-          aHostVersion == cdm::Host_9::kVersion);
+         (aInterfaceVersion == cdm::ContentDecryptionModule_9::kVersion ||
+          aInterfaceVersion == cdm::ContentDecryptionModule_10::kVersion) &&
+         (aHostVersion == cdm::Host_9::kVersion ||
+          aHostVersion == cdm::Host_10::kVersion);
 }
 
 #ifdef XP_WIN
 
 static WindowsDllInterceptor sKernel32Intercept;
 
 typedef DWORD(WINAPI* QueryDosDeviceWFnPtr)(_In_opt_ LPCWSTR lpDeviceName,
                                             _Out_ LPWSTR lpTargetPath,
diff --git a/dom/media/gmp/ChromiumCDMCallbackProxy.cpp b/dom/media/gmp/ChromiumCDMCallbackProxy.cpp
--- a/dom/media/gmp/ChromiumCDMCallbackProxy.cpp
+++ b/dom/media/gmp/ChromiumCDMCallbackProxy.cpp
@@ -51,16 +51,18 @@ void ChromiumCDMCallbackProxy::RejectPro
 static dom::MediaKeyMessageType ToDOMMessageType(uint32_t aMessageType) {
   switch (static_cast<cdm::MessageType>(aMessageType)) {
     case cdm::kLicenseRequest:
       return dom::MediaKeyMessageType::License_request;
     case cdm::kLicenseRenewal:
       return dom::MediaKeyMessageType::License_renewal;
     case cdm::kLicenseRelease:
       return dom::MediaKeyMessageType::License_release;
+    case cdm::kIndividualizationRequest:
+      return dom::MediaKeyMessageType::Individualization_request;
   }
   MOZ_ASSERT_UNREACHABLE("Invalid cdm::MessageType enum value.");
   return dom::MediaKeyMessageType::License_request;
 }
 
 void ChromiumCDMCallbackProxy::SessionMessage(const nsACString& aSessionId,
                                               uint32_t aMessageType,
                                               nsTArray<uint8_t>&& aMessage) {
diff --git a/dom/media/gmp/ChromiumCDMChild.cpp b/dom/media/gmp/ChromiumCDMChild.cpp
--- a/dom/media/gmp/ChromiumCDMChild.cpp
+++ b/dom/media/gmp/ChromiumCDMChild.cpp
@@ -186,17 +186,16 @@ void ChromiumCDMChild::CallOnMessageLoop
     RefPtr<mozilla::Runnable> t =
         NewRunnableMethod<decltype(aMethod),
                           const typename RemoveReference<ParamType>::Type...>(
             aName, this, m, aMethod, Forward<ParamType>(aParams)...);
     mPlugin->GMPMessageLoop()->PostTask(t.forget());
   }
 }
 
-// cdm::Host_9 interface
 void ChromiumCDMChild::OnResolveKeyStatusPromise(uint32_t aPromiseId,
                                                  cdm::KeyStatus aKeyStatus) {
   GMP_LOG("ChromiumCDMChild::OnResolveKeyStatusPromise(pid=%" PRIu32
           "keystatus=%d)",
           aPromiseId, aKeyStatus);
   CallOnMessageLoopThread("gmp::ChromiumCDMChild::OnResolveKeyStatusPromise",
                           &ChromiumCDMChild::SendOnResolvePromiseWithKeyStatus,
                           aPromiseId, static_cast<uint32_t>(aKeyStatus));
@@ -235,73 +234,30 @@ void ChromiumCDMChild::OnResolveNewSessi
 }
 
 void ChromiumCDMChild::OnResolvePromise(uint32_t aPromiseId) {
   GMP_LOG("ChromiumCDMChild::OnResolvePromise(pid=%" PRIu32 ")", aPromiseId);
   CallOnMessageLoopThread("gmp::ChromiumCDMChild::OnResolvePromise",
                           &ChromiumCDMChild::SendOnResolvePromise, aPromiseId);
 }
 
-// Align with spec, the Exceptions used by CDM to reject promises .
-// https://w3c.github.io/encrypted-media/#exceptions
-cdm::Exception ConvertCDMErrorToCDMException(cdm::Error error) {
-  switch (error) {
-    case cdm::kNotSupportedError:
-      return cdm::Exception::kExceptionNotSupportedError;
-    case cdm::kInvalidStateError:
-      return cdm::Exception::kExceptionInvalidStateError;
-    case cdm::kInvalidAccessError:
-      return cdm::Exception::kExceptionTypeError;
-    case cdm::kQuotaExceededError:
-      return cdm::Exception::kExceptionQuotaExceededError;
-
-    // cdm8 only error
-    case cdm::kUnknownError:
-    case cdm::kClientError:
-    case cdm::kOutputError:
-      break;
-  }
-
-  return cdm::Exception::kExceptionInvalidStateError;
-}
-
-// cdm::Host_8 only interface
-void ChromiumCDMChild::OnRejectPromise(uint32_t aPromiseId, cdm::Error aError,
-                                       uint32_t aSystemCode,
-                                       const char* aErrorMessage,
-                                       uint32_t aErrorMessageSize) {
-  OnRejectPromise(aPromiseId, ConvertCDMErrorToCDMException(aError),
-                  aSystemCode, aErrorMessage, aErrorMessageSize);
-}
-
-// cdm::Host_9 interface
 void ChromiumCDMChild::OnRejectPromise(uint32_t aPromiseId,
                                        cdm::Exception aException,
                                        uint32_t aSystemCode,
                                        const char* aErrorMessage,
                                        uint32_t aErrorMessageSize) {
   GMP_LOG("ChromiumCDMChild::OnRejectPromise(pid=%" PRIu32 ", err=%" PRIu32
           " code=%" PRIu32 ", msg='%s')",
           aPromiseId, aException, aSystemCode, aErrorMessage);
   CallOnMessageLoopThread("gmp::ChromiumCDMChild::OnRejectPromise",
                           &ChromiumCDMChild::SendOnRejectPromise, aPromiseId,
                           static_cast<uint32_t>(aException), aSystemCode,
                           nsCString(aErrorMessage, aErrorMessageSize));
 }
 
-// cdm::Host_8 only interface
-void ChromiumCDMChild::OnSessionMessage(
-    const char* aSessionId, uint32_t aSessionIdSize,
-    cdm::MessageType aMessageType, const char* aMessage, uint32_t aMessageSize,
-    const char* aLegacyDestinationUrl, uint32_t aLegacyDestinationUrlLength) {
-  OnSessionMessage(aSessionId, aSessionIdSize, aMessageType, aMessage,
-                   aMessageSize);
-}
-
-// cdm::Host_9 interface
 void ChromiumCDMChild::OnSessionMessage(const char* aSessionId,
                                         uint32_t aSessionIdSize,
                                         cdm::MessageType aMessageType,
                                         const char* aMessage,
                                         uint32_t aMessageSize) {
   GMP_LOG("ChromiumCDMChild::OnSessionMessage(sid=%s, type=%" PRIu32
           " size=%" PRIu32 ")",
           aSessionId, aMessageType, aMessageSize);
@@ -363,32 +319,16 @@ void ChromiumCDMChild::OnExpirationChang
 void ChromiumCDMChild::OnSessionClosed(const char* aSessionId,
                                        uint32_t aSessionIdSize) {
   GMP_LOG("ChromiumCDMChild::OnSessionClosed(sid=%s)", aSessionId);
   CallOnMessageLoopThread("gmp::ChromiumCDMChild::OnSessionClosed",
                           &ChromiumCDMChild::SendOnSessionClosed,
                           nsCString(aSessionId, aSessionIdSize));
 }
 
-void ChromiumCDMChild::OnLegacySessionError(const char* aSessionId,
-                                            uint32_t aSessionIdLength,
-                                            cdm::Error aError,
-                                            uint32_t aSystemCode,
-                                            const char* aErrorMessage,
-                                            uint32_t aErrorMessageLength) {
-  GMP_LOG("ChromiumCDMChild::OnLegacySessionError(sid=%s, error=%" PRIu32
-          " msg='%s')",
-          aSessionId, aError, aErrorMessage);
-  CallOnMessageLoopThread("gmp::ChromiumCDMChild::OnLegacySessionError",
-                          &ChromiumCDMChild::SendOnLegacySessionError,
-                          nsCString(aSessionId, aSessionIdLength),
-                          ConvertCDMErrorToCDMException(aError), aSystemCode,
-                          nsCString(aErrorMessage, aErrorMessageLength));
-}
-
 cdm::FileIO* ChromiumCDMChild::CreateFileIO(cdm::FileIOClient* aClient) {
   MOZ_ASSERT(IsOnMessageLoopThread());
   GMP_LOG("ChromiumCDMChild::CreateFileIO()");
   if (!mPersistentStateAllowed) {
     return nullptr;
   }
   return new WidevineFileIO(aClient);
 }
@@ -571,43 +511,41 @@ mozilla::ipc::IPCResult ChromiumCDMChild
   MOZ_ASSERT(IsOnMessageLoopThread());
   GMP_LOG("ChromiumCDMChild::RecvGetStatusForPolicy(pid=%" PRIu32
           ", MinHdcpVersion=%s)",
           aPromiseId, aMinHdcpVersion.get());
   if (mCDM) {
     cdm::Policy policy;
     // We didn't check the return value of ToCDMHdcpVersion.
     // Let CDM to handle the cdm::HdcpVersion::kHdcpVersionNone case.
-    // ChromiumCDM8BackwardsCompat::GetStatusForPolicy will reject the promise
-    // since this API is only supported by CDM version 9.
     // CDM will callback by OnResolveKeyStatusPromise when it successfully
     // executes.
     policy.min_hdcp_version = ToCDMHdcpVersion(aMinHdcpVersion);
     mCDM->GetStatusForPolicy(aPromiseId, policy);
   }
   return IPC_OK();
 }
 
 static void InitInputBuffer(const CDMInputBuffer& aBuffer,
                             nsTArray<cdm::SubsampleEntry>& aSubSamples,
-                            cdm::InputBuffer& aInputBuffer) {
+                            cdm::InputBuffer_1& aInputBuffer) {
   aInputBuffer.data = aBuffer.mData().get<uint8_t>();
   aInputBuffer.data_size = aBuffer.mData().Size<uint8_t>();
 
   if (aBuffer.mIsEncrypted()) {
     aInputBuffer.key_id = aBuffer.mKeyId().Elements();
     aInputBuffer.key_id_size = aBuffer.mKeyId().Length();
 
     aInputBuffer.iv = aBuffer.mIV().Elements();
     aInputBuffer.iv_size = aBuffer.mIV().Length();
 
     aSubSamples.SetCapacity(aBuffer.mClearBytes().Length());
     for (size_t i = 0; i < aBuffer.mCipherBytes().Length(); i++) {
-      aSubSamples.AppendElement(cdm::SubsampleEntry(aBuffer.mClearBytes()[i],
-                                                    aBuffer.mCipherBytes()[i]));
+      aSubSamples.AppendElement(cdm::SubsampleEntry{aBuffer.mClearBytes()[i],
+                                                    aBuffer.mCipherBytes()[i]});
     }
     aInputBuffer.subsamples = aSubSamples.Elements();
     aInputBuffer.num_subsamples = aSubSamples.Length();
   }
   aInputBuffer.timestamp = aBuffer.mTimestamp();
 }
 
 bool ChromiumCDMChild::HasShmemOfSize(size_t aSize) const {
@@ -655,17 +593,17 @@ mozilla::ipc::IPCResult ChromiumCDMChild
   if (aBuffer.mClearBytes().Length() != aBuffer.mCipherBytes().Length()) {
     GMP_LOG(
         "ChromiumCDMChild::RecvDecrypt() clear/cipher bytes length doesn't "
         "match");
     Unused << SendDecryptFailed(aId, cdm::kDecryptError);
     return IPC_OK();
   }
 
-  cdm::InputBuffer input;
+  cdm::InputBuffer_1 input = {};
   nsTArray<cdm::SubsampleEntry> subsamples;
   InitInputBuffer(aBuffer, subsamples, input);
 
   WidevineDecryptedBlock output;
   cdm::Status status = mCDM->Decrypt(input, &output);
 
   // CDM should have allocated a cdm::Buffer for output.
   CDMShmemBuffer* buffer =
@@ -694,21 +632,19 @@ mozilla::ipc::IPCResult ChromiumCDMChild
     const CDMVideoDecoderConfig& aConfig) {
   MOZ_ASSERT(IsOnMessageLoopThread());
   MOZ_ASSERT(!mDecoderInitialized);
   if (!mCDM) {
     GMP_LOG("ChromiumCDMChild::RecvInitializeVideoDecoder() no CDM");
     Unused << SendOnDecoderInitDone(cdm::kInitializationError);
     return IPC_OK();
   }
-  cdm::VideoDecoderConfig config;
-  config.codec =
-      static_cast<cdm::VideoDecoderConfig::VideoCodec>(aConfig.mCodec());
-  config.profile = static_cast<cdm::VideoDecoderConfig::VideoCodecProfile>(
-      aConfig.mProfile());
+  cdm::VideoDecoderConfig_1 config = {};
+  config.codec = static_cast<cdm::VideoCodec>(aConfig.mCodec());
+  config.profile = static_cast<cdm::VideoCodecProfile>(aConfig.mProfile());
   config.format = static_cast<cdm::VideoFormat>(aConfig.mFormat());
   config.coded_size =
       mCodedSize = {aConfig.mImageWidth(), aConfig.mImageHeight()};
   nsTArray<uint8_t> extraData(aConfig.mExtraData());
   config.extra_data = extraData.Elements();
   config.extra_data_size = extraData.Length();
   cdm::Status status = mCDM->InitializeVideoDecoder(config);
   GMP_LOG("ChromiumCDMChild::RecvInitializeVideoDecoder() status=%u", status);
@@ -758,17 +694,17 @@ mozilla::ipc::IPCResult ChromiumCDMChild
 
   // The output frame may not have the same timestamp as the frame we put in.
   // We may need to input a number of frames before we receive output. The
   // CDM's decoder reorders to ensure frames output are in presentation order.
   // So we need to store the durations of the frames input, and retrieve them
   // on output.
   mFrameDurations.Insert(aBuffer.mTimestamp(), aBuffer.mDuration());
 
-  cdm::InputBuffer input;
+  cdm::InputBuffer_1 input = {};
   nsTArray<cdm::SubsampleEntry> subsamples;
   InitInputBuffer(aBuffer, subsamples, input);
 
   WidevineVideoFrame frame;
   cdm::Status rv = mCDM->DecryptAndDecodeFrame(input, &frame);
   GMP_LOG("ChromiumCDMChild::RecvDecryptAndDecodeFrame() t=%" PRId64
           " CDM decoder rv=%d",
           aBuffer.mTimestamp(), rv);
@@ -840,17 +776,17 @@ void ChromiumCDMChild::ReturnOutput(Wide
 mozilla::ipc::IPCResult ChromiumCDMChild::RecvDrain() {
   MOZ_ASSERT(IsOnMessageLoopThread());
   if (!mCDM) {
     GMP_LOG("ChromiumCDMChild::RecvDrain() no CDM");
     Unused << SendDrainComplete();
     return IPC_OK();
   }
   WidevineVideoFrame frame;
-  cdm::InputBuffer sample;
+  cdm::InputBuffer_1 sample = {};
   cdm::Status rv = mCDM->DecryptAndDecodeFrame(sample, &frame);
   GMP_LOG("ChromiumCDMChild::RecvDrain();  DecryptAndDecodeFrame() rv=%d", rv);
   if (rv == cdm::kSuccess) {
     MOZ_ASSERT(frame.Format() != cdm::kUnknownVideoFormat);
     ReturnOutput(frame);
   } else {
     Unused << SendDrainComplete();
   }
diff --git a/dom/media/gmp/ChromiumCDMChild.h b/dom/media/gmp/ChromiumCDMChild.h
--- a/dom/media/gmp/ChromiumCDMChild.h
+++ b/dom/media/gmp/ChromiumCDMChild.h
@@ -12,42 +12,39 @@
 #include "WidevineVideoFrame.h"
 
 namespace mozilla {
 namespace gmp {
 
 class GMPContentChild;
 
 class ChromiumCDMChild : public PChromiumCDMChild,
-                         public cdm::Host_8,
-                         public cdm::Host_9 {
+                         public cdm::Host_9,
+                         public cdm::Host_10 {
  public:
   NS_INLINE_DECL_THREADSAFE_REFCOUNTING(ChromiumCDMChild);
 
   explicit ChromiumCDMChild(GMPContentChild* aPlugin);
 
   void Init(cdm::ContentDecryptionModule_9* aCDM, const nsCString& aStorageId);
 
   void TimerExpired(void* aContext);
 
-  // cdm::Host_9 implementation
+  // Shared cdm::Host_9 and cdm::Host10 implementation
   cdm::Buffer* Allocate(uint32_t aCapacity) override;
   void SetTimer(int64_t aDelayMs, void* aContext) override;
   cdm::Time GetCurrentWallTime() override;
-  // cdm::Host_9 interface
   void OnResolveKeyStatusPromise(uint32_t aPromiseId,
                                  cdm::KeyStatus aKeyStatus) override;
   void OnResolveNewSessionPromise(uint32_t aPromiseId, const char* aSessionId,
                                   uint32_t aSessionIdSize) override;
   void OnResolvePromise(uint32_t aPromiseId) override;
-  // cdm::Host_9 interface
   void OnRejectPromise(uint32_t aPromiseId, cdm::Exception aException,
                        uint32_t aSystemCode, const char* aErrorMessage,
                        uint32_t aErrorMessageSize) override;
-  // cdm::Host_9 interface
   void OnSessionMessage(const char* aSessionId, uint32_t aSessionIdSize,
                         cdm::MessageType aMessageType, const char* aMessage,
                         uint32_t aMessageSize) override;
   void OnSessionKeysChange(const char* aSessionId, uint32_t aSessionIdSize,
                            bool aHasAdditionalUsableKey,
                            const cdm::KeyInformation* aKeysInfo,
                            uint32_t aKeysInfoCount) override;
   void OnExpirationChange(const char* aSessionId, uint32_t aSessionIdSize,
@@ -56,33 +53,22 @@ class ChromiumCDMChild : public PChromiu
                        uint32_t aSessionIdSize) override;
   void SendPlatformChallenge(const char* aServiceId, uint32_t aServiceIdSize,
                              const char* aChallenge,
                              uint32_t aChallengeSize) override {}
   void EnableOutputProtection(uint32_t aDesiredProtectionMask) override {}
   void QueryOutputProtectionStatus() override {}
   void OnDeferredInitializationDone(cdm::StreamType aStreamType,
                                     cdm::Status aDecoderStatus) override {}
-  // cdm::Host_9 interface
   void RequestStorageId(uint32_t aVersion) override;
   cdm::FileIO* CreateFileIO(cdm::FileIOClient* aClient) override;
-
-  // cdm::Host_8 implementation
-  void OnSessionMessage(const char* aSessionId, uint32_t aSessionIdSize,
-                        cdm::MessageType aMessageType, const char* aMessage,
-                        uint32_t aMessageSize,
-                        const char* aLegacyDestinationUrl,
-                        uint32_t aLegacyDestinationUrlLength) override;
-  void OnRejectPromise(uint32_t aPromiseId, cdm::Error aError,
-                       uint32_t aSystemCode, const char* aErrorMessage,
-                       uint32_t aErrorMessageSize) override;
-  void OnLegacySessionError(const char* aSessionId, uint32_t aSessionIdLength,
-                            cdm::Error aError, uint32_t aSystemCode,
-                            const char* aErrorMessage,
-                            uint32_t aErrorMessageLength) override;
+  // End shared cdm::Host_9 and cdm::Host10 implementation
+  // cdm::Host_10 specific
+  void OnInitialized(bool success) override {}
+  // end cdm::Host_10 specific
 
   void GiveBuffer(ipc::Shmem&& aBuffer);
 
  protected:
   ~ChromiumCDMChild();
 
   bool OnResolveNewSessionPromiseInternal(uint32_t aPromiseId,
                                           const nsCString& aSessionId);
@@ -133,17 +119,17 @@ class ChromiumCDMChild : public PChromiu
 
   GMPContentChild* mPlugin = nullptr;
   cdm::ContentDecryptionModule_9* mCDM = nullptr;
 
   typedef SimpleMap<uint64_t> DurationMap;
   DurationMap mFrameDurations;
   nsTArray<uint32_t> mLoadSessionPromiseIds;
 
-  cdm::Size mCodedSize;
+  cdm::Size mCodedSize = {0, 0};
   nsTArray<ipc::Shmem> mBuffers;
 
   bool mDecoderInitialized = false;
   bool mPersistentStateAllowed = false;
   bool mDestroyed = false;
   nsCString mStorageId;
 };
 
diff --git a/dom/media/gmp/ChromiumCDMParent.cpp b/dom/media/gmp/ChromiumCDMParent.cpp
--- a/dom/media/gmp/ChromiumCDMParent.cpp
+++ b/dom/media/gmp/ChromiumCDMParent.cpp
@@ -803,17 +803,17 @@ RefPtr<MediaDataDecoder::InitPromise> Ch
 
   if (!SendInitializeVideoDecoder(aConfig)) {
     return MediaDataDecoder::InitPromise::CreateAndReject(
         MediaResult(NS_ERROR_DOM_MEDIA_FATAL_ERR,
                     RESULT_DETAIL("Failed to send init video decoder to CDM")),
         __func__);
   }
 
-  mMaxRefFrames = (aConfig.mCodec() == cdm::VideoDecoderConfig::kCodecH264)
+  mMaxRefFrames = (aConfig.mCodec() == cdm::VideoCodec::kCodecH264)
                       ? H264::HasSPS(aInfo.mExtraData)
                             ? H264::ComputeMaxRefFrames(aInfo.mExtraData)
                             : 16
                       : 0;
 
   mVideoDecoderInitialized = true;
   mImageContainer = aImageContainer;
   mVideoInfo = aInfo;
diff --git a/dom/media/gmp/GMPContentChild.cpp b/dom/media/gmp/GMPContentChild.cpp
--- a/dom/media/gmp/GMPContentChild.cpp
+++ b/dom/media/gmp/GMPContentChild.cpp
@@ -100,150 +100,29 @@ mozilla::ipc::IPCResult GMPContentChild:
     return IPC_FAIL_NO_REASON(this);
   }
 
   vec->Init(static_cast<GMPVideoEncoder*>(ve));
 
   return IPC_OK();
 }
 
-class ChromiumCDM8BackwardsCompat : public cdm::ContentDecryptionModule_9 {
- public:
-  explicit ChromiumCDM8BackwardsCompat(cdm::Host_9* aHost,
-                                       cdm::ContentDecryptionModule_8* aCDM)
-      : mCDM(aCDM), mHost(aHost) {}
-
-  void Initialize(bool aAllowDistinctiveIdentifier,
-                  bool aAllowPersistentState) override {
-    mCDM->Initialize(aAllowDistinctiveIdentifier, aAllowPersistentState);
-  }
-
-  void SetServerCertificate(uint32_t aPromiseId,
-                            const uint8_t* aServerCertificateData,
-                            uint32_t aServerCertificateDataSize) override {
-    mCDM->SetServerCertificate(aPromiseId, aServerCertificateData,
-                               aServerCertificateDataSize);
-  }
-
-  void GetStatusForPolicy(uint32_t aPromiseId,
-                          const cdm::Policy& policy) override {
-    // Only support on version 9 CDM, so rejecting the promise.
-    mHost->OnRejectPromise(
-        aPromiseId, cdm::Exception::kExceptionNotSupportedError, 0, nullptr, 0);
-  }
-
-  void CreateSessionAndGenerateRequest(uint32_t aPromiseId,
-                                       cdm::SessionType aSessionType,
-                                       cdm::InitDataType aInitDataType,
-                                       const uint8_t* aInitData,
-                                       uint32_t aInitDataSize) override {
-    mCDM->CreateSessionAndGenerateRequest(
-        aPromiseId, aSessionType, aInitDataType, aInitData, aInitDataSize);
-  }
-
-  void LoadSession(uint32_t aPromiseId, cdm::SessionType aSessionType,
-                   const char* aSessionId, uint32_t aSessionIdSize) override {
-    mCDM->LoadSession(aPromiseId, aSessionType, aSessionId, aSessionIdSize);
-  }
-
-  void UpdateSession(uint32_t aPromiseId, const char* aSessionId,
-                     uint32_t aSessionIdSize, const uint8_t* aResponse,
-                     uint32_t aResponseSize) override {
-    mCDM->UpdateSession(aPromiseId, aSessionId, aSessionIdSize, aResponse,
-                        aResponseSize);
-  }
-
-  void CloseSession(uint32_t aPromiseId, const char* aSessionId,
-                    uint32_t aSessionIdSize) override {
-    mCDM->CloseSession(aPromiseId, aSessionId, aSessionIdSize);
-  }
-
-  void RemoveSession(uint32_t aPromiseId, const char* aSessionId,
-                     uint32_t aSessionIdSize) override {
-    mCDM->RemoveSession(aPromiseId, aSessionId, aSessionIdSize);
-  }
-
-  void TimerExpired(void* aContext) override { mCDM->TimerExpired(aContext); }
-
-  cdm::Status Decrypt(const cdm::InputBuffer& aEncryptedBuffer,
-                      cdm::DecryptedBlock* aDecryptedBuffer) override {
-    return mCDM->Decrypt(aEncryptedBuffer, aDecryptedBuffer);
-  }
-
-  cdm::Status InitializeAudioDecoder(
-      const cdm::AudioDecoderConfig& aAudioDecoderConfig) override {
-    return mCDM->InitializeAudioDecoder(aAudioDecoderConfig);
-  }
-
-  cdm::Status InitializeVideoDecoder(
-      const cdm::VideoDecoderConfig& aVideoDecoderConfig) override {
-    return mCDM->InitializeVideoDecoder(aVideoDecoderConfig);
-  }
-
-  void DeinitializeDecoder(cdm::StreamType aDecoderType) override {
-    mCDM->DeinitializeDecoder(aDecoderType);
-  }
-
-  void ResetDecoder(cdm::StreamType aDecoderType) override {
-    mCDM->ResetDecoder(aDecoderType);
-  }
-
-  cdm::Status DecryptAndDecodeFrame(const cdm::InputBuffer& aEncryptedBuffer,
-                                    cdm::VideoFrame* aVideoFrame) override {
-    return mCDM->DecryptAndDecodeFrame(aEncryptedBuffer, aVideoFrame);
-  }
-
-  cdm::Status DecryptAndDecodeSamples(const cdm::InputBuffer& aEncryptedBuffer,
-                                      cdm::AudioFrames* aAudioFrames) override {
-    return mCDM->DecryptAndDecodeSamples(aEncryptedBuffer, aAudioFrames);
-  }
-
-  void OnPlatformChallengeResponse(
-      const cdm::PlatformChallengeResponse& aResponse) override {
-    mCDM->OnPlatformChallengeResponse(aResponse);
-  }
-
-  void OnQueryOutputProtectionStatus(cdm::QueryResult aResult,
-                                     uint32_t aLinkMask,
-                                     uint32_t aOutputProtectionMask) override {
-    mCDM->OnQueryOutputProtectionStatus(aResult, aLinkMask,
-                                        aOutputProtectionMask);
-  }
-
-  void OnStorageId(uint32_t aVersion, const uint8_t* aStorageId,
-                   uint32_t aStorageIdSize) override {
-    // Only support on version 9 CDM.
-  }
-
-  void Destroy() override {
-    mCDM->Destroy();
-    delete this;
-  }
-  cdm::ContentDecryptionModule_8* mCDM;
-  cdm::Host_9* mHost;
-};  // class ChromiumCDM8BackwardsCompat
-
 mozilla::ipc::IPCResult GMPContentChild::RecvPChromiumCDMConstructor(
     PChromiumCDMChild* aActor) {
+  // TODO: Update to create 10 and have backward compat instance of 9 for
+  // fallback
   ChromiumCDMChild* child = static_cast<ChromiumCDMChild*>(aActor);
   cdm::Host_9* host9 = child;
 
   void* cdm = nullptr;
   // Create version 9 CDM first.
-  GMPErr err = mGMPChild->GetAPI(CHROMIUM_CDM_API, host9, &cdm);
+  GMPErr err = mGMPChild->GetAPI(CHROMIUM_CDM_API_BACKWARD_COMPAT, host9, &cdm);
   if (err != GMPNoErr || !cdm) {
-    // Try to create older version 8 CDM.
-    cdm::Host_8* host8 = child;
-    err = mGMPChild->GetAPI(CHROMIUM_CDM_API_BACKWARD_COMPAT, host8, &cdm);
-    if (err != GMPNoErr) {
-      NS_WARNING("GMPGetAPI call failed trying to get CDM.");
-      return IPC_FAIL_NO_REASON(this);
-    }
-    cdm = new ChromiumCDM8BackwardsCompat(
-        host9, static_cast<cdm::ContentDecryptionModule_8*>(cdm));
+    NS_WARNING("GMPGetAPI call failed trying to get CDM.");
+    return IPC_FAIL_NO_REASON(this);
   }
 
   child->Init(static_cast<cdm::ContentDecryptionModule_9*>(cdm),
               mGMPChild->mStorageId);
 
   return IPC_OK();
 }
 
diff --git a/dom/media/gmp/GMPUtils.h b/dom/media/gmp/GMPUtils.h
--- a/dom/media/gmp/GMPUtils.h
+++ b/dom/media/gmp/GMPUtils.h
@@ -9,18 +9,19 @@
 #include "mozilla/UniquePtr.h"
 #include "mozilla/RefPtr.h"
 #include "mozilla/AbstractThread.h"
 #include "nsStringFwd.h"
 #include "nsTArray.h"
 #include "nsCOMPtr.h"
 #include "nsClassHashtable.h"
 
-#define CHROMIUM_CDM_API_BACKWARD_COMPAT "chromium-cdm8-host4"
-#define CHROMIUM_CDM_API "chromium-cdm9-host4"
+#define CHROMIUM_CDM_API_BACKWARD_COMPAT "chromium-cdm9-host4"
+// TODO: The following should be used as we switch to cdm10
+#define CHROMIUM_CDM_API "chromium-cdm10-host4"
 
 class nsIFile;
 class nsISimpleEnumerator;
 
 namespace mozilla {
 
 template <typename T>
 struct DestroyPolicy {
diff --git a/dom/media/gmp/moz.build b/dom/media/gmp/moz.build
--- a/dom/media/gmp/moz.build
+++ b/dom/media/gmp/moz.build
@@ -58,16 +58,17 @@ EXPORTS += [
     'GMPVideoEncoderParent.h',
     'GMPVideoEncoderProxy.h',
     'GMPVideoHost.h',
     'GMPVideoi420FrameImpl.h',
     'GMPVideoPlaneImpl.h',
     'widevine-adapter/content_decryption_module.h',
     'widevine-adapter/content_decryption_module_export.h',
     'widevine-adapter/content_decryption_module_ext.h',
+    'widevine-adapter/content_decryption_module_proxy.h',
 ]
 
 UNIFIED_SOURCES += [
     'CDMStorageIdProvider.cpp',
     'ChromiumCDMAdapter.cpp',
     'ChromiumCDMCallbackProxy.cpp',
     'ChromiumCDMChild.cpp',
     'ChromiumCDMParent.cpp',
diff --git a/dom/media/gmp/widevine-adapter/WidevineVideoFrame.cpp b/dom/media/gmp/widevine-adapter/WidevineVideoFrame.cpp
--- a/dom/media/gmp/widevine-adapter/WidevineVideoFrame.cpp
+++ b/dom/media/gmp/widevine-adapter/WidevineVideoFrame.cpp
@@ -10,19 +10,20 @@
 #include "mozilla/IntegerPrintfMacros.h"
 
 using namespace cdm;
 
 namespace mozilla {
 
 WidevineVideoFrame::WidevineVideoFrame()
     : mFormat(kUnknownVideoFormat),
-      mSize(0, 0),
+      mSize{0, 0},
       mBuffer(nullptr),
       mTimestamp(0) {
+  MOZ_ASSERT(mSize.height == 0 && mSize.width == 0, "Size should be zeroed");
   GMP_LOG("WidevineVideoFrame::WidevineVideoFrame() this=%p", this);
   memset(mPlaneOffsets, 0, sizeof(mPlaneOffsets));
   memset(mPlaneStrides, 0, sizeof(mPlaneStrides));
 }
 
 WidevineVideoFrame::WidevineVideoFrame(WidevineVideoFrame&& aOther)
     : mFormat(aOther.mFormat),
       mSize(aOther.mSize),
@@ -93,18 +94,20 @@ uint32_t WidevineVideoFrame::Stride(cdm:
 void WidevineVideoFrame::SetTimestamp(int64_t timestamp) {
   GMP_LOG("WidevineVideoFrame::SetTimestamp(%" PRId64 ") this=%p", timestamp,
           this);
   mTimestamp = timestamp;
 }
 
 int64_t WidevineVideoFrame::Timestamp() const { return mTimestamp; }
 
-bool WidevineVideoFrame::InitToBlack(uint32_t aWidth, uint32_t aHeight,
+bool WidevineVideoFrame::InitToBlack(int32_t aWidth, int32_t aHeight,
                                      int64_t aTimeStamp) {
+  MOZ_ASSERT(aWidth >= 0 && aHeight >= 0,
+             "Frame dimensions should be positive");
   CheckedInt<size_t> ySizeChk = aWidth;
   ySizeChk *= aHeight;
   // If w*h didn't overflow, half of them won't.
   const size_t uSize = ((aWidth + 1) / 2) * ((aHeight + 1) / 2);
   CheckedInt<size_t> yuSizeChk = ySizeChk + uSize;
   if (!yuSizeChk.isValid()) {
     return false;
   }
@@ -113,17 +116,17 @@ bool WidevineVideoFrame::InitToBlack(uin
   // Black in YCbCr is (0,128,128).
   memset(buffer->Data(), 0, ySize);
   memset(buffer->Data() + ySize, 128, uSize);
   if (mBuffer) {
     mBuffer->Destroy();
     mBuffer = nullptr;
   }
   SetFormat(VideoFormat::kI420);
-  SetSize(cdm::Size(aWidth, aHeight));
+  SetSize(cdm::Size{aWidth, aHeight});
   SetFrameBuffer(buffer);
   SetPlaneOffset(VideoFrame::kYPlane, 0);
   SetStride(VideoFrame::kYPlane, aWidth);
   // Note: U and V planes are stored at the same place in order to
   // save memory since their contents are the same.
   SetPlaneOffset(VideoFrame::kUPlane, ySize);
   SetStride(VideoFrame::kUPlane, (aWidth + 1) / 2);
   SetPlaneOffset(VideoFrame::kVPlane, ySize);
diff --git a/dom/media/gmp/widevine-adapter/WidevineVideoFrame.h b/dom/media/gmp/widevine-adapter/WidevineVideoFrame.h
--- a/dom/media/gmp/widevine-adapter/WidevineVideoFrame.h
+++ b/dom/media/gmp/widevine-adapter/WidevineVideoFrame.h
@@ -33,17 +33,17 @@ class WidevineVideoFrame : public cdm::V
   uint32_t PlaneOffset(cdm::VideoFrame::VideoPlane aPlane) override;
 
   void SetStride(cdm::VideoFrame::VideoPlane aPlane, uint32_t aStride) override;
   uint32_t Stride(cdm::VideoFrame::VideoPlane aPlane) override;
 
   void SetTimestamp(int64_t aTimestamp) override;
   int64_t Timestamp() const override;
 
-  MOZ_MUST_USE bool InitToBlack(uint32_t aWidth, uint32_t aHeight,
+  MOZ_MUST_USE bool InitToBlack(int32_t aWidth, int32_t aHeight,
                                 int64_t aTimeStamp);
 
  protected:
   cdm::VideoFormat mFormat;
   cdm::Size mSize;
   cdm::Buffer* mBuffer;
   uint32_t mPlaneOffsets[kMaxPlanes];
   uint32_t mPlaneStrides[kMaxPlanes];
diff --git a/dom/media/gmp/widevine-adapter/content_decryption_module.h b/dom/media/gmp/widevine-adapter/content_decryption_module.h
--- a/dom/media/gmp/widevine-adapter/content_decryption_module.h
+++ b/dom/media/gmp/widevine-adapter/content_decryption_module.h
@@ -1,56 +1,57 @@
 // Copyright (c) 2012 The Chromium Authors. All rights reserved.
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
 #ifndef CDM_CONTENT_DECRYPTION_MODULE_H_
 #define CDM_CONTENT_DECRYPTION_MODULE_H_
 
+#include <type_traits>
+
 #include "content_decryption_module_export.h"
+#include "content_decryption_module_proxy.h"
 
 #if defined(_MSC_VER)
 typedef unsigned char uint8_t;
 typedef unsigned int uint32_t;
 typedef int int32_t;
 typedef __int64 int64_t;
 #else
 #include <stdint.h>
 #endif
 
-// Define CDM_CLASS_API to export class types. We have to add visibility
-// attributes to make sure virtual tables in CDM consumer and CDM implementation
-// are the same. Generally, it was always a good idea, as there're no guarantees
-// about that for the internal symbols, but it has only become a practical issue
-// after introduction of LTO devirtualization. See more details on
-// https://crbug.com/609564#c35
-#if defined(_WIN32)
-#if defined(__clang__)
-#define CDM_CLASS_API [[clang::lto_visibility_public]]
-#else
-#define CDM_CLASS_API
-#endif
-#else  // defined(_WIN32)
-#define CDM_CLASS_API __attribute__((visibility("default")))
-#endif  // defined(_WIN32)
-
 // The version number must be rolled when the exported functions are updated!
 // If the CDM and the adapter use different versions of these functions, the
 // adapter will fail to load or crash!
 #define CDM_MODULE_VERSION 4
 
 // Build the versioned entrypoint name.
 // The extra macros are necessary to expand version to an actual value.
 #define INITIALIZE_CDM_MODULE \
   BUILD_ENTRYPOINT(InitializeCdmModule, CDM_MODULE_VERSION)
 #define BUILD_ENTRYPOINT(name, version) \
   BUILD_ENTRYPOINT_NO_EXPANSION(name, version)
 #define BUILD_ENTRYPOINT_NO_EXPANSION(name, version) name##_##version
 
+// Macro to check that |type| does the following:
+// 1. is a standard layout.
+// 2. is trivial.
+// 3. sizeof(type) matches the expected size in bytes. As some types contain
+//    pointers, the size is specified for both 32 and 64 bit.
+#define CHECK_TYPE(type, size_32, size_64)                           \
+  static_assert(std::is_standard_layout<type>(),                     \
+                #type " not standard_layout");                       \
+  static_assert(std::is_trivial<type>(), #type " not trivial");      \
+  static_assert((sizeof(void*) == 4 && sizeof(type) == size_32) ||   \
+                    (sizeof(void*) == 8 && sizeof(type) == size_64), \
+                #type " size mismatch")
+
 extern "C" {
+
 CDM_API void INITIALIZE_CDM_MODULE();
 
 CDM_API void DeinitializeCdmModule();
 
 // Returns a pointer to the requested CDM Host interface upon success.
 // Returns NULL if the requested CDM Host interface is not supported.
 // The caller should cast the returned pointer to the type matching
 // |host_interface_version|.
@@ -58,73 +59,64 @@ typedef void* (*GetCdmHostFunc)(int host
 
 // Returns a pointer to the requested CDM upon success.
 // Returns NULL if an error occurs or the requested |cdm_interface_version| or
 // |key_system| is not supported or another error occurs.
 // The caller should cast the returned pointer to the type matching
 // |cdm_interface_version|.
 // Caller retains ownership of arguments and must call Destroy() on the returned
 // object.
-CDM_API void* CreateCdmInstance(
-    int cdm_interface_version,
-    const char* key_system, uint32_t key_system_size,
-    GetCdmHostFunc get_cdm_host_func, void* user_data);
+CDM_API void* CreateCdmInstance(int cdm_interface_version,
+                                const char* key_system,
+                                uint32_t key_system_size,
+                                GetCdmHostFunc get_cdm_host_func,
+                                void* user_data);
 
 CDM_API const char* GetCdmVersion();
-}
+
+}  // extern "C"
 
 namespace cdm {
 
-class CDM_CLASS_API AudioFrames;
-class CDM_CLASS_API DecryptedBlock;
-class CDM_CLASS_API VideoFrame;
-
-class CDM_CLASS_API Host_8;
-class CDM_CLASS_API Host_9;
-
-enum Status {
+enum Status : uint32_t {
   kSuccess = 0,
   kNeedMoreData,  // Decoder needs more data to produce a decoded frame/sample.
   kNoKey,         // The required decryption key is not available.
   kInitializationError,    // Initialization error.
   kDecryptError,           // Decryption failed.
   kDecodeError,            // Error decoding audio or video.
   kDeferredInitialization  // Decoder is not ready for initialization.
 };
-
-// This must at least contain the exceptions defined in the spec:
-// https://w3c.github.io/encrypted-media/#exceptions
-// The following starts with the list of DOM4 exceptions from:
-// http://www.w3.org/TR/dom/#domexception
-// Some DOM4 exceptions are not included as they are not expected to be used.
-// Should only be used on Host_8 and before.
-enum Error {
-  kNotSupportedError = 9,
-  kInvalidStateError = 11,
-  kInvalidAccessError = 15,
-  kQuotaExceededError = 22,
-
-  // Additional exceptions that do not have assigned codes.
-  // There are other non-EME-specific values, not included in this list.
-  kUnknownError = 30,
-
-  // Additional values from previous EME versions. They currently have no
-  // matching DOMException.
-  kClientError = 100,
-  kOutputError = 101
-};
+CHECK_TYPE(Status, 4, 4);
 
 // Exceptions used by the CDM to reject promises.
 // https://w3c.github.io/encrypted-media/#exceptions
-enum Exception {
+enum Exception : uint32_t {
   kExceptionTypeError,
   kExceptionNotSupportedError,
   kExceptionInvalidStateError,
   kExceptionQuotaExceededError
 };
+CHECK_TYPE(Exception, 4, 4);
+
+// The encryption scheme. The definitions are from ISO/IEC 23001-7:2016.
+enum class EncryptionScheme : uint32_t {
+  kUnencrypted = 0,
+  kCenc,  // 'cenc' subsample encryption using AES-CTR mode.
+  kCbcs   // 'cbcs' pattern encryption using AES-CBC mode.
+};
+CHECK_TYPE(EncryptionScheme, 4, 4);
+
+// The pattern used for pattern encryption. Note that ISO/IEC 23001-7:2016
+// defines each block to be 16-bytes.
+struct Pattern {
+  uint32_t crypt_byte_block;  // Count of the encrypted blocks.
+  uint32_t skip_byte_block;   // Count of the unencrypted blocks.
+};
+CHECK_TYPE(Pattern, 8, 8);
 
 // Time is defined as the number of seconds since the Epoch
 // (00:00:00 UTC, January 1, 1970), not including any added leap second.
 // Also see Time definition in spec: https://w3c.github.io/encrypted-media/#time
 // Note that Time is defined in millisecond accuracy in the spec but in second
 // accuracy here.
 typedef double Time;
 
@@ -145,93 +137,121 @@ typedef double Time;
 // After decryption, the decrypted bytes should be copied over the position
 // of the corresponding cipher bytes in the original buffer to form the output
 // buffer. Following the above example, the decrypted buffer should be:
 //
 // |<----- subsample1 ----->|<----- subsample2 ----->|<----- subsample3 ----->|
 // |   clear1   | decrypted1|  clear2  |  decrypted2 | clear3 |   decrypted3  |
 //
 struct SubsampleEntry {
-  SubsampleEntry(uint32_t clear_bytes, uint32_t cipher_bytes)
-      : clear_bytes(clear_bytes), cipher_bytes(cipher_bytes) {}
-
   uint32_t clear_bytes;
   uint32_t cipher_bytes;
 };
+CHECK_TYPE(SubsampleEntry, 8, 8);
 
 // Represents an input buffer to be decrypted (and possibly decoded). It does
 // not own any pointers in this struct. If |iv_size| = 0, the data is
 // unencrypted.
-struct InputBuffer {
-  InputBuffer()
-      : data(nullptr),
-        data_size(0),
-        key_id(nullptr),
-        key_id_size(0),
-        iv(nullptr),
-        iv_size(0),
-        subsamples(nullptr),
-        num_subsamples(0),
-        timestamp(0) {}
-
+// Deprecated: New CDM implementations should use InputBuffer_2.
+struct InputBuffer_1 {
   const uint8_t* data;  // Pointer to the beginning of the input data.
-  uint32_t data_size;  // Size (in bytes) of |data|.
+  uint32_t data_size;   // Size (in bytes) of |data|.
 
   const uint8_t* key_id;  // Key ID to identify the decryption key.
-  uint32_t key_id_size;  // Size (in bytes) of |key_id|.
+  uint32_t key_id_size;   // Size (in bytes) of |key_id|.
 
   const uint8_t* iv;  // Initialization vector.
-  uint32_t iv_size;  // Size (in bytes) of |iv|.
+  uint32_t iv_size;   // Size (in bytes) of |iv|.
 
   const struct SubsampleEntry* subsamples;
   uint32_t num_subsamples;  // Number of subsamples in |subsamples|.
 
   int64_t timestamp;  // Presentation timestamp in microseconds.
 };
+CHECK_TYPE(InputBuffer_1, 40, 72);
 
-struct AudioDecoderConfig {
-  enum AudioCodec {
-    kUnknownAudioCodec = 0,
-    kCodecVorbis,
-    kCodecAac
-  };
+// Represents an input buffer to be decrypted (and possibly decoded). It does
+// not own any pointers in this struct. If |encryption_scheme| = kUnencrypted,
+// the data is unencrypted.
+// Note that this struct is organized so that sizeof(InputBuffer_2)
+// equals the sum of sizeof() all members in both 32-bit and 64-bit compiles.
+// Padding has been added to keep the fields aligned.
+struct InputBuffer_2 {
+  const uint8_t* data;  // Pointer to the beginning of the input data.
+  uint32_t data_size;   // Size (in bytes) of |data|.
+
+  EncryptionScheme encryption_scheme;
+
+  const uint8_t* key_id;  // Key ID to identify the decryption key.
+  uint32_t key_id_size;   // Size (in bytes) of |key_id|.
+  uint32_t : 32;          // Padding.
 
-  AudioDecoderConfig()
-      : codec(kUnknownAudioCodec),
-        channel_count(0),
-        bits_per_channel(0),
-        samples_per_second(0),
-        extra_data(nullptr),
-        extra_data_size(0) {}
+  const uint8_t* iv;  // Initialization vector.
+  uint32_t iv_size;   // Size (in bytes) of |iv|.
+  uint32_t : 32;      // Padding.
+
+  const struct SubsampleEntry* subsamples;
+  uint32_t num_subsamples;  // Number of subsamples in |subsamples|.
+  uint32_t : 32;            // Padding.
 
+  // |pattern| is required if |encryption_scheme| specifies pattern encryption.
+  Pattern pattern;
+
+  int64_t timestamp;  // Presentation timestamp in microseconds.
+};
+CHECK_TYPE(InputBuffer_2, 64, 80);
+
+enum AudioCodec : uint32_t { kUnknownAudioCodec = 0, kCodecVorbis, kCodecAac };
+CHECK_TYPE(AudioCodec, 4, 4);
+
+// Deprecated: New CDM implementations should use AudioDecoderConfig_2.
+struct AudioDecoderConfig_1 {
   AudioCodec codec;
   int32_t channel_count;
   int32_t bits_per_channel;
   int32_t samples_per_second;
 
   // Optional byte data required to initialize audio decoders, such as the
   // vorbis setup header.
   uint8_t* extra_data;
   uint32_t extra_data_size;
 };
+CHECK_TYPE(AudioDecoderConfig_1, 24, 32);
+
+struct AudioDecoderConfig_2 {
+  AudioCodec codec;
+  int32_t channel_count;
+  int32_t bits_per_channel;
+  int32_t samples_per_second;
+
+  // Optional byte data required to initialize audio decoders, such as the
+  // vorbis setup header.
+  uint8_t* extra_data;
+  uint32_t extra_data_size;
+
+  // Encryption scheme.
+  EncryptionScheme encryption_scheme;
+};
+CHECK_TYPE(AudioDecoderConfig_2, 28, 32);
 
 // Supported sample formats for AudioFrames.
-enum AudioFormat {
+enum AudioFormat : uint32_t {
   kUnknownAudioFormat = 0,  // Unknown format value. Used for error reporting.
-  kAudioFormatU8,  // Interleaved unsigned 8-bit w/ bias of 128.
-  kAudioFormatS16,  // Interleaved signed 16-bit.
-  kAudioFormatS32,  // Interleaved signed 32-bit.
-  kAudioFormatF32,  // Interleaved float 32-bit.
-  kAudioFormatPlanarS16,  // Signed 16-bit planar.
-  kAudioFormatPlanarF32,  // Float 32-bit planar.
+  kAudioFormatU8,           // Interleaved unsigned 8-bit w/ bias of 128.
+  kAudioFormatS16,          // Interleaved signed 16-bit.
+  kAudioFormatS32,          // Interleaved signed 32-bit.
+  kAudioFormatF32,          // Interleaved float 32-bit.
+  kAudioFormatPlanarS16,    // Signed 16-bit planar.
+  kAudioFormatPlanarF32,    // Float 32-bit planar.
 };
+CHECK_TYPE(AudioFormat, 4, 4);
 
 // Surface formats based on FOURCC labels, see: http://www.fourcc.org/yuv.php
 // Values are chosen to be consistent with Chromium's VideoPixelFormat values.
-enum VideoFormat {
+enum VideoFormat : uint32_t {
   kUnknownVideoFormat = 0,  // Unknown format value. Used for error reporting.
   kYv12 = 1,                // 12bpp YVU planar 1x1 Y, 2x2 VU samples.
   kI420 = 2,                // 12bpp YUV planar 1x1 Y, 2x2 UV samples.
 
   // In the following formats, each sample uses 16-bit in storage, while the
   // sample value is stored in the least significant N bits where N is
   // specified by the number after "P". For example, for YUV420P9, each Y, U,
   // and V sample is stored in the least significant 9 bits in a 2-byte block.
@@ -240,75 +260,92 @@ enum VideoFormat {
   kYUV422P9 = 18,
   kYUV422P10 = 19,
   kYUV444P9 = 20,
   kYUV444P10 = 21,
   kYUV420P12 = 22,
   kYUV422P12 = 23,
   kYUV444P12 = 24,
 };
+CHECK_TYPE(VideoFormat, 4, 4);
 
 struct Size {
-  Size() : width(0), height(0) {}
-  Size(int32_t width, int32_t height) : width(width), height(height) {}
-
   int32_t width;
   int32_t height;
 };
+CHECK_TYPE(Size, 8, 8);
 
-struct VideoDecoderConfig {
-  enum VideoCodec {
-    kUnknownVideoCodec = 0,
-    kCodecVp8,
-    kCodecH264,
-    kCodecVp9
-  };
+enum VideoCodec : uint32_t {
+  kUnknownVideoCodec = 0,
+  kCodecVp8,
+  kCodecH264,
+  kCodecVp9
+};
+CHECK_TYPE(VideoCodec, 4, 4);
 
-  enum VideoCodecProfile {
-    kUnknownVideoCodecProfile = 0,
-    kProfileNotNeeded,
-    kH264ProfileBaseline,
-    kH264ProfileMain,
-    kH264ProfileExtended,
-    kH264ProfileHigh,
-    kH264ProfileHigh10,
-    kH264ProfileHigh422,
-    kH264ProfileHigh444Predictive,
-    // VP9 Profiles are only passed in starting from CDM_9.
-    kVP9Profile0,
-    kVP9Profile1,
-    kVP9Profile2,
-    kVP9Profile3
-  };
+enum VideoCodecProfile : uint32_t {
+  kUnknownVideoCodecProfile = 0,
+  kProfileNotNeeded,
+  kH264ProfileBaseline,
+  kH264ProfileMain,
+  kH264ProfileExtended,
+  kH264ProfileHigh,
+  kH264ProfileHigh10,
+  kH264ProfileHigh422,
+  kH264ProfileHigh444Predictive,
+  // VP9 Profiles are only passed in starting from CDM_9.
+  kVP9Profile0,
+  kVP9Profile1,
+  kVP9Profile2,
+  kVP9Profile3
+};
+CHECK_TYPE(VideoCodecProfile, 4, 4);
 
-  VideoDecoderConfig()
-      : codec(kUnknownVideoCodec),
-        profile(kUnknownVideoCodecProfile),
-        format(kUnknownVideoFormat),
-        extra_data(nullptr),
-        extra_data_size(0) {}
-
+// Deprecated: New CDM implementations should use VideoDecoderConfig_2.
+struct VideoDecoderConfig_1 {
   VideoCodec codec;
   VideoCodecProfile profile;
   VideoFormat format;
 
   // Width and height of video frame immediately post-decode. Not all pixels
   // in this region are valid.
   Size coded_size;
 
   // Optional byte data required to initialize video decoders, such as H.264
   // AAVC data.
   uint8_t* extra_data;
   uint32_t extra_data_size;
 };
+CHECK_TYPE(VideoDecoderConfig_1, 28, 40);
 
-enum StreamType {
-  kStreamTypeAudio = 0,
-  kStreamTypeVideo = 1
+// Note that this struct is organized so that sizeof(VideoDecoderConfig_2)
+// equals the sum of sizeof() all members in both 32-bit and 64-bit compiles.
+// Padding has been added to keep the fields aligned.
+struct VideoDecoderConfig_2 {
+  VideoCodec codec;
+  VideoCodecProfile profile;
+  VideoFormat format;
+  uint32_t : 32;  // Padding.
+
+  // Width and height of video frame immediately post-decode. Not all pixels
+  // in this region are valid.
+  Size coded_size;
+
+  // Optional byte data required to initialize video decoders, such as H.264
+  // AAVC data.
+  uint8_t* extra_data;
+  uint32_t extra_data_size;
+
+  // Encryption scheme.
+  EncryptionScheme encryption_scheme;
 };
+CHECK_TYPE(VideoDecoderConfig_2, 36, 40);
+
+enum StreamType : uint32_t { kStreamTypeAudio = 0, kStreamTypeVideo = 1 };
+CHECK_TYPE(StreamType, 4, 4);
 
 // Structure provided to ContentDecryptionModule::OnPlatformChallengeResponse()
 // after a platform challenge was initiated via Host::SendPlatformChallenge().
 // All values will be NULL / zero in the event of a challenge failure.
 struct PlatformChallengeResponse {
   // |challenge| provided during Host::SendPlatformChallenge() combined with
   // nonce data and signed with the platform's private key.
   const uint8_t* signed_data;
@@ -317,116 +354,205 @@ struct PlatformChallengeResponse {
   // RSASSA-PKCS1-v1_5-SHA256 signature of the |signed_data| block.
   const uint8_t* signed_data_signature;
   uint32_t signed_data_signature_length;
 
   // X.509 device specific certificate for the |service_id| requested.
   const uint8_t* platform_key_certificate;
   uint32_t platform_key_certificate_length;
 };
-
-// Used when passing arrays of binary data. Does not own the referenced data.
-struct BinaryData {
-  BinaryData() : data(nullptr), length(0) {}
-  const uint8_t* data;
-  uint32_t length;
-};
+CHECK_TYPE(PlatformChallengeResponse, 24, 48);
 
 // The current status of the associated key. The valid types are defined in the
 // spec: https://w3c.github.io/encrypted-media/#idl-def-MediaKeyStatus
-enum KeyStatus {
+enum KeyStatus : uint32_t {
   kUsable = 0,
   kInternalError = 1,
   kExpired = 2,
   kOutputRestricted = 3,
   kOutputDownscaled = 4,
   kStatusPending = 5,
   kReleased = 6
 };
+CHECK_TYPE(KeyStatus, 4, 4);
 
 // Used when passing arrays of key information. Does not own the referenced
 // data. |system_code| is an additional error code for unusable keys and
 // should be 0 when |status| == kUsable.
 struct KeyInformation {
-  KeyInformation()
-      : key_id(nullptr),
-        key_id_size(0),
-        status(kInternalError),
-        system_code(0) {}
   const uint8_t* key_id;
   uint32_t key_id_size;
   KeyStatus status;
   uint32_t system_code;
 };
+CHECK_TYPE(KeyInformation, 16, 24);
 
 // Supported output protection methods for use with EnableOutputProtection() and
 // returned by OnQueryOutputProtectionStatus().
-enum OutputProtectionMethods {
+enum OutputProtectionMethods : uint32_t {
   kProtectionNone = 0,
   kProtectionHDCP = 1 << 0
 };
+CHECK_TYPE(OutputProtectionMethods, 4, 4);
 
 // Connected output link types returned by OnQueryOutputProtectionStatus().
-enum OutputLinkTypes {
+enum OutputLinkTypes : uint32_t {
   kLinkTypeNone = 0,
   kLinkTypeUnknown = 1 << 0,
   kLinkTypeInternal = 1 << 1,
   kLinkTypeVGA = 1 << 2,
   kLinkTypeHDMI = 1 << 3,
   kLinkTypeDVI = 1 << 4,
   kLinkTypeDisplayPort = 1 << 5,
   kLinkTypeNetwork = 1 << 6
 };
+CHECK_TYPE(OutputLinkTypes, 4, 4);
 
 // Result of the QueryOutputProtectionStatus() call.
-enum QueryResult {
-  kQuerySucceeded = 0,
-  kQueryFailed
-};
+enum QueryResult : uint32_t { kQuerySucceeded = 0, kQueryFailed };
+CHECK_TYPE(QueryResult, 4, 4);
 
 // The Initialization Data Type. The valid types are defined in the spec:
-// http://w3c.github.io/encrypted-media/initdata-format-registry.html#registry
-enum InitDataType {
-  kCenc = 0,
-  kKeyIds = 1,
-  kWebM = 2
-};
+// https://w3c.github.io/encrypted-media/format-registry/initdata/index.html#registry
+enum InitDataType : uint32_t { kCenc = 0, kKeyIds = 1, kWebM = 2 };
+CHECK_TYPE(InitDataType, 4, 4);
 
 // The type of session to create. The valid types are defined in the spec:
 // https://w3c.github.io/encrypted-media/#idl-def-SessionType
-enum SessionType {
+enum SessionType : uint32_t {
   kTemporary = 0,
   kPersistentLicense = 1,
   kPersistentKeyRelease = 2
 };
+CHECK_TYPE(SessionType, 4, 4);
 
 // The type of the message event.  The valid types are defined in the spec:
 // https://w3c.github.io/encrypted-media/#idl-def-MediaKeyMessageType
-enum MessageType {
+enum MessageType : uint32_t {
   kLicenseRequest = 0,
   kLicenseRenewal = 1,
-  kLicenseRelease = 2
+  kLicenseRelease = 2,
+  // Only supported by Host_10 and later. On Host_9 and earlier, it's undefined
+  // behavior. For example, the host can drop the message or send it using
+  // other message type.
+  kIndividualizationRequest = 3
 };
+CHECK_TYPE(MessageType, 4, 4);
 
-enum HdcpVersion {
+enum HdcpVersion : uint32_t {
   kHdcpVersionNone,
   kHdcpVersion1_0,
   kHdcpVersion1_1,
   kHdcpVersion1_2,
   kHdcpVersion1_3,
   kHdcpVersion1_4,
   kHdcpVersion2_0,
   kHdcpVersion2_1,
   kHdcpVersion2_2
 };
+CHECK_TYPE(HdcpVersion, 4, 4);
 
 struct Policy {
-  Policy() : min_hdcp_version(kHdcpVersionNone) {}
+  HdcpVersion min_hdcp_version;
+};
+CHECK_TYPE(Policy, 4, 4);
+
+// Represents a buffer created by Allocator implementations.
+class CDM_CLASS_API Buffer {
+ public:
+  // Destroys the buffer in the same context as it was created.
+  virtual void Destroy() = 0;
+
+  virtual uint32_t Capacity() const = 0;
+  virtual uint8_t* Data() = 0;
+  virtual void SetSize(uint32_t size) = 0;
+  virtual uint32_t Size() const = 0;
+
+ protected:
+  Buffer() {}
+  virtual ~Buffer() {}
+
+ private:
+  Buffer(const Buffer&);
+  void operator=(const Buffer&);
+};
+
+// Represents a decrypted block that has not been decoded.
+class CDM_CLASS_API DecryptedBlock {
+ public:
+  virtual void SetDecryptedBuffer(Buffer* buffer) = 0;
+  virtual Buffer* DecryptedBuffer() = 0;
+
+  // TODO(tomfinegan): Figure out if timestamp is really needed. If it is not,
+  // we can just pass Buffer pointers around.
+  virtual void SetTimestamp(int64_t timestamp) = 0;
+  virtual int64_t Timestamp() const = 0;
+
+ protected:
+  DecryptedBlock() {}
+  virtual ~DecryptedBlock() {}
+};
+
+class CDM_CLASS_API VideoFrame {
+ public:
+  enum VideoPlane : uint32_t {
+    kYPlane = 0,
+    kUPlane = 1,
+    kVPlane = 2,
+    kMaxPlanes = 3,
+  };
 
-  HdcpVersion min_hdcp_version;
+  virtual void SetFormat(VideoFormat format) = 0;
+  virtual VideoFormat Format() const = 0;
+
+  virtual void SetSize(cdm::Size size) = 0;
+  virtual cdm::Size Size() const = 0;
+
+  virtual void SetFrameBuffer(Buffer* frame_buffer) = 0;
+  virtual Buffer* FrameBuffer() = 0;
+
+  virtual void SetPlaneOffset(VideoPlane plane, uint32_t offset) = 0;
+  virtual uint32_t PlaneOffset(VideoPlane plane) = 0;
+
+  virtual void SetStride(VideoPlane plane, uint32_t stride) = 0;
+  virtual uint32_t Stride(VideoPlane plane) = 0;
+
+  virtual void SetTimestamp(int64_t timestamp) = 0;
+  virtual int64_t Timestamp() const = 0;
+
+ protected:
+  VideoFrame() {}
+  virtual ~VideoFrame() {}
+};
+
+// Represents decrypted and decoded audio frames. AudioFrames can contain
+// multiple audio output buffers, which are serialized into this format:
+//
+// |<------------------- serialized audio buffer ------------------->|
+// | int64_t timestamp | int64_t length | length bytes of audio data |
+//
+// For example, with three audio output buffers, the AudioFrames will look
+// like this:
+//
+// |<----------------- AudioFrames ------------------>|
+// | audio buffer 0 | audio buffer 1 | audio buffer 2 |
+class CDM_CLASS_API AudioFrames {
+ public:
+  virtual void SetFrameBuffer(Buffer* buffer) = 0;
+  virtual Buffer* FrameBuffer() = 0;
+
+  // The CDM must call this method, providing a valid format, when providing
+  // frame buffers. Planar data should be stored end to end; e.g.,
+  // |ch1 sample1||ch1 sample2|....|ch1 sample_last||ch2 sample1|...
+  virtual void SetFormat(AudioFormat format) = 0;
+  virtual AudioFormat Format() const = 0;
+
+ protected:
+  AudioFrames() {}
+  virtual ~AudioFrames() {}
 };
 
 // FileIO interface provides a way for the CDM to store data in a file in
 // persistent storage. This interface aims only at providing basic read/write
 // capabilities and should not be used as a full fledged file IO API.
 // Each CDM and origin (e.g. HTTPS, "foo.example.com", 443) combination has
 // its own persistent storage. All instances of a given CDM associated with a
 // given origin share the same persistent storage.
@@ -471,236 +597,49 @@ class CDM_CLASS_API FileIO {
 };
 
 // Responses to FileIO calls. All responses will be called asynchronously.
 // When kError is returned, the FileIO object could be in an error state. All
 // following calls (other than Close()) could return kError. The CDM should
 // still call Close() to destroy the FileIO object.
 class CDM_CLASS_API FileIOClient {
  public:
-  enum Status {
-    kSuccess = 0,
-    kInUse,
-    kError
-  };
+  enum Status : uint32_t { kSuccess = 0, kInUse, kError };
 
   // Response to a FileIO::Open() call with the open |status|.
   virtual void OnOpenComplete(Status status) = 0;
 
   // Response to a FileIO::Read() call to provide |data_size| bytes of |data|
   // read from the file.
   // - kSuccess indicates that all contents of the file has been successfully
   //   read. In this case, 0 |data_size| means that the file is empty.
   // - kInUse indicates that there are other read/write operations pending.
   // - kError indicates read failure, e.g. the storage is not open or cannot be
   //   fully read.
   virtual void OnReadComplete(Status status,
-                              const uint8_t* data, uint32_t data_size) = 0;
+                              const uint8_t* data,
+                              uint32_t data_size) = 0;
 
   // Response to a FileIO::Write() call.
   // - kSuccess indicates that all the data has been written into the file
   //   successfully.
   // - kInUse indicates that there are other read/write operations pending.
   // - kError indicates write failure, e.g. the storage is not open or cannot be
   //   fully written. Upon write failure, the contents of the file should be
   //   regarded as corrupt and should not used.
   virtual void OnWriteComplete(Status status) = 0;
 
  protected:
   FileIOClient() {}
   virtual ~FileIOClient() {}
 };
 
-// ContentDecryptionModule interface that all CDMs need to implement.
-// The interface is versioned for backward compatibility.
-// Note: ContentDecryptionModule implementations must use the allocator
-// provided in CreateCdmInstance() to allocate any Buffer that needs to
-// be passed back to the caller. Implementations must call Buffer::Destroy()
-// when a Buffer is created that will never be returned to the caller.
-class CDM_CLASS_API ContentDecryptionModule_8 {
- public:
-  static const int kVersion = 8;
-  typedef Host_8 Host;
-
-  // Initializes the CDM instance, providing information about permitted
-  // functionalities.
-  // If |allow_distinctive_identifier| is false, messages from the CDM,
-  // such as message events, must not contain a Distinctive Identifier,
-  // even in an encrypted form.
-  // If |allow_persistent_state| is false, the CDM must not attempt to
-  // persist state. Calls to CreateFileIO() will fail.
-  virtual void Initialize(bool allow_distinctive_identifier,
-                          bool allow_persistent_state) = 0;
-
-  // SetServerCertificate(), CreateSessionAndGenerateRequest(), LoadSession(),
-  // UpdateSession(), CloseSession(), and RemoveSession() all accept a
-  // |promise_id|, which must be passed to the completion Host method
-  // (e.g. Host::OnResolveNewSessionPromise()).
-
-  // Provides a server certificate to be used to encrypt messages to the
-  // license server. The CDM must respond by calling either
-  // Host::OnResolvePromise() or Host::OnRejectPromise().
-  virtual void SetServerCertificate(uint32_t promise_id,
-                                    const uint8_t* server_certificate_data,
-                                    uint32_t server_certificate_data_size) = 0;
-
-  // Creates a session given |session_type|, |init_data_type|, and |init_data|.
-  // The CDM must respond by calling either Host::OnResolveNewSessionPromise()
-  // or Host::OnRejectPromise().
-  virtual void CreateSessionAndGenerateRequest(uint32_t promise_id,
-                                               SessionType session_type,
-                                               InitDataType init_data_type,
-                                               const uint8_t* init_data,
-                                               uint32_t init_data_size) = 0;
-
-  // Loads the session of type |session_type| specified by |session_id|.
-  // The CDM must respond by calling either Host::OnResolveNewSessionPromise()
-  // or Host::OnRejectPromise(). If the session is not found, call
-  // Host::OnResolveNewSessionPromise() with session_id = NULL.
-  virtual void LoadSession(uint32_t promise_id,
-                           SessionType session_type,
-                           const char* session_id,
-                           uint32_t session_id_size) = 0;
-
-  // Updates the session with |response|. The CDM must respond by calling
-  // either Host::OnResolvePromise() or Host::OnRejectPromise().
-  virtual void UpdateSession(uint32_t promise_id,
-                             const char* session_id,
-                             uint32_t session_id_size,
-                             const uint8_t* response,
-                             uint32_t response_size) = 0;
-
-  // Requests that the CDM close the session. The CDM must respond by calling
-  // either Host::OnResolvePromise() or Host::OnRejectPromise() when the request
-  // has been processed. This may be before the session is closed. Once the
-  // session is closed, Host::OnSessionClosed() must also be called.
-  virtual void CloseSession(uint32_t promise_id,
-                            const char* session_id,
-                            uint32_t session_id_size) = 0;
-
-  // Removes any stored session data associated with this session. Will only be
-  // called for persistent sessions. The CDM must respond by calling either
-  // Host::OnResolvePromise() or Host::OnRejectPromise() when the request has
-  // been processed.
-  virtual void RemoveSession(uint32_t promise_id,
-                             const char* session_id,
-                             uint32_t session_id_size) = 0;
-
-  // Performs scheduled operation with |context| when the timer fires.
-  virtual void TimerExpired(void* context) = 0;
-
-  // Decrypts the |encrypted_buffer|.
-  //
-  // Returns kSuccess if decryption succeeded, in which case the callee
-  // should have filled the |decrypted_buffer| and passed the ownership of
-  // |data| in |decrypted_buffer| to the caller.
-  // Returns kNoKey if the CDM did not have the necessary decryption key
-  // to decrypt.
-  // Returns kDecryptError if any other error happened.
-  // If the return value is not kSuccess, |decrypted_buffer| should be ignored
-  // by the caller.
-  virtual Status Decrypt(const InputBuffer& encrypted_buffer,
-                         DecryptedBlock* decrypted_buffer) = 0;
-
-  // Initializes the CDM audio decoder with |audio_decoder_config|. This
-  // function must be called before DecryptAndDecodeSamples() is called.
-  //
-  // Returns kSuccess if the |audio_decoder_config| is supported and the CDM
-  // audio decoder is successfully initialized.
-  // Returns kSessionError if |audio_decoder_config| is not supported. The CDM
-  // may still be able to do Decrypt().
-  // Returns kDeferredInitialization if the CDM is not ready to initialize the
-  // decoder at this time. Must call Host::OnDeferredInitializationDone() once
-  // initialization is complete.
-  virtual Status InitializeAudioDecoder(
-      const AudioDecoderConfig& audio_decoder_config) = 0;
-
-  // Initializes the CDM video decoder with |video_decoder_config|. This
-  // function must be called before DecryptAndDecodeFrame() is called.
-  //
-  // Returns kSuccess if the |video_decoder_config| is supported and the CDM
-  // video decoder is successfully initialized.
-  // Returns kSessionError if |video_decoder_config| is not supported. The CDM
-  // may still be able to do Decrypt().
-  // Returns kDeferredInitialization if the CDM is not ready to initialize the
-  // decoder at this time. Must call Host::OnDeferredInitializationDone() once
-  // initialization is complete.
-  virtual Status InitializeVideoDecoder(
-      const VideoDecoderConfig& video_decoder_config) = 0;
-
-  // De-initializes the CDM decoder and sets it to an uninitialized state. The
-  // caller can initialize the decoder again after this call to re-initialize
-  // it. This can be used to reconfigure the decoder if the configuration
-  // changes.
-  virtual void DeinitializeDecoder(StreamType decoder_type) = 0;
-
-  // Resets the CDM decoder to an initialized clean state. All internal buffers
-  // MUST be flushed.
-  virtual void ResetDecoder(StreamType decoder_type) = 0;
-
-  // Decrypts the |encrypted_buffer| and decodes the decrypted buffer into a
-  // |video_frame|. Upon end-of-stream, the caller should call this function
-  // repeatedly with empty |encrypted_buffer| (|data| == NULL) until only empty
-  // |video_frame| (|format| == kEmptyVideoFrame) is produced.
-  //
-  // Returns kSuccess if decryption and decoding both succeeded, in which case
-  // the callee will have filled the |video_frame| and passed the ownership of
-  // |frame_buffer| in |video_frame| to the caller.
-  // Returns kNoKey if the CDM did not have the necessary decryption key
-  // to decrypt.
-  // Returns kNeedMoreData if more data was needed by the decoder to generate
-  // a decoded frame (e.g. during initialization and end-of-stream).
-  // Returns kDecryptError if any decryption error happened.
-  // Returns kDecodeError if any decoding error happened.
-  // If the return value is not kSuccess, |video_frame| should be ignored by
-  // the caller.
-  virtual Status DecryptAndDecodeFrame(const InputBuffer& encrypted_buffer,
-                                       VideoFrame* video_frame) = 0;
-
-  // Decrypts the |encrypted_buffer| and decodes the decrypted buffer into
-  // |audio_frames|. Upon end-of-stream, the caller should call this function
-  // repeatedly with empty |encrypted_buffer| (|data| == NULL) until only empty
-  // |audio_frames| is produced.
-  //
-  // Returns kSuccess if decryption and decoding both succeeded, in which case
-  // the callee will have filled |audio_frames| and passed the ownership of
-  // |data| in |audio_frames| to the caller.
-  // Returns kNoKey if the CDM did not have the necessary decryption key
-  // to decrypt.
-  // Returns kNeedMoreData if more data was needed by the decoder to generate
-  // audio samples (e.g. during initialization and end-of-stream).
-  // Returns kDecryptError if any decryption error happened.
-  // Returns kDecodeError if any decoding error happened.
-  // If the return value is not kSuccess, |audio_frames| should be ignored by
-  // the caller.
-  virtual Status DecryptAndDecodeSamples(const InputBuffer& encrypted_buffer,
-                                         AudioFrames* audio_frames) = 0;
-
-  // Called by the host after a platform challenge was initiated via
-  // Host::SendPlatformChallenge().
-  virtual void OnPlatformChallengeResponse(
-      const PlatformChallengeResponse& response) = 0;
-
-  // Called by the host after a call to Host::QueryOutputProtectionStatus(). The
-  // |link_mask| is a bit mask of OutputLinkTypes and |output_protection_mask|
-  // is a bit mask of OutputProtectionMethods. If |result| is kQueryFailed,
-  // then |link_mask| and |output_protection_mask| are undefined and should
-  // be ignored.
-  virtual void OnQueryOutputProtectionStatus(
-      QueryResult result,
-      uint32_t link_mask,
-      uint32_t output_protection_mask) = 0;
-
-  // Destroys the object in the same context as it was created.
-  virtual void Destroy() = 0;
-
- protected:
-  ContentDecryptionModule_8() {}
-  virtual ~ContentDecryptionModule_8() {}
-};
+class CDM_CLASS_API Host_9;
+class CDM_CLASS_API Host_10;
+class CDM_CLASS_API Host_11;
 
 // ContentDecryptionModule interface that all CDMs need to implement.
 // The interface is versioned for backward compatibility.
 // Note: ContentDecryptionModule implementations must use the allocator
 // provided in CreateCdmInstance() to allocate any Buffer that needs to
 // be passed back to the caller. Implementations must call Buffer::Destroy()
 // when a Buffer is created that will never be returned to the caller.
 class CDM_CLASS_API ContentDecryptionModule_9 {
@@ -787,44 +726,44 @@ class CDM_CLASS_API ContentDecryptionMod
   // Returns kSuccess if decryption succeeded, in which case the callee
   // should have filled the |decrypted_buffer| and passed the ownership of
   // |data| in |decrypted_buffer| to the caller.
   // Returns kNoKey if the CDM did not have the necessary decryption key
   // to decrypt.
   // Returns kDecryptError if any other error happened.
   // If the return value is not kSuccess, |decrypted_buffer| should be ignored
   // by the caller.
-  virtual Status Decrypt(const InputBuffer& encrypted_buffer,
+  virtual Status Decrypt(const InputBuffer_1& encrypted_buffer,
                          DecryptedBlock* decrypted_buffer) = 0;
 
   // Initializes the CDM audio decoder with |audio_decoder_config|. This
   // function must be called before DecryptAndDecodeSamples() is called.
   //
   // Returns kSuccess if the |audio_decoder_config| is supported and the CDM
   // audio decoder is successfully initialized.
   // Returns kInitializationError if |audio_decoder_config| is not supported.
   // The CDM may still be able to do Decrypt().
   // Returns kDeferredInitialization if the CDM is not ready to initialize the
   // decoder at this time. Must call Host::OnDeferredInitializationDone() once
   // initialization is complete.
   virtual Status InitializeAudioDecoder(
-      const AudioDecoderConfig& audio_decoder_config) = 0;
+      const AudioDecoderConfig_1& audio_decoder_config) = 0;
 
   // Initializes the CDM video decoder with |video_decoder_config|. This
   // function must be called before DecryptAndDecodeFrame() is called.
   //
   // Returns kSuccess if the |video_decoder_config| is supported and the CDM
   // video decoder is successfully initialized.
   // Returns kInitializationError if |video_decoder_config| is not supported.
   // The CDM may still be able to do Decrypt().
   // Returns kDeferredInitialization if the CDM is not ready to initialize the
   // decoder at this time. Must call Host::OnDeferredInitializationDone() once
   // initialization is complete.
   virtual Status InitializeVideoDecoder(
-      const VideoDecoderConfig& video_decoder_config) = 0;
+      const VideoDecoderConfig_1& video_decoder_config) = 0;
 
   // De-initializes the CDM decoder and sets it to an uninitialized state. The
   // caller can initialize the decoder again after this call to re-initialize
   // it. This can be used to reconfigure the decoder if the configuration
   // changes.
   virtual void DeinitializeDecoder(StreamType decoder_type) = 0;
 
   // Resets the CDM decoder to an initialized clean state. All internal buffers
@@ -842,17 +781,17 @@ class CDM_CLASS_API ContentDecryptionMod
   // Returns kNoKey if the CDM did not have the necessary decryption key
   // to decrypt.
   // Returns kNeedMoreData if more data was needed by the decoder to generate
   // a decoded frame (e.g. during initialization and end-of-stream).
   // Returns kDecryptError if any decryption error happened.
   // Returns kDecodeError if any decoding error happened.
   // If the return value is not kSuccess, |video_frame| should be ignored by
   // the caller.
-  virtual Status DecryptAndDecodeFrame(const InputBuffer& encrypted_buffer,
+  virtual Status DecryptAndDecodeFrame(const InputBuffer_1& encrypted_buffer,
                                        VideoFrame* video_frame) = 0;
 
   // Decrypts the |encrypted_buffer| and decodes the decrypted buffer into
   // |audio_frames|. Upon end-of-stream, the caller should call this function
   // repeatedly with empty |encrypted_buffer| (|data| == NULL) until only empty
   // |audio_frames| is produced.
   //
   // Returns kSuccess if decryption and decoding both succeeded, in which case
@@ -861,17 +800,17 @@ class CDM_CLASS_API ContentDecryptionMod
   // Returns kNoKey if the CDM did not have the necessary decryption key
   // to decrypt.
   // Returns kNeedMoreData if more data was needed by the decoder to generate
   // audio samples (e.g. during initialization and end-of-stream).
   // Returns kDecryptError if any decryption error happened.
   // Returns kDecodeError if any decoding error happened.
   // If the return value is not kSuccess, |audio_frames| should be ignored by
   // the caller.
-  virtual Status DecryptAndDecodeSamples(const InputBuffer& encrypted_buffer,
+  virtual Status DecryptAndDecodeSamples(const InputBuffer_1& encrypted_buffer,
                                          AudioFrames* audio_frames) = 0;
 
   // Called by the host after a platform challenge was initiated via
   // Host::SendPlatformChallenge().
   virtual void OnPlatformChallengeResponse(
       const PlatformChallengeResponse& response) = 0;
 
   // Called by the host after a call to Host::QueryOutputProtectionStatus(). The
@@ -899,175 +838,456 @@ class CDM_CLASS_API ContentDecryptionMod
   // Destroys the object in the same context as it was created.
   virtual void Destroy() = 0;
 
  protected:
   ContentDecryptionModule_9() {}
   virtual ~ContentDecryptionModule_9() {}
 };
 
-typedef ContentDecryptionModule_9 ContentDecryptionModule;
+// ContentDecryptionModule interface that all CDMs need to implement.
+// The interface is versioned for backward compatibility.
+// Note: ContentDecryptionModule implementations must use the allocator
+// provided in CreateCdmInstance() to allocate any Buffer that needs to
+// be passed back to the caller. Implementations must call Buffer::Destroy()
+// when a Buffer is created that will never be returned to the caller.
+class CDM_CLASS_API ContentDecryptionModule_10 {
+ public:
+  static const int kVersion = 10;
+  static const bool kIsStable = true;
+  typedef Host_10 Host;
+
+  // Initializes the CDM instance, providing information about permitted
+  // functionalities. The CDM must respond by calling Host::OnInitialized()
+  // with whether the initialization succeeded. No other calls will be made by
+  // the host before Host::OnInitialized() returns.
+  // If |allow_distinctive_identifier| is false, messages from the CDM,
+  // such as message events, must not contain a Distinctive Identifier,
+  // even in an encrypted form.
+  // If |allow_persistent_state| is false, the CDM must not attempt to
+  // persist state. Calls to CreateFileIO() will fail.
+  // If |use_hw_secure_codecs| is true, the CDM must ensure the decryption key
+  // and video buffers (compressed and uncompressed) are securely protected by
+  // hardware.
+  virtual void Initialize(bool allow_distinctive_identifier,
+                          bool allow_persistent_state,
+                          bool use_hw_secure_codecs) = 0;
+
+  // Gets the key status if the CDM has a hypothetical key with the |policy|.
+  // The CDM must respond by calling either Host::OnResolveKeyStatusPromise()
+  // with the result key status or Host::OnRejectPromise() if an unexpected
+  // error happened or this method is not supported.
+  virtual void GetStatusForPolicy(uint32_t promise_id,
+                                  const Policy& policy) = 0;
+
+  // SetServerCertificate(), CreateSessionAndGenerateRequest(), LoadSession(),
+  // UpdateSession(), CloseSession(), and RemoveSession() all accept a
+  // |promise_id|, which must be passed to the completion Host method
+  // (e.g. Host::OnResolveNewSessionPromise()).
+
+  // Provides a server certificate to be used to encrypt messages to the
+  // license server. The CDM must respond by calling either
+  // Host::OnResolvePromise() or Host::OnRejectPromise().
+  // If the CDM does not support server certificates, the promise should be
+  // rejected with kExceptionNotSupportedError. If |server_certificate_data|
+  // is empty, reject with kExceptionTypeError. Any other error should be
+  // rejected with kExceptionInvalidStateError or kExceptionQuotaExceededError.
+  // TODO(crbug.com/796417): Add support for the promise to return true or
+  // false, rather than using kExceptionNotSupportedError to mean false.
+  virtual void SetServerCertificate(uint32_t promise_id,
+                                    const uint8_t* server_certificate_data,
+                                    uint32_t server_certificate_data_size) = 0;
+
+  // Creates a session given |session_type|, |init_data_type|, and |init_data|.
+  // The CDM must respond by calling either Host::OnResolveNewSessionPromise()
+  // or Host::OnRejectPromise().
+  virtual void CreateSessionAndGenerateRequest(uint32_t promise_id,
+                                               SessionType session_type,
+                                               InitDataType init_data_type,
+                                               const uint8_t* init_data,
+                                               uint32_t init_data_size) = 0;
+
+  // Loads the session of type |session_type| specified by |session_id|.
+  // The CDM must respond by calling either Host::OnResolveNewSessionPromise()
+  // or Host::OnRejectPromise(). If the session is not found, call
+  // Host::OnResolveNewSessionPromise() with session_id = NULL.
+  virtual void LoadSession(uint32_t promise_id,
+                           SessionType session_type,
+                           const char* session_id,
+                           uint32_t session_id_size) = 0;
+
+  // Updates the session with |response|. The CDM must respond by calling
+  // either Host::OnResolvePromise() or Host::OnRejectPromise().
+  virtual void UpdateSession(uint32_t promise_id,
+                             const char* session_id,
+                             uint32_t session_id_size,
+                             const uint8_t* response,
+                             uint32_t response_size) = 0;
+
+  // Requests that the CDM close the session. The CDM must respond by calling
+  // either Host::OnResolvePromise() or Host::OnRejectPromise() when the request
+  // has been processed. This may be before the session is closed. Once the
+  // session is closed, Host::OnSessionClosed() must also be called.
+  virtual void CloseSession(uint32_t promise_id,
+                            const char* session_id,
+                            uint32_t session_id_size) = 0;
+
+  // Removes any stored session data associated with this session. Will only be
+  // called for persistent sessions. The CDM must respond by calling either
+  // Host::OnResolvePromise() or Host::OnRejectPromise() when the request has
+  // been processed.
+  virtual void RemoveSession(uint32_t promise_id,
+                             const char* session_id,
+                             uint32_t session_id_size) = 0;
+
+  // Performs scheduled operation with |context| when the timer fires.
+  virtual void TimerExpired(void* context) = 0;
 
-// Represents a buffer created by Allocator implementations.
-class CDM_CLASS_API Buffer {
- public:
-  // Destroys the buffer in the same context as it was created.
+  // Decrypts the |encrypted_buffer|.
+  //
+  // Returns kSuccess if decryption succeeded, in which case the callee
+  // should have filled the |decrypted_buffer| and passed the ownership of
+  // |data| in |decrypted_buffer| to the caller.
+  // Returns kNoKey if the CDM did not have the necessary decryption key
+  // to decrypt.
+  // Returns kDecryptError if any other error happened.
+  // If the return value is not kSuccess, |decrypted_buffer| should be ignored
+  // by the caller.
+  virtual Status Decrypt(const InputBuffer_2& encrypted_buffer,
+                         DecryptedBlock* decrypted_buffer) = 0;
+
+  // Initializes the CDM audio decoder with |audio_decoder_config|. This
+  // function must be called before DecryptAndDecodeSamples() is called.
+  //
+  // Returns kSuccess if the |audio_decoder_config| is supported and the CDM
+  // audio decoder is successfully initialized.
+  // Returns kInitializationError if |audio_decoder_config| is not supported.
+  // The CDM may still be able to do Decrypt().
+  // Returns kDeferredInitialization if the CDM is not ready to initialize the
+  // decoder at this time. Must call Host::OnDeferredInitializationDone() once
+  // initialization is complete.
+  virtual Status InitializeAudioDecoder(
+      const AudioDecoderConfig_2& audio_decoder_config) = 0;
+
+  // Initializes the CDM video decoder with |video_decoder_config|. This
+  // function must be called before DecryptAndDecodeFrame() is called.
+  //
+  // Returns kSuccess if the |video_decoder_config| is supported and the CDM
+  // video decoder is successfully initialized.
+  // Returns kInitializationError if |video_decoder_config| is not supported.
+  // The CDM may still be able to do Decrypt().
+  // Returns kDeferredInitialization if the CDM is not ready to initialize the
+  // decoder at this time. Must call Host::OnDeferredInitializationDone() once
+  // initialization is complete.
+  virtual Status InitializeVideoDecoder(
+      const VideoDecoderConfig_2& video_decoder_config) = 0;
+
+  // De-initializes the CDM decoder and sets it to an uninitialized state. The
+  // caller can initialize the decoder again after this call to re-initialize
+  // it. This can be used to reconfigure the decoder if the configuration
+  // changes.
+  virtual void DeinitializeDecoder(StreamType decoder_type) = 0;
+
+  // Resets the CDM decoder to an initialized clean state. All internal buffers
+  // MUST be flushed.
+  virtual void ResetDecoder(StreamType decoder_type) = 0;
+
+  // Decrypts the |encrypted_buffer| and decodes the decrypted buffer into a
+  // |video_frame|. Upon end-of-stream, the caller should call this function
+  // repeatedly with empty |encrypted_buffer| (|data| == NULL) until only empty
+  // |video_frame| (|format| == kEmptyVideoFrame) is produced.
+  //
+  // Returns kSuccess if decryption and decoding both succeeded, in which case
+  // the callee will have filled the |video_frame| and passed the ownership of
+  // |frame_buffer| in |video_frame| to the caller.
+  // Returns kNoKey if the CDM did not have the necessary decryption key
+  // to decrypt.
+  // Returns kNeedMoreData if more data was needed by the decoder to generate
+  // a decoded frame (e.g. during initialization and end-of-stream).
+  // Returns kDecryptError if any decryption error happened.
+  // Returns kDecodeError if any decoding error happened.
+  // If the return value is not kSuccess, |video_frame| should be ignored by
+  // the caller.
+  virtual Status DecryptAndDecodeFrame(const InputBuffer_2& encrypted_buffer,
+                                       VideoFrame* video_frame) = 0;
+
+  // Decrypts the |encrypted_buffer| and decodes the decrypted buffer into
+  // |audio_frames|. Upon end-of-stream, the caller should call this function
+  // repeatedly with empty |encrypted_buffer| (|data| == NULL) until only empty
+  // |audio_frames| is produced.
+  //
+  // Returns kSuccess if decryption and decoding both succeeded, in which case
+  // the callee will have filled |audio_frames| and passed the ownership of
+  // |data| in |audio_frames| to the caller.
+  // Returns kNoKey if the CDM did not have the necessary decryption key
+  // to decrypt.
+  // Returns kNeedMoreData if more data was needed by the decoder to generate
+  // audio samples (e.g. during initialization and end-of-stream).
+  // Returns kDecryptError if any decryption error happened.
+  // Returns kDecodeError if any decoding error happened.
+  // If the return value is not kSuccess, |audio_frames| should be ignored by
+  // the caller.
+  virtual Status DecryptAndDecodeSamples(const InputBuffer_2& encrypted_buffer,
+                                         AudioFrames* audio_frames) = 0;
+
+  // Called by the host after a platform challenge was initiated via
+  // Host::SendPlatformChallenge().
+  virtual void OnPlatformChallengeResponse(
+      const PlatformChallengeResponse& response) = 0;
+
+  // Called by the host after a call to Host::QueryOutputProtectionStatus(). The
+  // |link_mask| is a bit mask of OutputLinkTypes and |output_protection_mask|
+  // is a bit mask of OutputProtectionMethods. If |result| is kQueryFailed,
+  // then |link_mask| and |output_protection_mask| are undefined and should
+  // be ignored.
+  virtual void OnQueryOutputProtectionStatus(
+      QueryResult result,
+      uint32_t link_mask,
+      uint32_t output_protection_mask) = 0;
+
+  // Called by the host after a call to Host::RequestStorageId(). If the
+  // version of the storage ID requested is available, |storage_id| and
+  // |storage_id_size| are set appropriately. |version| will be the same as
+  // what was requested, unless 0 (latest) was requested, in which case
+  // |version| will be the actual version number for the |storage_id| returned.
+  // If the requested version is not available, null/zero will be provided as
+  // |storage_id| and |storage_id_size|, respectively, and |version| should be
+  // ignored.
+  virtual void OnStorageId(uint32_t version,
+                           const uint8_t* storage_id,
+                           uint32_t storage_id_size) = 0;
+
+  // Destroys the object in the same context as it was created.
   virtual void Destroy() = 0;
 
-  virtual uint32_t Capacity() const = 0;
-  virtual uint8_t* Data() = 0;
-  virtual void SetSize(uint32_t size) = 0;
-  virtual uint32_t Size() const = 0;
-
  protected:
-  Buffer() {}
-  virtual ~Buffer() {}
-
- private:
-  Buffer(const Buffer&);
-  void operator=(const Buffer&);
+  ContentDecryptionModule_10() {}
+  virtual ~ContentDecryptionModule_10() {}
 };
 
-class CDM_CLASS_API Host_8 {
+// ----- Note: CDM interface(s) below still in development and not stable! -----
+
+// ContentDecryptionModule interface that all CDMs need to implement.
+// The interface is versioned for backward compatibility.
+// Note: ContentDecryptionModule implementations must use the allocator
+// provided in CreateCdmInstance() to allocate any Buffer that needs to
+// be passed back to the caller. Implementations must call Buffer::Destroy()
+// when a Buffer is created that will never be returned to the caller.
+class CDM_CLASS_API ContentDecryptionModule_11 {
  public:
-  static const int kVersion = 8;
+  static const int kVersion = 11;
+  static const bool kIsStable = false;
+  typedef Host_11 Host;
 
-  // Returns a Buffer* containing non-zero members upon success, or NULL on
-  // failure. The caller owns the Buffer* after this call. The buffer is not
-  // guaranteed to be zero initialized. The capacity of the allocated Buffer
-  // is guaranteed to be not less than |capacity|.
-  virtual Buffer* Allocate(uint32_t capacity) = 0;
+  // Initializes the CDM instance, providing information about permitted
+  // functionalities. The CDM must respond by calling Host::OnInitialized()
+  // with whether the initialization succeeded. No other calls will be made by
+  // the host before Host::OnInitialized() returns.
+  // If |allow_distinctive_identifier| is false, messages from the CDM,
+  // such as message events, must not contain a Distinctive Identifier,
+  // even in an encrypted form.
+  // If |allow_persistent_state| is false, the CDM must not attempt to
+  // persist state. Calls to CreateFileIO() will fail.
+  // If |use_hw_secure_codecs| is true, the CDM must ensure the decryption key
+  // and video buffers (compressed and uncompressed) are securely protected by
+  // hardware.
+  virtual void Initialize(bool allow_distinctive_identifier,
+                          bool allow_persistent_state,
+                          bool use_hw_secure_codecs) = 0;
 
-  // Requests the host to call ContentDecryptionModule::TimerFired() |delay_ms|
-  // from now with |context|.
-  virtual void SetTimer(int64_t delay_ms, void* context) = 0;
+  // Gets the key status if the CDM has a hypothetical key with the |policy|.
+  // The CDM must respond by calling either Host::OnResolveKeyStatusPromise()
+  // with the result key status or Host::OnRejectPromise() if an unexpected
+  // error happened or this method is not supported.
+  virtual void GetStatusForPolicy(uint32_t promise_id,
+                                  const Policy& policy) = 0;
 
-  // Returns the current wall time.
-  virtual Time GetCurrentWallTime() = 0;
+  // SetServerCertificate(), CreateSessionAndGenerateRequest(), LoadSession(),
+  // UpdateSession(), CloseSession(), and RemoveSession() all accept a
+  // |promise_id|, which must be passed to the completion Host method
+  // (e.g. Host::OnResolveNewSessionPromise()).
 
-  // Called by the CDM when a session is created or loaded and the value for the
-  // MediaKeySession's sessionId attribute is available (|session_id|).
-  // This must be called before OnSessionMessage() or
-  // OnSessionKeysChange() is called for the same session. |session_id_size|
-  // should not include null termination.
-  // When called in response to LoadSession(), the |session_id| must be the
-  // same as the |session_id| passed in LoadSession(), or NULL if the
-  // session could not be loaded.
-  virtual void OnResolveNewSessionPromise(uint32_t promise_id,
-                                          const char* session_id,
-                                          uint32_t session_id_size) = 0;
+  // Provides a server certificate to be used to encrypt messages to the
+  // license server. The CDM must respond by calling either
+  // Host::OnResolvePromise() or Host::OnRejectPromise().
+  // If the CDM does not support server certificates, the promise should be
+  // rejected with kExceptionNotSupportedError. If |server_certificate_data|
+  // is empty, reject with kExceptionTypeError. Any other error should be
+  // rejected with kExceptionInvalidStateError or kExceptionQuotaExceededError.
+  // TODO(crbug.com/796417): Add support for the promise to return true or
+  // false, rather than using kExceptionNotSupportedError to mean false.
+  virtual void SetServerCertificate(uint32_t promise_id,
+                                    const uint8_t* server_certificate_data,
+                                    uint32_t server_certificate_data_size) = 0;
 
-  // Called by the CDM when a session is updated or released.
-  virtual void OnResolvePromise(uint32_t promise_id) = 0;
+  // Creates a session given |session_type|, |init_data_type|, and |init_data|.
+  // The CDM must respond by calling either Host::OnResolveNewSessionPromise()
+  // or Host::OnRejectPromise().
+  virtual void CreateSessionAndGenerateRequest(uint32_t promise_id,
+                                               SessionType session_type,
+                                               InitDataType init_data_type,
+                                               const uint8_t* init_data,
+                                               uint32_t init_data_size) = 0;
 
-  // Called by the CDM when an error occurs as a result of one of the
-  // ContentDecryptionModule calls that accept a |promise_id|.
-  // |error| must be specified, |error_message| and |system_code|
-  // are optional. |error_message_size| should not include null termination.
-  virtual void OnRejectPromise(uint32_t promise_id,
-                               Error error,
-                               uint32_t system_code,
-                               const char* error_message,
-                               uint32_t error_message_size) = 0;
+  // Loads the session of type |session_type| specified by |session_id|.
+  // The CDM must respond by calling either Host::OnResolveNewSessionPromise()
+  // or Host::OnRejectPromise(). If the session is not found, call
+  // Host::OnResolveNewSessionPromise() with session_id = NULL.
+  virtual void LoadSession(uint32_t promise_id,
+                           SessionType session_type,
+                           const char* session_id,
+                           uint32_t session_id_size) = 0;
+
+  // Updates the session with |response|. The CDM must respond by calling
+  // either Host::OnResolvePromise() or Host::OnRejectPromise().
+  virtual void UpdateSession(uint32_t promise_id,
+                             const char* session_id,
+                             uint32_t session_id_size,
+                             const uint8_t* response,
+                             uint32_t response_size) = 0;
 
-  // Called by the CDM when it has a message for session |session_id|.
-  // Size parameters should not include null termination.
-  // |legacy_destination_url| is only for supporting the prefixed EME API and
-  // is ignored by unprefixed EME. It should only be non-null if |message_type|
-  // is kLicenseRenewal.
-  virtual void OnSessionMessage(const char* session_id,
-                                uint32_t session_id_size,
-                                MessageType message_type,
-                                const char* message,
-                                uint32_t message_size,
-                                const char* legacy_destination_url,
-                                uint32_t legacy_destination_url_length) = 0;
+  // Requests that the CDM close the session. The CDM must respond by calling
+  // either Host::OnResolvePromise() or Host::OnRejectPromise() when the request
+  // has been processed. This may be before the session is closed. Once the
+  // session is closed, Host::OnSessionClosed() must also be called.
+  virtual void CloseSession(uint32_t promise_id,
+                            const char* session_id,
+                            uint32_t session_id_size) = 0;
+
+  // Removes any stored session data associated with this session. Will only be
+  // called for persistent sessions. The CDM must respond by calling either
+  // Host::OnResolvePromise() or Host::OnRejectPromise() when the request has
+  // been processed.
+  virtual void RemoveSession(uint32_t promise_id,
+                             const char* session_id,
+                             uint32_t session_id_size) = 0;
+
+  // Performs scheduled operation with |context| when the timer fires.
+  virtual void TimerExpired(void* context) = 0;
 
-  // Called by the CDM when there has been a change in keys or their status for
-  // session |session_id|. |has_additional_usable_key| should be set if a
-  // key is newly usable (e.g. new key available, previously expired key has
-  // been renewed, etc.) and the browser should attempt to resume playback.
-  // |key_ids| is the list of key ids for this session along with their
-  // current status. |key_ids_count| is the number of entries in |key_ids|.
-  // Size parameter for |session_id| should not include null termination.
-  virtual void OnSessionKeysChange(const char* session_id,
-                                   uint32_t session_id_size,
-                                   bool has_additional_usable_key,
-                                   const KeyInformation* keys_info,
-                                   uint32_t keys_info_count) = 0;
+  // Decrypts the |encrypted_buffer|.
+  //
+  // Returns kSuccess if decryption succeeded, in which case the callee
+  // should have filled the |decrypted_buffer| and passed the ownership of
+  // |data| in |decrypted_buffer| to the caller.
+  // Returns kNoKey if the CDM did not have the necessary decryption key
+  // to decrypt.
+  // Returns kDecryptError if any other error happened.
+  // If the return value is not kSuccess, |decrypted_buffer| should be ignored
+  // by the caller.
+  virtual Status Decrypt(const InputBuffer_2& encrypted_buffer,
+                         DecryptedBlock* decrypted_buffer) = 0;
 
-  // Called by the CDM when there has been a change in the expiration time for
-  // session |session_id|. This can happen as the result of an Update() call
-  // or some other event. If this happens as a result of a call to Update(),
-  // it must be called before resolving the Update() promise. |new_expiry_time|
-  // represents the time after which the key(s) in the session will no longer
-  // be usable for decryption. It can be 0 if no such time exists or if the
-  // license explicitly never expires. Size parameter should not include null
-  // termination.
-  virtual void OnExpirationChange(const char* session_id,
-                                  uint32_t session_id_size,
-                                  Time new_expiry_time) = 0;
+  // Initializes the CDM audio decoder with |audio_decoder_config|. This
+  // function must be called before DecryptAndDecodeSamples() is called.
+  //
+  // Returns kSuccess if the |audio_decoder_config| is supported and the CDM
+  // audio decoder is successfully initialized.
+  // Returns kInitializationError if |audio_decoder_config| is not supported.
+  // The CDM may still be able to do Decrypt().
+  // Returns kDeferredInitialization if the CDM is not ready to initialize the
+  // decoder at this time. Must call Host::OnDeferredInitializationDone() once
+  // initialization is complete.
+  virtual Status InitializeAudioDecoder(
+      const AudioDecoderConfig_2& audio_decoder_config) = 0;
 
-  // Called by the CDM when session |session_id| is closed. Size
-  // parameter should not include null termination.
-  virtual void OnSessionClosed(const char* session_id,
-                               uint32_t session_id_size) = 0;
+  // Initializes the CDM video decoder with |video_decoder_config|. This
+  // function must be called before DecryptAndDecodeFrame() is called.
+  //
+  // Returns kSuccess if the |video_decoder_config| is supported and the CDM
+  // video decoder is successfully initialized.
+  // Returns kInitializationError if |video_decoder_config| is not supported.
+  // The CDM may still be able to do Decrypt().
+  // Returns kDeferredInitialization if the CDM is not ready to initialize the
+  // decoder at this time. Must call Host::OnDeferredInitializationDone() once
+  // initialization is complete.
+  virtual Status InitializeVideoDecoder(
+      const VideoDecoderConfig_2& video_decoder_config) = 0;
+
+  // De-initializes the CDM decoder and sets it to an uninitialized state. The
+  // caller can initialize the decoder again after this call to re-initialize
+  // it. This can be used to reconfigure the decoder if the configuration
+  // changes.
+  virtual void DeinitializeDecoder(StreamType decoder_type) = 0;
+
+  // Resets the CDM decoder to an initialized clean state. All internal buffers
+  // MUST be flushed.
+  virtual void ResetDecoder(StreamType decoder_type) = 0;
 
-  // Called by the CDM when an error occurs in session |session_id|
-  // unrelated to one of the ContentDecryptionModule calls that accept a
-  // |promise_id|. |error| must be specified, |error_message| and
-  // |system_code| are optional. Length parameters should not include null
-  // termination.
-  // Note:
-  // - This method is only for supporting prefixed EME API.
-  // - This method will be ignored by unprefixed EME. All errors reported
-  //   in this method should probably also be reported by one of other methods.
-  virtual void OnLegacySessionError(
-      const char* session_id, uint32_t session_id_length,
-      Error error,
-      uint32_t system_code,
-      const char* error_message, uint32_t error_message_length) = 0;
-
-  // The following are optional methods that may not be implemented on all
-  // platforms.
+  // Decrypts the |encrypted_buffer| and decodes the decrypted buffer into a
+  // |video_frame|. Upon end-of-stream, the caller should call this function
+  // repeatedly with empty |encrypted_buffer| (|data| == NULL) until only empty
+  // |video_frame| (|format| == kEmptyVideoFrame) is produced.
+  //
+  // Returns kSuccess if decryption and decoding both succeeded, in which case
+  // the callee will have filled the |video_frame| and passed the ownership of
+  // |frame_buffer| in |video_frame| to the caller.
+  // Returns kNoKey if the CDM did not have the necessary decryption key
+  // to decrypt.
+  // Returns kNeedMoreData if more data was needed by the decoder to generate
+  // a decoded frame (e.g. during initialization and end-of-stream).
+  // Returns kDecryptError if any decryption error happened.
+  // Returns kDecodeError if any decoding error happened.
+  // If the return value is not kSuccess, |video_frame| should be ignored by
+  // the caller.
+  virtual Status DecryptAndDecodeFrame(const InputBuffer_2& encrypted_buffer,
+                                       VideoFrame* video_frame) = 0;
 
-  // Sends a platform challenge for the given |service_id|. |challenge| is at
-  // most 256 bits of data to be signed. Once the challenge has been completed,
-  // the host will call ContentDecryptionModule::OnPlatformChallengeResponse()
-  // with the signed challenge response and platform certificate. Size
-  // parameters should not include null termination.
-  virtual void SendPlatformChallenge(const char* service_id,
-                                     uint32_t service_id_size,
-                                     const char* challenge,
-                                     uint32_t challenge_size) = 0;
+  // Decrypts the |encrypted_buffer| and decodes the decrypted buffer into
+  // |audio_frames|. Upon end-of-stream, the caller should call this function
+  // repeatedly with empty |encrypted_buffer| (|data| == NULL) until only empty
+  // |audio_frames| is produced.
+  //
+  // Returns kSuccess if decryption and decoding both succeeded, in which case
+  // the callee will have filled |audio_frames| and passed the ownership of
+  // |data| in |audio_frames| to the caller.
+  // Returns kNoKey if the CDM did not have the necessary decryption key
+  // to decrypt.
+  // Returns kNeedMoreData if more data was needed by the decoder to generate
+  // audio samples (e.g. during initialization and end-of-stream).
+  // Returns kDecryptError if any decryption error happened.
+  // Returns kDecodeError if any decoding error happened.
+  // If the return value is not kSuccess, |audio_frames| should be ignored by
+  // the caller.
+  virtual Status DecryptAndDecodeSamples(const InputBuffer_2& encrypted_buffer,
+                                         AudioFrames* audio_frames) = 0;
+
+  // Called by the host after a platform challenge was initiated via
+  // Host::SendPlatformChallenge().
+  virtual void OnPlatformChallengeResponse(
+      const PlatformChallengeResponse& response) = 0;
 
-  // Attempts to enable output protection (e.g. HDCP) on the display link. The
-  // |desired_protection_mask| is a bit mask of OutputProtectionMethods. No
-  // status callback is issued, the CDM must call QueryOutputProtectionStatus()
-  // periodically to ensure the desired protections are applied.
-  virtual void EnableOutputProtection(uint32_t desired_protection_mask) = 0;
-
-  // Requests the current output protection status. Once the host has the status
-  // it will call ContentDecryptionModule::OnQueryOutputProtectionStatus().
-  virtual void QueryOutputProtectionStatus() = 0;
+  // Called by the host after a call to Host::QueryOutputProtectionStatus(). The
+  // |link_mask| is a bit mask of OutputLinkTypes and |output_protection_mask|
+  // is a bit mask of OutputProtectionMethods. If |result| is kQueryFailed,
+  // then |link_mask| and |output_protection_mask| are undefined and should
+  // be ignored.
+  virtual void OnQueryOutputProtectionStatus(
+      QueryResult result,
+      uint32_t link_mask,
+      uint32_t output_protection_mask) = 0;
 
-  // Must be called by the CDM if it returned kDeferredInitialization during
-  // InitializeAudioDecoder() or InitializeVideoDecoder().
-  virtual void OnDeferredInitializationDone(StreamType stream_type,
-                                            Status decoder_status) = 0;
+  // Called by the host after a call to Host::RequestStorageId(). If the
+  // version of the storage ID requested is available, |storage_id| and
+  // |storage_id_size| are set appropriately. |version| will be the same as
+  // what was requested, unless 0 (latest) was requested, in which case
+  // |version| will be the actual version number for the |storage_id| returned.
+  // If the requested version is not available, null/zero will be provided as
+  // |storage_id| and |storage_id_size|, respectively, and |version| should be
+  // ignored.
+  virtual void OnStorageId(uint32_t version,
+                           const uint8_t* storage_id,
+                           uint32_t storage_id_size) = 0;
 
-  // Creates a FileIO object from the host to do file IO operation. Returns NULL
-  // if a FileIO object cannot be obtained. Once a valid FileIO object is
-  // returned, |client| must be valid until FileIO::Close() is called. The
-  // CDM can call this method multiple times to operate on different files.
-  virtual FileIO* CreateFileIO(FileIOClient* client) = 0;
+  // Destroys the object in the same context as it was created.
+  virtual void Destroy() = 0;
 
  protected:
-  Host_8() {}
-  virtual ~Host_8() {}
+  ContentDecryptionModule_11() {}
+  virtual ~ContentDecryptionModule_11() {}
 };
 
 class CDM_CLASS_API Host_9 {
  public:
   static const int kVersion = 9;
 
   // Returns a Buffer* containing non-zero members upon success, or NULL on
   // failure. The caller owns the Buffer* after this call. The buffer is not
@@ -1119,18 +1339,18 @@ class CDM_CLASS_API Host_9 {
                                 MessageType message_type,
                                 const char* message,
                                 uint32_t message_size) = 0;
 
   // Called by the CDM when there has been a change in keys or their status for
   // session |session_id|. |has_additional_usable_key| should be set if a
   // key is newly usable (e.g. new key available, previously expired key has
   // been renewed, etc.) and the browser should attempt to resume playback.
-  // |key_ids| is the list of key ids for this session along with their
-  // current status. |key_ids_count| is the number of entries in |key_ids|.
+  // |keys_info| is the list of key IDs for this session along with their
+  // current status. |keys_info_count| is the number of entries in |keys_info|.
   // Size parameter for |session_id| should not include null termination.
   virtual void OnSessionKeysChange(const char* session_id,
                                    uint32_t session_id_size,
                                    bool has_additional_usable_key,
                                    const KeyInformation* keys_info,
                                    uint32_t keys_info_count) = 0;
 
   // Called by the CDM when there has been a change in the expiration time for
@@ -1193,86 +1413,296 @@ class CDM_CLASS_API Host_9 {
   // the ID outside the client device, even in encrypted form.
   virtual void RequestStorageId(uint32_t version) = 0;
 
  protected:
   Host_9() {}
   virtual ~Host_9() {}
 };
 
-// Represents a decrypted block that has not been decoded.
-class CDM_CLASS_API DecryptedBlock {
+class CDM_CLASS_API Host_10 {
  public:
-  virtual void SetDecryptedBuffer(Buffer* buffer) = 0;
-  virtual Buffer* DecryptedBuffer() = 0;
+  static const int kVersion = 10;
+
+  // Returns a Buffer* containing non-zero members upon success, or NULL on
+  // failure. The caller owns the Buffer* after this call. The buffer is not
+  // guaranteed to be zero initialized. The capacity of the allocated Buffer
+  // is guaranteed to be not less than |capacity|.
+  virtual Buffer* Allocate(uint32_t capacity) = 0;
+
+  // Requests the host to call ContentDecryptionModule::TimerFired() |delay_ms|
+  // from now with |context|.
+  virtual void SetTimer(int64_t delay_ms, void* context) = 0;
+
+  // Returns the current wall time.
+  virtual Time GetCurrentWallTime() = 0;
+
+  // Called by the CDM with the result after the CDM instance was initialized.
+  virtual void OnInitialized(bool success) = 0;
+
+  // Called by the CDM when a key status is available in response to
+  // GetStatusForPolicy().
+  virtual void OnResolveKeyStatusPromise(uint32_t promise_id,
+                                         KeyStatus key_status) = 0;
+
+  // Called by the CDM when a session is created or loaded and the value for the
+  // MediaKeySession's sessionId attribute is available (|session_id|).
+  // This must be called before OnSessionMessage() or
+  // OnSessionKeysChange() is called for the same session. |session_id_size|
+  // should not include null termination.
+  // When called in response to LoadSession(), the |session_id| must be the
+  // same as the |session_id| passed in LoadSession(), or NULL if the
+  // session could not be loaded.
+  virtual void OnResolveNewSessionPromise(uint32_t promise_id,
+                                          const char* session_id,
+                                          uint32_t session_id_size) = 0;
+
+  // Called by the CDM when a session is updated or released.
+  virtual void OnResolvePromise(uint32_t promise_id) = 0;
+
+  // Called by the CDM when an error occurs as a result of one of the
+  // ContentDecryptionModule calls that accept a |promise_id|.
+  // |exception| must be specified. |error_message| and |system_code|
+  // are optional. |error_message_size| should not include null termination.
+  virtual void OnRejectPromise(uint32_t promise_id,
+                               Exception exception,
+                               uint32_t system_code,
+                               const char* error_message,
+                               uint32_t error_message_size) = 0;
+
+  // Called by the CDM when it has a message for session |session_id|.
+  // Size parameters should not include null termination.
+  virtual void OnSessionMessage(const char* session_id,
+                                uint32_t session_id_size,
+                                MessageType message_type,
+                                const char* message,
+                                uint32_t message_size) = 0;
 
-  // TODO(tomfinegan): Figure out if timestamp is really needed. If it is not,
-  // we can just pass Buffer pointers around.
-  virtual void SetTimestamp(int64_t timestamp) = 0;
-  virtual int64_t Timestamp() const = 0;
+  // Called by the CDM when there has been a change in keys or their status for
+  // session |session_id|. |has_additional_usable_key| should be set if a
+  // key is newly usable (e.g. new key available, previously expired key has
+  // been renewed, etc.) and the browser should attempt to resume playback.
+  // |keys_info| is the list of key IDs for this session along with their
+  // current status. |keys_info_count| is the number of entries in |keys_info|.
+  // Size parameter for |session_id| should not include null termination.
+  virtual void OnSessionKeysChange(const char* session_id,
+                                   uint32_t session_id_size,
+                                   bool has_additional_usable_key,
+                                   const KeyInformation* keys_info,
+                                   uint32_t keys_info_count) = 0;
+
+  // Called by the CDM when there has been a change in the expiration time for
+  // session |session_id|. This can happen as the result of an Update() call
+  // or some other event. If this happens as a result of a call to Update(),
+  // it must be called before resolving the Update() promise. |new_expiry_time|
+  // represents the time after which the key(s) in the session will no longer
+  // be usable for decryption. It can be 0 if no such time exists or if the
+  // license explicitly never expires. Size parameter should not include null
+  // termination.
+  virtual void OnExpirationChange(const char* session_id,
+                                  uint32_t session_id_size,
+                                  Time new_expiry_time) = 0;
+
+  // Called by the CDM when session |session_id| is closed. Size
+  // parameter should not include null termination.
+  virtual void OnSessionClosed(const char* session_id,
+                               uint32_t session_id_size) = 0;
+
+  // The following are optional methods that may not be implemented on all
+  // platforms.
+
+  // Sends a platform challenge for the given |service_id|. |challenge| is at
+  // most 256 bits of data to be signed. Once the challenge has been completed,
+  // the host will call ContentDecryptionModule::OnPlatformChallengeResponse()
+  // with the signed challenge response and platform certificate. Size
+  // parameters should not include null termination.
+  virtual void SendPlatformChallenge(const char* service_id,
+                                     uint32_t service_id_size,
+                                     const char* challenge,
+                                     uint32_t challenge_size) = 0;
+
+  // Attempts to enable output protection (e.g. HDCP) on the display link. The
+  // |desired_protection_mask| is a bit mask of OutputProtectionMethods. No
+  // status callback is issued, the CDM must call QueryOutputProtectionStatus()
+  // periodically to ensure the desired protections are applied.
+  virtual void EnableOutputProtection(uint32_t desired_protection_mask) = 0;
+
+  // Requests the current output protection status. Once the host has the status
+  // it will call ContentDecryptionModule::OnQueryOutputProtectionStatus().
+  virtual void QueryOutputProtectionStatus() = 0;
+
+  // Must be called by the CDM if it returned kDeferredInitialization during
+  // InitializeAudioDecoder() or InitializeVideoDecoder().
+  virtual void OnDeferredInitializationDone(StreamType stream_type,
+                                            Status decoder_status) = 0;
+
+  // Creates a FileIO object from the host to do file IO operation. Returns NULL
+  // if a FileIO object cannot be obtained. Once a valid FileIO object is
+  // returned, |client| must be valid until FileIO::Close() is called. The
+  // CDM can call this method multiple times to operate on different files.
+  virtual FileIO* CreateFileIO(FileIOClient* client) = 0;
+
+  // Requests a specific version of the storage ID. A storage ID is a stable,
+  // device specific ID used by the CDM to securely store persistent data. The
+  // ID will be returned by the host via ContentDecryptionModule::OnStorageId().
+  // If |version| is 0, the latest version will be returned. All |version|s
+  // that are greater than or equal to 0x80000000 are reserved for the CDM and
+  // should not be supported or returned by the host. The CDM must not expose
+  // the ID outside the client device, even in encrypted form.
+  virtual void RequestStorageId(uint32_t version) = 0;
 
  protected:
-  DecryptedBlock() {}
-  virtual ~DecryptedBlock() {}
+  Host_10() {}
+  virtual ~Host_10() {}
 };
 
-class CDM_CLASS_API VideoFrame {
+class CDM_CLASS_API Host_11 {
  public:
-  enum VideoPlane {
-    kYPlane = 0,
-    kUPlane = 1,
-    kVPlane = 2,
-    kMaxPlanes = 3,
-  };
+  static const int kVersion = 11;
+
+  // Returns a Buffer* containing non-zero members upon success, or NULL on
+  // failure. The caller owns the Buffer* after this call. The buffer is not
+  // guaranteed to be zero initialized. The capacity of the allocated Buffer
+  // is guaranteed to be not less than |capacity|.
+  virtual Buffer* Allocate(uint32_t capacity) = 0;
+
+  // Requests the host to call ContentDecryptionModule::TimerFired() |delay_ms|
+  // from now with |context|.
+  virtual void SetTimer(int64_t delay_ms, void* context) = 0;
+
+  // Returns the current wall time.
+  virtual Time GetCurrentWallTime() = 0;
+
+  // Called by the CDM with the result after the CDM instance was initialized.
+  virtual void OnInitialized(bool success) = 0;
+
+  // Called by the CDM when a key status is available in response to
+  // GetStatusForPolicy().
+  virtual void OnResolveKeyStatusPromise(uint32_t promise_id,
+                                         KeyStatus key_status) = 0;
 
-  virtual void SetFormat(VideoFormat format) = 0;
-  virtual VideoFormat Format() const = 0;
+  // Called by the CDM when a session is created or loaded and the value for the
+  // MediaKeySession's sessionId attribute is available (|session_id|).
+  // This must be called before OnSessionMessage() or
+  // OnSessionKeysChange() is called for the same session. |session_id_size|
+  // should not include null termination.
+  // When called in response to LoadSession(), the |session_id| must be the
+  // same as the |session_id| passed in LoadSession(), or NULL if the
+  // session could not be loaded.
+  virtual void OnResolveNewSessionPromise(uint32_t promise_id,
+                                          const char* session_id,
+                                          uint32_t session_id_size) = 0;
+
+  // Called by the CDM when a session is updated or released.
+  virtual void OnResolvePromise(uint32_t promise_id) = 0;
+
+  // Called by the CDM when an error occurs as a result of one of the
+  // ContentDecryptionModule calls that accept a |promise_id|.
+  // |exception| must be specified. |error_message| and |system_code|
+  // are optional. |error_message_size| should not include null termination.
+  virtual void OnRejectPromise(uint32_t promise_id,
+                               Exception exception,
+                               uint32_t system_code,
+                               const char* error_message,
+                               uint32_t error_message_size) = 0;
+
+  // Called by the CDM when it has a message for session |session_id|.
+  // Size parameters should not include null termination.
+  virtual void OnSessionMessage(const char* session_id,
+                                uint32_t session_id_size,
+                                MessageType message_type,
+                                const char* message,
+                                uint32_t message_size) = 0;
+
+  // Called by the CDM when there has been a change in keys or their status for
+  // session |session_id|. |has_additional_usable_key| should be set if a
+  // key is newly usable (e.g. new key available, previously expired key has
+  // been renewed, etc.) and the browser should attempt to resume playback.
+  // |keys_info| is the list of key IDs for this session along with their
+  // current status. |keys_info_count| is the number of entries in |keys_info|.
+  // Size parameter for |session_id| should not include null termination.
+  virtual void OnSessionKeysChange(const char* session_id,
+                                   uint32_t session_id_size,
+                                   bool has_additional_usable_key,
+                                   const KeyInformation* keys_info,
+                                   uint32_t keys_info_count) = 0;
 
-  virtual void SetSize(cdm::Size size) = 0;
-  virtual cdm::Size Size() const = 0;
+  // Called by the CDM when there has been a change in the expiration time for
+  // session |session_id|. This can happen as the result of an Update() call
+  // or some other event. If this happens as a result of a call to Update(),
+  // it must be called before resolving the Update() promise. |new_expiry_time|
+  // represents the time after which the key(s) in the session will no longer
+  // be usable for decryption. It can be 0 if no such time exists or if the
+  // license explicitly never expires. Size parameter should not include null
+  // termination.
+  virtual void OnExpirationChange(const char* session_id,
+                                  uint32_t session_id_size,
+                                  Time new_expiry_time) = 0;
+
+  // Called by the CDM when session |session_id| is closed. Size
+  // parameter should not include null termination.
+  virtual void OnSessionClosed(const char* session_id,
+                               uint32_t session_id_size) = 0;
 
-  virtual void SetFrameBuffer(Buffer* frame_buffer) = 0;
-  virtual Buffer* FrameBuffer() = 0;
+  // The following are optional methods that may not be implemented on all
+  // platforms.
+
+  // Sends a platform challenge for the given |service_id|. |challenge| is at
+  // most 256 bits of data to be signed. Once the challenge has been completed,
+  // the host will call ContentDecryptionModule::OnPlatformChallengeResponse()
+  // with the signed challenge response and platform certificate. Size
+  // parameters should not include null termination.
+  virtual void SendPlatformChallenge(const char* service_id,
+                                     uint32_t service_id_size,
+                                     const char* challenge,
+                                     uint32_t challenge_size) = 0;
+
+  // Attempts to enable output protection (e.g. HDCP) on the display link. The
+  // |desired_protection_mask| is a bit mask of OutputProtectionMethods. No
+  // status callback is issued, the CDM must call QueryOutputProtectionStatus()
+  // periodically to ensure the desired protections are applied.
+  virtual void EnableOutputProtection(uint32_t desired_protection_mask) = 0;
 
-  virtual void SetPlaneOffset(VideoPlane plane, uint32_t offset) = 0;
-  virtual uint32_t PlaneOffset(VideoPlane plane) = 0;
+  // Requests the current output protection status. Once the host has the status
+  // it will call ContentDecryptionModule::OnQueryOutputProtectionStatus().
+  virtual void QueryOutputProtectionStatus() = 0;
+
+  // Must be called by the CDM if it returned kDeferredInitialization during
+  // InitializeAudioDecoder() or InitializeVideoDecoder().
+  virtual void OnDeferredInitializationDone(StreamType stream_type,
+                                            Status decoder_status) = 0;
+
+  // Creates a FileIO object from the host to do file IO operation. Returns NULL
+  // if a FileIO object cannot be obtained. Once a valid FileIO object is
+  // returned, |client| must be valid until FileIO::Close() is called. The
+  // CDM can call this method multiple times to operate on different files.
+  virtual FileIO* CreateFileIO(FileIOClient* client) = 0;
 
-  virtual void SetStride(VideoPlane plane, uint32_t stride) = 0;
-  virtual uint32_t Stride(VideoPlane plane) = 0;
+  // Requests a CdmProxy that proxies part of CDM functionalities to a different
+  // entity, e.g. a hardware CDM module. A CDM instance can have at most one
+  // CdmProxy throughout its lifetime, which must be requested and initialized
+  // during CDM instance initialization time, i.e. in or after CDM::Initialize()
+  // and before OnInitialized() is called, to ensure proper connection of the
+  // CdmProxy and the media player (e.g. hardware decoder). The CdmProxy is
+  // owned by the host and is guaranteed to be valid throughout the CDM
+  // instance's lifetime. The CDM must ensure that the |client| remain valid
+  // before the CDM instance is destroyed. Returns null if CdmProxy is not
+  // supported, called before CDM::Initialize(), RequestCdmProxy() is called
+  // more than once, or called after the CDM instance has been initialized.
+  virtual CdmProxy* RequestCdmProxy(CdmProxyClient* client) = 0;
 
-  virtual void SetTimestamp(int64_t timestamp) = 0;
-  virtual int64_t Timestamp() const = 0;
+  // Requests a specific version of the storage ID. A storage ID is a stable,
+  // device specific ID used by the CDM to securely store persistent data. The
+  // ID will be returned by the host via ContentDecryptionModule::OnStorageId().
+  // If |version| is 0, the latest version will be returned. All |version|s
+  // that are greater than or equal to 0x80000000 are reserved for the CDM and
+  // should not be supported or returned by the host. The CDM must not expose
+  // the ID outside the client device, even in encrypted form.
+  virtual void RequestStorageId(uint32_t version) = 0;
 
  protected:
-  VideoFrame() {}
-  virtual ~VideoFrame() {}
-};
-
-// Represents decrypted and decoded audio frames. AudioFrames can contain
-// multiple audio output buffers, which are serialized into this format:
-//
-// |<------------------- serialized audio buffer ------------------->|
-// | int64_t timestamp | int64_t length | length bytes of audio data |
-//
-// For example, with three audio output buffers, the AudioFrames will look
-// like this:
-//
-// |<----------------- AudioFrames ------------------>|
-// | audio buffer 0 | audio buffer 1 | audio buffer 2 |
-class CDM_CLASS_API AudioFrames {
- public:
-  virtual void SetFrameBuffer(Buffer* buffer) = 0;
-  virtual Buffer* FrameBuffer() = 0;
-
-  // The CDM must call this method, providing a valid format, when providing
-  // frame buffers. Planar data should be stored end to end; e.g.,
-  // |ch1 sample1||ch1 sample2|....|ch1 sample_last||ch2 sample1|...
-  virtual void SetFormat(AudioFormat format) = 0;
-  virtual AudioFormat Format() const = 0;
-
- protected:
-  AudioFrames() {}
-  virtual ~AudioFrames() {}
+  Host_11() {}
+  virtual ~Host_11() {}
 };
 
 }  // namespace cdm
 
 #endif  // CDM_CONTENT_DECRYPTION_MODULE_H_
diff --git a/dom/media/gmp/widevine-adapter/content_decryption_module_export.h b/dom/media/gmp/widevine-adapter/content_decryption_module_export.h
--- a/dom/media/gmp/widevine-adapter/content_decryption_module_export.h
+++ b/dom/media/gmp/widevine-adapter/content_decryption_module_export.h
@@ -14,9 +14,25 @@
 #else
 #define CDM_API __declspec(dllimport)
 #endif  // defined(CDM_IMPLEMENTATION)
 
 #else  // defined(_WIN32)
 #define CDM_API __attribute__((visibility("default")))
 #endif  // defined(_WIN32)
 
+// Define CDM_CLASS_API to export class types. We have to add visibility
+// attributes to make sure virtual tables in CDM consumer and CDM implementation
+// are the same. Generally, it was always a good idea, as there're no guarantees
+// about that for the internal symbols, but it has only become a practical issue
+// after introduction of LTO devirtualization. See more details on
+// https://crbug.com/609564#c35
+#if defined(_WIN32)
+#if defined(__clang__)
+#define CDM_CLASS_API [[clang::lto_visibility_public]]
+#else
+#define CDM_CLASS_API
+#endif
+#else  // defined(_WIN32)
+#define CDM_CLASS_API __attribute__((visibility("default")))
+#endif  // defined(_WIN32)
+
 #endif  // CDM_CONTENT_DECRYPTION_MODULE_EXPORT_H_
diff --git a/dom/media/gmp/widevine-adapter/content_decryption_module_proxy.h b/dom/media/gmp/widevine-adapter/content_decryption_module_proxy.h
new file mode 100644
--- /dev/null
+++ b/dom/media/gmp/widevine-adapter/content_decryption_module_proxy.h
@@ -0,0 +1,117 @@
+// Copyright 2017 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CDM_CONTENT_DECRYPTION_MODULE_PROXY_H_
+#define CDM_CONTENT_DECRYPTION_MODULE_PROXY_H_
+
+#include "content_decryption_module_export.h"
+
+#if defined(_MSC_VER)
+typedef unsigned char uint8_t;
+typedef unsigned int uint32_t;
+typedef unsigned __int64 uint64_t;
+#else
+#include <stdint.h>
+#endif
+
+namespace cdm {
+
+class CDM_CLASS_API CdmProxyClient;
+
+// A proxy class for the CDM.
+// In general, the interpretation of the CdmProxy and CdmProxyClient method
+// parameters are protocol dependent. For enum parameters, values outside the
+// enum range may not work.
+class CDM_CLASS_API CdmProxy {
+ public:
+  enum Function : uint32_t {
+    // For Intel Negotiate Crypto SessionKey Exchange (CSME) path to call
+    // ID3D11VideoContext::NegotiateCryptoSessionKeyExchange.
+    kIntelNegotiateCryptoSessionKeyExchange = 1,
+    // There will be more values in the future e.g. for D3D11 RSA method.
+  };
+
+  // Initializes the proxy. The results will be returned in
+  // CdmProxyClient::OnInitialized().
+  virtual void Initialize() = 0;
+
+  // Processes and updates the state of the proxy.
+  // |output_data_size| is required by some protocol to set up the output data.
+  // The operation may fail if the |output_data_size| is wrong. The results will
+  // be returned in CdmProxyClient::OnProcessed().
+  virtual void Process(Function function,
+                       uint32_t crypto_session_id,
+                       const uint8_t* input_data,
+                       uint32_t input_data_size,
+                       uint32_t output_data_size) = 0;
+
+  // Creates a crypto session for handling media.
+  // If extra data has to be passed to further setup the media crypto session,
+  // pass the data as |input_data|. The results will be returned in
+  // CdmProxyClient::OnMediaCryptoSessionCreated().
+  virtual void CreateMediaCryptoSession(const uint8_t* input_data,
+                                        uint32_t input_data_size) = 0;
+
+  // Sets a key for the session identified by |crypto_session_id|.
+  virtual void SetKey(uint32_t crypto_session_id,
+                      const uint8_t* key_id,
+                      uint32_t key_id_size,
+                      const uint8_t* key_blob,
+                      uint32_t key_blob_size) = 0;
+
+  // Removes a key for the session identified by |crypto_session_id|.
+  virtual void RemoveKey(uint32_t crypto_session_id,
+                         const uint8_t* key_id,
+                         uint32_t key_id_size) = 0;
+
+ protected:
+  CdmProxy() {}
+  virtual ~CdmProxy() {}
+};
+
+// Responses to CdmProxy calls. All responses will be called asynchronously.
+class CDM_CLASS_API CdmProxyClient {
+ public:
+  enum Status : uint32_t {
+    kOk,
+    kFail,
+  };
+
+  enum Protocol : uint32_t {
+    kNone = 0,  // No protocol supported. Can be used in failure cases.
+    kIntel,  // Method using Intel CSME.
+    // There will be more values in the future e.g. kD3D11RsaHardware,
+    // kD3D11RsaSoftware to use the D3D11 RSA method.
+  };
+
+  // Callback for Initialize(). If the proxy created a crypto session, then the
+  // ID for the crypto session is |crypto_session_id|.
+  virtual void OnInitialized(Status status,
+                             Protocol protocol,
+                             uint32_t crypto_session_id) = 0;
+
+  // Callback for Process(). |output_data| is the output of processing.
+  virtual void OnProcessed(Status status,
+                           const uint8_t* output_data,
+                           uint32_t output_data_size) = 0;
+
+  // Callback for CreateMediaCryptoSession(). On success:
+  // - |crypto_session_id| is the ID for the created crypto session.
+  // - |output_data| is extra value, if any.
+  // Otherwise, |crypto_session_id| and |output_data| should be ignored.
+  virtual void OnMediaCryptoSessionCreated(Status status,
+                                           uint32_t crypto_session_id,
+                                           uint64_t output_data) = 0;
+
+  // Called when there is a hardware reset and all the hardware context is lost.
+  virtual void NotifyHardwareReset() = 0;
+
+ protected:
+  CdmProxyClient() {}
+  virtual ~CdmProxyClient() {}
+};
+
+}  // namespace cdm
+
+#endif  // CDM_CONTENT_DECRYPTION_MODULE_PROXY_H_
diff --git a/dom/media/platforms/agnostic/eme/ChromiumCDMVideoDecoder.cpp b/dom/media/platforms/agnostic/eme/ChromiumCDMVideoDecoder.cpp
--- a/dom/media/platforms/agnostic/eme/ChromiumCDMVideoDecoder.cpp
+++ b/dom/media/platforms/agnostic/eme/ChromiumCDMVideoDecoder.cpp
@@ -22,54 +22,54 @@ ChromiumCDMVideoDecoder::ChromiumCDMVide
       mGMPThread(GetGMPAbstractThread()),
       mImageContainer(aParams.mImageContainer) {}
 
 ChromiumCDMVideoDecoder::~ChromiumCDMVideoDecoder() {}
 
 static uint32_t ToCDMH264Profile(uint8_t aProfile) {
   switch (aProfile) {
     case 66:
-      return cdm::VideoDecoderConfig::kH264ProfileBaseline;
+      return cdm::VideoCodecProfile::kH264ProfileBaseline;
     case 77:
-      return cdm::VideoDecoderConfig::kH264ProfileMain;
+      return cdm::VideoCodecProfile::kH264ProfileMain;
     case 88:
-      return cdm::VideoDecoderConfig::kH264ProfileExtended;
+      return cdm::VideoCodecProfile::kH264ProfileExtended;
     case 100:
-      return cdm::VideoDecoderConfig::kH264ProfileHigh;
+      return cdm::VideoCodecProfile::kH264ProfileHigh;
     case 110:
-      return cdm::VideoDecoderConfig::kH264ProfileHigh10;
+      return cdm::VideoCodecProfile::kH264ProfileHigh10;
     case 122:
-      return cdm::VideoDecoderConfig::kH264ProfileHigh422;
+      return cdm::VideoCodecProfile::kH264ProfileHigh422;
     case 144:
-      return cdm::VideoDecoderConfig::kH264ProfileHigh444Predictive;
+      return cdm::VideoCodecProfile::kH264ProfileHigh444Predictive;
   }
-  return cdm::VideoDecoderConfig::kUnknownVideoCodecProfile;
+  return cdm::VideoCodecProfile::kUnknownVideoCodecProfile;
 }
 
 RefPtr<MediaDataDecoder::InitPromise> ChromiumCDMVideoDecoder::Init() {
   if (!mCDMParent) {
     // Must have failed to get the CDMParent from the ChromiumCDMProxy
     // in our constructor; the MediaKeys must have shut down the CDM
     // before we had a chance to start up the decoder.
     return InitPromise::CreateAndReject(NS_ERROR_DOM_MEDIA_FATAL_ERR, __func__);
   }
 
   gmp::CDMVideoDecoderConfig config;
   if (MP4Decoder::IsH264(mConfig.mMimeType)) {
-    config.mCodec() = cdm::VideoDecoderConfig::kCodecH264;
+    config.mCodec() = cdm::VideoCodec::kCodecH264;
     config.mProfile() =
         ToCDMH264Profile(mConfig.mExtraData->SafeElementAt(1, 0));
     config.mExtraData() = *mConfig.mExtraData;
     mConvertToAnnexB = true;
   } else if (VPXDecoder::IsVP8(mConfig.mMimeType)) {
-    config.mCodec() = cdm::VideoDecoderConfig::kCodecVp8;
-    config.mProfile() = cdm::VideoDecoderConfig::kProfileNotNeeded;
+    config.mCodec() = cdm::VideoCodec::kCodecVp8;
+    config.mProfile() = cdm::VideoCodecProfile::kProfileNotNeeded;
   } else if (VPXDecoder::IsVP9(mConfig.mMimeType)) {
-    config.mCodec() = cdm::VideoDecoderConfig::kCodecVp9;
-    config.mProfile() = cdm::VideoDecoderConfig::kProfileNotNeeded;
+    config.mCodec() = cdm::VideoCodec::kCodecVp9;
+    config.mProfile() = cdm::VideoCodecProfile::kProfileNotNeeded;
   } else {
     return MediaDataDecoder::InitPromise::CreateAndReject(
         NS_ERROR_DOM_MEDIA_FATAL_ERR, __func__);
   }
   config.mImageWidth() = mConfig.mImage.width;
   config.mImageHeight() = mConfig.mImage.height;
 
   RefPtr<gmp::ChromiumCDMParent> cdm = mCDMParent;
diff --git a/media/gmp-clearkey/0.1/ClearKeyCDM.cpp b/media/gmp-clearkey/0.1/ClearKeyCDM.cpp
--- a/media/gmp-clearkey/0.1/ClearKeyCDM.cpp
+++ b/media/gmp-clearkey/0.1/ClearKeyCDM.cpp
@@ -61,31 +61,31 @@ void ClearKeyCDM::RemoveSession(uint32_t
 }
 
 void ClearKeyCDM::TimerExpired(void* aContext) {
   // Clearkey is not interested in timers, so this method has not been
   // implemented.
   assert(false);
 }
 
-Status ClearKeyCDM::Decrypt(const InputBuffer& aEncryptedBuffer,
+Status ClearKeyCDM::Decrypt(const InputBuffer_1& aEncryptedBuffer,
                             DecryptedBlock* aDecryptedBuffer) {
   return mSessionManager->Decrypt(aEncryptedBuffer, aDecryptedBuffer);
 }
 
 Status ClearKeyCDM::InitializeAudioDecoder(
-    const AudioDecoderConfig& aAudioDecoderConfig) {
+    const AudioDecoderConfig_1& aAudioDecoderConfig) {
   // Audio decoding is not supported by Clearkey because Widevine doesn't
   // support it and Clearkey's raison d'etre is to provide test coverage
   // for paths that Widevine will exercise in the wild.
   return Status::kDecodeError;
 }
 
 Status ClearKeyCDM::InitializeVideoDecoder(
-    const VideoDecoderConfig& aVideoDecoderConfig) {
+    const VideoDecoderConfig_1& aVideoDecoderConfig) {
 #ifdef ENABLE_WMF
   mVideoDecoder = new VideoDecoder(mHost);
   return mVideoDecoder->InitDecode(aVideoDecoderConfig);
 #else
   return Status::kDecodeError;
 #endif
 }
 
@@ -101,27 +101,27 @@ void ClearKeyCDM::DeinitializeDecoder(St
 void ClearKeyCDM::ResetDecoder(StreamType aDecoderType) {
 #ifdef ENABLE_WMF
   if (aDecoderType == StreamType::kStreamTypeVideo) {
     mVideoDecoder->Reset();
   }
 #endif
 }
 
-Status ClearKeyCDM::DecryptAndDecodeFrame(const InputBuffer& aEncryptedBuffer,
+Status ClearKeyCDM::DecryptAndDecodeFrame(const InputBuffer_1& aEncryptedBuffer,
                                           VideoFrame* aVideoFrame) {
 #ifdef ENABLE_WMF
   return mVideoDecoder->Decode(aEncryptedBuffer, aVideoFrame);
 #else
   return Status::kDecodeError;
 #endif
 }
 
-Status ClearKeyCDM::DecryptAndDecodeSamples(const InputBuffer& aEncryptedBuffer,
-                                            AudioFrames* aAudioFrame) {
+Status ClearKeyCDM::DecryptAndDecodeSamples(
+    const InputBuffer_1& aEncryptedBuffer, AudioFrames* aAudioFrame) {
   // Audio decoding is not supported by Clearkey because Widevine doesn't
   // support it and Clearkey's raison d'etre is to provide test coverage
   // for paths that Widevine will exercise in the wild.
   return Status::kDecodeError;
 }
 
 void ClearKeyCDM::OnPlatformChallengeResponse(
     const PlatformChallengeResponse& aResponse) {
diff --git a/media/gmp-clearkey/0.1/ClearKeyCDM.h b/media/gmp-clearkey/0.1/ClearKeyCDM.h
--- a/media/gmp-clearkey/0.1/ClearKeyCDM.h
+++ b/media/gmp-clearkey/0.1/ClearKeyCDM.h
@@ -52,34 +52,35 @@ class ClearKeyCDM : public cdm::ContentD
   void CloseSession(uint32_t aPromiseId, const char* aSessionId,
                     uint32_t aSessionIdSize) override;
 
   void RemoveSession(uint32_t aPromiseId, const char* aSessionId,
                      uint32_t aSessionIdSize) override;
 
   void TimerExpired(void* aContext) override;
 
-  cdm::Status Decrypt(const cdm::InputBuffer& aEncryptedBuffer,
+  cdm::Status Decrypt(const cdm::InputBuffer_1& aEncryptedBuffer,
                       cdm::DecryptedBlock* aDecryptedBuffer) override;
 
   cdm::Status InitializeAudioDecoder(
-      const cdm::AudioDecoderConfig& aAudioDecoderConfig) override;
+      const cdm::AudioDecoderConfig_1& aAudioDecoderConfig) override;
 
   cdm::Status InitializeVideoDecoder(
-      const cdm::VideoDecoderConfig& aVideoDecoderConfig) override;
+      const cdm::VideoDecoderConfig_1& aVideoDecoderConfig) override;
 
   void DeinitializeDecoder(cdm::StreamType aDecoderType) override;
 
   void ResetDecoder(cdm::StreamType aDecoderType) override;
 
-  cdm::Status DecryptAndDecodeFrame(const cdm::InputBuffer& aEncryptedBuffer,
+  cdm::Status DecryptAndDecodeFrame(const cdm::InputBuffer_1& aEncryptedBuffer,
                                     cdm::VideoFrame* aVideoFrame) override;
 
-  cdm::Status DecryptAndDecodeSamples(const cdm::InputBuffer& aEncryptedBuffer,
-                                      cdm::AudioFrames* aAudioFrame) override;
+  cdm::Status DecryptAndDecodeSamples(
+      const cdm::InputBuffer_1& aEncryptedBuffer,
+      cdm::AudioFrames* aAudioFrame) override;
 
   void OnPlatformChallengeResponse(
       const cdm::PlatformChallengeResponse& aResponse) override;
 
   void OnQueryOutputProtectionStatus(cdm::QueryResult aResult,
                                      uint32_t aLinkMask,
                                      uint32_t aOutputProtectionMask) override;
 
diff --git a/media/gmp-clearkey/0.1/ClearKeyDecryptionManager.h b/media/gmp-clearkey/0.1/ClearKeyDecryptionManager.h
--- a/media/gmp-clearkey/0.1/ClearKeyDecryptionManager.h
+++ b/media/gmp-clearkey/0.1/ClearKeyDecryptionManager.h
@@ -27,21 +27,21 @@
 #include <map>
 
 class ClearKeyDecryptor;
 
 class CryptoMetaData {
  public:
   CryptoMetaData() {}
 
-  explicit CryptoMetaData(const cdm::InputBuffer* aInputBuffer) {
+  explicit CryptoMetaData(const cdm::InputBuffer_1* aInputBuffer) {
     Init(aInputBuffer);
   }
 
-  void Init(const cdm::InputBuffer* aInputBuffer) {
+  void Init(const cdm::InputBuffer_1* aInputBuffer) {
     if (!aInputBuffer) {
       assert(!IsValid());
       return;
     }
 
     Assign(mKeyId, aInputBuffer->key_id, aInputBuffer->key_id_size);
     Assign(mIV, aInputBuffer->iv, aInputBuffer->iv_size);
 
diff --git a/media/gmp-clearkey/0.1/ClearKeySessionManager.cpp b/media/gmp-clearkey/0.1/ClearKeySessionManager.cpp
--- a/media/gmp-clearkey/0.1/ClearKeySessionManager.cpp
+++ b/media/gmp-clearkey/0.1/ClearKeySessionManager.cpp
@@ -248,17 +248,17 @@ void ClearKeySessionManager::PersistentS
 
     session->AddKeyId(keyPair.mKeyId);
 
     mDecryptionManager->ExpectKeyId(keyPair.mKeyId);
     mDecryptionManager->InitKey(keyPair.mKeyId, keyPair.mKey);
     mKeyIds.insert(keyPair.mKey);
     keyPairs.push_back(keyPair);
 
-    KeyInformation keyInfo = KeyInformation();
+    KeyInformation keyInfo = {};
     keyInfo.key_id = &keyPairs.back().mKeyId[0];
     keyInfo.key_id_size = keyPair.mKeyId.size();
     keyInfo.status = KeyStatus::kUsable;
 
     keyInfos.push_back(keyInfo);
   }
 
   mHost->OnSessionKeysChange(&aSessionId[0], aSessionId.size(), true,
@@ -336,17 +336,17 @@ void ClearKeySessionManager::UpdateSessi
   }
 
   vector<KeyInformation> keyInfos;
   for (size_t i = 0; i < keyPairs.size(); i++) {
     KeyIdPair& keyPair = keyPairs[i];
     mDecryptionManager->InitKey(keyPair.mKeyId, keyPair.mKey);
     mKeyIds.insert(keyPair.mKeyId);
 
-    KeyInformation keyInfo = KeyInformation();
+    KeyInformation keyInfo = {};
     keyInfo.key_id = &keyPair.mKeyId[0];
     keyInfo.key_id_size = keyPair.mKeyId.size();
     keyInfo.status = KeyStatus::kUsable;
 
     keyInfos.push_back(keyInfo);
   }
 
   mHost->OnSessionKeysChange(aSessionId, aSessionIdLength, true,
@@ -524,17 +524,17 @@ void ClearKeySessionManager::SetServerCe
                                                   const uint8_t* aServerCert,
                                                   uint32_t aServerCertSize) {
   // ClearKey CDM doesn't support this method by spec.
   CK_LOGD("ClearKeySessionManager::SetServerCertificate");
   mHost->OnRejectPromise(aPromiseId, Exception::kExceptionNotSupportedError, 0,
                          nullptr /* message */, 0 /* messageLen */);
 }
 
-Status ClearKeySessionManager::Decrypt(const InputBuffer& aBuffer,
+Status ClearKeySessionManager::Decrypt(const InputBuffer_1& aBuffer,
                                        DecryptedBlock* aDecryptedBlock) {
   CK_LOGD("ClearKeySessionManager::Decrypt");
 
   CK_LOGARRAY("Key: ", aBuffer.key_id, aBuffer.key_id_size);
 
   Buffer* buffer = mHost->Allocate(aBuffer.data_size);
   assert(buffer != nullptr);
   assert(buffer->Data() != nullptr);
diff --git a/media/gmp-clearkey/0.1/ClearKeySessionManager.h b/media/gmp-clearkey/0.1/ClearKeySessionManager.h
--- a/media/gmp-clearkey/0.1/ClearKeySessionManager.h
+++ b/media/gmp-clearkey/0.1/ClearKeySessionManager.h
@@ -54,17 +54,17 @@ class ClearKeySessionManager final : pub
                     uint32_t aSessionIdLength);
 
   void RemoveSession(uint32_t aPromiseId, const char* aSessionId,
                      uint32_t aSessionIdLength);
 
   void SetServerCertificate(uint32_t aPromiseId, const uint8_t* aServerCert,
                             uint32_t aServerCertSize);
 
-  cdm::Status Decrypt(const cdm::InputBuffer& aBuffer,
+  cdm::Status Decrypt(const cdm::InputBuffer_1& aBuffer,
                       cdm::DecryptedBlock* aDecryptedBlock);
 
   void DecryptingComplete();
 
   void PersistentSessionDataLoaded(uint32_t aPromiseId,
                                    const std::string& aSessionId,
                                    const uint8_t* aKeyData,
                                    uint32_t aKeyDataSize);
diff --git a/media/gmp-clearkey/0.1/VideoDecoder.cpp b/media/gmp-clearkey/0.1/VideoDecoder.cpp
--- a/media/gmp-clearkey/0.1/VideoDecoder.cpp
+++ b/media/gmp-clearkey/0.1/VideoDecoder.cpp
@@ -37,29 +37,29 @@ VideoDecoder::VideoDecoder(Host_9* aHost
 
   uint32_t cores = std::max(1u, std::thread::hardware_concurrency());
 
   HRESULT hr = mDecoder->Init(cores);
 }
 
 VideoDecoder::~VideoDecoder() { CK_LOGD("VideoDecoder destroyed"); }
 
-Status VideoDecoder::InitDecode(const VideoDecoderConfig& aConfig) {
+Status VideoDecoder::InitDecode(const VideoDecoderConfig_1& aConfig) {
   CK_LOGD("VideoDecoder::InitDecode");
 
   if (!mDecoder) {
     CK_LOGD("VideoDecoder::InitDecode failed to init WMFH264Decoder");
 
     return Status::kDecodeError;
   }
 
   return Status::kSuccess;
 }
 
-Status VideoDecoder::Decode(const InputBuffer& aInputBuffer,
+Status VideoDecoder::Decode(const InputBuffer_1& aInputBuffer,
                             VideoFrame* aVideoFrame) {
   CK_LOGD("VideoDecoder::Decode");
   // If the input buffer we have been passed has a null buffer, it means we
   // should drain.
   if (!aInputBuffer.data) {
     // This will drain the decoder until there are no frames left to drain,
     // whereupon it will return 'NeedsMoreData'.
     CK_LOGD("VideoDecoder::Decode Input buffer null: Draining");
@@ -214,17 +214,17 @@ VideoDecoder::SampleToVideoFrame(IMFSamp
   uint32_t srcYSize = stride * (aFrameHeight + padding);
   uint32_t srcUVSize = stride * (aFrameHeight + padding) / 4;
   uint32_t halfStride = (stride + 1) / 2;
 
   aVideoFrame->SetStride(VideoFrame::kYPlane, stride);
   aVideoFrame->SetStride(VideoFrame::kUPlane, halfStride);
   aVideoFrame->SetStride(VideoFrame::kVPlane, halfStride);
 
-  aVideoFrame->SetSize(Size(aPictureWidth, aPictureHeight));
+  aVideoFrame->SetSize(Size{aPictureWidth, aPictureHeight});
 
   // Note: We allocate the minimal sized buffer required to send the
   // frame back over to the parent process. This is so that we request the
   // same sized frame as the buffer allocator expects.
   using mozilla::CheckedUint32;
   CheckedUint32 bufferSize = CheckedUint32(stride) * aPictureHeight +
                              ((CheckedUint32(stride) * aPictureHeight) / 4) * 2;
 
diff --git a/media/gmp-clearkey/0.1/VideoDecoder.h b/media/gmp-clearkey/0.1/VideoDecoder.h
--- a/media/gmp-clearkey/0.1/VideoDecoder.h
+++ b/media/gmp-clearkey/0.1/VideoDecoder.h
@@ -26,19 +26,19 @@
 #include "stddef.h"
 #include "content_decryption_module.h"
 #include "WMFH264Decoder.h"
 
 class VideoDecoder : public RefCounted {
  public:
   explicit VideoDecoder(cdm::Host_9* aHost);
 
-  cdm::Status InitDecode(const cdm::VideoDecoderConfig& aConfig);
+  cdm::Status InitDecode(const cdm::VideoDecoderConfig_1& aConfig);
 
-  cdm::Status Decode(const cdm::InputBuffer& aEncryptedBuffer,
+  cdm::Status Decode(const cdm::InputBuffer_1& aEncryptedBuffer,
                      cdm::VideoFrame* aVideoFrame);
 
   void Reset();
 
   void DecodingComplete();
 
   bool HasShutdown() { return mHasShutdown; }
 

